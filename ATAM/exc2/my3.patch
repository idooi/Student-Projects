diff --git a/browser-plugin/EvBrowserPlugin.cpp b/browser-plugin/EvBrowserPlugin.cpp
index 3b40158..9f771c1 100644
--- a/browser-plugin/EvBrowserPlugin.cpp
+++ b/browser-plugin/EvBrowserPlugin.cpp
@@ -27,720 +27,703 @@
 #include <string.h>
 
 struct EvBrowserPluginClass {
-        enum Methods {
-                GoToPage,
-                ToggleContinuous,
-                ToggleDual,
-                ZoomIn,
-                ZoomOut,
-                Download,
-                Print,
-
-                NumMethodIdentifiers
-        };
-
-        enum Properties {
-                CurrentPage,
-                PageCount,
-                Zoom,
-                ZoomMode,
-                Continuous,
-                Dual,
-                Toolbar,
-
-                NumPropertyIdentifiers
-        };
-
-        EvBrowserPlugin* createObject(NPP instance)
-        {
-                if (!identifiersInitialized) {
-                        NPN_GetStringIdentifiers(methodIdentifierNames, NumMethodIdentifiers, methodIdentifiers);
-                        NPN_GetStringIdentifiers(propertyIdentifierNames, NumPropertyIdentifiers, propertyIdentifiers);
-                        identifiersInitialized = true;
-                }
-
-                return static_cast<EvBrowserPlugin *>(NPN_CreateObject(instance, &npClass));
-        }
-
-        NPClass npClass;
-
-        const NPUTF8 *methodIdentifierNames[NumMethodIdentifiers];
-        const NPUTF8 *propertyIdentifierNames[NumPropertyIdentifiers];
-        bool identifiersInitialized;
-        NPIdentifier methodIdentifiers[NumMethodIdentifiers];
-        NPIdentifier propertyIdentifiers[NumPropertyIdentifiers];
+  enum Methods {
+    GoToPage,
+    ToggleContinuous,
+    ToggleCreaterMode,
+    ToggleDual,
+    ZoomIn,
+    ZoomOut,
+    Download,
+    Print,
+
+    NumMethodIdentifiers
+  };
+
+  enum Properties {
+    CurrentPage,
+    PageCount,
+    Zoom,
+    ZoomMode,
+    Continuous,
+    CreaterMode,
+    Dual,
+    Toolbar,
+
+    NumPropertyIdentifiers
+  };
+
+  EvBrowserPlugin *createObject(NPP instance) {
+    if (!identifiersInitialized) {
+      NPN_GetStringIdentifiers(methodIdentifierNames, NumMethodIdentifiers, methodIdentifiers);
+      NPN_GetStringIdentifiers(propertyIdentifierNames, NumPropertyIdentifiers, propertyIdentifiers);
+      identifiersInitialized = true;
+    }
+
+    return static_cast<EvBrowserPlugin *>(NPN_CreateObject(instance, &npClass));
+  }
+
+  NPClass npClass;
+
+  const NPUTF8 *methodIdentifierNames[NumMethodIdentifiers];
+  const NPUTF8 *propertyIdentifierNames[NumPropertyIdentifiers];
+  bool identifiersInitialized;
+  NPIdentifier methodIdentifiers[NumMethodIdentifiers];
+  NPIdentifier propertyIdentifiers[NumPropertyIdentifiers];
 };
 
-EvBrowserPlugin *EvBrowserPlugin::create(NPP instance)
-{
-        return s_pluginClass.createObject(instance);
+EvBrowserPlugin *EvBrowserPlugin::create(NPP instance) {
+  return s_pluginClass.createObject(instance);
 }
 
-const char *EvBrowserPlugin::nameString()
-{
-        return "Evince Browser Plugin";
+const char *EvBrowserPlugin::nameString() {
+  return "Evince Browser Plugin";
 }
 
-const char *EvBrowserPlugin::descriptionString()
-{
-        return "The <a href=\"http://wiki.gnome.org/Apps/Evince/\">Evince</a> " PACKAGE_VERSION " plugin handles documents inside the browser window.";
+const char *EvBrowserPlugin::descriptionString() {
+  return "The <a href=\"http://wiki.gnome.org/Apps/Evince/\">Evince</a> " PACKAGE_VERSION " plugin handles documents inside the browser window.";
 }
 
 EvBrowserPlugin::EvBrowserPlugin(NPP instance)
-        : m_NPP(instance)
-        , m_window(nullptr)
-        , m_model(nullptr)
-        , m_view(nullptr)
-        , m_toolbar(nullptr)
-{
-        m_NPP->pdata = this;
+  : m_NPP(instance)
+  , m_window(nullptr)
+  , m_model(nullptr)
+  , m_view(nullptr)
+  , m_toolbar(nullptr) {
+  m_NPP->pdata = this;
 }
 
-EvBrowserPlugin::~EvBrowserPlugin()
-{
-        if (m_window)
-                gtk_widget_destroy(m_window);
-        g_clear_object(&m_model);
-        m_NPP->pdata = nullptr;
+EvBrowserPlugin::~EvBrowserPlugin() {
+  if (m_window)
+    gtk_widget_destroy(m_window);
+  g_clear_object(&m_model);
+  m_NPP->pdata = nullptr;
 }
 
 template <typename IntegerType>
-static inline void parseInteger(const char *strValue, IntegerType &intValue)
-{
-        static const IntegerType intMax = std::numeric_limits<IntegerType>::max();
-        static const bool isSigned = std::numeric_limits<IntegerType>::is_signed;
-
-        if (!strValue)
-                return;
-
-        char *endPtr = nullptr;
-        errno = 0;
-        gint64 value = isSigned ? g_ascii_strtoll(strValue, &endPtr, 0) : g_ascii_strtoull(strValue, &endPtr, 0);
-        if (endPtr != strValue && errno == 0 && value <= intMax)
-                intValue = static_cast<IntegerType>(value);
-}
-
-static inline void parseDouble(const char *strValue, double &doubleValue)
-{
-        if (!strValue)
-                return;
-
-        char *endPtr = nullptr;
-        errno = 0;
-        double value = g_ascii_strtod(strValue, &endPtr);
-        if (endPtr != strValue && errno == 0)
-                doubleValue = value;
-}
-
-static inline void parseBoolean(const char *strValue, bool &boolValue)
-{
-        if (!strValue)
-                return;
-
-        unique_gptr<char> value(g_ascii_strdown(strValue, -1));
-        if (g_ascii_strcasecmp(value.get(), "false") == 0 || g_ascii_strcasecmp(value.get(), "no") == 0)
-                boolValue = false;
-        else if (g_ascii_strcasecmp(value.get(), "true") == 0 || g_ascii_strcasecmp(value.get(), "yes") == 0)
-                boolValue = true;
-        else {
-                int intValue = boolValue;
-                parseInteger<int>(strValue, intValue);
-                boolValue = intValue > 0;
-        }
-}
-
-static inline void parseZoomMode(const char *strValue, EvSizingMode &sizingModeValue)
-{
-        if (!strValue)
-                return;
-
-        unique_gptr<char> value(g_ascii_strdown(strValue, -1));
-        if (g_ascii_strcasecmp(value.get(), "none") == 0)
-                sizingModeValue = EV_SIZING_FREE;
-        else if (g_ascii_strcasecmp(value.get(), "fit-page") == 0)
-                sizingModeValue = EV_SIZING_FIT_PAGE;
-        else if (g_ascii_strcasecmp(value.get(), "fit-width") == 0)
-                sizingModeValue = EV_SIZING_FIT_WIDTH;
-        else if (g_ascii_strcasecmp(value.get(), "auto") == 0)
-                sizingModeValue = EV_SIZING_AUTOMATIC;
-}
-
-NPError EvBrowserPlugin::initialize(NPMIMEType, uint16_t mode, int16_t argc, char *argn[], char *argv[], NPSavedData *)
-{
-        // Default values.
-        bool toolbarVisible = true;
-        unsigned currentPage = 1;
-        EvSizingMode sizingMode = EV_SIZING_AUTOMATIC;
-        bool continuous = true;
-        bool dual = false;
-        double zoom = 0;
-
-        for (int16_t i = 0; i < argc; ++i) {
-                if (g_ascii_strcasecmp(argn[i], "toolbar") == 0)
-                        parseBoolean(argv[i], toolbarVisible);
-                else if (g_ascii_strcasecmp(argn[i], "currentpage") == 0)
-                        parseInteger<unsigned>(argv[i], currentPage);
-                else if (g_ascii_strcasecmp(argn[i], "zoom") == 0)
-                        parseDouble(argv[i], zoom);
-                else if (g_ascii_strcasecmp(argn[i], "zoommode") == 0)
-                        parseZoomMode(argv[i], sizingMode);
-                else if (g_ascii_strcasecmp(argn[i], "continuous") == 0)
-                        parseBoolean(argv[i], continuous);
-                else if (g_ascii_strcasecmp(argn[i], "dual") == 0)
-                        parseBoolean(argv[i], dual);
-        }
-
-        m_model = ev_document_model_new();
-        if (currentPage > 0)
-                ev_document_model_set_page(m_model, currentPage - 1);
-        ev_document_model_set_continuous(m_model, continuous);
-        ev_document_model_set_page_layout(m_model, dual ? EV_PAGE_LAYOUT_DUAL : EV_PAGE_LAYOUT_SINGLE);
-        if (zoom) {
-                ev_document_model_set_sizing_mode(m_model, EV_SIZING_FREE);
-                ev_document_model_set_scale(m_model, zoom);
-        } else
-                ev_document_model_set_sizing_mode(m_model, sizingMode);
+static inline void parseInteger(const char *strValue, IntegerType &intValue) {
+  static const IntegerType intMax = std::numeric_limits<IntegerType>::max();
+  static const bool isSigned = std::numeric_limits<IntegerType>::is_signed;
+
+  if (!strValue)
+    return;
+
+  char *endPtr = nullptr;
+  errno = 0;
+  gint64 value = isSigned ? g_ascii_strtoll(strValue, &endPtr, 0) : g_ascii_strtoull(strValue, &endPtr, 0);
+  if (endPtr != strValue && errno == 0 && value <= intMax)
+    intValue = static_cast<IntegerType>(value);
+}
+
+static inline void parseDouble(const char *strValue, double &doubleValue) {
+  if (!strValue)
+    return;
+
+  char *endPtr = nullptr;
+  errno = 0;
+  double value = g_ascii_strtod(strValue, &endPtr);
+  if (endPtr != strValue && errno == 0)
+    doubleValue = value;
+}
+
+static inline void parseBoolean(const char *strValue, bool &boolValue) {
+  if (!strValue)
+    return;
+
+  unique_gptr<char> value(g_ascii_strdown(strValue, -1));
+  if (g_ascii_strcasecmp(value.get(), "false") == 0 || g_ascii_strcasecmp(value.get(), "no") == 0)
+    boolValue = false;
+  else if (g_ascii_strcasecmp(value.get(), "true") == 0 || g_ascii_strcasecmp(value.get(), "yes") == 0)
+    boolValue = true;
+  else {
+    int intValue = boolValue;
+    parseInteger<int>(strValue, intValue);
+    boolValue = intValue > 0;
+  }
+}
+
+static inline void parseZoomMode(const char *strValue, EvSizingMode &sizingModeValue) {
+  if (!strValue)
+    return;
+
+  unique_gptr<char> value(g_ascii_strdown(strValue, -1));
+  if (g_ascii_strcasecmp(value.get(), "none") == 0)
+    sizingModeValue = EV_SIZING_FREE;
+  else if (g_ascii_strcasecmp(value.get(), "fit-page") == 0)
+    sizingModeValue = EV_SIZING_FIT_PAGE;
+  else if (g_ascii_strcasecmp(value.get(), "fit-width") == 0)
+    sizingModeValue = EV_SIZING_FIT_WIDTH;
+  else if (g_ascii_strcasecmp(value.get(), "auto") == 0)
+    sizingModeValue = EV_SIZING_AUTOMATIC;
+}
+
+NPError EvBrowserPlugin::initialize(NPMIMEType, uint16_t mode, int16_t argc, char *argn[], char *argv[], NPSavedData *) {
+  // Default values.
+  bool toolbarVisible = true;
+  unsigned currentPage = 1;
+  EvSizingMode sizingMode = EV_SIZING_AUTOMATIC;
+  bool continuous = true;
+  bool creator_mode = true;
+  bool dual = false;
+  double zoom = 0;
+
+  for (int16_t i = 0; i < argc; ++i) {
+    if (g_ascii_strcasecmp(argn[i], "toolbar") == 0)
+      parseBoolean(argv[i], toolbarVisible);
+    else if (g_ascii_strcasecmp(argn[i], "currentpage") == 0)
+      parseInteger<unsigned>(argv[i], currentPage);
+    else if (g_ascii_strcasecmp(argn[i], "zoom") == 0)
+      parseDouble(argv[i], zoom);
+    else if (g_ascii_strcasecmp(argn[i], "zoommode") == 0)
+      parseZoomMode(argv[i], sizingMode);
+    else if (g_ascii_strcasecmp(argn[i], "continuous") == 0)
+      parseBoolean(argv[i], continuous);
+    else if (g_ascii_strcasecmp(argn[i], "creator_mode") == 0)
+      parseBoolean(argv[i], creator_mode);
+    else if (g_ascii_strcasecmp(argn[i], "dual") == 0)
+      parseBoolean(argv[i], dual);
+  }
 
-        m_view = EV_VIEW(ev_view_new());
-        ev_view_set_model(m_view, m_model);
+  m_model = ev_document_model_new();
+  if (currentPage > 0)
+    ev_document_model_set_page(m_model, currentPage - 1);
+  ev_document_model_set_continuous(m_model, continuous);
+  ev_document_model_set_creator_mode(m_model, creator_mode);
+  ev_document_model_set_page_layout(m_model, dual ? EV_PAGE_LAYOUT_DUAL : EV_PAGE_LAYOUT_SINGLE);
+  if (zoom) {
+    ev_document_model_set_sizing_mode(m_model, EV_SIZING_FREE);
+    ev_document_model_set_scale(m_model, zoom);
+  } else
+    ev_document_model_set_sizing_mode(m_model, sizingMode);
 
-        m_toolbar = ev_browser_plugin_toolbar_new(this);
-        if (toolbarVisible)
-                gtk_widget_show(m_toolbar);
+  m_view = EV_VIEW(ev_view_new());
+  ev_view_set_model(m_view, m_model);
 
-        return NPERR_NO_ERROR;
+  m_toolbar = ev_browser_plugin_toolbar_new(this);
+  if (toolbarVisible)
+    gtk_widget_show(m_toolbar);
+
+  return NPERR_NO_ERROR;
 }
 
-NPError EvBrowserPlugin::setWindow(NPWindow *window)
-{
-        if (!m_window) {
-                m_window = gtk_plug_new(reinterpret_cast<Window>(window->window));
-                gtk_widget_realize(m_window);
+NPError EvBrowserPlugin::setWindow(NPWindow *window) {
+  if (!m_window) {
+    m_window = gtk_plug_new(reinterpret_cast<Window>(window->window));
+    gtk_widget_realize(m_window);
 
-                GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
-                gtk_box_pack_start(GTK_BOX(vbox), m_toolbar, FALSE, FALSE, 0);
+    GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+    gtk_box_pack_start(GTK_BOX(vbox), m_toolbar, FALSE, FALSE, 0);
 
-                GtkWidget *scrolledWindow = gtk_scrolled_window_new(nullptr, nullptr);
-                gtk_container_add(GTK_CONTAINER(scrolledWindow), GTK_WIDGET(m_view));
-                gtk_widget_show(GTK_WIDGET(m_view));
+    GtkWidget *scrolledWindow = gtk_scrolled_window_new(nullptr, nullptr);
+    gtk_container_add(GTK_CONTAINER(scrolledWindow), GTK_WIDGET(m_view));
+    gtk_widget_show(GTK_WIDGET(m_view));
 
-                gtk_box_pack_start(GTK_BOX(vbox), scrolledWindow, TRUE, TRUE, 0);
-                gtk_widget_show(scrolledWindow);
+    gtk_box_pack_start(GTK_BOX(vbox), scrolledWindow, TRUE, TRUE, 0);
+    gtk_widget_show(scrolledWindow);
 
-                gtk_container_add(GTK_CONTAINER(m_window), vbox);
-                gtk_widget_show(vbox);
-        }
+    gtk_container_add(GTK_CONTAINER(m_window), vbox);
+    gtk_widget_show(vbox);
+  }
 
-        gtk_widget_set_size_request(m_window, window->width, window->height);
-        gtk_widget_show(m_window);
+  gtk_widget_set_size_request(m_window, window->width, window->height);
+  gtk_widget_show(m_window);
 
-        return NPERR_NO_ERROR;
+  return NPERR_NO_ERROR;
 }
 
-NPError EvBrowserPlugin::newStream(NPMIMEType, NPStream *stream, NPBool seekable, uint16_t *stype)
-{
-        m_url.reset(g_strdup(stream->url));
-        *stype = NP_ASFILEONLY;
-        return NPERR_NO_ERROR;
+NPError EvBrowserPlugin::newStream(NPMIMEType, NPStream *stream, NPBool seekable, uint16_t *stype) {
+  m_url.reset(g_strdup(stream->url));
+  *stype = NP_ASFILEONLY;
+  return NPERR_NO_ERROR;
 }
 
-NPError EvBrowserPlugin::destroyStream(NPStream *, NPReason)
-{
-        return NPERR_NO_ERROR;
+NPError EvBrowserPlugin::destroyStream(NPStream *, NPReason) {
+  return NPERR_NO_ERROR;
 }
 
-void EvBrowserPlugin::streamAsFile(NPStream *, const char *fname)
-{
-        GFile *file = g_file_new_for_commandline_arg(fname);
-        unique_gptr<char> uri(g_file_get_uri(file));
-        g_object_unref(file);
+void EvBrowserPlugin::streamAsFile(NPStream *, const char *fname) {
+  GFile *file = g_file_new_for_commandline_arg(fname);
+  unique_gptr<char> uri(g_file_get_uri(file));
+  g_object_unref(file);
 
-        // Load the document synchronously here because the temporary file created by the browser
-        // is deleted when this function returns.
-        GError *error = nullptr;
-        EvDocument *document = ev_document_factory_get_document(uri.get(), &error);
-        if (!document) {
-                g_printerr("Error loading document %s: %s\n", uri.get(), error->message);
-                g_error_free(error);
-        } else {
-                ev_document_model_set_document(m_model, document);
-                g_object_unref(document);
+  // Load the document synchronously here because the temporary file created by the browser
+  // is deleted when this function returns.
+  GError *error = nullptr;
+  EvDocument *document = ev_document_factory_get_document(uri.get(), &error);
+  if (!document) {
+    g_printerr("Error loading document %s: %s\n", uri.get(), error->message);
+    g_error_free(error);
+  } else {
+    ev_document_model_set_document(m_model, document);
+    g_object_unref(document);
 
-                ev_view_set_loading(EV_VIEW(m_view), FALSE);
-        }
+    ev_view_set_loading(EV_VIEW(m_view), FALSE);
+  }
 }
 
-int32_t EvBrowserPlugin::writeReady(NPStream *)
-{
-        return 0;
+int32_t EvBrowserPlugin::writeReady(NPStream *) {
+  return 0;
 }
 
-int32_t EvBrowserPlugin::write(NPStream *, int32_t /*offset*/, int32_t /*len*/, void */*buffer*/)
-{
-        return 0;
+int32_t EvBrowserPlugin::write(NPStream *, int32_t /*offset*/, int32_t /*len*/, void */*buffer*/) {
+  return 0;
 }
 
-void EvBrowserPlugin::print(NPPrint *)
-{
+void EvBrowserPlugin::print(NPPrint *) {
 
 }
 
-int16_t EvBrowserPlugin::handleEvent(XEvent *)
-{
-        return 0;
+int16_t EvBrowserPlugin::handleEvent(XEvent *) {
+  return 0;
 }
 
-void EvBrowserPlugin::urlNotify(const char */*url*/, NPReason, void */*notifyData*/)
-{
+void EvBrowserPlugin::urlNotify(const char */*url*/, NPReason, void */*notifyData*/) {
 
 }
 
-unsigned EvBrowserPlugin::currentPage() const
-{
-        g_return_val_if_fail(EV_IS_DOCUMENT_MODEL(m_model), 0);
-        return ev_document_model_get_page(m_model);
+unsigned EvBrowserPlugin::currentPage() const {
+  g_return_val_if_fail(EV_IS_DOCUMENT_MODEL(m_model), 0);
+  return ev_document_model_get_page(m_model);
 }
 
-unsigned EvBrowserPlugin::pageCount() const
-{
-        g_return_val_if_fail(EV_IS_DOCUMENT_MODEL(m_model), 0);
-        EvDocument *document = ev_document_model_get_document(m_model);
-        return document ? ev_document_get_n_pages(document) : 0;
+unsigned EvBrowserPlugin::pageCount() const {
+  g_return_val_if_fail(EV_IS_DOCUMENT_MODEL(m_model), 0);
+  EvDocument *document = ev_document_model_get_document(m_model);
+  return document ? ev_document_get_n_pages(document) : 0;
 }
 
-double EvBrowserPlugin::zoom() const
-{
-        g_return_val_if_fail(EV_IS_DOCUMENT_MODEL(m_model), 1);
-        return ev_document_model_get_scale(m_model);
+double EvBrowserPlugin::zoom() const {
+  g_return_val_if_fail(EV_IS_DOCUMENT_MODEL(m_model), 1);
+  return ev_document_model_get_scale(m_model);
 }
 
-void EvBrowserPlugin::setZoom(double scale)
-{
-        g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
-        ev_document_model_set_sizing_mode(m_model, EV_SIZING_FREE);
-        ev_document_model_set_scale(m_model, scale);
+void EvBrowserPlugin::setZoom(double scale) {
+  g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
+  ev_document_model_set_sizing_mode(m_model, EV_SIZING_FREE);
+  ev_document_model_set_scale(m_model, scale);
 }
 
-void EvBrowserPlugin::goToPreviousPage()
-{
-        g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
-        ev_document_model_set_page(m_model, ev_document_model_get_page(m_model) - 1);
+void EvBrowserPlugin::goToPreviousPage() {
+  g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
+  ev_document_model_set_page(m_model, ev_document_model_get_page(m_model) - 1);
 }
 
-void EvBrowserPlugin::goToNextPage()
-{
-        g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
-        ev_document_model_set_page(m_model, ev_document_model_get_page(m_model) + 1);
+void EvBrowserPlugin::goToNextPage() {
+  g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
+  ev_document_model_set_page(m_model, ev_document_model_get_page(m_model) + 1);
 }
 
-void EvBrowserPlugin::goToPage(unsigned page)
-{
-        g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
-        ev_document_model_set_page(m_model, page - 1);
+void EvBrowserPlugin::goToPage(unsigned page) {
+  g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
+  ev_document_model_set_page(m_model, page - 1);
 }
 
-void EvBrowserPlugin::goToPage(const char *pageLabel)
-{
-        g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
-        ev_document_model_set_page_by_label(m_model, pageLabel);
+void EvBrowserPlugin::goToPage(const char *pageLabel) {
+  g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
+  ev_document_model_set_page_by_label(m_model, pageLabel);
 }
 
-void EvBrowserPlugin::activateLink(EvLink *link)
-{
-        g_return_if_fail(EV_IS_VIEW(m_view));
-        g_return_if_fail(EV_IS_LINK(link));
-        ev_view_handle_link(m_view, link);
-        gtk_widget_grab_focus(GTK_WIDGET(m_view));
+void EvBrowserPlugin::activateLink(EvLink *link) {
+  g_return_if_fail(EV_IS_VIEW(m_view));
+  g_return_if_fail(EV_IS_LINK(link));
+  ev_view_handle_link(m_view, link);
+  gtk_widget_grab_focus(GTK_WIDGET(m_view));
 }
 
-bool EvBrowserPlugin::isContinuous() const
-{
-        g_return_val_if_fail(EV_IS_DOCUMENT_MODEL(m_model), false);
-        return ev_document_model_get_continuous(m_model);
+bool EvBrowserPlugin::isContinuous() const {
+  g_return_val_if_fail(EV_IS_DOCUMENT_MODEL(m_model), false);
+  return ev_document_model_get_continuous(m_model);
 }
 
-void EvBrowserPlugin::setContinuous(bool continuous)
-{
-        g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
-        ev_document_model_set_continuous(m_model, continuous);
+void EvBrowserPlugin::setContinuous(bool continuous) {
+  g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
+  ev_document_model_set_continuous(m_model, continuous);
 }
 
-void EvBrowserPlugin::toggleContinuous()
-{
-        g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
-        ev_document_model_set_continuous(m_model, !ev_document_model_get_continuous(m_model));
+void EvBrowserPlugin::toggleContinuous() {
+  g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
+  ev_document_model_set_continuous(m_model, !ev_document_model_get_continuous(m_model));
 }
 
-bool EvBrowserPlugin::isDual() const
-{
-        g_return_val_if_fail(EV_IS_DOCUMENT_MODEL(m_model), false);
-        return ev_document_model_get_page_layout(m_model) == EV_PAGE_LAYOUT_DUAL;
+bool EvBrowserPlugin::isCreatorMode() const {
+  g_return_val_if_fail(EV_IS_DOCUMENT_MODEL(m_model), false);
+  return ev_document_model_get_creator_mode(m_model);
 }
 
-void EvBrowserPlugin::setDual(bool dual)
-{
-        g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
-        ev_document_model_set_page_layout(m_model, dual ? EV_PAGE_LAYOUT_DUAL : EV_PAGE_LAYOUT_SINGLE);
+void EvBrowserPlugin::setCreatorMode(bool creatorMode) {
+  g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
+  ev_document_model_set_creator_mode(m_model, creatorMode);
 }
 
-void EvBrowserPlugin::toggleDual()
-{
-        g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
-        ev_document_model_set_page_layout(m_model, isDual() ? EV_PAGE_LAYOUT_SINGLE : EV_PAGE_LAYOUT_DUAL);
+void EvBrowserPlugin::toggleCreatorMode() {
+  g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
+  ev_document_model_set_creator_mode(m_model, !ev_document_model_get_creator_mode(m_model));
 }
 
-void EvBrowserPlugin::zoomIn()
-{
-        g_return_if_fail(EV_IS_VIEW(m_view));
-        ev_document_model_set_sizing_mode(m_model, EV_SIZING_FREE);
-        ev_view_zoom_in(m_view);
-}
 
-void EvBrowserPlugin::zoomOut()
-{
-        g_return_if_fail(EV_IS_VIEW(m_view));
-        ev_document_model_set_sizing_mode(m_model, EV_SIZING_FREE);
-        ev_view_zoom_out(m_view);
+bool EvBrowserPlugin::isDual() const {
+  g_return_val_if_fail(EV_IS_DOCUMENT_MODEL(m_model), false);
+  return ev_document_model_get_page_layout(m_model) == EV_PAGE_LAYOUT_DUAL;
 }
 
-EvSizingMode EvBrowserPlugin::sizingMode() const
-{
-        g_return_val_if_fail(EV_IS_DOCUMENT_MODEL(m_model), EV_SIZING_FREE);
-        return ev_document_model_get_sizing_mode(m_model);
+void EvBrowserPlugin::setDual(bool dual) {
+  g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
+  ev_document_model_set_page_layout(m_model, dual ? EV_PAGE_LAYOUT_DUAL : EV_PAGE_LAYOUT_SINGLE);
 }
 
-void EvBrowserPlugin::setSizingMode(EvSizingMode sizingMode)
-{
-        g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
-        ev_document_model_set_sizing_mode(m_model, sizingMode);
+void EvBrowserPlugin::toggleDual() {
+  g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
+  ev_document_model_set_page_layout(m_model, isDual() ? EV_PAGE_LAYOUT_SINGLE : EV_PAGE_LAYOUT_DUAL);
 }
 
-void EvBrowserPlugin::download() const
-{
-        g_return_if_fail(m_url);
-        // Since I don't know how to force a download in the browser, I use
-        // a special frame name here that Epiphany will check in the new window policy
-        // callback to start the download.
-        NPN_GetURL(m_NPP, m_url.get(), "_evince_download");
+void EvBrowserPlugin::zoomIn() {
+  g_return_if_fail(EV_IS_VIEW(m_view));
+  ev_document_model_set_sizing_mode(m_model, EV_SIZING_FREE);
+  ev_view_zoom_in(m_view);
 }
 
-void EvBrowserPlugin::print() const
-{
-        g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
-
-        EvDocument *document = ev_document_model_get_document(m_model);
-        if (!document)
-                return;
-
-        EvPrintOperation *printOperation = ev_print_operation_new(document);
-        if (!printOperation)
-                return;
-
-        unique_gptr<char> outputBasename(g_path_get_basename(m_url.get()));
-        if (char *dot = g_strrstr(outputBasename.get(), "."))
-                dot[0] = '\0';
-
-        unique_gptr<char> unescapedBasename(g_uri_unescape_string(outputBasename.get(), nullptr));
-        // Set output basename for printing to file.
-        GtkPrintSettings *printSettings = gtk_print_settings_new();
-        gtk_print_settings_set(printSettings, GTK_PRINT_SETTINGS_OUTPUT_BASENAME, unescapedBasename.get());
-
-        if (const char *title = ev_document_get_title(document))
-                ev_print_operation_set_job_name(printOperation, title);
-        ev_print_operation_set_current_page(printOperation, ev_document_model_get_page(m_model));
-        ev_print_operation_set_embed_page_setup (printOperation, TRUE);
-        ev_print_operation_set_print_settings(printOperation, printSettings);
-        g_object_unref(printSettings);
-
-        g_signal_connect(printOperation, "done", G_CALLBACK(g_object_unref), nullptr);
-
-        GtkWidget *toplevel = gtk_widget_get_toplevel(GTK_WIDGET(m_view));
-        ev_print_operation_run(printOperation, GTK_IS_WINDOW(toplevel) ? GTK_WINDOW(toplevel) : nullptr);
+void EvBrowserPlugin::zoomOut() {
+  g_return_if_fail(EV_IS_VIEW(m_view));
+  ev_document_model_set_sizing_mode(m_model, EV_SIZING_FREE);
+  ev_view_zoom_out(m_view);
 }
 
-bool EvBrowserPlugin::canDownload() const
-{
-        // Download is only available for Epiphany for now.
-        return g_strrstr(NPN_UserAgent(m_NPP), "Epiphany");
+EvSizingMode EvBrowserPlugin::sizingMode() const {
+  g_return_val_if_fail(EV_IS_DOCUMENT_MODEL(m_model), EV_SIZING_FREE);
+  return ev_document_model_get_sizing_mode(m_model);
 }
 
-bool EvBrowserPlugin::toolbarVisible() const
-{
-        g_return_val_if_fail(EV_IS_BROWSER_PLUGIN_TOOLBAR(m_toolbar), false);
-        return gtk_widget_get_visible(m_toolbar);
+void EvBrowserPlugin::setSizingMode(EvSizingMode sizingMode) {
+  g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
+  ev_document_model_set_sizing_mode(m_model, sizingMode);
 }
 
-void EvBrowserPlugin::setToolbarVisible(bool isVisible)
-{
-        g_return_if_fail(EV_IS_BROWSER_PLUGIN_TOOLBAR(m_toolbar));
-        if (isVisible)
-                gtk_widget_show(m_toolbar);
-        else
-                gtk_widget_hide(m_toolbar);
+void EvBrowserPlugin::download() const {
+  g_return_if_fail(m_url);
+  // Since I don't know how to force a download in the browser, I use
+  // a special frame name here that Epiphany will check in the new window policy
+  // callback to start the download.
+  NPN_GetURL(m_NPP, m_url.get(), "_evince_download");
 }
 
-void EvBrowserPlugin::setSearchModeEnabled(bool enabled)
-{
-        ev_view_find_set_highlight_search(m_view, enabled);
-}
+void EvBrowserPlugin::print() const {
+  g_return_if_fail(EV_IS_DOCUMENT_MODEL(m_model));
 
-void EvBrowserPlugin::search(EvJobFind *job)
-{
-        ev_view_find_search_changed(m_view);
-        ev_view_find_started(m_view, job);
-}
+  EvDocument *document = ev_document_model_get_document(m_model);
+  if (!document)
+    return;
 
-void EvBrowserPlugin::search(SearchDirection direction)
-{
-        switch (direction) {
-        case Next:
-                ev_view_find_next(m_view);
-                break;
-        case Previous:
-                ev_view_find_previous(m_view);
-                break;
-        }
-}
+  EvPrintOperation *printOperation = ev_print_operation_new(document);
+  if (!printOperation)
+    return;
 
-void EvBrowserPlugin::clearSearch()
-{
-        ev_view_find_search_changed(m_view);
-        gtk_widget_queue_draw(GTK_WIDGET(m_view));
-}
+  unique_gptr<char> outputBasename(g_path_get_basename(m_url.get()));
+  if (char *dot = g_strrstr(outputBasename.get(), "."))
+    dot[0] = '\0';
 
-void EvBrowserPlugin::restartSearch()
-{
-        ev_view_find_restart(m_view, ev_document_model_get_page(m_model));
-}
+  unique_gptr<char> unescapedBasename(g_uri_unescape_string(outputBasename.get(), nullptr));
+  // Set output basename for printing to file.
+  GtkPrintSettings *printSettings = gtk_print_settings_new();
+  gtk_print_settings_set(printSettings, GTK_PRINT_SETTINGS_OUTPUT_BASENAME, unescapedBasename.get());
 
-// Scripting interface
-NPObject *EvBrowserPlugin::allocate(NPP instance, NPClass *)
-{
-        return new EvBrowserPlugin(instance);
+  if (const char *title = ev_document_get_title(document))
+    ev_print_operation_set_job_name(printOperation, title);
+  ev_print_operation_set_current_page(printOperation, ev_document_model_get_page(m_model));
+  ev_print_operation_set_embed_page_setup (printOperation, TRUE);
+  ev_print_operation_set_print_settings(printOperation, printSettings);
+  g_object_unref(printSettings);
+
+  g_signal_connect(printOperation, "done", G_CALLBACK(g_object_unref), nullptr);
+
+  GtkWidget *toplevel = gtk_widget_get_toplevel(GTK_WIDGET(m_view));
+  ev_print_operation_run(printOperation, GTK_IS_WINDOW(toplevel) ? GTK_WINDOW(toplevel) : nullptr);
 }
 
-void EvBrowserPlugin::deallocate(NPObject *npObject)
-{
-        delete static_cast<EvBrowserPlugin *>(npObject);
+bool EvBrowserPlugin::canDownload() const {
+  // Download is only available for Epiphany for now.
+  return g_strrstr(NPN_UserAgent(m_NPP), "Epiphany");
 }
 
-void EvBrowserPlugin::invalidate(NPObject *)
-{
+bool EvBrowserPlugin::toolbarVisible() const {
+  g_return_val_if_fail(EV_IS_BROWSER_PLUGIN_TOOLBAR(m_toolbar), false);
+  return gtk_widget_get_visible(m_toolbar);
 }
 
-bool EvBrowserPlugin::hasMethod(NPObject *npObject, NPIdentifier name)
-{
-        for (unsigned i = 0; i < EvBrowserPluginClass::Methods::NumMethodIdentifiers; ++i) {
-                if (name == s_pluginClass.methodIdentifiers[i]) {
-                        if (i == EvBrowserPluginClass::Methods::Download)
-                                return static_cast<EvBrowserPlugin *>(npObject)->canDownload();
-                        return true;
-                }
-        }
-        return false;
+void EvBrowserPlugin::setToolbarVisible(bool isVisible) {
+  g_return_if_fail(EV_IS_BROWSER_PLUGIN_TOOLBAR(m_toolbar));
+  if (isVisible)
+    gtk_widget_show(m_toolbar);
+  else
+    gtk_widget_hide(m_toolbar);
 }
 
-bool EvBrowserPlugin::invoke(NPObject *npObject, NPIdentifier name, const NPVariant *args, uint32_t argCount, NPVariant *result)
-{
-        EvBrowserPlugin *plugin = static_cast<EvBrowserPlugin *>(npObject);
-
-        if (name == s_pluginClass.methodIdentifiers[EvBrowserPluginClass::Methods::GoToPage]) {
-                if (argCount != 1)
-                        return false;
-
-                if (NPVARIANT_IS_DOUBLE(args[0]))
-                        plugin->goToPage(static_cast<unsigned>(NPVARIANT_TO_DOUBLE(args[0])));
-                else if (NPVARIANT_IS_STRING(args[0])) {
-                        unique_gptr<char> pageLabel(g_strndup(NPVARIANT_TO_STRING(args[0]).UTF8Characters, NPVARIANT_TO_STRING(args[0]).UTF8Length));
-                        plugin->goToPage(pageLabel.get());
-                } else
-                        return false;
-
-                VOID_TO_NPVARIANT(*result);
-                return true;
-        }
-        if (name == s_pluginClass.methodIdentifiers[EvBrowserPluginClass::Methods::ToggleContinuous]) {
-                plugin->toggleContinuous();
-                VOID_TO_NPVARIANT(*result);
-                return true;
-        }
-        if (name == s_pluginClass.methodIdentifiers[EvBrowserPluginClass::Methods::ToggleDual]) {
-                plugin->toggleDual();
-                VOID_TO_NPVARIANT(*result);
-                return true;
-        }
-        if (name == s_pluginClass.methodIdentifiers[EvBrowserPluginClass::Methods::ZoomIn]) {
-                plugin->zoomIn();
-                VOID_TO_NPVARIANT(*result);
-                return true;
-        }
-        if (name == s_pluginClass.methodIdentifiers[EvBrowserPluginClass::Methods::ZoomOut]) {
-                plugin->zoomOut();
-                VOID_TO_NPVARIANT(*result);
-                return true;
-        }
-        if (name == s_pluginClass.methodIdentifiers[EvBrowserPluginClass::Methods::Download]) {
-                plugin->download();
-                VOID_TO_NPVARIANT(*result);
-                return true;
-        }
-        if (name == s_pluginClass.methodIdentifiers[EvBrowserPluginClass::Methods::Print]) {
-                plugin->print();
-                VOID_TO_NPVARIANT(*result);
-                return true;
-        }
-        return false;
+void EvBrowserPlugin::setSearchModeEnabled(bool enabled) {
+  ev_view_find_set_highlight_search(m_view, enabled);
 }
 
-bool EvBrowserPlugin::hasProperty(NPObject *npObject, NPIdentifier name)
-{
-        for (unsigned i = 0; i < EvBrowserPluginClass::Properties::NumPropertyIdentifiers; ++i) {
-                if (name == s_pluginClass.propertyIdentifiers[i])
-                        return true;
-        }
-        return false;
+void EvBrowserPlugin::search(EvJobFind *job) {
+  ev_view_find_search_changed(m_view);
+  ev_view_find_started(m_view, job);
 }
 
-bool EvBrowserPlugin::getProperty(NPObject *npObject, NPIdentifier name, NPVariant *value)
-{
-        EvBrowserPlugin *plugin = static_cast<EvBrowserPlugin *>(npObject);
-
-        if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::CurrentPage]) {
-                INT32_TO_NPVARIANT(plugin->currentPage() + 1, *value);
-                return true;
-        }
-        if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::PageCount]) {
-                INT32_TO_NPVARIANT(plugin->pageCount(), *value);
-                return true;
-        }
-        if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::Zoom]) {
-                DOUBLE_TO_NPVARIANT(plugin->zoom(), *value);
-                return true;
-        }
-        if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::ZoomMode]) {
-                const char *zoomMode;
-
-                switch (plugin->sizingMode()) {
-                case EV_SIZING_FREE:
-                        zoomMode = "none";
-                        break;
-                case EV_SIZING_FIT_PAGE:
-                        zoomMode = "fit-page";
-                        break;
-                case EV_SIZING_FIT_WIDTH:
-                        zoomMode = "fit-width";
-                        break;
-                case EV_SIZING_AUTOMATIC:
-                        zoomMode = "auto";
-                        break;
-                default:
-                        return false;
-                }
-
-                size_t zoomModeLength = strlen(zoomMode);
-                char *result = static_cast<char *>(NPN_MemAlloc(zoomModeLength + 1));
-                memcpy(result, zoomMode, zoomModeLength);
-                result[zoomModeLength] = '\0';
-
-                STRINGZ_TO_NPVARIANT(result, *value);
-
-                return true;
-        }
-        if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::Continuous]) {
-                BOOLEAN_TO_NPVARIANT(plugin->isContinuous(), *value);
-                return true;
-        }
-        if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::Dual]) {
-                BOOLEAN_TO_NPVARIANT(plugin->isDual(), *value);
-                return true;
-        }
-        if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::Toolbar]) {
-                BOOLEAN_TO_NPVARIANT(plugin->toolbarVisible(), *value);
-                return true;
-        }
+void EvBrowserPlugin::search(SearchDirection direction) {
+  switch (direction) {
+    case Next:
+      ev_view_find_next(m_view);
+      break;
+    case Previous:
+      ev_view_find_previous(m_view);
+      break;
+  }
+}
 
-        return false;
+void EvBrowserPlugin::clearSearch() {
+  ev_view_find_search_changed(m_view);
+  gtk_widget_queue_draw(GTK_WIDGET(m_view));
 }
 
-bool EvBrowserPlugin::setProperty(NPObject *npObject, NPIdentifier name, const NPVariant *value)
-{
-        EvBrowserPlugin *plugin = static_cast<EvBrowserPlugin *>(npObject);
-
-        if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::CurrentPage]) {
-                plugin->goToPage(static_cast<unsigned>(NPVARIANT_TO_DOUBLE(*value)));
-                return true;
-        }
-        if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::Zoom]) {
-                plugin->setZoom(NPVARIANT_TO_DOUBLE(*value));
-                return true;
-        }
-        if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::ZoomMode]) {
-                unique_gptr<char> zoomMode(g_strndup(NPVARIANT_TO_STRING(*value).UTF8Characters, NPVARIANT_TO_STRING(*value).UTF8Length));
-
-                if (g_strcmp0(zoomMode.get(), "none") == 0)
-                        plugin->setSizingMode(EV_SIZING_FREE);
-                else if (g_strcmp0(zoomMode.get(), "fit-page") == 0)
-                        plugin->setSizingMode(EV_SIZING_FIT_PAGE);
-                else if (g_strcmp0(zoomMode.get(), "fit-width") == 0)
-                        plugin->setSizingMode(EV_SIZING_FIT_WIDTH);
-                else if (g_strcmp0(zoomMode.get(), "auto") == 0)
-                        plugin->setSizingMode(EV_SIZING_AUTOMATIC);
-                else
-                        return false;
-
-                return true;
-        }
-        if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::Continuous]) {
-                plugin->setContinuous(NPVARIANT_TO_BOOLEAN(*value));
-                return true;
-        }
-        if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::Dual]) {
-                plugin->setDual(NPVARIANT_TO_BOOLEAN(*value));
-                return true;
-        }
-        if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::Toolbar]) {
-                plugin->setToolbarVisible(NPVARIANT_TO_BOOLEAN(*value));
-                return true;
-        }
+void EvBrowserPlugin::restartSearch() {
+  ev_view_find_restart(m_view, ev_document_model_get_page(m_model));
+}
 
+// Scripting interface
+NPObject *EvBrowserPlugin::allocate(NPP instance, NPClass *) {
+  return new EvBrowserPlugin(instance);
+}
+
+void EvBrowserPlugin::deallocate(NPObject *npObject) {
+  delete static_cast<EvBrowserPlugin *>(npObject);
+}
+
+void EvBrowserPlugin::invalidate(NPObject *) {
+}
+
+bool EvBrowserPlugin::hasMethod(NPObject *npObject, NPIdentifier name) {
+  for (unsigned i = 0; i < EvBrowserPluginClass::Methods::NumMethodIdentifiers; ++i) {
+    if (name == s_pluginClass.methodIdentifiers[i]) {
+      if (i == EvBrowserPluginClass::Methods::Download)
+        return static_cast<EvBrowserPlugin *>(npObject)->canDownload();
+      return true;
+    }
+  }
+  return false;
+}
+
+bool EvBrowserPlugin::invoke(NPObject *npObject, NPIdentifier name, const NPVariant *args, uint32_t argCount, NPVariant *result) {
+  EvBrowserPlugin *plugin = static_cast<EvBrowserPlugin *>(npObject);
+
+  if (name == s_pluginClass.methodIdentifiers[EvBrowserPluginClass::Methods::GoToPage]) {
+    if (argCount != 1)
+      return false;
+
+    if (NPVARIANT_IS_DOUBLE(args[0]))
+      plugin->goToPage(static_cast<unsigned>(NPVARIANT_TO_DOUBLE(args[0])));
+    else if (NPVARIANT_IS_STRING(args[0])) {
+      unique_gptr<char> pageLabel(g_strndup(NPVARIANT_TO_STRING(args[0]).UTF8Characters, NPVARIANT_TO_STRING(args[0]).UTF8Length));
+      plugin->goToPage(pageLabel.get());
+    } else
+      return false;
+
+    VOID_TO_NPVARIANT(*result);
+    return true;
+  }
+  if (name == s_pluginClass.methodIdentifiers[EvBrowserPluginClass::Methods::ToggleContinuous]) {
+    plugin->toggleContinuous();
+    VOID_TO_NPVARIANT(*result);
+    return true;
+  }
+
+  if (name == s_pluginClass.methodIdentifiers[EvBrowserPluginClass::Methods::ToggleCreaterMode]) {
+    plugin->toggleCreatorMode();
+    VOID_TO_NPVARIANT(*result);
+    return true;
+  }
+
+
+  if (name == s_pluginClass.methodIdentifiers[EvBrowserPluginClass::Methods::ToggleDual]) {
+    plugin->toggleDual();
+    VOID_TO_NPVARIANT(*result);
+    return true;
+  }
+  if (name == s_pluginClass.methodIdentifiers[EvBrowserPluginClass::Methods::ZoomIn]) {
+    plugin->zoomIn();
+    VOID_TO_NPVARIANT(*result);
+    return true;
+  }
+  if (name == s_pluginClass.methodIdentifiers[EvBrowserPluginClass::Methods::ZoomOut]) {
+    plugin->zoomOut();
+    VOID_TO_NPVARIANT(*result);
+    return true;
+  }
+  if (name == s_pluginClass.methodIdentifiers[EvBrowserPluginClass::Methods::Download]) {
+    plugin->download();
+    VOID_TO_NPVARIANT(*result);
+    return true;
+  }
+  if (name == s_pluginClass.methodIdentifiers[EvBrowserPluginClass::Methods::Print]) {
+    plugin->print();
+    VOID_TO_NPVARIANT(*result);
+    return true;
+  }
+  return false;
+}
+
+bool EvBrowserPlugin::hasProperty(NPObject *npObject, NPIdentifier name) {
+  for (unsigned i = 0; i < EvBrowserPluginClass::Properties::NumPropertyIdentifiers; ++i) {
+    if (name == s_pluginClass.propertyIdentifiers[i])
+      return true;
+  }
+  return false;
+}
+
+bool EvBrowserPlugin::getProperty(NPObject *npObject, NPIdentifier name, NPVariant *value) {
+  EvBrowserPlugin *plugin = static_cast<EvBrowserPlugin *>(npObject);
+
+  if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::CurrentPage]) {
+    INT32_TO_NPVARIANT(plugin->currentPage() + 1, *value);
+    return true;
+  }
+  if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::PageCount]) {
+    INT32_TO_NPVARIANT(plugin->pageCount(), *value);
+    return true;
+  }
+  if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::Zoom]) {
+    DOUBLE_TO_NPVARIANT(plugin->zoom(), *value);
+    return true;
+  }
+  if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::ZoomMode]) {
+    const char *zoomMode;
+
+    switch (plugin->sizingMode()) {
+      case EV_SIZING_FREE:
+        zoomMode = "none";
+        break;
+      case EV_SIZING_FIT_PAGE:
+        zoomMode = "fit-page";
+        break;
+      case EV_SIZING_FIT_WIDTH:
+        zoomMode = "fit-width";
+        break;
+      case EV_SIZING_AUTOMATIC:
+        zoomMode = "auto";
+        break;
+      default:
         return false;
+    }
+
+    size_t zoomModeLength = strlen(zoomMode);
+    char *result = static_cast<char *>(NPN_MemAlloc(zoomModeLength + 1));
+    memcpy(result, zoomMode, zoomModeLength);
+    result[zoomModeLength] = '\0';
+
+    STRINGZ_TO_NPVARIANT(result, *value);
+
+    return true;
+  }
+  if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::Continuous]) {
+    BOOLEAN_TO_NPVARIANT(plugin->isContinuous(), *value);
+    return true;
+  }
+  if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::CreaterMode]) {
+    BOOLEAN_TO_NPVARIANT(plugin->isCreatorMode(), *value);
+    return true;
+  }
+  if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::Dual]) {
+    BOOLEAN_TO_NPVARIANT(plugin->isDual(), *value);
+    return true;
+  }
+  if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::Toolbar]) {
+    BOOLEAN_TO_NPVARIANT(plugin->toolbarVisible(), *value);
+    return true;
+  }
+
+  return false;
+}
+
+bool EvBrowserPlugin::setProperty(NPObject *npObject, NPIdentifier name, const NPVariant *value) {
+  EvBrowserPlugin *plugin = static_cast<EvBrowserPlugin *>(npObject);
+
+  if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::CurrentPage]) {
+    plugin->goToPage(static_cast<unsigned>(NPVARIANT_TO_DOUBLE(*value)));
+    return true;
+  }
+  if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::Zoom]) {
+    plugin->setZoom(NPVARIANT_TO_DOUBLE(*value));
+    return true;
+  }
+  if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::ZoomMode]) {
+    unique_gptr<char> zoomMode(g_strndup(NPVARIANT_TO_STRING(*value).UTF8Characters, NPVARIANT_TO_STRING(*value).UTF8Length));
+
+    if (g_strcmp0(zoomMode.get(), "none") == 0)
+      plugin->setSizingMode(EV_SIZING_FREE);
+    else if (g_strcmp0(zoomMode.get(), "fit-page") == 0)
+      plugin->setSizingMode(EV_SIZING_FIT_PAGE);
+    else if (g_strcmp0(zoomMode.get(), "fit-width") == 0)
+      plugin->setSizingMode(EV_SIZING_FIT_WIDTH);
+    else if (g_strcmp0(zoomMode.get(), "auto") == 0)
+      plugin->setSizingMode(EV_SIZING_AUTOMATIC);
+    else
+      return false;
+
+    return true;
+  }
+  if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::Continuous]) {
+    plugin->setContinuous(NPVARIANT_TO_BOOLEAN(*value));
+    return true;
+  }
+  if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::CreaterMode]) {
+    plugin->setCreatorMode(NPVARIANT_TO_BOOLEAN(*value));
+    return true;
+  }
+  if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::Dual]) {
+    plugin->setDual(NPVARIANT_TO_BOOLEAN(*value));
+    return true;
+  }
+  if (name == s_pluginClass.propertyIdentifiers[EvBrowserPluginClass::Properties::Toolbar]) {
+    plugin->setToolbarVisible(NPVARIANT_TO_BOOLEAN(*value));
+    return true;
+  }
+
+  return false;
 }
 
 EvBrowserPluginClass EvBrowserPlugin::s_pluginClass {
-        {
-                NP_CLASS_STRUCT_VERSION,
-                allocate,
-                deallocate,
-                invalidate,
-                hasMethod,
-                invoke,
-                nullptr, // NPClass::invokeDefault
-                hasProperty,
-                getProperty,
-                setProperty,
-                nullptr, // NPClass::removeProperty
-                nullptr, // NPClass::enumerate
-                nullptr // NPClass::construct
-        },
-        // methodIdentifierNames
-        {
-                "goToPage",
-                "toggleContinuous",
-                "toggleDual",
-                "zoomIn",
-                "zoomOut",
-                "download",
-                "print"
-        },
-        // propertyIdentifierNames
-        {
-                "currentPage",
-                "pageCount",
-                "zoom",
-                "zoomMode",
-                "continuous",
-                "dual",
-                "toolbar"
-        },
-        false // identifiersInitialized
+  {
+    NP_CLASS_STRUCT_VERSION,
+    allocate,
+    deallocate,
+    invalidate,
+    hasMethod,
+    invoke,
+    nullptr, // NPClass::invokeDefault
+    hasProperty,
+    getProperty,
+    setProperty,
+    nullptr, // NPClass::removeProperty
+    nullptr, // NPClass::enumerate
+    nullptr // NPClass::construct
+  },
+  // methodIdentifierNames
+  {
+    "goToPage",
+    "toggleContinuous",
+    "toggleCreatorMode",
+    "toggleDual",
+    "zoomIn",
+    "zoomOut",
+    "download",
+    "print"
+  },
+  // propertyIdentifierNames
+  {
+    "currentPage",
+    "pageCount",
+    "zoom",
+    "zoomMode",
+    "continuous",
+    "creatorMode",
+    "dual",
+    "toolbar"
+  },
+  false // identifiersInitialized
 };
diff --git a/browser-plugin/EvBrowserPlugin.h b/browser-plugin/EvBrowserPlugin.h
index 6a3533d..5e1b283 100644
--- a/browser-plugin/EvBrowserPlugin.h
+++ b/browser-plugin/EvBrowserPlugin.h
@@ -29,81 +29,87 @@ typedef union _XEvent XEvent;
 struct EvBrowserPluginClass;
 
 class EvBrowserPlugin: public NPObject {
-public:
-        static EvBrowserPlugin* create(NPP);
+ public:
+  static EvBrowserPlugin *create(NPP);
 
-        static const char *nameString();
-        static const char *descriptionString();
+  static const char *nameString();
+  static const char *descriptionString();
 
-        // NPP API
-        NPError initialize(NPMIMEType, uint16_t mode, int16_t argc, char *argn[], char *argv[], NPSavedData *);
-        NPError setWindow(NPWindow *);
-        NPError newStream(NPMIMEType, NPStream *, NPBool seekable, uint16_t *stype);
-        NPError destroyStream(NPStream *, NPReason);
-        void streamAsFile(NPStream *, const char *fname);
-        int32_t writeReady(NPStream *);
-        int32_t write(NPStream *, int32_t offset, int32_t len, void *buffer);
-        void print(NPPrint *);
-        int16_t handleEvent(XEvent *);
-        void urlNotify(const char *url, NPReason, void *notifyData);
+  // NPP API
+  NPError initialize(NPMIMEType, uint16_t mode, int16_t argc, char *argn[], char *argv[], NPSavedData *);
+  NPError setWindow(NPWindow *);
+  NPError newStream(NPMIMEType, NPStream *, NPBool seekable, uint16_t *stype);
+  NPError destroyStream(NPStream *, NPReason);
+  void streamAsFile(NPStream *, const char *fname);
+  int32_t writeReady(NPStream *);
+  int32_t write(NPStream *, int32_t offset, int32_t len, void *buffer);
+  void print(NPPrint *);
+  int16_t handleEvent(XEvent *);
+  void urlNotify(const char *url, NPReason, void *notifyData);
 
-        // Viewer API
-        EvDocumentModel *model() const { return m_model; }
-        unsigned currentPage() const;
-        unsigned pageCount() const;
-        double zoom() const;
-        void setZoom(double scale);
-        void goToPreviousPage();
-        void goToNextPage();
-        void goToPage(unsigned page);
-        void goToPage(const char *pageLabel);
-        void activateLink(EvLink *);
-        bool isContinuous() const;
-        void setContinuous(bool);
-        void toggleContinuous();
-        bool isDual() const;
-        void setDual(bool);
-        void toggleDual();
-        void zoomIn();
-        void zoomOut();
-        EvSizingMode sizingMode() const;
-        void setSizingMode(EvSizingMode);
-        void download() const;
-        void print() const;
-        bool toolbarVisible() const;
-        void setToolbarVisible(bool);
+  // Viewer API
+  EvDocumentModel *model() const {
+    return m_model;
+  }
+  unsigned currentPage() const;
+  unsigned pageCount() const;
+  double zoom() const;
+  void setZoom(double scale);
+  void goToPreviousPage();
+  void goToNextPage();
+  void goToPage(unsigned page);
+  void goToPage(const char *pageLabel);
+  void activateLink(EvLink *);
+  bool isContinuous() const;
+  void setContinuous(bool);
+  void toggleContinuous();
+  void toggleCreatorMode();
+  void setCreatorMode(bool CreatorMode);
+  bool isCreatorMode() const;
 
-        bool canDownload() const;
+  bool isDual() const;
+  void setDual(bool);
+  void toggleDual();
+  void zoomIn();
+  void zoomOut();
+  EvSizingMode sizingMode() const;
+  void setSizingMode(EvSizingMode);
+  void download() const;
+  void print() const;
+  bool toolbarVisible() const;
+  void setToolbarVisible(bool);
 
-        void setSearchModeEnabled(bool);
-        void search(EvJobFind *);
-        enum SearchDirection { Next, Previous };
-        void search(SearchDirection);
-        void clearSearch();
-        void restartSearch();
+  bool canDownload() const;
 
-private:
-        EvBrowserPlugin(NPP);
-        virtual ~EvBrowserPlugin();
+  void setSearchModeEnabled(bool);
+  void search(EvJobFind *);
+  enum SearchDirection { Next, Previous };
+  void search(SearchDirection);
+  void clearSearch();
+  void restartSearch();
 
-        // Scripting interface
-        static NPObject *allocate(NPP, NPClass *);
-        static void deallocate(NPObject *);
-        static void invalidate(NPObject *);
-        static bool hasMethod(NPObject *, NPIdentifier name);
-        static bool invoke(NPObject *, NPIdentifier name, const NPVariant *args, uint32_t argCount, NPVariant *result);
-        static bool hasProperty(NPObject *, NPIdentifier name);
-        static bool getProperty(NPObject *, NPIdentifier name, NPVariant *);
-        static bool setProperty(NPObject *, NPIdentifier name, const NPVariant *);
+ private:
+  EvBrowserPlugin(NPP);
+  virtual ~EvBrowserPlugin();
 
-        NPP m_NPP;
-        GtkWidget *m_window;
-        EvDocumentModel *m_model;
-        EvView *m_view;
-        GtkWidget *m_toolbar;
-        unique_gptr<char> m_url;
+  // Scripting interface
+  static NPObject *allocate(NPP, NPClass *);
+  static void deallocate(NPObject *);
+  static void invalidate(NPObject *);
+  static bool hasMethod(NPObject *, NPIdentifier name);
+  static bool invoke(NPObject *, NPIdentifier name, const NPVariant *args, uint32_t argCount, NPVariant *result);
+  static bool hasProperty(NPObject *, NPIdentifier name);
+  static bool getProperty(NPObject *, NPIdentifier name, NPVariant *);
+  static bool setProperty(NPObject *, NPIdentifier name, const NPVariant *);
 
-        static EvBrowserPluginClass s_pluginClass;
+  NPP m_NPP;
+  GtkWidget *m_window;
+  EvDocumentModel *m_model;
+  EvView *m_view;
+  GtkWidget *m_toolbar;
+  unique_gptr<char> m_url;
+
+  static EvBrowserPluginClass s_pluginClass;
 };
 
 #endif // EvBrowserPlugin_h
diff --git a/browser-plugin/EvBrowserPluginToolbar.cpp b/browser-plugin/EvBrowserPluginToolbar.cpp
index 9d6aeac..9fe8765 100644
--- a/browser-plugin/EvBrowserPluginToolbar.cpp
+++ b/browser-plugin/EvBrowserPluginToolbar.cpp
@@ -24,470 +24,436 @@
 #include <glib/gi18n-lib.h>
 
 enum {
-        PROP_0,
-        PROP_PLUGIN
+  PROP_0,
+  PROP_PLUGIN
 };
 
 struct _EvBrowserPluginToolbarPrivate {
-        EvBrowserPlugin *plugin;
-
-        GtkWidget *continuousToggleButton;
-        GtkWidget *dualToggleButton;
-        GtkWidget *zoomFitPageRadioButton;
-        GtkWidget *zoomFitWidthRadioButton;
-        GtkWidget *zoomAutomaticRadioButton;
-        GtkWidget *searchToggleButton;
-        GtkWidget *searchPopover;
+  EvBrowserPlugin *plugin;
+
+  GtkWidget *continuousToggleButton;
+  GtkWidget *dualToggleButton;
+  GtkWidget *zoomFitPageRadioButton;
+  GtkWidget *zoomFitWidthRadioButton;
+  GtkWidget *zoomAutomaticRadioButton;
+  GtkWidget *searchToggleButton;
+  GtkWidget *searchPopover;
 };
 
 G_DEFINE_TYPE_WITH_PRIVATE(EvBrowserPluginToolbar, ev_browser_plugin_toolbar, GTK_TYPE_TOOLBAR)
 
-static void goToPreviousPage(EvBrowserPluginToolbar *toolbar)
-{
-        toolbar->priv->plugin->goToPreviousPage();
+static void goToPreviousPage(EvBrowserPluginToolbar *toolbar) {
+  toolbar->priv->plugin->goToPreviousPage();
 }
 
-static void goToNextPage(EvBrowserPluginToolbar *toolbar)
-{
-        toolbar->priv->plugin->goToNextPage();
+static void goToNextPage(EvBrowserPluginToolbar *toolbar) {
+  toolbar->priv->plugin->goToNextPage();
 }
 
-static void activateLink(EvBrowserPluginToolbar *toolbar, EvLink *link)
-{
-        toolbar->priv->plugin->activateLink(link);
+static void activateLink(EvBrowserPluginToolbar *toolbar, EvLink *link) {
+  toolbar->priv->plugin->activateLink(link);
 }
 
-static void toggleContinuous(EvBrowserPluginToolbar *toolbar)
-{
-        toolbar->priv->plugin->toggleContinuous();
+static void toggleContinuous(EvBrowserPluginToolbar *toolbar) {
+  toolbar->priv->plugin->toggleContinuous();
 }
 
-static void toggleDual(EvBrowserPluginToolbar *toolbar)
-{
-        toolbar->priv->plugin->toggleDual();
+static void toggleDual(EvBrowserPluginToolbar *toolbar) {
+  toolbar->priv->plugin->toggleDual();
 }
 
-static void zoomIn(EvBrowserPluginToolbar *toolbar)
-{
-        toolbar->priv->plugin->zoomIn();
+static void zoomIn(EvBrowserPluginToolbar *toolbar) {
+  toolbar->priv->plugin->zoomIn();
 }
 
-static void zoomOut(EvBrowserPluginToolbar *toolbar)
-{
-        toolbar->priv->plugin->zoomOut();
+static void zoomOut(EvBrowserPluginToolbar *toolbar) {
+  toolbar->priv->plugin->zoomOut();
 }
 
-static void zoomFitPageToggled(EvBrowserPluginToolbar *toolbar)
-{
-        if (gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(toolbar->priv->zoomFitPageRadioButton)))
-                toolbar->priv->plugin->setSizingMode(EV_SIZING_FIT_PAGE);
+static void zoomFitPageToggled(EvBrowserPluginToolbar *toolbar) {
+  if (gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(toolbar->priv->zoomFitPageRadioButton)))
+    toolbar->priv->plugin->setSizingMode(EV_SIZING_FIT_PAGE);
 }
 
-static void zoomFitWidthToggled(EvBrowserPluginToolbar *toolbar)
-{
-        if (gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(toolbar->priv->zoomFitWidthRadioButton)))
-                toolbar->priv->plugin->setSizingMode(EV_SIZING_FIT_WIDTH);
+static void zoomFitWidthToggled(EvBrowserPluginToolbar *toolbar) {
+  if (gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(toolbar->priv->zoomFitWidthRadioButton)))
+    toolbar->priv->plugin->setSizingMode(EV_SIZING_FIT_WIDTH);
 }
 
-static void zoomAutomaticToggled(EvBrowserPluginToolbar *toolbar)
-{
-        if (gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(toolbar->priv->zoomAutomaticRadioButton)))
-                toolbar->priv->plugin->setSizingMode(EV_SIZING_AUTOMATIC);
+static void zoomAutomaticToggled(EvBrowserPluginToolbar *toolbar) {
+  if (gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(toolbar->priv->zoomAutomaticRadioButton)))
+    toolbar->priv->plugin->setSizingMode(EV_SIZING_AUTOMATIC);
 }
 
-static void printDocument(EvBrowserPluginToolbar *toolbar)
-{
-        toolbar->priv->plugin->print();
+static void printDocument(EvBrowserPluginToolbar *toolbar) {
+  toolbar->priv->plugin->print();
 }
 
-static void downloadDocument(EvBrowserPluginToolbar *toolbar)
-{
-        toolbar->priv->plugin->download();
+static void downloadDocument(EvBrowserPluginToolbar *toolbar) {
+  toolbar->priv->plugin->download();
 }
 
-static void searchPopoverClosed(EvBrowserPluginToolbar *toolbar)
-{
-        if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(toolbar->priv->searchToggleButton)))
-                gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(toolbar->priv->searchToggleButton), FALSE);
+static void searchPopoverClosed(EvBrowserPluginToolbar *toolbar) {
+  if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(toolbar->priv->searchToggleButton)))
+    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(toolbar->priv->searchToggleButton), FALSE);
 }
 
-static void searchStarted(EvBrowserPluginToolbar *toolbar, EvJobFind *job)
-{
-        toolbar->priv->plugin->search(job);
+static void searchStarted(EvBrowserPluginToolbar *toolbar, EvJobFind *job) {
+  toolbar->priv->plugin->search(job);
 }
 
-static void searchCleared(EvBrowserPluginToolbar *toolbar)
-{
-        toolbar->priv->plugin->clearSearch();
+static void searchCleared(EvBrowserPluginToolbar *toolbar) {
+  toolbar->priv->plugin->clearSearch();
 }
 
-static void searchNext(EvBrowserPluginToolbar *toolbar)
-{
-        toolbar->priv->plugin->search(EvBrowserPlugin::SearchDirection::Next);
+static void searchNext(EvBrowserPluginToolbar *toolbar) {
+  toolbar->priv->plugin->search(EvBrowserPlugin::SearchDirection::Next);
 }
 
-static void searchPrevious(EvBrowserPluginToolbar *toolbar)
-{
-        toolbar->priv->plugin->search(EvBrowserPlugin::SearchDirection::Previous);
+static void searchPrevious(EvBrowserPluginToolbar *toolbar) {
+  toolbar->priv->plugin->search(EvBrowserPlugin::SearchDirection::Previous);
 }
 
-static void toggleSearch(EvBrowserPluginToolbar *toolbar)
-{
-        if (!toolbar->priv->searchPopover) {
-                toolbar->priv->searchPopover = gtk_popover_new(toolbar->priv->searchToggleButton);
-                gtk_popover_set_position (GTK_POPOVER (toolbar->priv->searchPopover), GTK_POS_BOTTOM);
-                g_signal_connect_swapped(toolbar->priv->searchPopover, "closed", G_CALLBACK(searchPopoverClosed), toolbar);
-                GtkWidget *searchBox = ev_search_box_new(toolbar->priv->plugin->model());
-                g_signal_connect_swapped(searchBox, "started", G_CALLBACK(searchStarted), toolbar);
-                g_signal_connect_swapped(searchBox, "cleared", G_CALLBACK(searchCleared), toolbar);
-                g_signal_connect_swapped(searchBox, "next", G_CALLBACK(searchNext), toolbar);
-                g_signal_connect_swapped(searchBox, "previous", G_CALLBACK(searchPrevious), toolbar);
-                gtk_container_add(GTK_CONTAINER(toolbar->priv->searchPopover), searchBox);
-                gtk_widget_show(searchBox);
-        }
+static void toggleSearch(EvBrowserPluginToolbar *toolbar) {
+  if (!toolbar->priv->searchPopover) {
+    toolbar->priv->searchPopover = gtk_popover_new(toolbar->priv->searchToggleButton);
+    gtk_popover_set_position (GTK_POPOVER (toolbar->priv->searchPopover), GTK_POS_BOTTOM);
+    g_signal_connect_swapped(toolbar->priv->searchPopover, "closed", G_CALLBACK(searchPopoverClosed), toolbar);
+    GtkWidget *searchBox = ev_search_box_new(toolbar->priv->plugin->model());
+    g_signal_connect_swapped(searchBox, "started", G_CALLBACK(searchStarted), toolbar);
+    g_signal_connect_swapped(searchBox, "cleared", G_CALLBACK(searchCleared), toolbar);
+    g_signal_connect_swapped(searchBox, "next", G_CALLBACK(searchNext), toolbar);
+    g_signal_connect_swapped(searchBox, "previous", G_CALLBACK(searchPrevious), toolbar);
+    gtk_container_add(GTK_CONTAINER(toolbar->priv->searchPopover), searchBox);
+    gtk_widget_show(searchBox);
+  }
 
-        if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(toolbar->priv->searchToggleButton))) {
-                gtk_widget_show(toolbar->priv->searchPopover);
-                toolbar->priv->plugin->setSearchModeEnabled(true);
+  if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(toolbar->priv->searchToggleButton))) {
+    gtk_widget_show(toolbar->priv->searchPopover);
+    toolbar->priv->plugin->setSearchModeEnabled(true);
 
-                GtkSearchEntry *entry = ev_search_box_get_entry(EV_SEARCH_BOX(gtk_bin_get_child(GTK_BIN(toolbar->priv->searchPopover))));
-                const char *searchString = gtk_entry_get_text(GTK_ENTRY(entry));
-                if (searchString && searchString[0])
-                        toolbar->priv->plugin->restartSearch();
-        } else {
-                gtk_widget_hide(toolbar->priv->searchPopover);
-                toolbar->priv->plugin->setSearchModeEnabled(false);
-        }
+    GtkSearchEntry *entry = ev_search_box_get_entry(EV_SEARCH_BOX(gtk_bin_get_child(GTK_BIN(toolbar->priv->searchPopover))));
+    const char *searchString = gtk_entry_get_text(GTK_ENTRY(entry));
+    if (searchString && searchString[0])
+      toolbar->priv->plugin->restartSearch();
+  } else {
+    gtk_widget_hide(toolbar->priv->searchPopover);
+    toolbar->priv->plugin->setSearchModeEnabled(false);
+  }
 }
 
 class SignalBlocker {
-public:
-        SignalBlocker(gpointer instance, void (* closure)(EvBrowserPluginToolbar *), gpointer data)
-                : m_instance(instance)
-                , m_closure(reinterpret_cast<gpointer>(closure))
-                , m_data(data)
-        {
-                g_signal_handlers_block_by_func(m_instance, m_closure, m_data);
-        }
-
-        ~SignalBlocker()
-        {
-                g_signal_handlers_unblock_by_func(m_instance, m_closure, m_data);
-        }
-
-private:
-        gpointer m_instance;
-        gpointer m_closure;
-        gpointer m_data;
+ public:
+  SignalBlocker(gpointer instance, void (* closure)(EvBrowserPluginToolbar *), gpointer data)
+    : m_instance(instance)
+    , m_closure(reinterpret_cast<gpointer>(closure))
+    , m_data(data) {
+    g_signal_handlers_block_by_func(m_instance, m_closure, m_data);
+  }
+
+  ~SignalBlocker() {
+    g_signal_handlers_unblock_by_func(m_instance, m_closure, m_data);
+  }
+
+ private:
+  gpointer m_instance;
+  gpointer m_closure;
+  gpointer m_data;
 };
 
-static void continuousChanged(EvDocumentModel *model, GParamSpec *, EvBrowserPluginToolbar *toolbar)
-{
-        SignalBlocker blocker(toolbar->priv->continuousToggleButton, toggleContinuous, toolbar);
-        gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(toolbar->priv->continuousToggleButton),
-                                     toolbar->priv->plugin->isContinuous());
+static void continuousChanged(EvDocumentModel *model, GParamSpec *, EvBrowserPluginToolbar *toolbar) {
+  SignalBlocker blocker(toolbar->priv->continuousToggleButton, toggleContinuous, toolbar);
+  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(toolbar->priv->continuousToggleButton),
+                               toolbar->priv->plugin->isContinuous());
 }
 
-static void dualPageChanged(EvDocumentModel *model, GParamSpec *, EvBrowserPluginToolbar *toolbar)
-{
-        SignalBlocker blocker(toolbar->priv->dualToggleButton, toggleDual, toolbar);
-        gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(toolbar->priv->dualToggleButton),
-                                     toolbar->priv->plugin->isDual());
+static void dualPageChanged(EvDocumentModel *model, GParamSpec *, EvBrowserPluginToolbar *toolbar) {
+  SignalBlocker blocker(toolbar->priv->dualToggleButton, toggleDual, toolbar);
+  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(toolbar->priv->dualToggleButton),
+                               toolbar->priv->plugin->isDual());
 }
 
-static void sizingModeChanged(EvDocumentModel *model, GParamSpec *, EvBrowserPluginToolbar *toolbar)
-{
-        {
-                SignalBlocker fitPageBlocker(toolbar->priv->zoomFitPageRadioButton, zoomFitPageToggled, toolbar);
-                gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(toolbar->priv->zoomFitPageRadioButton),
-                                               toolbar->priv->plugin->sizingMode() == EV_SIZING_FIT_PAGE);
-        }
+static void sizingModeChanged(EvDocumentModel *model, GParamSpec *, EvBrowserPluginToolbar *toolbar) {
+  {
+    SignalBlocker fitPageBlocker(toolbar->priv->zoomFitPageRadioButton, zoomFitPageToggled, toolbar);
+    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(toolbar->priv->zoomFitPageRadioButton),
+                                   toolbar->priv->plugin->sizingMode() == EV_SIZING_FIT_PAGE);
+  }
 
-        {
-                SignalBlocker fitWidthBlocker(toolbar->priv->zoomFitPageRadioButton, zoomFitWidthToggled, toolbar);
-                gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(toolbar->priv->zoomFitWidthRadioButton),
-                                               toolbar->priv->plugin->sizingMode() == EV_SIZING_FIT_WIDTH);
-        }
-
-        {
-                SignalBlocker automaticBlocker(toolbar->priv->zoomAutomaticRadioButton, zoomAutomaticToggled, toolbar);
-                gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(toolbar->priv->zoomAutomaticRadioButton),
-                                               toolbar->priv->plugin->sizingMode() == EV_SIZING_AUTOMATIC);
-        }
+  {
+    SignalBlocker fitWidthBlocker(toolbar->priv->zoomFitPageRadioButton, zoomFitWidthToggled, toolbar);
+    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(toolbar->priv->zoomFitWidthRadioButton),
+                                   toolbar->priv->plugin->sizingMode() == EV_SIZING_FIT_WIDTH);
+  }
+
+  {
+    SignalBlocker automaticBlocker(toolbar->priv->zoomAutomaticRadioButton, zoomAutomaticToggled, toolbar);
+    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(toolbar->priv->zoomAutomaticRadioButton),
+                                   toolbar->priv->plugin->sizingMode() == EV_SIZING_AUTOMATIC);
+  }
+}
+
+static void evBrowserPluginToolbarSetProperty(GObject *object, guint propID, const GValue *value, GParamSpec *paramSpec) {
+  EvBrowserPluginToolbar *toolbar = EV_BROWSER_PLUGIN_TOOLBAR(object);
+
+  switch (propID) {
+    case PROP_PLUGIN:
+      toolbar->priv->plugin = static_cast<EvBrowserPlugin *>(g_value_get_pointer(value));
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID(object, propID, paramSpec);
+  }
 }
 
-static void evBrowserPluginToolbarSetProperty(GObject *object, guint propID, const GValue *value, GParamSpec *paramSpec)
-{
-        EvBrowserPluginToolbar *toolbar = EV_BROWSER_PLUGIN_TOOLBAR(object);
-
-        switch (propID) {
-        case PROP_PLUGIN:
-                toolbar->priv->plugin = static_cast<EvBrowserPlugin *>(g_value_get_pointer(value));
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID(object, propID, paramSpec);
-        }
+static GtkWidget *createButton(EvBrowserPluginToolbar *toolbar, const char *iconName, const char *description, GCallback callback) {
+  GtkWidget *button = gtk_button_new();
+
+  gtk_widget_set_valign(button, GTK_ALIGN_CENTER);
+  gtk_widget_set_tooltip_text(button, description);
+  gtk_button_set_image(GTK_BUTTON(button), gtk_image_new_from_icon_name(iconName, GTK_ICON_SIZE_MENU));
+  gtk_button_set_label(GTK_BUTTON(button), nullptr);
+  gtk_button_set_focus_on_click(GTK_BUTTON(button), FALSE);
+  g_signal_connect_swapped(button, "clicked", callback, toolbar);
+
+  return button;
 }
 
-static GtkWidget *createButton(EvBrowserPluginToolbar *toolbar, const char *iconName, const char *description, GCallback callback)
-{
-        GtkWidget *button = gtk_button_new();
+static GtkWidget *createToggleButton(EvBrowserPluginToolbar *toolbar, const char *iconName, const char *description, bool initialState, GCallback callback) {
+  GtkWidget *button = gtk_toggle_button_new();
 
-        gtk_widget_set_valign(button, GTK_ALIGN_CENTER);
-        gtk_widget_set_tooltip_text(button, description);
-        gtk_button_set_image(GTK_BUTTON(button), gtk_image_new_from_icon_name(iconName, GTK_ICON_SIZE_MENU));
-        gtk_button_set_label(GTK_BUTTON(button), nullptr);
-        gtk_button_set_focus_on_click(GTK_BUTTON(button), FALSE);
-        g_signal_connect_swapped(button, "clicked", callback, toolbar);
+  gtk_widget_set_valign(button, GTK_ALIGN_CENTER);
+  gtk_widget_set_tooltip_text(button, description);
+  gtk_button_set_image(GTK_BUTTON(button), gtk_image_new_from_icon_name(iconName, GTK_ICON_SIZE_MENU));
+  gtk_button_set_label(GTK_BUTTON(button), nullptr);
+  gtk_button_set_focus_on_click(GTK_BUTTON(button), FALSE);
+  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), initialState);
+  g_signal_connect_swapped(button, "toggled", callback, toolbar);
 
-        return button;
+  return button;
 }
 
-static GtkWidget *createToggleButton(EvBrowserPluginToolbar *toolbar, const char *iconName, const char *description, bool initialState, GCallback callback)
-{
-        GtkWidget *button = gtk_toggle_button_new();
+static GtkWidget *createMenuButton(EvBrowserPluginToolbar *toolbar, const gchar *iconName, GtkWidget *menu, GtkAlign menuAlign) {
+  GtkWidget *button = gtk_menu_button_new();
+
+  gtk_widget_set_valign(button, GTK_ALIGN_CENTER);
+  gtk_button_set_image(GTK_BUTTON(button), gtk_image_new_from_icon_name(iconName, GTK_ICON_SIZE_MENU));
+  gtk_widget_set_halign(menu, menuAlign);
+  gtk_menu_button_set_popup(GTK_MENU_BUTTON(button), menu);
+
+  return button;
+}
+
+static GtkWidget *createButtonGroup(EvBrowserPluginToolbar *toolbar) {
+  GtkWidget *box = gtk_box_new(gtk_orientable_get_orientation(GTK_ORIENTABLE(toolbar)), 0);
+
+  GtkStyleContext *styleContext = gtk_widget_get_style_context(box);
+  gtk_style_context_add_class(styleContext, GTK_STYLE_CLASS_RAISED);
+  gtk_style_context_add_class(styleContext, GTK_STYLE_CLASS_LINKED);
 
-        gtk_widget_set_valign(button, GTK_ALIGN_CENTER);
-        gtk_widget_set_tooltip_text(button, description);
-        gtk_button_set_image(GTK_BUTTON(button), gtk_image_new_from_icon_name(iconName, GTK_ICON_SIZE_MENU));
-        gtk_button_set_label(GTK_BUTTON(button), nullptr);
-        gtk_button_set_focus_on_click(GTK_BUTTON(button), FALSE);
-        gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), initialState);
-        g_signal_connect_swapped(button, "toggled", callback, toolbar);
-
-        return button;
-}
-
-static GtkWidget *createMenuButton(EvBrowserPluginToolbar *toolbar, const gchar *iconName, GtkWidget *menu, GtkAlign menuAlign)
-{
-        GtkWidget *button = gtk_menu_button_new();
-
-        gtk_widget_set_valign(button, GTK_ALIGN_CENTER);
-        gtk_button_set_image(GTK_BUTTON(button), gtk_image_new_from_icon_name(iconName, GTK_ICON_SIZE_MENU));
-        gtk_widget_set_halign(menu, menuAlign);
-        gtk_menu_button_set_popup(GTK_MENU_BUTTON(button), menu);
-
-        return button;
-}
-
-static GtkWidget *createButtonGroup(EvBrowserPluginToolbar *toolbar)
-{
-        GtkWidget *box = gtk_box_new(gtk_orientable_get_orientation(GTK_ORIENTABLE(toolbar)), 0);
-
-        GtkStyleContext *styleContext = gtk_widget_get_style_context(box);
-        gtk_style_context_add_class(styleContext, GTK_STYLE_CLASS_RAISED);
-        gtk_style_context_add_class(styleContext, GTK_STYLE_CLASS_LINKED);
-
-        return box;
-}
-
-static GtkWidget *createSizingModeMenu(EvBrowserPluginToolbar *toolbar)
-{
-        GtkWidget *menu = gtk_menu_new();
-
-        GtkWidget *menuItem = gtk_check_menu_item_new_with_mnemonic(_("Fit Pa_ge"));
-        toolbar->priv->zoomFitPageRadioButton = menuItem;
-        gtk_check_menu_item_set_draw_as_radio(GTK_CHECK_MENU_ITEM(menuItem), TRUE);
-        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(menuItem),
-                                       toolbar->priv->plugin->sizingMode() == EV_SIZING_FIT_PAGE);
-        g_signal_connect_swapped(menuItem, "toggled", G_CALLBACK(zoomFitPageToggled), toolbar);
-        gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuItem);
-        gtk_widget_show(menuItem);
-
-        menuItem = gtk_check_menu_item_new_with_mnemonic(_("Fit _Width"));
-        toolbar->priv->zoomFitWidthRadioButton = menuItem;
-        gtk_check_menu_item_set_draw_as_radio(GTK_CHECK_MENU_ITEM(menuItem), TRUE);
-        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(menuItem),
-                                       toolbar->priv->plugin->sizingMode() == EV_SIZING_FIT_WIDTH);
-        g_signal_connect_swapped(menuItem, "toggled", G_CALLBACK(zoomFitWidthToggled), toolbar);
-        gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuItem);
-        gtk_widget_show(menuItem);
-
-        menuItem = gtk_check_menu_item_new_with_mnemonic(_("_Automatic"));
-        toolbar->priv->zoomAutomaticRadioButton = menuItem;
-        gtk_check_menu_item_set_draw_as_radio(GTK_CHECK_MENU_ITEM(menuItem), TRUE);
-        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(menuItem),
-                                       toolbar->priv->plugin->sizingMode() == EV_SIZING_AUTOMATIC);
-        g_signal_connect_swapped(menuItem, "toggled", G_CALLBACK(zoomAutomaticToggled), toolbar);
-        gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuItem);
-        gtk_widget_show(menuItem);
-
-        g_signal_connect(toolbar->priv->plugin->model(), "notify::sizing-mode",
-                         G_CALLBACK(sizingModeChanged), toolbar);
-
-        return menu;
-}
-
-static void evBrowserPluginToolbarConstructed(GObject *object)
-{
-        G_OBJECT_CLASS(ev_browser_plugin_toolbar_parent_class)->constructed(object);
-
-        EvBrowserPluginToolbar *toolbar = EV_BROWSER_PLUGIN_TOOLBAR(object);
-        bool rtl = gtk_widget_get_direction(GTK_WIDGET(toolbar)) == GTK_TEXT_DIR_RTL;
-
-        GtkWidget *hbox = createButtonGroup(toolbar);
-
-        // Navigation buttons
-        GtkWidget *button = createButton(toolbar, "go-up-symbolic", _("Go to the previous page"), G_CALLBACK(goToPreviousPage));
-        gtk_container_add(GTK_CONTAINER(hbox), button);
-        gtk_widget_show(button);
-
-        button = createButton(toolbar, "go-down-symbolic", _("Go to the next page"), G_CALLBACK(goToNextPage));
-        gtk_container_add(GTK_CONTAINER(hbox), button);
-        gtk_widget_show(button);
-
-        GtkWidget *toolItem = GTK_WIDGET(gtk_tool_item_new());
-        if (rtl)
-                gtk_widget_set_margin_left(toolItem, 12);
-        else
-                gtk_widget_set_margin_right(toolItem, 12);
-        gtk_container_add(GTK_CONTAINER(toolItem), hbox);
-        gtk_widget_show(hbox);
-
-        gtk_container_add(GTK_CONTAINER(toolbar), toolItem);
-        gtk_widget_show(toolItem);
-
-        // Page Selector
-        toolItem = GTK_WIDGET(g_object_new(EV_TYPE_PAGE_ACTION_WIDGET, nullptr));
-        ev_page_action_widget_set_model(EV_PAGE_ACTION_WIDGET(toolItem), toolbar->priv->plugin->model());
-        g_signal_connect_swapped(toolItem, "activate-link", G_CALLBACK(activateLink), toolbar);
-        if (rtl)
-                gtk_widget_set_margin_left(toolItem, 12);
-        else
-                gtk_widget_set_margin_right(toolItem, 12);
-        gtk_container_add(GTK_CONTAINER(toolbar), toolItem);
-        gtk_widget_show(toolItem);
-
-        // Search.
-        button = createToggleButton(toolbar, "edit-find-symbolic", _("Find a word or phrase in the document"),
-                                    false, G_CALLBACK(toggleSearch));
-        toolbar->priv->searchToggleButton = button;
-        toolItem = GTK_WIDGET(gtk_tool_item_new());
-        gtk_container_add(GTK_CONTAINER(toolItem), button);
-        gtk_widget_show(button);
-
-        gtk_container_add(GTK_CONTAINER(toolbar), toolItem);
-        gtk_widget_show(toolItem);
-
-        // Separator
-        toolItem = GTK_WIDGET(gtk_tool_item_new());
-        gtk_tool_item_set_expand(GTK_TOOL_ITEM(toolItem), TRUE);
-        gtk_container_add(GTK_CONTAINER(toolbar), toolItem);
-        gtk_widget_show(toolItem);
-
-        // View mode
-        hbox = createButtonGroup(toolbar);
-
-        button = createToggleButton(toolbar, "view-continuous-symbolic", _("Show the entire document"),
-                                    toolbar->priv->plugin->isContinuous(), G_CALLBACK(toggleContinuous));
-        toolbar->priv->continuousToggleButton = button;
-        g_signal_connect(toolbar->priv->plugin->model(), "notify::continuous",
-                         G_CALLBACK(continuousChanged), toolbar);
-        gtk_container_add(GTK_CONTAINER(hbox), button);
-        gtk_widget_show(button);
-
-        button = createToggleButton(toolbar, "view-dual-symbolic", _("Show two pages at once"),
-                                    toolbar->priv->plugin->isDual(), G_CALLBACK(toggleDual));
-        toolbar->priv->dualToggleButton = button;
-        g_signal_connect(toolbar->priv->plugin->model(), "notify::dual-page",
-                         G_CALLBACK(dualPageChanged), toolbar);
-        gtk_container_add(GTK_CONTAINER(hbox), button);
-        gtk_widget_show(button);
-
-        toolItem = GTK_WIDGET(gtk_tool_item_new());
-        if (rtl)
-                gtk_widget_set_margin_left(toolItem, 12);
-        else
-                gtk_widget_set_margin_right(toolItem, 12);
-        gtk_container_add(GTK_CONTAINER(toolItem), hbox);
-        gtk_widget_show(hbox);
-
-        gtk_container_add(GTK_CONTAINER(toolbar), toolItem);
-        gtk_widget_show(toolItem);
-
-        // Zoom
-        hbox = createButtonGroup(toolbar);
-
-        button = createButton(toolbar, "zoom-in-symbolic", _("Enlarge the document"), G_CALLBACK(zoomIn));
-        gtk_container_add(GTK_CONTAINER(hbox), button);
-        gtk_widget_show(button);
-
-        button = createButton(toolbar, "zoom-out-symbolic", _("Shrink the document"), G_CALLBACK(zoomOut));
-        gtk_container_add(GTK_CONTAINER(hbox), button);
-        gtk_widget_show(button);
-
-        button = createMenuButton(toolbar, "pan-down-symbolic", createSizingModeMenu(toolbar), GTK_ALIGN_END);
-        gtk_container_add(GTK_CONTAINER(hbox), button);
-        gtk_widget_show(button);
-
-        toolItem = GTK_WIDGET(gtk_tool_item_new());
-        if (rtl)
-                gtk_widget_set_margin_left(toolItem, 12);
-        else
-                gtk_widget_set_margin_right(toolItem, 12);
-        gtk_container_add(GTK_CONTAINER(toolItem), hbox);
-        gtk_widget_show(hbox);
-
-        gtk_container_add(GTK_CONTAINER(toolbar), toolItem);
-        gtk_widget_show(toolItem);
-
-        // Actions
-        // Only add download button if browser is Epiphany for now.
-        if (toolbar->priv->plugin->canDownload()) {
-                button = createButton(toolbar, "folder-download-symbolic", _("Download document"), G_CALLBACK(downloadDocument));
-                toolItem = GTK_WIDGET(gtk_tool_item_new());
-                gtk_container_add(GTK_CONTAINER(toolItem), button);
-                gtk_widget_show(button);
-                if (rtl)
-                        gtk_widget_set_margin_left(toolItem, 6);
-                else
-                        gtk_widget_set_margin_right(toolItem, 6);
-
-                gtk_container_add(GTK_CONTAINER(toolbar), toolItem);
-                gtk_widget_show(toolItem);
-        }
-
-        button = createButton(toolbar, "printer-symbolic", _("Print document"), G_CALLBACK(printDocument));
-        toolItem = GTK_WIDGET(gtk_tool_item_new());
-        gtk_container_add(GTK_CONTAINER(toolItem), button);
-        gtk_widget_show(button);
-
-        gtk_container_add(GTK_CONTAINER(toolbar), toolItem);
-        gtk_widget_show(toolItem);
-}
-
-static void evBrowserPluginToolbarDispose(GObject *object)
-{
-        EvBrowserPluginToolbar *toolbar = EV_BROWSER_PLUGIN_TOOLBAR(object);
-        if (toolbar->priv->searchPopover) {
-                gtk_widget_destroy(toolbar->priv->searchPopover);
-                toolbar->priv->searchPopover = nullptr;
-        }
-
-        G_OBJECT_CLASS(ev_browser_plugin_toolbar_parent_class)->dispose(object);
-}
-
-static void ev_browser_plugin_toolbar_class_init(EvBrowserPluginToolbarClass *klass)
-{
-        GObjectClass *gObjectClass = G_OBJECT_CLASS(klass);
-        gObjectClass->set_property = evBrowserPluginToolbarSetProperty;
-        gObjectClass->constructed = evBrowserPluginToolbarConstructed;
-        gObjectClass->dispose = evBrowserPluginToolbarDispose;
-
-        g_object_class_install_property(gObjectClass,
-                                         PROP_PLUGIN,
-                                         g_param_spec_pointer("plugin",
-                                                              "Plugin",
-                                                              "The plugin",
-                                                              static_cast<GParamFlags>(G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_STRINGS)));
-}
-
-static void ev_browser_plugin_toolbar_init(EvBrowserPluginToolbar *toolbar)
-{
-        toolbar->priv = static_cast<EvBrowserPluginToolbarPrivate *>(ev_browser_plugin_toolbar_get_instance_private(toolbar));
-}
-
-GtkWidget *ev_browser_plugin_toolbar_new(EvBrowserPlugin *plugin)
-{
-        return GTK_WIDGET(g_object_new(EV_TYPE_BROWSER_PLUGIN_TOOLBAR, "plugin", plugin, nullptr));
+  return box;
+}
+
+static GtkWidget *createSizingModeMenu(EvBrowserPluginToolbar *toolbar) {
+  GtkWidget *menu = gtk_menu_new();
+
+  GtkWidget *menuItem = gtk_check_menu_item_new_with_mnemonic(_("Fit Pa_ge"));
+  toolbar->priv->zoomFitPageRadioButton = menuItem;
+  gtk_check_menu_item_set_draw_as_radio(GTK_CHECK_MENU_ITEM(menuItem), TRUE);
+  gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(menuItem),
+                                 toolbar->priv->plugin->sizingMode() == EV_SIZING_FIT_PAGE);
+  g_signal_connect_swapped(menuItem, "toggled", G_CALLBACK(zoomFitPageToggled), toolbar);
+  gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuItem);
+  gtk_widget_show(menuItem);
+
+  menuItem = gtk_check_menu_item_new_with_mnemonic(_("Fit _Width"));
+  toolbar->priv->zoomFitWidthRadioButton = menuItem;
+  gtk_check_menu_item_set_draw_as_radio(GTK_CHECK_MENU_ITEM(menuItem), TRUE);
+  gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(menuItem),
+                                 toolbar->priv->plugin->sizingMode() == EV_SIZING_FIT_WIDTH);
+  g_signal_connect_swapped(menuItem, "toggled", G_CALLBACK(zoomFitWidthToggled), toolbar);
+  gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuItem);
+  gtk_widget_show(menuItem);
+
+  menuItem = gtk_check_menu_item_new_with_mnemonic(_("_Automatic"));
+  toolbar->priv->zoomAutomaticRadioButton = menuItem;
+  gtk_check_menu_item_set_draw_as_radio(GTK_CHECK_MENU_ITEM(menuItem), TRUE);
+  gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(menuItem),
+                                 toolbar->priv->plugin->sizingMode() == EV_SIZING_AUTOMATIC);
+  g_signal_connect_swapped(menuItem, "toggled", G_CALLBACK(zoomAutomaticToggled), toolbar);
+  gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuItem);
+  gtk_widget_show(menuItem);
+
+  g_signal_connect(toolbar->priv->plugin->model(), "notify::sizing-mode",
+                   G_CALLBACK(sizingModeChanged), toolbar);
+
+  return menu;
+}
+
+static void evBrowserPluginToolbarConstructed(GObject *object) {
+  G_OBJECT_CLASS(ev_browser_plugin_toolbar_parent_class)->constructed(object);
+
+  EvBrowserPluginToolbar *toolbar = EV_BROWSER_PLUGIN_TOOLBAR(object);
+  bool rtl = gtk_widget_get_direction(GTK_WIDGET(toolbar)) == GTK_TEXT_DIR_RTL;
+
+  GtkWidget *hbox = createButtonGroup(toolbar);
+
+  // Navigation buttons
+  GtkWidget *button = createButton(toolbar, "go-up-symbolic", _("Go to the previous page"), G_CALLBACK(goToPreviousPage));
+  gtk_container_add(GTK_CONTAINER(hbox), button);
+  gtk_widget_show(button);
+
+  button = createButton(toolbar, "go-down-symbolic", _("Go to the next page"), G_CALLBACK(goToNextPage));
+  gtk_container_add(GTK_CONTAINER(hbox), button);
+  gtk_widget_show(button);
+
+  GtkWidget *toolItem = GTK_WIDGET(gtk_tool_item_new());
+  if (rtl)
+    gtk_widget_set_margin_left(toolItem, 12);
+  else
+    gtk_widget_set_margin_right(toolItem, 12);
+  gtk_container_add(GTK_CONTAINER(toolItem), hbox);
+  gtk_widget_show(hbox);
+
+  gtk_container_add(GTK_CONTAINER(toolbar), toolItem);
+  gtk_widget_show(toolItem);
+
+  // Page Selector
+  toolItem = GTK_WIDGET(g_object_new(EV_TYPE_PAGE_ACTION_WIDGET, nullptr));
+  ev_page_action_widget_set_model(EV_PAGE_ACTION_WIDGET(toolItem), toolbar->priv->plugin->model());
+  g_signal_connect_swapped(toolItem, "activate-link", G_CALLBACK(activateLink), toolbar);
+  if (rtl)
+    gtk_widget_set_margin_left(toolItem, 12);
+  else
+    gtk_widget_set_margin_right(toolItem, 12);
+  gtk_container_add(GTK_CONTAINER(toolbar), toolItem);
+  gtk_widget_show(toolItem);
+
+  // Search.
+  button = createToggleButton(toolbar, "edit-find-symbolic", _("Find a word or phrase in the document"),
+                              false, G_CALLBACK(toggleSearch));
+  toolbar->priv->searchToggleButton = button;
+  toolItem = GTK_WIDGET(gtk_tool_item_new());
+  gtk_container_add(GTK_CONTAINER(toolItem), button);
+  gtk_widget_show(button);
+
+  gtk_container_add(GTK_CONTAINER(toolbar), toolItem);
+  gtk_widget_show(toolItem);
+
+  // Separator
+  toolItem = GTK_WIDGET(gtk_tool_item_new());
+  gtk_tool_item_set_expand(GTK_TOOL_ITEM(toolItem), TRUE);
+  gtk_container_add(GTK_CONTAINER(toolbar), toolItem);
+  gtk_widget_show(toolItem);
+
+  // View mode
+  hbox = createButtonGroup(toolbar);
+
+  button = createToggleButton(toolbar, "view-continuous-symbolic", _("Show the entire document"),
+                              toolbar->priv->plugin->isContinuous(), G_CALLBACK(toggleContinuous));
+  toolbar->priv->continuousToggleButton = button;
+  g_signal_connect(toolbar->priv->plugin->model(), "notify::continuous",
+                   G_CALLBACK(continuousChanged), toolbar);
+  gtk_container_add(GTK_CONTAINER(hbox), button);
+  gtk_widget_show(button);
+
+  button = createToggleButton(toolbar, "view-dual-symbolic", _("Show two pages at once"),
+                              toolbar->priv->plugin->isDual(), G_CALLBACK(toggleDual));
+  toolbar->priv->dualToggleButton = button;
+  g_signal_connect(toolbar->priv->plugin->model(), "notify::dual-page",
+                   G_CALLBACK(dualPageChanged), toolbar);
+  gtk_container_add(GTK_CONTAINER(hbox), button);
+  gtk_widget_show(button);
+
+  toolItem = GTK_WIDGET(gtk_tool_item_new());
+  if (rtl)
+    gtk_widget_set_margin_left(toolItem, 12);
+  else
+    gtk_widget_set_margin_right(toolItem, 12);
+  gtk_container_add(GTK_CONTAINER(toolItem), hbox);
+  gtk_widget_show(hbox);
+
+  gtk_container_add(GTK_CONTAINER(toolbar), toolItem);
+  gtk_widget_show(toolItem);
+
+  // Zoom
+  hbox = createButtonGroup(toolbar);
+
+  button = createButton(toolbar, "zoom-in-symbolic", _("Enlarge the document"), G_CALLBACK(zoomIn));
+  gtk_container_add(GTK_CONTAINER(hbox), button);
+  gtk_widget_show(button);
+
+  button = createButton(toolbar, "zoom-out-symbolic", _("Shrink the document"), G_CALLBACK(zoomOut));
+  gtk_container_add(GTK_CONTAINER(hbox), button);
+  gtk_widget_show(button);
+
+  button = createMenuButton(toolbar, "pan-down-symbolic", createSizingModeMenu(toolbar), GTK_ALIGN_END);
+  gtk_container_add(GTK_CONTAINER(hbox), button);
+  gtk_widget_show(button);
+
+  toolItem = GTK_WIDGET(gtk_tool_item_new());
+  if (rtl)
+    gtk_widget_set_margin_left(toolItem, 12);
+  else
+    gtk_widget_set_margin_right(toolItem, 12);
+  gtk_container_add(GTK_CONTAINER(toolItem), hbox);
+  gtk_widget_show(hbox);
+
+  gtk_container_add(GTK_CONTAINER(toolbar), toolItem);
+  gtk_widget_show(toolItem);
+
+  // Actions
+  // Only add download button if browser is Epiphany for now.
+  if (toolbar->priv->plugin->canDownload()) {
+    button = createButton(toolbar, "folder-download-symbolic", _("Download document"), G_CALLBACK(downloadDocument));
+    toolItem = GTK_WIDGET(gtk_tool_item_new());
+    gtk_container_add(GTK_CONTAINER(toolItem), button);
+    gtk_widget_show(button);
+    if (rtl)
+      gtk_widget_set_margin_left(toolItem, 6);
+    else
+      gtk_widget_set_margin_right(toolItem, 6);
+
+    gtk_container_add(GTK_CONTAINER(toolbar), toolItem);
+    gtk_widget_show(toolItem);
+  }
+
+  button = createButton(toolbar, "printer-symbolic", _("Print document"), G_CALLBACK(printDocument));
+  toolItem = GTK_WIDGET(gtk_tool_item_new());
+  gtk_container_add(GTK_CONTAINER(toolItem), button);
+  gtk_widget_show(button);
+
+  gtk_container_add(GTK_CONTAINER(toolbar), toolItem);
+  gtk_widget_show(toolItem);
+}
+
+static void evBrowserPluginToolbarDispose(GObject *object) {
+  EvBrowserPluginToolbar *toolbar = EV_BROWSER_PLUGIN_TOOLBAR(object);
+  if (toolbar->priv->searchPopover) {
+    gtk_widget_destroy(toolbar->priv->searchPopover);
+    toolbar->priv->searchPopover = nullptr;
+  }
+
+  G_OBJECT_CLASS(ev_browser_plugin_toolbar_parent_class)->dispose(object);
+}
+
+static void ev_browser_plugin_toolbar_class_init(EvBrowserPluginToolbarClass *klass) {
+  GObjectClass *gObjectClass = G_OBJECT_CLASS(klass);
+  gObjectClass->set_property = evBrowserPluginToolbarSetProperty;
+  gObjectClass->constructed = evBrowserPluginToolbarConstructed;
+  gObjectClass->dispose = evBrowserPluginToolbarDispose;
+
+  g_object_class_install_property(gObjectClass,
+                                  PROP_PLUGIN,
+                                  g_param_spec_pointer("plugin",
+                                                       "Plugin",
+                                                       "The plugin",
+                                                       static_cast<GParamFlags>(G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_STRINGS)));
+}
+
+static void ev_browser_plugin_toolbar_init(EvBrowserPluginToolbar *toolbar) {
+  toolbar->priv = static_cast<EvBrowserPluginToolbarPrivate *>(ev_browser_plugin_toolbar_get_instance_private(toolbar));
+}
+
+GtkWidget *ev_browser_plugin_toolbar_new(EvBrowserPlugin *plugin) {
+  return GTK_WIDGET(g_object_new(EV_TYPE_BROWSER_PLUGIN_TOOLBAR, "plugin", plugin, nullptr));
 }
diff --git a/data/org.gnome.Evince.gschema.xml b/data/org.gnome.Evince.gschema.xml
index 604eb48..2fe2bf2 100644
--- a/data/org.gnome.Evince.gschema.xml
+++ b/data/org.gnome.Evince.gschema.xml
@@ -83,6 +83,9 @@
     <key name="sidebar-size" type="i">
       <default>132</default>
     </key>
+    <key name="creator-mode" type="b">
+      <default>false</default>
+    </key>
   </schema>
 
 </schemalist>
diff --git a/libview/ev-document-model.c b/libview/ev-document-model.c
index db537a5..5d7885d 100644
--- a/libview/ev-document-model.c
+++ b/libview/ev-document-model.c
@@ -24,51 +24,51 @@
 #include "ev-view-type-builtins.h"
 #include "ev-view-marshal.h"
 
-struct _EvDocumentModel
-{
-	GObject base;
-
-	EvDocument *document;
-	gint n_pages;
-
-	gint page;
-	gint rotation;
-	gdouble scale;
-	EvSizingMode sizing_mode;
-	EvPageLayout page_layout;
-	guint continuous : 1;
-	guint dual_page  : 1;
-	guint dual_page_odd_left : 1;
-	guint rtl : 1;
-	guint fullscreen : 1;
-	guint inverted_colors : 1;
-
-	gdouble max_scale;
-	gdouble min_scale;
+struct _EvDocumentModel {
+  GObject base;
+
+  EvDocument *document;
+  gint n_pages;
+
+  gint page;
+  gint rotation;
+  gdouble scale;
+  EvSizingMode sizing_mode;
+  EvPageLayout page_layout;
+  guint continuous : 1;
+  guint creator_mode : 1;
+  guint dual_page  : 1;
+  guint dual_page_odd_left : 1;
+  guint rtl : 1;
+  guint fullscreen : 1;
+  guint inverted_colors : 1;
+
+  gdouble max_scale;
+  gdouble min_scale;
 };
 
 enum {
-	PROP_0,
-	PROP_DOCUMENT,
-	PROP_PAGE,
-	PROP_ROTATION,
-	PROP_INVERTED_COLORS,
-	PROP_SCALE,
-	PROP_SIZING_MODE,
-	PROP_CONTINUOUS,
-	PROP_DUAL_PAGE,
-	PROP_DUAL_PAGE_ODD_LEFT,
-	PROP_RTL,
-	PROP_FULLSCREEN,
-	PROP_MIN_SCALE,
-	PROP_MAX_SCALE,
-	PROP_PAGE_LAYOUT
+  PROP_0,
+  PROP_DOCUMENT,
+  PROP_PAGE,
+  PROP_ROTATION,
+  PROP_INVERTED_COLORS,
+  PROP_SCALE,
+  PROP_SIZING_MODE,
+  PROP_CONTINUOUS,
+  PROP_CREATOR_MODE,
+  PROP_DUAL_PAGE,
+  PROP_DUAL_PAGE_ODD_LEFT,
+  PROP_RTL,
+  PROP_FULLSCREEN,
+  PROP_MIN_SCALE,
+  PROP_MAX_SCALE,
+  PROP_PAGE_LAYOUT
 };
 
-enum
-{
-	PAGE_CHANGED,
-	N_SIGNALS
+enum {
+  PAGE_CHANGED,
+  N_SIGNALS
 };
 
 static guint signals[N_SIGNALS] = { 0 };
@@ -79,312 +79,321 @@ G_DEFINE_TYPE (EvDocumentModel, ev_document_model, G_TYPE_OBJECT)
 #define DEFAULT_MAX_SCALE 5.0
 
 static void
-ev_document_model_finalize (GObject *object)
-{
-	EvDocumentModel *model = EV_DOCUMENT_MODEL (object);
+ev_document_model_finalize (GObject *object) {
+  EvDocumentModel *model = EV_DOCUMENT_MODEL (object);
 
-	if (model->document) {
-		g_object_unref (model->document);
-		model->document = NULL;
-	}
+  if (model->document) {
+    g_object_unref (model->document);
+    model->document = NULL;
+  }
 
-	G_OBJECT_CLASS (ev_document_model_parent_class)->finalize (object);
+  G_OBJECT_CLASS (ev_document_model_parent_class)->finalize (object);
 }
 
 static void
 ev_document_model_set_property (GObject      *object,
-				guint         prop_id,
-				const GValue *value,
-				GParamSpec   *pspec)
-{
-	EvDocumentModel *model = EV_DOCUMENT_MODEL (object);
-
-	switch (prop_id) {
-	case PROP_DOCUMENT:
-		ev_document_model_set_document (model, (EvDocument *)g_value_get_object (value));
-		break;
-	case PROP_PAGE:
-		ev_document_model_set_page (model, g_value_get_int (value));
-		break;
-	case PROP_ROTATION:
-		ev_document_model_set_rotation (model, g_value_get_int (value));
-		break;
-	case PROP_INVERTED_COLORS:
-		ev_document_model_set_inverted_colors (model, g_value_get_boolean (value));
-		break;
-	case PROP_SCALE:
-		ev_document_model_set_scale (model, g_value_get_double (value));
-		break;
-	case PROP_MIN_SCALE:
-		ev_document_model_set_min_scale (model, g_value_get_double (value));
-		break;
-	case PROP_MAX_SCALE:
-		ev_document_model_set_max_scale (model, g_value_get_double (value));
-		break;
-	case PROP_SIZING_MODE:
-		ev_document_model_set_sizing_mode (model, g_value_get_enum (value));
-		break;
-	case PROP_CONTINUOUS:
-		ev_document_model_set_continuous (model, g_value_get_boolean (value));
-		break;
-	case PROP_PAGE_LAYOUT:
-		ev_document_model_set_page_layout (model, g_value_get_enum (value));
-		break;
-	case PROP_DUAL_PAGE:
-		ev_document_model_set_dual_page (model, g_value_get_boolean (value));
-		break;
-	case PROP_DUAL_PAGE_ODD_LEFT:
-		ev_document_model_set_dual_page_odd_pages_left (model, g_value_get_boolean (value));
-		break;
-	case PROP_RTL:
-		ev_document_model_set_rtl (model, g_value_get_boolean (value));
-		break;
-	case PROP_FULLSCREEN:
-		ev_document_model_set_fullscreen (model, g_value_get_boolean (value));
-		break;
-	default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-	}
+                                guint         prop_id,
+                                const GValue *value,
+                                GParamSpec   *pspec) {
+  EvDocumentModel *model = EV_DOCUMENT_MODEL (object);
+
+  switch (prop_id) {
+    case PROP_DOCUMENT:
+      ev_document_model_set_document (model, (EvDocument *)g_value_get_object (value));
+      break;
+    case PROP_PAGE:
+      ev_document_model_set_page (model, g_value_get_int (value));
+      break;
+    case PROP_ROTATION:
+      ev_document_model_set_rotation (model, g_value_get_int (value));
+      break;
+    case PROP_INVERTED_COLORS:
+      ev_document_model_set_inverted_colors (model, g_value_get_boolean (value));
+      break;
+    case PROP_SCALE:
+      ev_document_model_set_scale (model, g_value_get_double (value));
+      break;
+    case PROP_MIN_SCALE:
+      ev_document_model_set_min_scale (model, g_value_get_double (value));
+      break;
+    case PROP_MAX_SCALE:
+      ev_document_model_set_max_scale (model, g_value_get_double (value));
+      break;
+    case PROP_SIZING_MODE:
+      ev_document_model_set_sizing_mode (model, g_value_get_enum (value));
+      break;
+    case PROP_CONTINUOUS:
+      ev_document_model_set_continuous (model, g_value_get_boolean (value));
+      break;
+    case PROP_CREATOR_MODE:
+      ev_document_model_set_creator_mode( model, g_value_get_boolean (value));
+      break;
+    case PROP_PAGE_LAYOUT:
+      ev_document_model_set_page_layout (model, g_value_get_enum (value));
+      break;
+    case PROP_DUAL_PAGE:
+      ev_document_model_set_dual_page (model, g_value_get_boolean (value));
+      break;
+    case PROP_DUAL_PAGE_ODD_LEFT:
+      ev_document_model_set_dual_page_odd_pages_left (model, g_value_get_boolean (value));
+      break;
+    case PROP_RTL:
+      ev_document_model_set_rtl (model, g_value_get_boolean (value));
+      break;
+    case PROP_FULLSCREEN:
+      ev_document_model_set_fullscreen (model, g_value_get_boolean (value));
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+  }
 }
 
 static void
 ev_document_model_get_property (GObject    *object,
-				guint       prop_id,
-				GValue     *value,
-				GParamSpec *pspec)
-{
-	EvDocumentModel *model = EV_DOCUMENT_MODEL (object);
-
-	switch (prop_id) {
-	case PROP_DOCUMENT:
-		g_value_set_object (value, model->document);
-		break;
-	case PROP_PAGE:
-		g_value_set_int (value, model->page);
-		break;
-	case PROP_ROTATION:
-		g_value_set_int (value, model->rotation);
-		break;
-	case PROP_INVERTED_COLORS:
-		g_value_set_boolean (value, model->inverted_colors);
-		break;
-	case PROP_SCALE:
-		g_value_set_double (value, model->scale);
-		break;
-	case PROP_MIN_SCALE:
-		g_value_set_double (value, model->min_scale);
-		break;
-	case PROP_MAX_SCALE:
-		g_value_set_double (value, model->max_scale);
-		break;
-	case PROP_SIZING_MODE:
-		g_value_set_enum (value, model->sizing_mode);
-		break;
-	case PROP_CONTINUOUS:
-		g_value_set_boolean (value, ev_document_model_get_continuous (model));
-		break;
-	case PROP_PAGE_LAYOUT:
-		g_value_set_enum (value, model->page_layout);
-		break;
-	case PROP_DUAL_PAGE:
-		g_value_set_boolean (value, ev_document_model_get_dual_page (model));
-		break;
-	case PROP_DUAL_PAGE_ODD_LEFT:
-		g_value_set_boolean (value, ev_document_model_get_dual_page_odd_pages_left (model));
-		break;
-	case PROP_RTL:
-		g_value_set_boolean (value, ev_document_model_get_rtl (model));
-		break;
-	case PROP_FULLSCREEN:
-		g_value_set_boolean (value, ev_document_model_get_fullscreen (model));
-		break;
-	default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-	}
+                                guint       prop_id,
+                                GValue     *value,
+                                GParamSpec *pspec) {
+  EvDocumentModel *model = EV_DOCUMENT_MODEL (object);
+
+  switch (prop_id) {
+    case PROP_DOCUMENT:
+      g_value_set_object (value, model->document);
+      break;
+    case PROP_PAGE:
+      g_value_set_int (value, model->page);
+      break;
+    case PROP_ROTATION:
+      g_value_set_int (value, model->rotation);
+      break;
+    case PROP_INVERTED_COLORS:
+      g_value_set_boolean (value, model->inverted_colors);
+      break;
+    case PROP_SCALE:
+      g_value_set_double (value, model->scale);
+      break;
+    case PROP_MIN_SCALE:
+      g_value_set_double (value, model->min_scale);
+      break;
+    case PROP_MAX_SCALE:
+      g_value_set_double (value, model->max_scale);
+      break;
+    case PROP_SIZING_MODE:
+      g_value_set_enum (value, model->sizing_mode);
+      break;
+    case PROP_CONTINUOUS:
+      g_value_set_boolean (value, ev_document_model_get_continuous (model));
+      break;
+    case PROP_CREATOR_MODE:
+      g_value_set_boolean (value, ev_document_model_get_creator_mode (model));
+      break;
+    case PROP_PAGE_LAYOUT:
+      g_value_set_enum (value, model->page_layout);
+      break;
+    case PROP_DUAL_PAGE:
+      g_value_set_boolean (value, ev_document_model_get_dual_page (model));
+      break;
+    case PROP_DUAL_PAGE_ODD_LEFT:
+      g_value_set_boolean (value, ev_document_model_get_dual_page_odd_pages_left (model));
+      break;
+    case PROP_RTL:
+      g_value_set_boolean (value, ev_document_model_get_rtl (model));
+      break;
+    case PROP_FULLSCREEN:
+      g_value_set_boolean (value, ev_document_model_get_fullscreen (model));
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+  }
 }
 
 static void
-ev_document_model_class_init (EvDocumentModelClass *klass)
-{
-	GObjectClass *g_object_class = G_OBJECT_CLASS (klass);
-
-	g_object_class->get_property = ev_document_model_get_property;
-	g_object_class->set_property = ev_document_model_set_property;
-	g_object_class->finalize = ev_document_model_finalize;
-
-	/* Properties */
-	g_object_class_install_property (g_object_class,
-					 PROP_DOCUMENT,
-					 g_param_spec_object ("document",
-							      "Document",
-							      "The current document",
-							      EV_TYPE_DOCUMENT,
-							      G_PARAM_READWRITE |
-                                                              G_PARAM_STATIC_STRINGS));
-	g_object_class_install_property (g_object_class,
-					 PROP_PAGE,
-					 g_param_spec_int ("page",
-							   "Page",
-							   "Current page",
-							   -1, G_MAXINT, -1,
-							   G_PARAM_READWRITE |
-                                                           G_PARAM_STATIC_STRINGS));
-	g_object_class_install_property (g_object_class,
-					 PROP_ROTATION,
-					 g_param_spec_int ("rotation",
-							   "Rotation",
-							   "Current rotation angle",
-							   0, 360, 0,
-							   G_PARAM_READWRITE |
-                                                           G_PARAM_STATIC_STRINGS));
-	g_object_class_install_property (g_object_class,
-					 PROP_INVERTED_COLORS,
-					 g_param_spec_boolean ("inverted-colors",
-							       "Inverted Colors",
-							       "Whether document is displayed with inverted colors",
-							       FALSE,
-							       G_PARAM_READWRITE |
-                                                               G_PARAM_STATIC_STRINGS));
-	g_object_class_install_property (g_object_class,
-					 PROP_SCALE,
-					 g_param_spec_double ("scale",
-							      "Scale",
-							      "Current scale factor",
-							      0., G_MAXDOUBLE, 1.,
-							      G_PARAM_READWRITE |
-                                                              G_PARAM_STATIC_STRINGS));
-	g_object_class_install_property (g_object_class,
-					 PROP_MIN_SCALE,
-					 g_param_spec_double ("min-scale",
-							      "Minimum Scale",
-							      "Minium scale factor",
-							      0., G_MAXDOUBLE, DEFAULT_MIN_SCALE,
-							      G_PARAM_READWRITE |
-                                                              G_PARAM_STATIC_STRINGS));
-	g_object_class_install_property (g_object_class,
-					 PROP_MAX_SCALE,
-					 g_param_spec_double ("max-scale",
-							      "Maximum Scale",
-							      "Maximum scale factor",
-							      0., G_MAXDOUBLE, DEFAULT_MAX_SCALE,
-							      G_PARAM_READWRITE |
-                                                              G_PARAM_STATIC_STRINGS));
-	g_object_class_install_property (g_object_class,
-					 PROP_SIZING_MODE,
-					 g_param_spec_enum ("sizing-mode",
-							    "Sizing Mode",
-							    "Current sizing mode",
-							    EV_TYPE_SIZING_MODE,
-							    EV_SIZING_FIT_WIDTH,
-							    G_PARAM_READWRITE |
-                                                            G_PARAM_STATIC_STRINGS));
-	g_object_class_install_property (g_object_class,
-					 PROP_PAGE_LAYOUT,
-					 g_param_spec_enum ("page-layout",
-							    "Page Layout",
-							    "Current page layout",
-							    EV_TYPE_PAGE_LAYOUT,
-							    EV_PAGE_LAYOUT_SINGLE,
-							    G_PARAM_READWRITE |
-							    G_PARAM_STATIC_STRINGS));
-	g_object_class_install_property (g_object_class,
-					 PROP_CONTINUOUS,
-					 g_param_spec_boolean ("continuous",
-							       "Continuous",
-							       "Whether document is displayed in continuous mode",
-							       TRUE,
-							       G_PARAM_READWRITE |
-                                                               G_PARAM_STATIC_STRINGS));
-	g_object_class_install_property (g_object_class,
-					 PROP_DUAL_PAGE,
-					 g_param_spec_boolean ("dual-page",
-							       "Dual Page",
-							       "Whether document is displayed in dual page mode",
-							       FALSE,
-							       G_PARAM_READWRITE |
-                                                               G_PARAM_STATIC_STRINGS));
-	g_object_class_install_property (g_object_class,
-					 PROP_DUAL_PAGE_ODD_LEFT,
-					 g_param_spec_boolean ("dual-odd-left",
-							       "Odd Pages Left",
-							       "Whether odd pages are displayed on left side in dual mode",
-							       FALSE,
-							       G_PARAM_READWRITE |
-                                                               G_PARAM_STATIC_STRINGS));
-	g_object_class_install_property (g_object_class,
-					 PROP_RTL,
-					 g_param_spec_boolean ("rtl",
-							       "Right to Left",
-							       "Whether the document is written from right to left",
-							       FALSE,
-							       G_PARAM_READWRITE |
-                                                               G_PARAM_STATIC_STRINGS));
-	g_object_class_install_property (g_object_class,
-					 PROP_FULLSCREEN,
-					 g_param_spec_boolean ("fullscreen",
-							       "Fullscreen",
-							       "Whether document is displayed in fullscreen mode",
-							       FALSE,
-							       G_PARAM_READWRITE |
-                                                               G_PARAM_STATIC_STRINGS));
-
-	/* Signals */
-	signals [PAGE_CHANGED] =
-		g_signal_new ("page-changed",
-			      EV_TYPE_DOCUMENT_MODEL,
-			      G_SIGNAL_RUN_LAST,
-			      0,
-			      NULL, NULL,
-			      ev_view_marshal_VOID__INT_INT,
-			      G_TYPE_NONE, 2,
-			      G_TYPE_INT, G_TYPE_INT);
+ev_document_model_class_init (EvDocumentModelClass *klass) {
+  GObjectClass *g_object_class = G_OBJECT_CLASS (klass);
+
+  g_object_class->get_property = ev_document_model_get_property;
+  g_object_class->set_property = ev_document_model_set_property;
+  g_object_class->finalize = ev_document_model_finalize;
+
+  /* Properties */
+  g_object_class_install_property (g_object_class,
+                                   PROP_DOCUMENT,
+                                   g_param_spec_object ("document",
+                                                        "Document",
+                                                        "The current document",
+                                                        EV_TYPE_DOCUMENT,
+                                                        G_PARAM_READWRITE |
+                                                        G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (g_object_class,
+                                   PROP_PAGE,
+                                   g_param_spec_int ("page",
+                                                     "Page",
+                                                     "Current page",
+                                                     -1, G_MAXINT, -1,
+                                                     G_PARAM_READWRITE |
+                                                     G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (g_object_class,
+                                   PROP_ROTATION,
+                                   g_param_spec_int ("rotation",
+                                                     "Rotation",
+                                                     "Current rotation angle",
+                                                     0, 360, 0,
+                                                     G_PARAM_READWRITE |
+                                                     G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (g_object_class,
+                                   PROP_INVERTED_COLORS,
+                                   g_param_spec_boolean ("inverted-colors",
+                                                         "Inverted Colors",
+                                                         "Whether document is displayed with inverted colors",
+                                                         FALSE,
+                                                         G_PARAM_READWRITE |
+                                                         G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (g_object_class,
+                                   PROP_SCALE,
+                                   g_param_spec_double ("scale",
+                                                        "Scale",
+                                                        "Current scale factor",
+                                                        0., G_MAXDOUBLE, 1.,
+                                                        G_PARAM_READWRITE |
+                                                        G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (g_object_class,
+                                   PROP_MIN_SCALE,
+                                   g_param_spec_double ("min-scale",
+                                                        "Minimum Scale",
+                                                        "Minium scale factor",
+                                                        0., G_MAXDOUBLE, DEFAULT_MIN_SCALE,
+                                                        G_PARAM_READWRITE |
+                                                        G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (g_object_class,
+                                   PROP_MAX_SCALE,
+                                   g_param_spec_double ("max-scale",
+                                                        "Maximum Scale",
+                                                        "Maximum scale factor",
+                                                        0., G_MAXDOUBLE, DEFAULT_MAX_SCALE,
+                                                        G_PARAM_READWRITE |
+                                                        G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (g_object_class,
+                                   PROP_SIZING_MODE,
+                                   g_param_spec_enum ("sizing-mode",
+                                                      "Sizing Mode",
+                                                      "Current sizing mode",
+                                                      EV_TYPE_SIZING_MODE,
+                                                      EV_SIZING_FIT_WIDTH,
+                                                      G_PARAM_READWRITE |
+                                                      G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (g_object_class,
+                                   PROP_PAGE_LAYOUT,
+                                   g_param_spec_enum ("page-layout",
+                                                      "Page Layout",
+                                                      "Current page layout",
+                                                      EV_TYPE_PAGE_LAYOUT,
+                                                      EV_PAGE_LAYOUT_SINGLE,
+                                                      G_PARAM_READWRITE |
+                                                      G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (g_object_class,
+                                   PROP_CONTINUOUS,
+                                   g_param_spec_boolean ("continuous",
+                                                         "Continuous",
+                                                         "Whether document is displayed in continuous mode",
+                                                         TRUE,
+                                                         G_PARAM_READWRITE |
+                                                         G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (g_object_class,
+                                   PROP_CREATOR_MODE,
+                                   g_param_spec_boolean ("creator-mode",
+                                                         "Creator Mode",
+                                                         "Whether document is displayed in creator_mode mode",
+                                                         TRUE,
+                                                         G_PARAM_READWRITE |
+                                                         G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (g_object_class,
+                                   PROP_DUAL_PAGE,
+                                   g_param_spec_boolean ("dual-page",
+                                                         "Dual Page",
+                                                         "Whether document is displayed in dual page mode",
+                                                         FALSE,
+                                                         G_PARAM_READWRITE |
+                                                         G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (g_object_class,
+                                   PROP_DUAL_PAGE_ODD_LEFT,
+                                   g_param_spec_boolean ("dual-odd-left",
+                                                         "Odd Pages Left",
+                                                         "Whether odd pages are displayed on left side in dual mode",
+                                                         FALSE,
+                                                         G_PARAM_READWRITE |
+                                                         G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (g_object_class,
+                                   PROP_RTL,
+                                   g_param_spec_boolean ("rtl",
+                                                         "Right to Left",
+                                                         "Whether the document is written from right to left",
+                                                         FALSE,
+                                                         G_PARAM_READWRITE |
+                                                         G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (g_object_class,
+                                   PROP_FULLSCREEN,
+                                   g_param_spec_boolean ("fullscreen",
+                                                         "Fullscreen",
+                                                         "Whether document is displayed in fullscreen mode",
+                                                         FALSE,
+                                                         G_PARAM_READWRITE |
+                                                         G_PARAM_STATIC_STRINGS));
+
+  /* Signals */
+  signals [PAGE_CHANGED] =
+    g_signal_new ("page-changed",
+                  EV_TYPE_DOCUMENT_MODEL,
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL,
+                  ev_view_marshal_VOID__INT_INT,
+                  G_TYPE_NONE, 2,
+                  G_TYPE_INT, G_TYPE_INT);
 }
 
 static void
-ev_document_model_init (EvDocumentModel *model)
-{
-	model->page = -1;
-	model->scale = 1.;
-	model->sizing_mode = EV_SIZING_FIT_WIDTH;
-	model->continuous = TRUE;
-	model->inverted_colors = FALSE;
-	model->min_scale = DEFAULT_MIN_SCALE;
-	model->max_scale = DEFAULT_MAX_SCALE;
+ev_document_model_init (EvDocumentModel *model) {
+  model->page = -1;
+  model->scale = 1.;
+  model->sizing_mode = EV_SIZING_FIT_WIDTH;
+  model->continuous = TRUE;
+  model->creator_mode = FALSE;
+  model->inverted_colors = FALSE;
+  model->min_scale = DEFAULT_MIN_SCALE;
+  model->max_scale = DEFAULT_MAX_SCALE;
 }
 
 EvDocumentModel *
-ev_document_model_new (void)
-{
-	return g_object_new (EV_TYPE_DOCUMENT_MODEL, NULL);
+ev_document_model_new (void) {
+  return g_object_new (EV_TYPE_DOCUMENT_MODEL, NULL);
 }
 
 EvDocumentModel *
-ev_document_model_new_with_document (EvDocument *document)
-{
-	g_return_val_if_fail (EV_IS_DOCUMENT (document), NULL);
+ev_document_model_new_with_document (EvDocument *document) {
+  g_return_val_if_fail (EV_IS_DOCUMENT (document), NULL);
 
-	return g_object_new (EV_TYPE_DOCUMENT_MODEL, "document", document, NULL);
+  return g_object_new (EV_TYPE_DOCUMENT_MODEL, "document", document, NULL);
 }
 
 void
 ev_document_model_set_document (EvDocumentModel *model,
-				EvDocument      *document)
-{
-	g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
-	g_return_if_fail (EV_IS_DOCUMENT (document));
+                                EvDocument      *document) {
+  g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
+  g_return_if_fail (EV_IS_DOCUMENT (document));
 
-	if (document == model->document)
-		return;
+  if (document == model->document)
+    return;
 
-	if (model->document)
-		g_object_unref (model->document);
-	model->document = g_object_ref (document);
+  if (model->document)
+    g_object_unref (model->document);
+  model->document = g_object_ref (document);
 
-	model->n_pages = ev_document_get_n_pages (document);
-	ev_document_model_set_page (model, CLAMP (model->page, 0,
-						  model->n_pages - 1));
+  model->n_pages = ev_document_get_n_pages (document);
+  ev_document_model_set_page (model, CLAMP (model->page, 0,
+                                            model->n_pages - 1));
 
-	g_object_notify (G_OBJECT (model), "document");
+  g_object_notify (G_OBJECT (model), "document");
 }
 
 /**
@@ -396,166 +405,153 @@ ev_document_model_set_document (EvDocumentModel *model,
  * Returns: (transfer none): a #EvDocument
  */
 EvDocument *
-ev_document_model_get_document (EvDocumentModel *model)
-{
-	g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), NULL);
+ev_document_model_get_document (EvDocumentModel *model) {
+  g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), NULL);
 
-	return model->document;
+  return model->document;
 }
 
 void
 ev_document_model_set_page (EvDocumentModel *model,
-			    gint             page)
-{
-	gint old_page;
+                            gint             page) {
+  gint old_page;
 
-	g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
+  g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
 
-	if (model->page == page)
-		return;
-	if (page < 0 || (model->document && page >= model->n_pages))
-		return;
+  if (model->page == page)
+    return;
+  if (page < 0 || (model->document && model->creator_mode && page > model->n_pages) || (model->document && !model->creator_mode && page >= model->n_pages))
+    return;
 
-	old_page = model->page;
-	model->page = page;
-	g_signal_emit (model, signals[PAGE_CHANGED], 0, old_page, page);
+  old_page = model->page;
+  model->page = page;
+  g_signal_emit (model, signals[PAGE_CHANGED], 0, old_page, page);
 
-	g_object_notify (G_OBJECT (model), "page");
+  g_object_notify (G_OBJECT (model), "page");
 }
 
 void
 ev_document_model_set_page_by_label (EvDocumentModel *model,
-				     const gchar     *page_label)
-{
-	gint page;
+                                     const gchar     *page_label) {
+  gint page;
 
-	g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
-	g_return_if_fail (model->document != NULL);
+  g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
+  g_return_if_fail (model->document != NULL);
 
-	if (ev_document_find_page_by_label (model->document, page_label, &page))
-		ev_document_model_set_page (model, page);
+  if (ev_document_find_page_by_label (model->document, page_label, &page))
+    ev_document_model_set_page (model, page);
 }
 
 gint
-ev_document_model_get_page (EvDocumentModel *model)
-{
-	g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), -1);
+ev_document_model_get_page (EvDocumentModel *model) {
+  g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), -1);
 
-	return model->page;
+  return model->page;
 }
 
 void
 ev_document_model_set_scale (EvDocumentModel *model,
-			     gdouble          scale)
-{
-	g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
+                             gdouble          scale) {
+  g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
 
-	scale = CLAMP (scale,
-		       model->sizing_mode == EV_SIZING_FREE ?
-		       model->min_scale : 0, model->max_scale);
+  scale = CLAMP (scale,
+                 model->sizing_mode == EV_SIZING_FREE ?
+                 model->min_scale : 0, model->max_scale);
 
-	if (scale == model->scale)
-		return;
+  if (scale == model->scale)
+    return;
 
-	model->scale = scale;
+  model->scale = scale;
 
-	g_object_notify (G_OBJECT (model), "scale");
+  g_object_notify (G_OBJECT (model), "scale");
 }
 
 gdouble
-ev_document_model_get_scale (EvDocumentModel *model)
-{
-	g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), 1.0);
+ev_document_model_get_scale (EvDocumentModel *model) {
+  g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), 1.0);
 
-	return model->scale;
+  return model->scale;
 }
 
 void
 ev_document_model_set_max_scale (EvDocumentModel *model,
-				 gdouble          max_scale)
-{
-	g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
+                                 gdouble          max_scale) {
+  g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
 
-	if (max_scale == model->max_scale)
-		return;
+  if (max_scale == model->max_scale)
+    return;
 
-	model->max_scale = max_scale;
+  model->max_scale = max_scale;
 
-	if (model->scale > max_scale)
-		ev_document_model_set_scale (model, max_scale);
+  if (model->scale > max_scale)
+    ev_document_model_set_scale (model, max_scale);
 
-	g_object_notify (G_OBJECT (model), "max-scale");
+  g_object_notify (G_OBJECT (model), "max-scale");
 }
 
 gdouble
-ev_document_model_get_max_scale (EvDocumentModel *model)
-{
-	g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), 1.0);
+ev_document_model_get_max_scale (EvDocumentModel *model) {
+  g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), 1.0);
 
-	return model->max_scale;
+  return model->max_scale;
 }
 
 void
 ev_document_model_set_min_scale (EvDocumentModel *model,
-				 gdouble          min_scale)
-{
-	g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
+                                 gdouble          min_scale) {
+  g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
 
-	if (min_scale == model->min_scale)
-		return;
+  if (min_scale == model->min_scale)
+    return;
 
-	model->min_scale = min_scale;
+  model->min_scale = min_scale;
 
-	if (model->scale < min_scale)
-		ev_document_model_set_scale (model, min_scale);
+  if (model->scale < min_scale)
+    ev_document_model_set_scale (model, min_scale);
 
-	g_object_notify (G_OBJECT (model), "min-scale");
+  g_object_notify (G_OBJECT (model), "min-scale");
 }
 
 gdouble
-ev_document_model_get_min_scale (EvDocumentModel *model)
-{
-	g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), 0.);
+ev_document_model_get_min_scale (EvDocumentModel *model) {
+  g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), 0.);
 
-	return model->min_scale;
+  return model->min_scale;
 }
 
 void
 ev_document_model_set_sizing_mode (EvDocumentModel *model,
-				   EvSizingMode     mode)
-{
-	g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
+                                   EvSizingMode     mode) {
+  g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
 
-	if (mode == model->sizing_mode)
-		return;
+  if (mode == model->sizing_mode)
+    return;
 
-	model->sizing_mode = mode;
+  model->sizing_mode = mode;
 
-	g_object_notify (G_OBJECT (model), "sizing-mode");
+  g_object_notify (G_OBJECT (model), "sizing-mode");
 }
 
 EvSizingMode
-ev_document_model_get_sizing_mode (EvDocumentModel *model)
-{
-	g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), EV_SIZING_FIT_WIDTH);
+ev_document_model_get_sizing_mode (EvDocumentModel *model) {
+  g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), EV_SIZING_FIT_WIDTH);
 
-	return model->sizing_mode;
+  return model->sizing_mode;
 }
 
 static void
 _ev_document_model_set_dual_page_internal (EvDocumentModel *model,
-                                           gboolean         dual_page)
-{
-	g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
+                                           gboolean         dual_page) {
+  g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
 
-	dual_page = dual_page != FALSE;
+  dual_page = dual_page != FALSE;
 
-	if (dual_page == model->dual_page)
-		return;
+  if (dual_page == model->dual_page)
+    return;
 
-	model->dual_page = dual_page;
+  model->dual_page = dual_page;
 
-	g_object_notify (G_OBJECT (model), "dual-page");
+  g_object_notify (G_OBJECT (model), "dual-page");
 }
 
 /**
@@ -569,19 +565,18 @@ _ev_document_model_set_dual_page_internal (EvDocumentModel *model,
  */
 void
 ev_document_model_set_page_layout (EvDocumentModel *model,
-				   EvPageLayout	    layout)
-{
-	g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
+                                   EvPageLayout	    layout) {
+  g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
 
-	if (layout == model->page_layout)
-		return;
+  if (layout == model->page_layout)
+    return;
 
-	model->page_layout = layout;
+  model->page_layout = layout;
 
-	g_object_notify (G_OBJECT (model), "page-layout");
+  g_object_notify (G_OBJECT (model), "page-layout");
 
-	/* set deprecated property as well */
-	_ev_document_model_set_dual_page_internal (model, layout == EV_PAGE_LAYOUT_DUAL);
+  /* set deprecated property as well */
+  _ev_document_model_set_dual_page_internal (model, layout == EV_PAGE_LAYOUT_DUAL);
 }
 
 /**
@@ -593,84 +588,100 @@ ev_document_model_set_page_layout (EvDocumentModel *model,
  * Since: 3.8
  */
 EvPageLayout
-ev_document_model_get_page_layout (EvDocumentModel *model)
-{
-	g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), EV_PAGE_LAYOUT_SINGLE);
+ev_document_model_get_page_layout (EvDocumentModel *model) {
+  g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), EV_PAGE_LAYOUT_SINGLE);
 
-	return model->page_layout;
+  return model->page_layout;
 }
 
 void
 ev_document_model_set_rotation (EvDocumentModel *model,
-				gint             rotation)
-{
-	g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
+                                gint             rotation) {
+  g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
 
-	if (rotation >= 360)
-		rotation -= 360;
-	else if (rotation < 0)
-		rotation += 360;
+  if (rotation >= 360)
+    rotation -= 360;
+  else if (rotation < 0)
+    rotation += 360;
 
-	if (rotation == model->rotation)
-		return;
+  if (rotation == model->rotation)
+    return;
 
-	model->rotation = rotation;
+  model->rotation = rotation;
 
-	g_object_notify (G_OBJECT (model), "rotation");
+  g_object_notify (G_OBJECT (model), "rotation");
 }
 
 gint
-ev_document_model_get_rotation (EvDocumentModel *model)
-{
-	g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), 0);
+ev_document_model_get_rotation (EvDocumentModel *model) {
+  g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), 0);
 
-	return model->rotation;
+  return model->rotation;
 }
 
 void
 ev_document_model_set_inverted_colors (EvDocumentModel *model,
-				       gboolean         inverted_colors)
-{
-	g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
+                                       gboolean         inverted_colors) {
+  g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
 
-	if (inverted_colors == model->inverted_colors)
-		return;
+  if (inverted_colors == model->inverted_colors)
+    return;
 
-	model->inverted_colors = inverted_colors;
+  model->inverted_colors = inverted_colors;
 
-	g_object_notify (G_OBJECT (model), "inverted-colors");
+  g_object_notify (G_OBJECT (model), "inverted-colors");
 }
 
 gboolean
-ev_document_model_get_inverted_colors (EvDocumentModel *model)
-{
-	g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), FALSE);
+ev_document_model_get_inverted_colors (EvDocumentModel *model) {
+  g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), FALSE);
 
-	return model->inverted_colors;
+  return model->inverted_colors;
 }
 
 void
 ev_document_model_set_continuous (EvDocumentModel *model,
-				  gboolean         continuous)
-{
-	g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
+                                  gboolean         continuous) {
+  g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
+
+  continuous = continuous != FALSE;
+
+  if (continuous == model->continuous)
+    return;
+
+  model->continuous = continuous;
+
+  g_object_notify (G_OBJECT (model), "continuous");
+}
+
+gboolean
+ev_document_model_get_continuous (EvDocumentModel *model) {
+  g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), TRUE);
+
+  return model->continuous;
+}
+
+
+void
+ev_document_model_set_creator_mode (EvDocumentModel *model,
+                                    gboolean         creator_mode) {
+  g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
 
-	continuous = continuous != FALSE;
+  creator_mode = creator_mode != FALSE;
 
-	if (continuous == model->continuous)
-		return;
+  if (creator_mode == model->creator_mode)
+    return;
 
-	model->continuous = continuous;
+  model->creator_mode = creator_mode;
 
-	g_object_notify (G_OBJECT (model), "continuous");
+  g_object_notify (G_OBJECT (model), "creator_mode");
 }
 
 gboolean
-ev_document_model_get_continuous (EvDocumentModel *model)
-{
-	g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), TRUE);
+ev_document_model_get_creator_mode (EvDocumentModel *model) {
+  g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), TRUE);
 
-	return model->continuous;
+  return model->creator_mode;
 }
 
 /**
@@ -685,14 +696,13 @@ ev_document_model_get_continuous (EvDocumentModel *model)
  */
 void
 ev_document_model_set_dual_page (EvDocumentModel *model,
-				 gboolean         dual_page)
-{
-	EvPageLayout layout;
+                                 gboolean         dual_page) {
+  EvPageLayout layout;
 
-	g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
+  g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
 
-	layout = dual_page ? EV_PAGE_LAYOUT_DUAL : EV_PAGE_LAYOUT_SINGLE;
-	ev_document_model_set_page_layout (model, layout);
+  layout = dual_page ? EV_PAGE_LAYOUT_DUAL : EV_PAGE_LAYOUT_SINGLE;
+  ev_document_model_set_page_layout (model, layout);
 }
 
 /**
@@ -705,81 +715,74 @@ ev_document_model_set_dual_page (EvDocumentModel *model,
  * Deprecated: 3.8: Use ev_document_model_get_page_layout() instead
  */
 gboolean
-ev_document_model_get_dual_page (EvDocumentModel *model)
-{
-	g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), FALSE);
+ev_document_model_get_dual_page (EvDocumentModel *model) {
+  g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), FALSE);
 
-	return model->dual_page;
+  return model->dual_page;
 }
 
 void
 ev_document_model_set_dual_page_odd_pages_left (EvDocumentModel *model,
-						gboolean         odd_left)
-{
-	g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
+                                                gboolean         odd_left) {
+  g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
 
-	odd_left = odd_left != FALSE;
+  odd_left = odd_left != FALSE;
 
-	if (odd_left == model->dual_page_odd_left)
-		return;
+  if (odd_left == model->dual_page_odd_left)
+    return;
 
-	model->dual_page_odd_left = odd_left;
+  model->dual_page_odd_left = odd_left;
 
-	g_object_notify (G_OBJECT (model), "dual-odd-left");
+  g_object_notify (G_OBJECT (model), "dual-odd-left");
 }
 
 gboolean
-ev_document_model_get_dual_page_odd_pages_left (EvDocumentModel *model)
-{
-	g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), FALSE);
+ev_document_model_get_dual_page_odd_pages_left (EvDocumentModel *model) {
+  g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), FALSE);
 
-	return model->dual_page_odd_left;
+  return model->dual_page_odd_left;
 }
 
 void
 ev_document_model_set_rtl (EvDocumentModel *model,
-                           gboolean         rtl)
-{
-	g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
+                           gboolean         rtl) {
+  g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
 
-	rtl = rtl != FALSE;
+  rtl = rtl != FALSE;
 
-	if (rtl == model->rtl)
-		return;
+  if (rtl == model->rtl)
+    return;
 
-	model->rtl = rtl;
+  model->rtl = rtl;
 
-	g_object_notify (G_OBJECT (model), "rtl");
+  g_object_notify (G_OBJECT (model), "rtl");
 }
 
 gboolean
-ev_document_model_get_rtl (EvDocumentModel *model)
-{
-	g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), FALSE);
+ev_document_model_get_rtl (EvDocumentModel *model) {
+  g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), FALSE);
 
-	return model->rtl;
+  return model->rtl;
 }
 
 void
 ev_document_model_set_fullscreen (EvDocumentModel *model,
-				  gboolean         fullscreen)
-{
-	g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
+                                  gboolean         fullscreen) {
+  g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
 
-	fullscreen = fullscreen != FALSE;
+  fullscreen = fullscreen != FALSE;
 
-	if (fullscreen == model->fullscreen)
-		return;
+  if (fullscreen == model->fullscreen)
+    return;
 
-	model->fullscreen = fullscreen;
+  model->fullscreen = fullscreen;
 
-	g_object_notify (G_OBJECT (model), "fullscreen");
+  g_object_notify (G_OBJECT (model), "fullscreen");
 }
 
 gboolean
-ev_document_model_get_fullscreen (EvDocumentModel *model)
-{
-	g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), FALSE);
+ev_document_model_get_fullscreen (EvDocumentModel *model) {
+  g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), FALSE);
 
-	return model->fullscreen;
+  return model->fullscreen;
 }
diff --git a/libview/ev-document-model.h b/libview/ev-document-model.h
index 042977e..eea4973 100644
--- a/libview/ev-document-model.h
+++ b/libview/ev-document-model.h
@@ -41,69 +41,73 @@ G_DECLARE_FINAL_TYPE(EvDocumentModel, ev_document_model, EV, DOCUMENT_MODEL, GOb
  * @EV_SIZING_AUTOMATIC: Since: 3.8
  */
 typedef enum {
-        EV_SIZING_FIT_PAGE,
-	EV_SIZING_BEST_FIT = EV_SIZING_FIT_PAGE, /* Deprecated */
-	EV_SIZING_FIT_WIDTH,
-	EV_SIZING_FREE,
-        EV_SIZING_AUTOMATIC
+  EV_SIZING_FIT_PAGE,
+  EV_SIZING_BEST_FIT = EV_SIZING_FIT_PAGE, /* Deprecated */
+  EV_SIZING_FIT_WIDTH,
+  EV_SIZING_FREE,
+  EV_SIZING_AUTOMATIC
 } EvSizingMode;
 
 typedef enum {
-	EV_PAGE_LAYOUT_SINGLE,
-	EV_PAGE_LAYOUT_DUAL,
-	EV_PAGE_LAYOUT_AUTOMATIC
+  EV_PAGE_LAYOUT_SINGLE,
+  EV_PAGE_LAYOUT_DUAL,
+  EV_PAGE_LAYOUT_AUTOMATIC
 } EvPageLayout;
 
 EvDocumentModel *ev_document_model_new               (void);
 EvDocumentModel *ev_document_model_new_with_document (EvDocument      *document);
 
 void             ev_document_model_set_document      (EvDocumentModel *model,
-						      EvDocument      *document);
+                                                      EvDocument      *document);
 EvDocument      *ev_document_model_get_document      (EvDocumentModel *model);
 void             ev_document_model_set_page          (EvDocumentModel *model,
-						      gint             page);
+                                                      gint             page);
 void             ev_document_model_set_page_by_label (EvDocumentModel *model,
-						      const gchar     *page_label);
+                                                      const gchar     *page_label);
 gint             ev_document_model_get_page          (EvDocumentModel *model);
 void             ev_document_model_set_scale         (EvDocumentModel *model,
-						      gdouble          scale);
+                                                      gdouble          scale);
 gdouble          ev_document_model_get_scale         (EvDocumentModel *model);
 void             ev_document_model_set_max_scale     (EvDocumentModel *model,
-						      gdouble          max_scale);
+                                                      gdouble          max_scale);
 gdouble          ev_document_model_get_max_scale     (EvDocumentModel *model);
 void             ev_document_model_set_min_scale     (EvDocumentModel *model,
-						      gdouble          min_scale);
+                                                      gdouble          min_scale);
 gdouble          ev_document_model_get_min_scale     (EvDocumentModel *model);
 void             ev_document_model_set_sizing_mode   (EvDocumentModel *model,
-						      EvSizingMode     mode);
+                                                      EvSizingMode     mode);
 EvSizingMode     ev_document_model_get_sizing_mode   (EvDocumentModel *model);
 void             ev_document_model_set_page_layout   (EvDocumentModel *model,
-						     EvPageLayout     layout);
+                                                      EvPageLayout     layout);
 EvPageLayout	 ev_document_model_get_page_layout   (EvDocumentModel *model);
 void             ev_document_model_set_rotation      (EvDocumentModel *model,
-						      gint             rotation);
+                                                      gint             rotation);
 gint             ev_document_model_get_rotation      (EvDocumentModel *model);
 void           ev_document_model_set_inverted_colors (EvDocumentModel *model,
-						      gboolean         inverted_colors);
+                                                      gboolean         inverted_colors);
 gboolean       ev_document_model_get_inverted_colors (EvDocumentModel *model);
+
 void             ev_document_model_set_continuous    (EvDocumentModel *model,
-						      gboolean         continuous);
+                                                      gboolean         continuous);
 gboolean         ev_document_model_get_continuous    (EvDocumentModel *model);
+void             ev_document_model_set_creator_mode    (EvDocumentModel *model,
+                                                        gboolean         continuous);
+gboolean         ev_document_model_get_creator_mode    (EvDocumentModel *model);
 void             ev_document_model_set_dual_page_odd_pages_left (EvDocumentModel *model,
-								 gboolean         odd_left);
+                                                                 gboolean         odd_left);
 gboolean         ev_document_model_get_dual_page_odd_pages_left (EvDocumentModel *model);
 void             ev_document_model_set_rtl (EvDocumentModel *model,
                                             gboolean         rtl);
 gboolean         ev_document_model_get_rtl (EvDocumentModel *model);
 void             ev_document_model_set_fullscreen    (EvDocumentModel *model,
-						      gboolean         fullscreen);
+                                                      gboolean         fullscreen);
 gboolean         ev_document_model_get_fullscreen    (EvDocumentModel *model);
 
 /* deprecated */
 
 EV_DEPRECATED_FOR(ev_document_model_set_page_layout)
 void             ev_document_model_set_dual_page     (EvDocumentModel *model,
-						      gboolean         dual_page);
+                                                      gboolean         dual_page);
 EV_DEPRECATED_FOR(ev_document_model_get_page_layout)
 gboolean         ev_document_model_get_dual_page     (EvDocumentModel *model);
 
diff --git a/libview/ev-view.c b/libview/ev-view.c
index ffbe170..ff019d8 100644
--- a/libview/ev-view.c
+++ b/libview/ev-view.c
@@ -51,55 +51,55 @@
 #endif
 
 enum {
-	SIGNAL_SCROLL,
-	SIGNAL_HANDLE_LINK,
-	SIGNAL_EXTERNAL_LINK,
-	SIGNAL_POPUP_MENU,
-	SIGNAL_SELECTION_CHANGED,
-	SIGNAL_SYNC_SOURCE,
-	SIGNAL_ANNOT_ADDED,
-	SIGNAL_ANNOT_REMOVED,
-	SIGNAL_LAYERS_CHANGED,
-	SIGNAL_MOVE_CURSOR,
-	SIGNAL_CURSOR_MOVED,
-	SIGNAL_ACTIVATE,
-	N_SIGNALS
+  SIGNAL_SCROLL,
+  SIGNAL_HANDLE_LINK,
+  SIGNAL_EXTERNAL_LINK,
+  SIGNAL_POPUP_MENU,
+  SIGNAL_SELECTION_CHANGED,
+  SIGNAL_SYNC_SOURCE,
+  SIGNAL_ANNOT_ADDED,
+  SIGNAL_ANNOT_REMOVED,
+  SIGNAL_LAYERS_CHANGED,
+  SIGNAL_MOVE_CURSOR,
+  SIGNAL_CURSOR_MOVED,
+  SIGNAL_ACTIVATE,
+  N_SIGNALS
 };
 
 enum {
-	TARGET_DND_URI,
-	TARGET_DND_TEXT,
-	TARGET_DND_IMAGE
+  TARGET_DND_URI,
+  TARGET_DND_TEXT,
+  TARGET_DND_IMAGE
 };
 
 enum {
-	PROP_0,
-	PROP_IS_LOADING,
-	PROP_HADJUSTMENT,
-	PROP_VADJUSTMENT,
-	PROP_HSCROLL_POLICY,
-	PROP_VSCROLL_POLICY,
-	PROP_CAN_ZOOM_IN,
-	PROP_CAN_ZOOM_OUT
+  PROP_0,
+  PROP_IS_LOADING,
+  PROP_HADJUSTMENT,
+  PROP_VADJUSTMENT,
+  PROP_HSCROLL_POLICY,
+  PROP_VSCROLL_POLICY,
+  PROP_CAN_ZOOM_IN,
+  PROP_CAN_ZOOM_OUT
 };
 
 static guint signals[N_SIGNALS];
 
 typedef enum {
-	EV_VIEW_FIND_NEXT,
-	EV_VIEW_FIND_PREV
+  EV_VIEW_FIND_NEXT,
+  EV_VIEW_FIND_PREV
 } EvViewFindDirection;
 
 typedef struct {
-	GtkWidget  *widget;
+  GtkWidget  *widget;
 
-	/* View coords */
-	gint        x;
-	gint        y;
+  /* View coords */
+  gint        x;
+  gint        y;
 
-	/* Document */
-	guint       page;
-	EvRectangle doc_rect;
+  /* Document */
+  guint       page;
+  EvRectangle doc_rect;
 } EvViewChild;
 
 #define MIN_SCALE 0.05409 /* large documents (comics) need a small value, see #702 */
@@ -123,81 +123,81 @@ static void       view_update_range_and_current_page         (EvView
 
 /*** Geometry computations ***/
 static void       compute_border                             (EvView             *view,
-							      GtkBorder          *border);
+                                                              GtkBorder          *border);
 static void       get_page_y_offset                          (EvView             *view,
-							      int                 page,
-							      int                *y_offset,
-							      GtkBorder          *border);
+                                                              int                 page,
+                                                              int                *y_offset,
+                                                              GtkBorder          *border);
 static void       find_page_at_location                      (EvView             *view,
-							      gdouble             x,
-							      gdouble             y,
-							      gint               *page,
-							      gint               *x_offset,
-							      gint               *y_offset);
+                                                              gdouble             x,
+                                                              gdouble             y,
+                                                              gint               *page,
+                                                              gint               *x_offset,
+                                                              gint               *y_offset);
 static gboolean   real_ev_view_get_page_extents              (EvView             *view,
-							      gint                page,
-							      GdkRectangle       *page_area,
-							      GtkBorder          *border,
-							      gboolean            use_passed_border);
+                                                              gint                page,
+                                                              GdkRectangle       *page_area,
+                                                              GtkBorder          *border,
+                                                              gboolean            use_passed_border);
 /*** Hyperrefs ***/
-static EvLink *   ev_view_get_link_at_location 		     (EvView             *view,
-				  	         	      gdouble             x,
-		            				      gdouble             y);
-static char*      tip_from_link                              (EvView             *view,
-							      EvLink             *link);
+static EvLink    *ev_view_get_link_at_location 		     (EvView             *view,
+                                                        gdouble             x,
+                                                        gdouble             y);
+static char      *tip_from_link                              (EvView             *view,
+                                                              EvLink             *link);
 /*** Forms ***/
 static EvFormField *ev_view_get_form_field_at_location       (EvView             *view,
-							       gdouble            x,
-							       gdouble            y);
+                                                              gdouble            x,
+                                                              gdouble            y);
 /*** Media ***/
 static EvMedia     *ev_view_get_media_at_location            (EvView             *view,
-							      gdouble             x,
-							      gdouble             y);
+                                                              gdouble             x,
+                                                              gdouble             y);
 static gboolean     ev_view_find_player_for_media            (EvView             *view,
-							      EvMedia            *media);
+                                                              EvMedia            *media);
 /*** Annotations ***/
 static GtkWidget    *get_window_for_annot 		     (EvView 		 *view,
-							      EvAnnotation	 *annot);
+                                                    EvAnnotation	 *annot);
 static void          map_annot_to_window		     (EvView		 *view,
-							      EvAnnotation	 *annot,
-							      GtkWidget		 *window);
+                                                  EvAnnotation	 *annot,
+                                                  GtkWidget		 *window);
 static EvAnnotation *ev_view_get_annotation_at_location      (EvView             *view,
-							      gdouble             x,
-							      gdouble             y);
+                                                              gdouble             x,
+                                                              gdouble             y);
 static void          show_annotation_windows                 (EvView             *view,
-							      gint                page);
+                                                              gint                page);
 static void          hide_annotation_windows                 (EvView             *view,
-							      gint                page);
+                                                              gint                page);
 static void	     ev_view_create_annotation_from_selection (EvView          *view,
-							       EvViewSelection *selection);
+                                                           EvViewSelection *selection);
 /*** GtkWidget implementation ***/
 static void       ev_view_size_request_continuous_dual_page  (EvView             *view,
-							      GtkRequisition     *requisition);
+                                                              GtkRequisition     *requisition);
 static void       ev_view_size_request_continuous            (EvView             *view,
-							      GtkRequisition     *requisition);
+                                                              GtkRequisition     *requisition);
 static void       ev_view_size_request_dual_page             (EvView             *view,
-							      GtkRequisition     *requisition);
+                                                              GtkRequisition     *requisition);
 static void       ev_view_size_request_single_page           (EvView             *view,
-							      GtkRequisition     *requisition);
+                                                              GtkRequisition     *requisition);
 static void       ev_view_size_request                       (GtkWidget          *widget,
-							      GtkRequisition     *requisition);
+                                                              GtkRequisition     *requisition);
 static void       ev_view_size_allocate                      (GtkWidget          *widget,
-							      GtkAllocation      *allocation);
+                                                              GtkAllocation      *allocation);
 static gboolean   ev_view_scroll_event                       (GtkWidget          *widget,
-							      GdkEventScroll     *event);
+                                                              GdkEventScroll     *event);
 static gboolean   ev_view_draw                               (GtkWidget          *widget,
                                                               cairo_t            *cr);
 static gboolean   ev_view_popup_menu                         (GtkWidget 	 *widget);
 static gboolean   ev_view_button_press_event                 (GtkWidget          *widget,
-							      GdkEventButton     *event);
+                                                              GdkEventButton     *event);
 static gboolean   ev_view_motion_notify_event                (GtkWidget          *widget,
-							      GdkEventMotion     *event);
+                                                              GdkEventMotion     *event);
 static gboolean   ev_view_button_release_event               (GtkWidget          *widget,
-							      GdkEventButton     *event);
+                                                              GdkEventButton     *event);
 static gboolean   ev_view_enter_notify_event                 (GtkWidget          *widget,
-							      GdkEventCrossing   *event);
+                                                              GdkEventCrossing   *event);
 static gboolean   ev_view_leave_notify_event                 (GtkWidget          *widget,
-							      GdkEventCrossing   *event);
+                                                              GdkEventCrossing   *event);
 static void       ev_view_style_updated                      (GtkWidget          *widget);
 static void       ev_view_remove_all                         (EvView             *view);
 static void       ev_view_remove_all_form_fields             (EvView             *view);
@@ -207,32 +207,32 @@ static AtkObject *ev_view_get_accessible                     (GtkWidget *widget)
 /*** Drawing ***/
 static void       highlight_find_results                     (EvView             *view,
                                                               cairo_t            *cr,
-							      int                 page);
+                                                              int                 page);
 static void       highlight_forward_search_results           (EvView             *view,
                                                               cairo_t            *cr,
-							      int                 page);
+                                                              int                 page);
 static void       draw_one_page                              (EvView             *view,
-							      gint                page,
-							      cairo_t            *cr,
-							      GdkRectangle       *page_area,
-							      GtkBorder          *border,
-							      GdkRectangle       *expose_area,
-							      gboolean		 *page_ready);
+                                                              gint                page,
+                                                              cairo_t            *cr,
+                                                              GdkRectangle       *page_area,
+                                                              GtkBorder          *border,
+                                                              GdkRectangle       *expose_area,
+                                                              gboolean		 *page_ready);
 static void       ev_view_reload_page                        (EvView             *view,
-							      gint                page,
-							      cairo_region_t     *region);
+                                                              gint                page,
+                                                              cairo_region_t     *region);
 /*** Callbacks ***/
 static void       ev_view_change_page                        (EvView             *view,
-							      gint                new_page);
+                                                              gint                new_page);
 static void       job_finished_cb                            (EvPixbufCache      *pixbuf_cache,
-							      cairo_region_t     *region,
-							      EvView             *view);
+                                                              cairo_region_t     *region,
+                                                              EvView             *view);
 static void       ev_view_page_changed_cb                    (EvDocumentModel    *model,
-							      gint                old_page,
-							      gint                new_page,
-							      EvView             *view);
+                                                              gint                old_page,
+                                                              gint                new_page,
+                                                              EvView             *view);
 static void       on_adjustment_value_changed                (GtkAdjustment      *adjustment,
-							      EvView             *view);
+                                                              EvView             *view);
 /*** GObject ***/
 static void       ev_view_finalize                           (GObject            *object);
 static void       ev_view_dispose                            (GObject            *object);
@@ -241,756 +241,741 @@ static void       ev_view_init                               (EvView
 
 /*** Zoom and sizing ***/
 static double   zoom_for_size_fit_width	 		     (gdouble doc_width,
-							      gdouble doc_height,
-	    						      int     target_width,
-							      int     target_height);
+                                                  gdouble doc_height,
+                                                  int     target_width,
+                                                  int     target_height);
 static double   zoom_for_size_fit_height		     (gdouble doc_width,
-			  				      gdouble doc_height,
-							      int     target_width,
-							      int     target_height);
+                                                  gdouble doc_height,
+                                                  int     target_width,
+                                                  int     target_height);
 static double	zoom_for_size_fit_page 			     (gdouble doc_width,
-							      gdouble doc_height,
-							      int     target_width,
-							      int     target_height);
+                                                gdouble doc_height,
+                                                int     target_width,
+                                                int     target_height);
 static double   zoom_for_size_automatic                      (GtkWidget *widget,
-							      gdouble    doc_width,
-							      gdouble    doc_height,
-							      int        target_width,
-							      int        target_height);
+                                                              gdouble    doc_width,
+                                                              gdouble    doc_height,
+                                                              int        target_width,
+                                                              int        target_height);
 static gboolean ev_view_can_zoom                             (EvView *view,
                                                               gdouble factor);
 static void     ev_view_zoom                                 (EvView *view,
                                                               gdouble factor);
 static void     ev_view_zoom_for_size                        (EvView *view,
-							      int     width,
-							      int     height);
+                                                              int     width,
+                                                              int     height);
 static void	ev_view_zoom_for_size_continuous_and_dual_page (EvView *view,
-							        int     width,
-						     	        int     height);
+                                                            int     width,
+                                                            int     height);
 static void	ev_view_zoom_for_size_continuous	       (EvView *view,
-					    		        int     width,
-								int     height);
+                                                      int     width,
+                                                      int     height);
 static void 	ev_view_zoom_for_size_dual_page 	       (EvView *view,
-						    		int     width,
-								int     height);
+                                                        int     width,
+                                                        int     height);
 static void	ev_view_zoom_for_size_single_page 	       (EvView *view,
-				    			        int     width,
-					    			int     height);
+                                                        int     width,
+                                                        int     height);
 static gboolean	ev_view_page_fits			       (EvView         *view,
-								GtkOrientation  orientation);
+                                              GtkOrientation  orientation);
 /*** Cursors ***/
 static void       ev_view_set_cursor                         (EvView             *view,
-							      EvViewCursor        new_cursor);
+                                                              EvViewCursor        new_cursor);
 static void       ev_view_handle_cursor_over_xy              (EvView *view,
-							      gint x,
-							      gint y);
+                                                              gint x,
+                                                              gint y);
 
 /*** Find ***/
 static gint         ev_view_find_get_n_results               (EvView             *view,
-							      gint                page);
+                                                              gint                page);
 static EvRectangle *ev_view_find_get_result                  (EvView             *view,
-							      gint                page,
-							      gint                result);
+                                                              gint                page,
+                                                              gint                result);
 static void       jump_to_find_result                        (EvView             *view);
-static void       jump_to_find_page                          (EvView             *view, 
-							      EvViewFindDirection direction,
-							      gint                shift);
+static void       jump_to_find_page                          (EvView             *view,
+                                                              EvViewFindDirection direction,
+                                                              gint                shift);
 /*** Selection ***/
 static void       compute_selections                         (EvView             *view,
-							      EvSelectionStyle    style,
-							      GdkPoint           *start,
-							      GdkPoint           *stop);
+                                                              EvSelectionStyle    style,
+                                                              GdkPoint           *start,
+                                                              GdkPoint           *stop);
 static void       extend_selection                           (EvView             *view,
-							      GdkPoint           *start,
-							      GdkPoint           *stop);
+                                                              GdkPoint           *start,
+                                                              GdkPoint           *stop);
 static void       clear_selection                            (EvView             *view);
 static void       clear_link_selected                        (EvView             *view);
 static void       selection_free                             (EvViewSelection    *selection);
-static char*      get_selected_text                          (EvView             *ev_view);
+static char      *get_selected_text                          (EvView             *ev_view);
 static void       ev_view_primary_get_cb                     (GtkClipboard       *clipboard,
-							      GtkSelectionData   *selection_data,
-							      guint               info,
-							      gpointer            data);
+                                                              GtkSelectionData   *selection_data,
+                                                              guint               info,
+                                                              gpointer            data);
 static void       ev_view_primary_clear_cb                   (GtkClipboard       *clipboard,
-							      gpointer            data);
+                                                              gpointer            data);
 static void       ev_view_update_primary_selection           (EvView             *ev_view);
 
 /*** Caret navigation ***/
 static void       ev_view_check_cursor_blink                 (EvView             *ev_view);
 
 G_DEFINE_TYPE_WITH_CODE (EvView, ev_view, GTK_TYPE_CONTAINER,
-			 G_IMPLEMENT_INTERFACE (GTK_TYPE_SCROLLABLE, NULL))
+                         G_IMPLEMENT_INTERFACE (GTK_TYPE_SCROLLABLE, NULL))
 
 /* HeightToPage cache */
 #define EV_HEIGHT_TO_PAGE_CACHE_KEY "ev-height-to-page-cache"
 
 static void
 ev_view_build_height_to_page_cache (EvView		*view,
-                                    EvHeightToPageCache *cache)
-{
-	gboolean swap, uniform;
-	int i;
-	double uniform_height, page_height, next_page_height;
-	double saved_height;
-	gdouble u_width, u_height;
-	gint n_pages;
-	EvDocument *document = view->document;
-
-	swap = (view->rotation == 90 || view->rotation == 270);
-
-	uniform = ev_document_is_page_size_uniform (document);
-	n_pages = ev_document_get_n_pages (document);
-
-	g_free (cache->height_to_page);
-	g_free (cache->dual_height_to_page);
-
-	cache->rotation = view->rotation;
-	cache->dual_even_left = view->dual_even_left;
-	cache->height_to_page = g_new0 (gdouble, n_pages + 1);
-	cache->dual_height_to_page = g_new0 (gdouble, n_pages + 2);
-
-	if (uniform)
-		ev_document_get_page_size (document, 0, &u_width, &u_height);
-
-	saved_height = 0;
-	for (i = 0; i <= n_pages; i++) {
-		if (uniform) {
-			uniform_height = swap ? u_width : u_height;
-			cache->height_to_page[i] = i * uniform_height;
-		} else {
-			if (i < n_pages) {
-				gdouble w, h;
-
-				ev_document_get_page_size (document, i, &w, &h);
-				page_height = swap ? w : h;
-			} else {
-				page_height = 0;
-			}
-			cache->height_to_page[i] = saved_height;
-			saved_height += page_height;
-		}
-	}
-
-	if (cache->dual_even_left && !uniform) {
-		gdouble w, h;
-
-		ev_document_get_page_size (document, 0, &w, &h);
-		saved_height = swap ? w : h;
-	} else {
-		saved_height = 0;
-	}
-
-	for (i = cache->dual_even_left; i < n_pages + 2; i += 2) {
-    		if (uniform) {
-			uniform_height = swap ? u_width : u_height;
-			cache->dual_height_to_page[i] = ((i + cache->dual_even_left) / 2) * uniform_height;
-			if (i + 1 < n_pages + 2)
-				cache->dual_height_to_page[i + 1] = ((i + cache->dual_even_left) / 2) * uniform_height;
-		} else {
-			if (i + 1 < n_pages) {
-				gdouble w, h;
-
-				ev_document_get_page_size (document, i + 1, &w, &h);
-				next_page_height = swap ? w : h;
-			} else {
-				next_page_height = 0;
-			}
-
-			if (i < n_pages) {
-				gdouble w, h;
-
-				ev_document_get_page_size (document, i, &w, &h);
-				page_height = swap ? w : h;
-			} else {
-				page_height = 0;
-			}
-
-			if (i + 1 < n_pages + 2) {
-				cache->dual_height_to_page[i] = saved_height;
-				cache->dual_height_to_page[i + 1] = saved_height;
-				saved_height += MAX(page_height, next_page_height);
-			} else {
-				cache->dual_height_to_page[i] = saved_height;
-			}
-		}
-	}
-}
-
-static void
-ev_height_to_page_cache_free (EvHeightToPageCache *cache)
-{
-	if (cache->height_to_page) {
-		g_free (cache->height_to_page);
-		cache->height_to_page = NULL;
-	}
-
-	if (cache->dual_height_to_page) {
-		g_free (cache->dual_height_to_page);
-		cache->dual_height_to_page = NULL;
-	}
-	g_free (cache);
+                                    EvHeightToPageCache *cache) {
+  gboolean swap, uniform;
+  int i;
+  double uniform_height, page_height, next_page_height;
+  double saved_height;
+  gdouble u_width, u_height;
+  gint n_pages;
+  EvDocument *document = view->document;
+
+  swap = (view->rotation == 90 || view->rotation == 270);
+
+  uniform = ev_document_is_page_size_uniform (document);
+  n_pages = ev_document_get_n_pages (document);
+
+  g_free (cache->height_to_page);
+  g_free (cache->dual_height_to_page);
+
+  cache->rotation = view->rotation;
+  cache->dual_even_left = view->dual_even_left;
+  cache->height_to_page = g_new0 (gdouble, n_pages + 1);
+  cache->dual_height_to_page = g_new0 (gdouble, n_pages + 2);
+
+  if (uniform)
+    ev_document_get_page_size (document, 0, &u_width, &u_height);
+
+  saved_height = 0;
+  for (i = 0; i <= n_pages; i++) {
+    if (uniform) {
+      uniform_height = swap ? u_width : u_height;
+      cache->height_to_page[i] = i * uniform_height;
+    } else {
+      if (i < n_pages) {
+        gdouble w, h;
+
+        ev_document_get_page_size (document, i, &w, &h);
+        page_height = swap ? w : h;
+      } else {
+        page_height = 0;
+      }
+      cache->height_to_page[i] = saved_height;
+      saved_height += page_height;
+    }
+  }
+
+  if (cache->dual_even_left && !uniform) {
+    gdouble w, h;
+
+    ev_document_get_page_size (document, 0, &w, &h);
+    saved_height = swap ? w : h;
+  } else {
+    saved_height = 0;
+  }
+
+  for (i = cache->dual_even_left; i < n_pages + 2; i += 2) {
+    if (uniform) {
+      uniform_height = swap ? u_width : u_height;
+      cache->dual_height_to_page[i] = ((i + cache->dual_even_left) / 2) * uniform_height;
+      if (i + 1 < n_pages + 2)
+        cache->dual_height_to_page[i + 1] = ((i + cache->dual_even_left) / 2) * uniform_height;
+    } else {
+      if (i + 1 < n_pages) {
+        gdouble w, h;
+
+        ev_document_get_page_size (document, i + 1, &w, &h);
+        next_page_height = swap ? w : h;
+      } else {
+        next_page_height = 0;
+      }
+
+      if (i < n_pages) {
+        gdouble w, h;
+
+        ev_document_get_page_size (document, i, &w, &h);
+        page_height = swap ? w : h;
+      } else {
+        page_height = 0;
+      }
+
+      if (i + 1 < n_pages + 2) {
+        cache->dual_height_to_page[i] = saved_height;
+        cache->dual_height_to_page[i + 1] = saved_height;
+        saved_height += MAX(page_height, next_page_height);
+      } else {
+        cache->dual_height_to_page[i] = saved_height;
+      }
+    }
+  }
+}
+
+static void
+ev_height_to_page_cache_free (EvHeightToPageCache *cache) {
+  if (cache->height_to_page) {
+    g_free (cache->height_to_page);
+    cache->height_to_page = NULL;
+  }
+
+  if (cache->dual_height_to_page) {
+    g_free (cache->dual_height_to_page);
+    cache->dual_height_to_page = NULL;
+  }
+  g_free (cache);
 }
 
 static EvHeightToPageCache *
-ev_view_get_height_to_page_cache (EvView *view)
-{
-	EvHeightToPageCache *cache;
+ev_view_get_height_to_page_cache (EvView *view) {
+  EvHeightToPageCache *cache;
 
-	if (!view->document)
-		return NULL;
+  if (!view->document)
+    return NULL;
 
-	cache = g_object_get_data (G_OBJECT (view->document), EV_HEIGHT_TO_PAGE_CACHE_KEY);
-	if (!cache) {
-		cache = g_new0 (EvHeightToPageCache, 1);
-		ev_view_build_height_to_page_cache (view, cache);
-		g_object_set_data_full (G_OBJECT (view->document),
-					EV_HEIGHT_TO_PAGE_CACHE_KEY,
-					cache,
-					(GDestroyNotify)ev_height_to_page_cache_free);
-	}
+  cache = g_object_get_data (G_OBJECT (view->document), EV_HEIGHT_TO_PAGE_CACHE_KEY);
+  if (!cache) {
+    cache = g_new0 (EvHeightToPageCache, 1);
+    ev_view_build_height_to_page_cache (view, cache);
+    g_object_set_data_full (G_OBJECT (view->document),
+                            EV_HEIGHT_TO_PAGE_CACHE_KEY,
+                            cache,
+                            (GDestroyNotify)ev_height_to_page_cache_free);
+  }
 
-	return cache;
+  return cache;
 }
 
 static void
 ev_view_get_height_to_page (EvView *view,
-			    gint    page,
-			    gint   *height,
-			    gint   *dual_height)
-{
-	EvHeightToPageCache *cache = NULL;
-	gdouble h, dh;
-
-	if (!view->height_to_page_cache)
-		return;
-
-	cache = view->height_to_page_cache;
-	if (cache->rotation != view->rotation ||
-	    cache->dual_even_left != view->dual_even_left) {
-		ev_view_build_height_to_page_cache (view, cache);
-	}
-
-	if (height) {
-		h = cache->height_to_page[page];
-		*height = (gint)(h * view->scale + 0.5);
-    }
+                            gint    page,
+                            gint   *height,
+                            gint   *dual_height) {
+  EvHeightToPageCache *cache = NULL;
+  gdouble h, dh;
+
+  if (!view->height_to_page_cache)
+    return;
+
+  cache = view->height_to_page_cache;
+  if (cache->rotation != view->rotation ||
+      cache->dual_even_left != view->dual_even_left) {
+    ev_view_build_height_to_page_cache (view, cache);
+  }
+
+  if (height) {
+    h = cache->height_to_page[page];
+    *height = (gint)(h * view->scale + 0.5);
+  }
 
-	if (dual_height) {
-		dh = cache->dual_height_to_page[page];
-		*dual_height = (gint)(dh * view->scale + 0.5);
-	}
+  if (dual_height) {
+    dh = cache->dual_height_to_page[page];
+    *dual_height = (gint)(dh * view->scale + 0.5);
+  }
 }
 
 static gint
 ev_view_get_scrollbar_size (EvView        *view,
-			    GtkOrientation orientation)
-{
-	GtkWidget *widget = GTK_WIDGET (view);
-	GtkWidget *sb;
-	GtkWidget *swindow = gtk_widget_get_parent (GTK_WIDGET (view));
-	GtkAllocation allocation;
-	GtkRequisition req;
-	gint spacing;
-
-	if (!GTK_IS_SCROLLED_WINDOW (swindow))
-		return 0;
-
-	gtk_widget_get_allocation (widget, &allocation);
-
-	if (orientation == GTK_ORIENTATION_VERTICAL) {
-		if (allocation.height >= view->requisition.height)
-			sb = gtk_scrolled_window_get_vscrollbar (GTK_SCROLLED_WINDOW (swindow));
-		else
-			return 0;
-	} else {
-		if (allocation.width >= view->requisition.width)
-			sb = gtk_scrolled_window_get_hscrollbar (GTK_SCROLLED_WINDOW (swindow));
-		else
-			return 0;
-	}
-
-	gtk_widget_style_get (swindow, "scrollbar_spacing", &spacing, NULL);
-	gtk_widget_get_preferred_size (sb, &req, NULL);
-
-	return (orientation == GTK_ORIENTATION_VERTICAL ? req.width : req.height) + spacing;
+                            GtkOrientation orientation) {
+  GtkWidget *widget = GTK_WIDGET (view);
+  GtkWidget *sb;
+  GtkWidget *swindow = gtk_widget_get_parent (GTK_WIDGET (view));
+  GtkAllocation allocation;
+  GtkRequisition req;
+  gint spacing;
+
+  if (!GTK_IS_SCROLLED_WINDOW (swindow))
+    return 0;
+
+  gtk_widget_get_allocation (widget, &allocation);
+
+  if (orientation == GTK_ORIENTATION_VERTICAL) {
+    if (allocation.height >= view->requisition.height)
+      sb = gtk_scrolled_window_get_vscrollbar (GTK_SCROLLED_WINDOW (swindow));
+    else
+      return 0;
+  } else {
+    if (allocation.width >= view->requisition.width)
+      sb = gtk_scrolled_window_get_hscrollbar (GTK_SCROLLED_WINDOW (swindow));
+    else
+      return 0;
+  }
+
+  gtk_widget_style_get (swindow, "scrollbar_spacing", &spacing, NULL);
+  gtk_widget_get_preferred_size (sb, &req, NULL);
+
+  return (orientation == GTK_ORIENTATION_VERTICAL ? req.width : req.height) + spacing;
 }
 
 static gboolean
 is_dual_page (EvView   *view,
-	      gboolean *odd_left_out)
-{
-	gboolean dual = FALSE;
-	gboolean odd_left = FALSE;
-
-	switch (view->page_layout) {
-	case EV_PAGE_LAYOUT_AUTOMATIC: {
-		double        scale;
-		double        doc_width;
-		double        doc_height;
-		GtkAllocation allocation;
-
-		scale = ev_document_misc_get_widget_dpi (GTK_WIDGET (view)) / 72.0;
-
-		ev_document_get_max_page_size (view->document, &doc_width, &doc_height);
-		gtk_widget_get_allocation (GTK_WIDGET (view), &allocation);
-
-		/* If the width is ok and the height is pretty close, try to fit it in */
-		if (ev_document_get_n_pages (view->document) > 1 &&
-		    doc_width < doc_height &&
-		    allocation.width > (2 * doc_width * scale) &&
-		    allocation.height > (doc_height * scale * 0.9)) {
-			odd_left = !view->dual_even_left;
-			dual = TRUE;
-		}
-	}
-		break;
-	case EV_PAGE_LAYOUT_DUAL:
-		odd_left = !view->dual_even_left;
-		dual = TRUE;
-		break;
-	case EV_PAGE_LAYOUT_SINGLE:
-		break;
-	default:
-		g_assert_not_reached ();
-	}
-
-	if (odd_left_out)
-		*odd_left_out = odd_left;
-
-	return dual;
+              gboolean *odd_left_out) {
+  gboolean dual = FALSE;
+  gboolean odd_left = FALSE;
+
+  switch (view->page_layout) {
+    case EV_PAGE_LAYOUT_AUTOMATIC: {
+      double        scale;
+      double        doc_width;
+      double        doc_height;
+      GtkAllocation allocation;
+
+      scale = ev_document_misc_get_widget_dpi (GTK_WIDGET (view)) / 72.0;
+
+      ev_document_get_max_page_size (view->document, &doc_width, &doc_height);
+      gtk_widget_get_allocation (GTK_WIDGET (view), &allocation);
+
+      /* If the width is ok and the height is pretty close, try to fit it in */
+      if (ev_document_get_n_pages (view->document) > 1 &&
+          doc_width < doc_height &&
+          allocation.width > (2 * doc_width * scale) &&
+          allocation.height > (doc_height * scale * 0.9)) {
+        odd_left = !view->dual_even_left;
+        dual = TRUE;
+      }
+    }
+    break;
+    case EV_PAGE_LAYOUT_DUAL:
+      odd_left = !view->dual_even_left;
+      dual = TRUE;
+      break;
+    case EV_PAGE_LAYOUT_SINGLE:
+      break;
+    default:
+      g_assert_not_reached ();
+  }
+
+  if (odd_left_out)
+    *odd_left_out = odd_left;
+
+  return dual;
 }
 
 static void
 scroll_to_point (EvView        *view,
-		 gdouble        x,
-		 gdouble        y,
-		 GtkOrientation orientation)
-{
-	gdouble page_size;
-	gdouble upper, lower;
-
-	if (orientation == GTK_ORIENTATION_VERTICAL) {
-		page_size = gtk_adjustment_get_page_size (view->vadjustment);
-		upper = gtk_adjustment_get_upper (view->vadjustment);
-		lower = gtk_adjustment_get_lower (view->vadjustment);
-
-		if (view->continuous) {
-    			gtk_adjustment_clamp_page (view->vadjustment,
-						   y, y + page_size);
-		} else {
-			gtk_adjustment_set_value (view->vadjustment,
-						  CLAMP (y, lower, upper - page_size));
-		}
-	} else {
-		page_size = gtk_adjustment_get_page_size (view->hadjustment);
-		upper = gtk_adjustment_get_upper (view->hadjustment);
-		lower = gtk_adjustment_get_lower (view->hadjustment);
-
-		if (is_dual_page (view, NULL)) {
-			gtk_adjustment_clamp_page (view->hadjustment, x,
-						   x + page_size);
-		} else {
-			gtk_adjustment_set_value (view->hadjustment,
-						  CLAMP (x, lower, upper - page_size));
-		}
-	}
-}
-
-static void
-ev_view_scroll_to_page_position (EvView *view, GtkOrientation orientation)
-{
-	gdouble x, y;
-
-	if (!view->document)
-		return;
-
-	if ((orientation == GTK_ORIENTATION_VERTICAL && view->pending_point.y == 0) ||
-	    (orientation == GTK_ORIENTATION_HORIZONTAL && view->pending_point.x == 0)) {
-		GdkRectangle page_area;
-		GtkBorder    border;
-
-		ev_view_get_page_extents (view, view->current_page, &page_area, &border);
-		x = page_area.x;
-		y = page_area.y;
-	} else {
-		GdkPoint view_point;
-
-		_ev_view_transform_doc_point_to_view_point (view, view->current_page,
-							    &view->pending_point, &view_point);
-		x = view_point.x;
-		y = view_point.y;
-	}
-
-	scroll_to_point (view, x, y, orientation);
+                 gdouble        x,
+                 gdouble        y,
+                 GtkOrientation orientation) {
+  gdouble page_size;
+  gdouble upper, lower;
+
+  if (orientation == GTK_ORIENTATION_VERTICAL) {
+    page_size = gtk_adjustment_get_page_size (view->vadjustment);
+    upper = gtk_adjustment_get_upper (view->vadjustment);
+    lower = gtk_adjustment_get_lower (view->vadjustment);
+
+    if (view->continuous) {
+      gtk_adjustment_clamp_page (view->vadjustment,
+                                 y, y + page_size);
+    } else {
+      gtk_adjustment_set_value (view->vadjustment,
+                                CLAMP (y, lower, upper - page_size));
+    }
+  } else {
+    page_size = gtk_adjustment_get_page_size (view->hadjustment);
+    upper = gtk_adjustment_get_upper (view->hadjustment);
+    lower = gtk_adjustment_get_lower (view->hadjustment);
+
+    if (is_dual_page (view, NULL)) {
+      gtk_adjustment_clamp_page (view->hadjustment, x,
+                                 x + page_size);
+    } else {
+      gtk_adjustment_set_value (view->hadjustment,
+                                CLAMP (x, lower, upper - page_size));
+    }
+  }
+}
+
+static void
+ev_view_scroll_to_page_position (EvView *view, GtkOrientation orientation) {
+  gdouble x, y;
+
+  if (!view->document)
+    return;
+
+  if ((orientation == GTK_ORIENTATION_VERTICAL && view->pending_point.y == 0) ||
+      (orientation == GTK_ORIENTATION_HORIZONTAL && view->pending_point.x == 0)) {
+    GdkRectangle page_area;
+    GtkBorder    border;
+
+    ev_view_get_page_extents (view, view->current_page, &page_area, &border);
+    x = page_area.x;
+    y = page_area.y;
+  } else {
+    GdkPoint view_point;
+
+    _ev_view_transform_doc_point_to_view_point (view, view->current_page,
+                                                &view->pending_point, &view_point);
+    x = view_point.x;
+    y = view_point.y;
+  }
+
+  scroll_to_point (view, x, y, orientation);
 }
 
 static void
 ev_view_set_adjustment_values (EvView         *view,
-			       GtkOrientation  orientation)
-{
-	GtkWidget *widget = GTK_WIDGET (view);
-	GtkAdjustment *adjustment;
-	GtkAllocation allocation;
-	int req_size;
-	int alloc_size;
-	gdouble page_size;
-	gdouble value;
-	gdouble upper;
-	double factor;
-	gint new_value;
-	gdouble zoom_center;
-
-	gtk_widget_get_allocation (widget, &allocation);
-
-	if (orientation == GTK_ORIENTATION_HORIZONTAL)  {
-		req_size = view->requisition.width;
-		alloc_size = allocation.width;
-		adjustment = view->hadjustment;
-		zoom_center = view->zoom_center_x;
-	} else {
-		req_size = view->requisition.height;
-		alloc_size = allocation.height;
-		adjustment = view->vadjustment;
-		zoom_center = view->zoom_center_y;
-	}
-
-	if (!adjustment)
-		return;
-
-	factor = 1.0;
-	value = gtk_adjustment_get_value (adjustment);
-	upper = gtk_adjustment_get_upper (adjustment);
-	page_size = gtk_adjustment_get_page_size (adjustment);
-	if (zoom_center < 0)
-		zoom_center = page_size * 0.5;
-
-	if (upper != .0) {
-		switch (view->pending_scroll) {
-    	        case SCROLL_TO_KEEP_POSITION:
-    	        case SCROLL_TO_FIND_LOCATION:
-			factor = value / upper;
-			break;
-    	        case SCROLL_TO_PAGE_POSITION:
-			break;
-		case SCROLL_TO_CENTER:
-			factor = (value + zoom_center) / upper;
-			break;
-		}
-	}
-
-	upper = MAX (alloc_size, req_size);
-	page_size = alloc_size;
-
-	gtk_adjustment_set_page_size (adjustment, page_size);
-	gtk_adjustment_set_step_increment (adjustment, alloc_size * 0.1);
-	gtk_adjustment_set_page_increment (adjustment, alloc_size * 0.9);
-	gtk_adjustment_set_lower (adjustment, 0);
-	gtk_adjustment_set_upper (adjustment, upper);
-
-	/*
-	 * We add 0.5 to the values before to average out our rounding errors.
-	 */
-	switch (view->pending_scroll) {
-    	        case SCROLL_TO_KEEP_POSITION:
-    	        case SCROLL_TO_FIND_LOCATION:
-			new_value = CLAMP (upper * factor + 0.5, 0, upper - page_size);
-			gtk_adjustment_set_value (adjustment, (int)new_value);
-			break;
-    	        case SCROLL_TO_PAGE_POSITION:
-			ev_view_scroll_to_page_position (view, orientation);
-			break;
-	        case SCROLL_TO_CENTER:
-			new_value = CLAMP (upper * factor - zoom_center + 0.5, 0, upper - page_size);
-			if (orientation == GTK_ORIENTATION_HORIZONTAL)
-				view->zoom_center_x = -1.0;
-			else
-				view->zoom_center_y = -1.0;
-			gtk_adjustment_set_value (adjustment, (int)new_value);
-			break;
-	}
-
-	gtk_adjustment_changed (adjustment);
-}
-
-static void
-view_update_range_and_current_page (EvView *view)
-{
-	gint start = view->start_page;
-	gint end = view->end_page;
-	gboolean odd_left;
-
-	if (ev_document_get_n_pages (view->document) <= 0 ||
-	    !ev_document_check_dimensions (view->document))
-		return;
-
-	if (view->continuous) {
-		GdkRectangle current_area, unused, page_area;
-		GtkBorder border;
-		gboolean found = FALSE;
-		gint area_max = -1, area;
-		gint best_current_page = -1;
-		gint n_pages;
-		int i, j = 0;
-
-		if (!(view->vadjustment && view->hadjustment))
-			return;
-
-		current_area.x = gtk_adjustment_get_value (view->hadjustment);
-		current_area.width = gtk_adjustment_get_page_size (view->hadjustment);
-		current_area.y = gtk_adjustment_get_value (view->vadjustment);
-		current_area.height = gtk_adjustment_get_page_size (view->vadjustment);
-
-		n_pages = ev_document_get_n_pages (view->document);
-		compute_border (view, &border);
-		for (i = 0; i < n_pages; i++) {
-
-			ev_view_get_page_extents_for_border (view, i, &border, &page_area);
-
-			if (gdk_rectangle_intersect (&current_area, &page_area, &unused)) {
-				area = unused.width * unused.height;
-
-				if (!found) {
-					area_max = area;
-					view->start_page = i;
-					found = TRUE;
-					best_current_page = i;
-				}
-				if (area > area_max) {
-					best_current_page = (area == area_max) ? MIN (i, best_current_page) : i;
-					area_max = area;
-				}
-
-				view->end_page = i;
-				j = 0;
-			} else if (found && view->current_page <= view->end_page) {
-				if (is_dual_page (view, NULL) && j < 1) {
-					/* In dual mode  we stop searching
-					 * after two consecutive non-visible pages.
-					 */
-					j++;
-					continue;
-				}
-				break;
-			}
-		}
-
-		if (view->pending_scroll == SCROLL_TO_KEEP_POSITION ||
-		    view->pending_scroll == SCROLL_TO_FIND_LOCATION) {
-			best_current_page = MAX (best_current_page, view->start_page);
-
-			if (best_current_page >= 0 && view->current_page != best_current_page) {
-				view->current_page = best_current_page;
-				ev_view_set_loading (view, FALSE);
-				ev_document_model_set_page (view->model, best_current_page);
-			}
-		}
-	} else if (is_dual_page (view, &odd_left)) {
-		if (view->current_page % 2 == !odd_left) {
-			view->start_page = view->current_page;
-			if (view->current_page + 1 < ev_document_get_n_pages (view->document))
-				view->end_page = view->start_page + 1;
-			else
-				view->end_page = view->start_page;
-		} else {
-			if (view->current_page < 1)
-				view->start_page = view->current_page;
-			else
-				view->start_page = view->current_page - 1;
-			view->end_page = view->current_page;
-		}
-	} else {
-		view->start_page = view->current_page;
-		view->end_page = view->current_page;
-	}
-
-	if (view->start_page == -1 || view->end_page == -1)
-		return;
-
-	if (start != view->start_page || end != view->end_page) {
-		gint i;
-
-		for (i = start; i < view->start_page && start != -1; i++) {
-			hide_annotation_windows (view, i);
-		}
-
-		for (i = end; i > view->end_page && end != -1; i--) {
-			hide_annotation_windows (view, i);
-		}
-
-		ev_view_check_cursor_blink (view);
-	}
-
-	ev_page_cache_set_page_range (view->page_cache,
-				      view->start_page,
-				      view->end_page);
-	ev_pixbuf_cache_set_page_range (view->pixbuf_cache,
-					view->start_page,
-					view->end_page,
-					view->selection_info.selections);
-	if (view->accessible)
-		ev_view_accessible_set_page_range (EV_VIEW_ACCESSIBLE (view->accessible),
-						   view->start_page,
-						   view->end_page);
-
-	if (ev_pixbuf_cache_get_surface (view->pixbuf_cache, view->current_page))
-	    gtk_widget_queue_draw (GTK_WIDGET (view));
+                               GtkOrientation  orientation) {
+  GtkWidget *widget = GTK_WIDGET (view);
+  GtkAdjustment *adjustment;
+  GtkAllocation allocation;
+  int req_size;
+  int alloc_size;
+  gdouble page_size;
+  gdouble value;
+  gdouble upper;
+  double factor;
+  gint new_value;
+  gdouble zoom_center;
+
+  gtk_widget_get_allocation (widget, &allocation);
+
+  if (orientation == GTK_ORIENTATION_HORIZONTAL)  {
+    req_size = view->requisition.width;
+    alloc_size = allocation.width;
+    adjustment = view->hadjustment;
+    zoom_center = view->zoom_center_x;
+  } else {
+    req_size = view->requisition.height;
+    alloc_size = allocation.height;
+    adjustment = view->vadjustment;
+    zoom_center = view->zoom_center_y;
+  }
+
+  if (!adjustment)
+    return;
+
+  factor = 1.0;
+  value = gtk_adjustment_get_value (adjustment);
+  upper = gtk_adjustment_get_upper (adjustment);
+  page_size = gtk_adjustment_get_page_size (adjustment);
+  if (zoom_center < 0)
+    zoom_center = page_size * 0.5;
+
+  if (upper != .0) {
+    switch (view->pending_scroll) {
+      case SCROLL_TO_KEEP_POSITION:
+      case SCROLL_TO_FIND_LOCATION:
+        factor = value / upper;
+        break;
+      case SCROLL_TO_PAGE_POSITION:
+        break;
+      case SCROLL_TO_CENTER:
+        factor = (value + zoom_center) / upper;
+        break;
+    }
+  }
+
+  upper = MAX (alloc_size, req_size);
+  page_size = alloc_size;
+
+  gtk_adjustment_set_page_size (adjustment, page_size);
+  gtk_adjustment_set_step_increment (adjustment, alloc_size * 0.1);
+  gtk_adjustment_set_page_increment (adjustment, alloc_size * 0.9);
+  gtk_adjustment_set_lower (adjustment, 0);
+  gtk_adjustment_set_upper (adjustment, upper);
+
+  /*
+   * We add 0.5 to the values before to average out our rounding errors.
+   */
+  switch (view->pending_scroll) {
+    case SCROLL_TO_KEEP_POSITION:
+    case SCROLL_TO_FIND_LOCATION:
+      new_value = CLAMP (upper * factor + 0.5, 0, upper - page_size);
+      gtk_adjustment_set_value (adjustment, (int)new_value);
+      break;
+    case SCROLL_TO_PAGE_POSITION:
+      ev_view_scroll_to_page_position (view, orientation);
+      break;
+    case SCROLL_TO_CENTER:
+      new_value = CLAMP (upper * factor - zoom_center + 0.5, 0, upper - page_size);
+      if (orientation == GTK_ORIENTATION_HORIZONTAL)
+        view->zoom_center_x = -1.0;
+      else
+        view->zoom_center_y = -1.0;
+      gtk_adjustment_set_value (adjustment, (int)new_value);
+      break;
+  }
+
+  gtk_adjustment_changed (adjustment);
+}
+
+static void
+view_update_range_and_current_page (EvView *view) {
+  gint start = view->start_page;
+  gint end = view->end_page;
+  gboolean odd_left;
+
+  if (ev_document_get_n_pages (view->document) <= 0 ||
+      !ev_document_check_dimensions (view->document))
+    return;
+
+  if (view->continuous) {
+    GdkRectangle current_area, unused, page_area;
+    GtkBorder border;
+    gboolean found = FALSE;
+    gint area_max = -1, area;
+    gint best_current_page = -1;
+    gint n_pages;
+    int i, j = 0;
+
+    if (!(view->vadjustment && view->hadjustment))
+      return;
+
+    current_area.x = gtk_adjustment_get_value (view->hadjustment);
+    current_area.width = gtk_adjustment_get_page_size (view->hadjustment);
+    current_area.y = gtk_adjustment_get_value (view->vadjustment);
+    current_area.height = gtk_adjustment_get_page_size (view->vadjustment);
+
+    n_pages = ev_document_get_n_pages (view->document);
+    compute_border (view, &border);
+    for (i = 0; i < n_pages; i++) {
+
+      ev_view_get_page_extents_for_border (view, i, &border, &page_area);
+
+      if (gdk_rectangle_intersect (&current_area, &page_area, &unused)) {
+        area = unused.width * unused.height;
+
+        if (!found) {
+          area_max = area;
+          view->start_page = i;
+          found = TRUE;
+          best_current_page = i;
+        }
+        if (area > area_max) {
+          best_current_page = (area == area_max) ? MIN (i, best_current_page) : i;
+          area_max = area;
+        }
+
+        view->end_page = i;
+        j = 0;
+      } else if (found && view->current_page <= view->end_page) {
+        if (is_dual_page (view, NULL) && j < 1) {
+          /* In dual mode  we stop searching
+           * after two consecutive non-visible pages.
+           */
+          j++;
+          continue;
+        }
+        break;
+      }
+    }
+
+    if (view->pending_scroll == SCROLL_TO_KEEP_POSITION ||
+        view->pending_scroll == SCROLL_TO_FIND_LOCATION) {
+      best_current_page = MAX (best_current_page, view->start_page);
+
+      if (best_current_page >= 0 && view->current_page != best_current_page) {
+        view->current_page = best_current_page;
+        ev_view_set_loading (view, FALSE);
+        ev_document_model_set_page (view->model, best_current_page);
+      }
+    }
+  } else if (is_dual_page (view, &odd_left)) {
+    if (view->current_page % 2 == !odd_left) {
+      view->start_page = view->current_page;
+      if (view->current_page + 1 < ev_document_get_n_pages (view->document))
+        view->end_page = view->start_page + 1;
+      else
+        view->end_page = view->start_page;
+    } else {
+      if (view->current_page < 1)
+        view->start_page = view->current_page;
+      else
+        view->start_page = view->current_page - 1;
+      view->end_page = view->current_page;
+    }
+  } else {
+    view->start_page = view->current_page;
+    view->end_page = view->current_page;
+  }
+
+  if (view->start_page == -1 || view->end_page == -1)
+    return;
+
+  if (start != view->start_page || end != view->end_page) {
+    gint i;
+
+    for (i = start; i < view->start_page && start != -1; i++) {
+      hide_annotation_windows (view, i);
+    }
+
+    for (i = end; i > view->end_page && end != -1; i--) {
+      hide_annotation_windows (view, i);
+    }
+
+    ev_view_check_cursor_blink (view);
+  }
+
+  ev_page_cache_set_page_range (view->page_cache,
+                                view->start_page,
+                                view->end_page);
+  ev_pixbuf_cache_set_page_range (view->pixbuf_cache,
+                                  view->start_page,
+                                  view->end_page,
+                                  view->selection_info.selections);
+  if (view->accessible)
+    ev_view_accessible_set_page_range (EV_VIEW_ACCESSIBLE (view->accessible),
+                                       view->start_page,
+                                       view->end_page);
+
+  if (ev_pixbuf_cache_get_surface (view->pixbuf_cache, view->current_page))
+    gtk_widget_queue_draw (GTK_WIDGET (view));
 }
 
 static void
 ev_view_set_scroll_adjustment (EvView         *view,
-			       GtkOrientation  orientation,
-			       GtkAdjustment  *adjustment)
-{
-	GtkAdjustment **to_set;
-	const gchar    *prop_name;
-
-	if (orientation == GTK_ORIENTATION_HORIZONTAL) {
-		to_set = &view->hadjustment;
-		prop_name = "hadjustment";
-	} else {
-		to_set = &view->vadjustment;
-		prop_name = "vadjustment";
-	}
-
-	if (adjustment && adjustment == *to_set)
-		return;
-
-	if (*to_set) {
-		g_signal_handlers_disconnect_by_func (*to_set,
-						      (gpointer) on_adjustment_value_changed,
-						      view);
-		g_object_unref (*to_set);
-	}
-
-	if (!adjustment)
-		adjustment = gtk_adjustment_new (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
-	g_signal_connect (adjustment, "value_changed",
-			  G_CALLBACK (on_adjustment_value_changed),
-			  view);
-	*to_set = g_object_ref_sink (adjustment);
-	ev_view_set_adjustment_values (view, orientation);
-
-	g_object_notify (G_OBJECT (view), prop_name);
+                               GtkOrientation  orientation,
+                               GtkAdjustment  *adjustment) {
+  GtkAdjustment **to_set;
+  const gchar    *prop_name;
+
+  if (orientation == GTK_ORIENTATION_HORIZONTAL) {
+    to_set = &view->hadjustment;
+    prop_name = "hadjustment";
+  } else {
+    to_set = &view->vadjustment;
+    prop_name = "vadjustment";
+  }
+
+  if (adjustment && adjustment == *to_set)
+    return;
+
+  if (*to_set) {
+    g_signal_handlers_disconnect_by_func (*to_set,
+                                          (gpointer) on_adjustment_value_changed,
+                                          view);
+    g_object_unref (*to_set);
+  }
+
+  if (!adjustment)
+    adjustment = gtk_adjustment_new (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
+  g_signal_connect (adjustment, "value_changed",
+                    G_CALLBACK (on_adjustment_value_changed),
+                    view);
+  *to_set = g_object_ref_sink (adjustment);
+  ev_view_set_adjustment_values (view, orientation);
+
+  g_object_notify (G_OBJECT (view), prop_name);
 }
 
 static void
 add_scroll_binding_keypad (GtkBindingSet  *binding_set,
-    			   guint           keyval,
-    			   GdkModifierType modifiers,
-    			   GtkScrollType   scroll,
-			   GtkOrientation  orientation)
-{
-	guint keypad_keyval = keyval - GDK_KEY_Left + GDK_KEY_KP_Left;
-
-	gtk_binding_entry_add_signal (binding_set, keyval, modifiers,
-				      "scroll", 2,
-				      GTK_TYPE_SCROLL_TYPE, scroll,
-				      GTK_TYPE_ORIENTATION, orientation);
-	gtk_binding_entry_add_signal (binding_set, keypad_keyval, modifiers,
-				      "scroll", 2,
-				      GTK_TYPE_SCROLL_TYPE, scroll,
-				      GTK_TYPE_ORIENTATION, orientation);
+                           guint           keyval,
+                           GdkModifierType modifiers,
+                           GtkScrollType   scroll,
+                           GtkOrientation  orientation) {
+  guint keypad_keyval = keyval - GDK_KEY_Left + GDK_KEY_KP_Left;
+
+  gtk_binding_entry_add_signal (binding_set, keyval, modifiers,
+                                "scroll", 2,
+                                GTK_TYPE_SCROLL_TYPE, scroll,
+                                GTK_TYPE_ORIENTATION, orientation);
+  gtk_binding_entry_add_signal (binding_set, keypad_keyval, modifiers,
+                                "scroll", 2,
+                                GTK_TYPE_SCROLL_TYPE, scroll,
+                                GTK_TYPE_ORIENTATION, orientation);
 }
 
 static gdouble
 compute_scroll_increment (EvView        *view,
-			  GtkScrollType  scroll)
-{
-	GtkWidget *widget = GTK_WIDGET (view);
-	GtkAdjustment *adjustment = view->vadjustment;
-	cairo_region_t *text_region, *region;
-	GtkAllocation allocation;
-	gint page;
-	GdkRectangle rect;
-	EvRectangle doc_rect;
-	GdkRectangle page_area;
-	GtkBorder border;
-	gdouble fraction = 1.0;
-
-	if (scroll != GTK_SCROLL_PAGE_BACKWARD && scroll != GTK_SCROLL_PAGE_FORWARD)
-		return gtk_adjustment_get_page_size (adjustment);
-
-	page = scroll == GTK_SCROLL_PAGE_BACKWARD ? view->start_page : view->end_page;
-
-	text_region = ev_page_cache_get_text_mapping (view->page_cache, page);
-	if (!text_region || cairo_region_is_empty (text_region))
-		return gtk_adjustment_get_page_size (adjustment);
-
-	gtk_widget_get_allocation (widget, &allocation);
-	ev_view_get_page_extents (view, page, &page_area, &border);
-	rect.x = page_area.x + view->scroll_x;
-	rect.y = view->scroll_y + (scroll == GTK_SCROLL_PAGE_BACKWARD ? 5 : allocation.height - 5);
-	rect.width = page_area.width;
-	rect.height = 1;
-	_ev_view_transform_view_rect_to_doc_rect (view, &rect, &page_area, &border, &doc_rect);
-
-	/* Convert the doc rectangle into a GdkRectangle */
-	rect.x = doc_rect.x1;
-	rect.y = doc_rect.y1;
-	rect.width = doc_rect.x2 - doc_rect.x1;
-	rect.height = MAX (1, doc_rect.y2 - doc_rect.y1);
-	region = cairo_region_create_rectangle (&rect);
-
-	cairo_region_intersect (region, text_region);
-	if (cairo_region_num_rectangles (region)) {
-		EvRenderContext *rc;
-		EvPage  *ev_page;
-		cairo_region_t *sel_region;
-
-		cairo_region_get_rectangle (region, 0, &rect);
-		ev_page = ev_document_get_page (view->document, page);
-		rc = ev_render_context_new (ev_page, view->rotation, 0.);
-		ev_render_context_set_target_size (rc,
-						   page_area.width - (border.left + border.right),
-						   page_area.height - (border.left + border.right));
-		g_object_unref (ev_page);
-		/* Get the selection region to know the height of the line */
-		doc_rect.x1 = doc_rect.x2 = rect.x + 0.5;
-		doc_rect.y1 = doc_rect.y2 = rect.y + 0.5;
-
-		ev_document_doc_mutex_lock ();
-		sel_region = ev_selection_get_selection_region (EV_SELECTION (view->document),
-								rc, EV_SELECTION_STYLE_LINE,
-								&doc_rect);
-		ev_document_doc_mutex_unlock ();
-
-		g_object_unref (rc);
-
-		if (cairo_region_num_rectangles (sel_region) > 0) {
-			cairo_region_get_rectangle (sel_region, 0, &rect);
-			fraction = 1 - (rect.height / gtk_adjustment_get_page_size (adjustment));
-			/* jump the full page height if the line is too large a
-			 * fraction of the page */
-			if (fraction < SCROLL_PAGE_THRESHOLD)
-				fraction = 1.0;
-		}
-		cairo_region_destroy (sel_region);
-	}
-	cairo_region_destroy (region);
-
-	return gtk_adjustment_get_page_size (adjustment) * fraction;
-
-}
-
-static void
-ev_view_first_page (EvView *view)
-{
-	ev_document_model_set_page (view->model, 0);
-}
-
-static void
-ev_view_last_page (EvView *view)
-{
-	gint n_pages;
-
-	if (!view->document)
-		return;
-
-	n_pages = ev_document_get_n_pages (view->document);
-	if (n_pages <= 1)
-		return;
-
-	ev_document_model_set_page (view->model, n_pages - 1);
+                          GtkScrollType  scroll) {
+  GtkWidget *widget = GTK_WIDGET (view);
+  GtkAdjustment *adjustment = view->vadjustment;
+  cairo_region_t *text_region, *region;
+  GtkAllocation allocation;
+  gint page;
+  GdkRectangle rect;
+  EvRectangle doc_rect;
+  GdkRectangle page_area;
+  GtkBorder border;
+  gdouble fraction = 1.0;
+
+  if (scroll != GTK_SCROLL_PAGE_BACKWARD && scroll != GTK_SCROLL_PAGE_FORWARD)
+    return gtk_adjustment_get_page_size (adjustment);
+
+  page = scroll == GTK_SCROLL_PAGE_BACKWARD ? view->start_page : view->end_page;
+
+  text_region = ev_page_cache_get_text_mapping (view->page_cache, page);
+  if (!text_region || cairo_region_is_empty (text_region))
+    return gtk_adjustment_get_page_size (adjustment);
+
+  gtk_widget_get_allocation (widget, &allocation);
+  ev_view_get_page_extents (view, page, &page_area, &border);
+  rect.x = page_area.x + view->scroll_x;
+  rect.y = view->scroll_y + (scroll == GTK_SCROLL_PAGE_BACKWARD ? 5 : allocation.height - 5);
+  rect.width = page_area.width;
+  rect.height = 1;
+  _ev_view_transform_view_rect_to_doc_rect (view, &rect, &page_area, &border, &doc_rect);
+
+  /* Convert the doc rectangle into a GdkRectangle */
+  rect.x = doc_rect.x1;
+  rect.y = doc_rect.y1;
+  rect.width = doc_rect.x2 - doc_rect.x1;
+  rect.height = MAX (1, doc_rect.y2 - doc_rect.y1);
+  region = cairo_region_create_rectangle (&rect);
+
+  cairo_region_intersect (region, text_region);
+  if (cairo_region_num_rectangles (region)) {
+    EvRenderContext *rc;
+    EvPage  *ev_page;
+    cairo_region_t *sel_region;
+
+    cairo_region_get_rectangle (region, 0, &rect);
+    ev_page = ev_document_get_page (view->document, page);
+    rc = ev_render_context_new (ev_page, view->rotation, 0.);
+    ev_render_context_set_target_size (rc,
+                                       page_area.width - (border.left + border.right),
+                                       page_area.height - (border.left + border.right));
+    g_object_unref (ev_page);
+    /* Get the selection region to know the height of the line */
+    doc_rect.x1 = doc_rect.x2 = rect.x + 0.5;
+    doc_rect.y1 = doc_rect.y2 = rect.y + 0.5;
+
+    ev_document_doc_mutex_lock ();
+    sel_region = ev_selection_get_selection_region (EV_SELECTION (view->document),
+                                                    rc, EV_SELECTION_STYLE_LINE,
+                                                    &doc_rect);
+    ev_document_doc_mutex_unlock ();
+
+    g_object_unref (rc);
+
+    if (cairo_region_num_rectangles (sel_region) > 0) {
+      cairo_region_get_rectangle (sel_region, 0, &rect);
+      fraction = 1 - (rect.height / gtk_adjustment_get_page_size (adjustment));
+      /* jump the full page height if the line is too large a
+       * fraction of the page */
+      if (fraction < SCROLL_PAGE_THRESHOLD)
+        fraction = 1.0;
+    }
+    cairo_region_destroy (sel_region);
+  }
+  cairo_region_destroy (region);
+
+  return gtk_adjustment_get_page_size (adjustment) * fraction;
+
+}
+
+static void
+ev_view_first_page (EvView *view) {
+  ev_document_model_set_page (view->model, 0);
+}
+
+static void
+ev_view_last_page (EvView *view) {
+  gint n_pages;
+
+  if (!view->document)
+    return;
+
+  n_pages = ev_document_get_n_pages (view->document);
+  if (n_pages <= 1)
+    return;
+
+  ev_document_model_set_page (view->model, n_pages - 1);
 }
 
 /**
@@ -1003,2677 +988,2587 @@ ev_view_last_page (EvView *view)
  */
 void
 ev_view_scroll (EvView        *view,
-	        GtkScrollType  scroll,
-		gboolean       horizontal)
-{
-	GtkAdjustment *adjustment;
-	double value, increment;
-	gdouble upper, lower;
-	gdouble page_size;
-	gdouble step_increment;
-	gboolean first_page = FALSE;
-	gboolean last_page = FALSE;
-
-	if (view->key_binding_handled)
-		return;
-
-	view->jump_to_find_result = FALSE;
-
-	if ((!horizontal && ev_view_page_fits (view, GTK_ORIENTATION_VERTICAL)) ||
-	    (horizontal && ev_view_page_fits (view, GTK_ORIENTATION_HORIZONTAL))) {
-		switch (scroll) {
-			case GTK_SCROLL_PAGE_BACKWARD:
-			case GTK_SCROLL_STEP_BACKWARD:
-				ev_view_previous_page (view);
-				break;
-			case GTK_SCROLL_PAGE_FORWARD:
-			case GTK_SCROLL_STEP_FORWARD:
-				ev_view_next_page (view);
-				break;
-		        case GTK_SCROLL_START:
-				ev_view_first_page (view);
-				break;
-		        case GTK_SCROLL_END:
-				ev_view_last_page (view);
-				break;
-			default:
-				break;
-		}
-		return;
-	}
-
-	/* Assign values for increment and vertical adjustment */
-	adjustment = horizontal ? view->hadjustment : view->vadjustment;
-	value = gtk_adjustment_get_value (adjustment);
-	upper = gtk_adjustment_get_upper (adjustment);
-	lower = gtk_adjustment_get_lower (adjustment);
-	page_size = gtk_adjustment_get_page_size (adjustment);
-	step_increment = gtk_adjustment_get_step_increment (adjustment);
-
-	/* Assign boolean for first and last page */
-	if (view->current_page == 0)
-		first_page = TRUE;
-	if (view->current_page == ev_document_get_n_pages (view->document) - 1)
-		last_page = TRUE;
-
-	switch (scroll) {
-		case GTK_SCROLL_PAGE_BACKWARD:
-			/* Do not jump backwards if at the first page */
-			if (value == lower && first_page) {
-				/* Do nothing */
-				/* At the top of a page, assign the upper bound limit of previous page */
-			} else if (value == lower) {
-				value = upper - page_size;
-				ev_view_previous_page (view);
-				/* Jump to the top */
-			} else {
-				increment = compute_scroll_increment (view, GTK_SCROLL_PAGE_BACKWARD);
-				value = MAX (value - increment, lower);
-			}
-			break;
-		case GTK_SCROLL_PAGE_FORWARD:
-			/* Do not jump forward if at the last page */
-			if (value == (upper - page_size) && last_page) {
-				/* Do nothing */
-			/* At the bottom of a page, assign the lower bound limit of next page */
-			} else if (value == (upper - page_size)) {
-				value = 0;
-				ev_view_next_page (view);
-			/* Jump to the bottom */
-			} else {
-				increment = compute_scroll_increment (view, GTK_SCROLL_PAGE_FORWARD);
-				value = MIN (value + increment, upper - page_size);
-			}
-			break;
-	        case GTK_SCROLL_STEP_BACKWARD:
-			value -= step_increment;
-			break;
-	        case GTK_SCROLL_STEP_FORWARD:
-			value += step_increment;
-			break;
-        	case GTK_SCROLL_STEP_DOWN:
-			value -= step_increment / 10;
-			break;
-        	case GTK_SCROLL_STEP_UP:
-			value += step_increment / 10;
-			break;
-	        case GTK_SCROLL_START:
-			value = lower;
-			if (!first_page)
-				ev_view_first_page (view);
-			break;
-	        case GTK_SCROLL_END:
-			value = upper - page_size;
-			if (!last_page)
-				ev_view_last_page (view);
-			/* Changing pages causes the top to be shown. Here we want the bottom shown. */
-			view->pending_point.y = value;
-			break;
-        	default:
-			break;
-	}
-
-	value = CLAMP (value, lower, upper - page_size);
-
-	gtk_adjustment_set_value (adjustment, value);
+                GtkScrollType  scroll,
+                gboolean       horizontal) {
+  GtkAdjustment *adjustment;
+  double value, increment;
+  gdouble upper, lower;
+  gdouble page_size;
+  gdouble step_increment;
+  gboolean first_page = FALSE;
+  gboolean last_page = FALSE;
+
+  if (view->key_binding_handled)
+    return;
+
+  view->jump_to_find_result = FALSE;
+
+  if ((!horizontal && ev_view_page_fits (view, GTK_ORIENTATION_VERTICAL)) ||
+      (horizontal && ev_view_page_fits (view, GTK_ORIENTATION_HORIZONTAL))) {
+    switch (scroll) {
+      case GTK_SCROLL_PAGE_BACKWARD:
+      case GTK_SCROLL_STEP_BACKWARD:
+        ev_view_previous_page (view);
+        break;
+      case GTK_SCROLL_PAGE_FORWARD:
+      case GTK_SCROLL_STEP_FORWARD:
+        ev_view_next_page (view);
+        break;
+      case GTK_SCROLL_START:
+        ev_view_first_page (view);
+        break;
+      case GTK_SCROLL_END:
+        ev_view_last_page (view);
+        break;
+      default:
+        break;
+    }
+    return;
+  }
+
+  /* Assign values for increment and vertical adjustment */
+  adjustment = horizontal ? view->hadjustment : view->vadjustment;
+  value = gtk_adjustment_get_value (adjustment);
+  upper = gtk_adjustment_get_upper (adjustment);
+  lower = gtk_adjustment_get_lower (adjustment);
+  page_size = gtk_adjustment_get_page_size (adjustment);
+  step_increment = gtk_adjustment_get_step_increment (adjustment);
+
+  /* Assign boolean for first and last page */
+  if (view->current_page == 0)
+    first_page = TRUE;
+  if (view->current_page == ev_document_get_n_pages (view->document) - 1)
+    last_page = TRUE;
+
+  switch (scroll) {
+    case GTK_SCROLL_PAGE_BACKWARD:
+      /* Do not jump backwards if at the first page */
+      if (value == lower && first_page) {
+        /* Do nothing */
+        /* At the top of a page, assign the upper bound limit of previous page */
+      } else if (value == lower) {
+        value = upper - page_size;
+        ev_view_previous_page (view);
+        /* Jump to the top */
+      } else {
+        increment = compute_scroll_increment (view, GTK_SCROLL_PAGE_BACKWARD);
+        value = MAX (value - increment, lower);
+      }
+      break;
+    case GTK_SCROLL_PAGE_FORWARD:
+      /* Do not jump forward if at the last page */
+      if (value == (upper - page_size) && last_page) {
+        /* Do nothing */
+        /* At the bottom of a page, assign the lower bound limit of next page */
+      } else if (value == (upper - page_size)) {
+        value = 0;
+        ev_view_next_page (view);
+        /* Jump to the bottom */
+      } else {
+        increment = compute_scroll_increment (view, GTK_SCROLL_PAGE_FORWARD);
+        value = MIN (value + increment, upper - page_size);
+      }
+      break;
+    case GTK_SCROLL_STEP_BACKWARD:
+      value -= step_increment;
+      break;
+    case GTK_SCROLL_STEP_FORWARD:
+      value += step_increment;
+      break;
+    case GTK_SCROLL_STEP_DOWN:
+      value -= step_increment / 10;
+      break;
+    case GTK_SCROLL_STEP_UP:
+      value += step_increment / 10;
+      break;
+    case GTK_SCROLL_START:
+      value = lower;
+      if (!first_page)
+        ev_view_first_page (view);
+      break;
+    case GTK_SCROLL_END:
+      value = upper - page_size;
+      if (!last_page)
+        ev_view_last_page (view);
+      /* Changing pages causes the top to be shown. Here we want the bottom shown. */
+      view->pending_point.y = value;
+      break;
+    default:
+      break;
+  }
+
+  value = CLAMP (value, lower, upper - page_size);
+
+  gtk_adjustment_set_value (adjustment, value);
 }
 
 static void
 ev_view_scroll_internal (EvView        *view,
-			 GtkScrollType  scroll,
-			 GtkOrientation orientation)
-{
-	ev_view_scroll (view, scroll, orientation == GTK_ORIENTATION_HORIZONTAL);
+                         GtkScrollType  scroll,
+                         GtkOrientation orientation) {
+  ev_view_scroll (view, scroll, orientation == GTK_ORIENTATION_HORIZONTAL);
 }
 
 #define MARGIN 5
 
 void
-_ev_view_ensure_rectangle_is_visible (EvView *view, GdkRectangle *rect)
-{
-	GtkWidget *widget = GTK_WIDGET (view);
-	GtkAdjustment *adjustment;
-	GtkAllocation allocation;
-	gdouble adj_value;
-	int value;
-
-	view->pending_scroll = SCROLL_TO_FIND_LOCATION;
-
-	gtk_widget_get_allocation (widget, &allocation);
-
-	adjustment = view->vadjustment;
-	adj_value = gtk_adjustment_get_value (adjustment);
-
-	if (rect->y < adj_value) {
-		value = MAX (gtk_adjustment_get_lower (adjustment), rect->y - MARGIN);
-		gtk_adjustment_set_value (view->vadjustment, value);
-	} else if (rect->y + rect->height > adj_value + allocation.height) {
-		value = MIN (gtk_adjustment_get_upper (adjustment), rect->y + rect->height -
-			     allocation.height + MARGIN);
-		gtk_adjustment_set_value (view->vadjustment, value);
-	}
-
-	adjustment = view->hadjustment;
-	adj_value = gtk_adjustment_get_value (adjustment);
-
-	if (rect->x < adj_value) {
-		value = MAX (gtk_adjustment_get_lower (adjustment), rect->x - MARGIN);
-		gtk_adjustment_set_value (view->hadjustment, value);
-	} else if (rect->x + rect->height > adj_value + allocation.width) {
-		value = MIN (gtk_adjustment_get_upper (adjustment), rect->x + rect->width -
-			     allocation.width + MARGIN);
-		gtk_adjustment_set_value (view->hadjustment, value);
-	}
+_ev_view_ensure_rectangle_is_visible (EvView *view, GdkRectangle *rect) {
+  GtkWidget *widget = GTK_WIDGET (view);
+  GtkAdjustment *adjustment;
+  GtkAllocation allocation;
+  gdouble adj_value;
+  int value;
+
+  view->pending_scroll = SCROLL_TO_FIND_LOCATION;
+
+  gtk_widget_get_allocation (widget, &allocation);
+
+  adjustment = view->vadjustment;
+  adj_value = gtk_adjustment_get_value (adjustment);
+
+  if (rect->y < adj_value) {
+    value = MAX (gtk_adjustment_get_lower (adjustment), rect->y - MARGIN);
+    gtk_adjustment_set_value (view->vadjustment, value);
+  } else if (rect->y + rect->height > adj_value + allocation.height) {
+    value = MIN (gtk_adjustment_get_upper (adjustment), rect->y + rect->height -
+                 allocation.height + MARGIN);
+    gtk_adjustment_set_value (view->vadjustment, value);
+  }
+
+  adjustment = view->hadjustment;
+  adj_value = gtk_adjustment_get_value (adjustment);
+
+  if (rect->x < adj_value) {
+    value = MAX (gtk_adjustment_get_lower (adjustment), rect->x - MARGIN);
+    gtk_adjustment_set_value (view->hadjustment, value);
+  } else if (rect->x + rect->height > adj_value + allocation.width) {
+    value = MIN (gtk_adjustment_get_upper (adjustment), rect->x + rect->width -
+                 allocation.width + MARGIN);
+    gtk_adjustment_set_value (view->hadjustment, value);
+  }
 }
 
 /*** Geometry computations ***/
 
 static void
-compute_border (EvView *view, GtkBorder *border)
-{
-	GtkWidget       *widget = GTK_WIDGET (view);
-	GtkStyleContext *context = gtk_widget_get_style_context (widget);
-	GtkStateFlags    state = gtk_widget_get_state_flags (widget);
+compute_border (EvView *view, GtkBorder *border) {
+  GtkWidget       *widget = GTK_WIDGET (view);
+  GtkStyleContext *context = gtk_widget_get_style_context (widget);
+  GtkStateFlags    state = gtk_widget_get_state_flags (widget);
 
-	gtk_style_context_save (context);
-	gtk_style_context_add_class (context, EV_STYLE_CLASS_DOCUMENT_PAGE);
-	gtk_style_context_get_border (context, state, border);
-	gtk_style_context_restore (context);
+  gtk_style_context_save (context);
+  gtk_style_context_add_class (context, EV_STYLE_CLASS_DOCUMENT_PAGE);
+  gtk_style_context_get_border (context, state, border);
+  gtk_style_context_restore (context);
 }
 
 void
 _get_page_size_for_scale_and_rotation (EvDocument *document,
-				       gint        page,
-				       gdouble     scale,
-				       gint        rotation,
-				       gint       *page_width,
-				       gint       *page_height)
-{
-	gdouble w, h;
-	gint    width, height;
+                                       gint        page,
+                                       gdouble     scale,
+                                       gint        rotation,
+                                       gint       *page_width,
+                                       gint       *page_height) {
+  gdouble w, h;
+  gint    width, height;
 
-	ev_document_get_page_size (document, page, &w, &h);
+  ev_document_get_page_size (document, page, &w, &h);
 
-	width = (gint)(w * scale + 0.5);
-	height = (gint)(h * scale + 0.5);
+  width = (gint)(w * scale + 0.5);
+  height = (gint)(h * scale + 0.5);
 
-	if (page_width)
-		*page_width = (rotation == 0 || rotation == 180) ? width : height;
-	if (page_height)
-		*page_height = (rotation == 0 || rotation == 180) ? height : width;
+  if (page_width)
+    *page_width = (rotation == 0 || rotation == 180) ? width : height;
+  if (page_height)
+    *page_height = (rotation == 0 || rotation == 180) ? height : width;
 }
 
 static void
 ev_view_get_page_size (EvView *view,
-		       gint    page,
-		       gint   *page_width,
-		       gint   *page_height)
-{
-	_get_page_size_for_scale_and_rotation (view->document,
-					       page,
-					       view->scale,
-					       view->rotation,
-					       page_width,
-					       page_height);
+                       gint    page,
+                       gint   *page_width,
+                       gint   *page_height) {
+  _get_page_size_for_scale_and_rotation (view->document,
+                                         page,
+                                         view->scale,
+                                         view->rotation,
+                                         page_width,
+                                         page_height);
 }
 
 static void
 ev_view_get_max_page_size (EvView *view,
-			   gint   *max_width,
-			   gint   *max_height)
-{
-	double w, h;
-	gint   width, height;
+                           gint   *max_width,
+                           gint   *max_height) {
+  double w, h;
+  gint   width, height;
 
-	ev_document_get_max_page_size (view->document, &w, &h);
+  ev_document_get_max_page_size (view->document, &w, &h);
 
-	width = (gint)(w * view->scale + 0.5);
-	height = (gint)(h * view->scale + 0.5);
+  width = (gint)(w * view->scale + 0.5);
+  height = (gint)(h * view->scale + 0.5);
 
-	if (max_width)
-		*max_width = (view->rotation == 0 || view->rotation == 180) ? width : height;
-	if (max_height)
-		*max_height = (view->rotation == 0 || view->rotation == 180) ? height : width;
+  if (max_width)
+    *max_width = (view->rotation == 0 || view->rotation == 180) ? width : height;
+  if (max_height)
+    *max_height = (view->rotation == 0 || view->rotation == 180) ? height : width;
 }
 
 static void
-get_page_y_offset (EvView *view, int page, int *y_offset, GtkBorder *border)
-{
-	int offset = 0;
-	gboolean odd_left;
+get_page_y_offset (EvView *view, int page, int *y_offset, GtkBorder *border) {
+  int offset = 0;
+  gboolean odd_left;
 
-	g_return_if_fail (y_offset != NULL);
+  g_return_if_fail (y_offset != NULL);
 
-	if (is_dual_page (view, &odd_left)) {
-		ev_view_get_height_to_page (view, page, NULL, &offset);
-		offset += ((page + !odd_left) / 2 + 1) * view->spacing +
-			((page + !odd_left) / 2 ) * (border->top + border->bottom);
-	} else {
-		ev_view_get_height_to_page (view, page, &offset, NULL);
-		offset += (page + 1) * view->spacing + page * (border->top + border->bottom);
-	}
+  if (is_dual_page (view, &odd_left)) {
+    ev_view_get_height_to_page (view, page, NULL, &offset);
+    offset += ((page + !odd_left) / 2 + 1) * view->spacing +
+              ((page + !odd_left) / 2 ) * (border->top + border->bottom);
+  } else {
+    ev_view_get_height_to_page (view, page, &offset, NULL);
+    offset += (page + 1) * view->spacing + page * (border->top + border->bottom);
+  }
 
-	*y_offset = offset;
-	return;
+  *y_offset = offset;
+  return;
 }
 
 gboolean
 ev_view_get_page_extents_for_border (EvView       *view,
-				     gint          page,
-				     GtkBorder    *border,
-				     GdkRectangle *page_area)
-{
-	return real_ev_view_get_page_extents (view, page, page_area, border, TRUE);
+                                     gint          page,
+                                     GtkBorder    *border,
+                                     GdkRectangle *page_area) {
+  return real_ev_view_get_page_extents (view, page, page_area, border, TRUE);
 }
 
 gboolean
 ev_view_get_page_extents (EvView       *view,
-			  gint          page,
-			  GdkRectangle *page_area,
-			  GtkBorder    *border)
-{
-	return real_ev_view_get_page_extents (view, page, page_area, border, FALSE);
+                          gint          page,
+                          GdkRectangle *page_area,
+                          GtkBorder    *border) {
+  return real_ev_view_get_page_extents (view, page, page_area, border, FALSE);
 }
 
 static gboolean
 real_ev_view_get_page_extents (EvView       *view,
-			       gint          page,
-			       GdkRectangle *page_area,
-			       GtkBorder    *border,
-			       gboolean      use_passed_border)
-{
-	GtkWidget *widget;
-	int width, height;
-	GtkAllocation allocation;
-
-	widget = GTK_WIDGET (view);
-	gtk_widget_get_allocation (widget, &allocation);
-
-	/* Get the size of the page */
-	ev_view_get_page_size (view, page, &width, &height);
-	if (!use_passed_border)
-		compute_border (view, border);
-	page_area->width = width + border->left + border->right;
-	page_area->height = height + border->top + border->bottom;
-
-	if (view->continuous) {
-		gint max_width;
-		gint x, y;
-		gboolean odd_left;
-
-		ev_view_get_max_page_size (view, &max_width, NULL);
-		max_width = max_width + border->left + border->right;
-		/* Get the location of the bounding box */
-		if (is_dual_page (view, &odd_left)) {
-			gboolean right_page;
-
-			right_page = (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_LTR && page % 2 == !odd_left) ||
-			             (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL && page % 2 == odd_left);
-
-			x = view->spacing + (right_page ? 0 : 1) * (max_width + view->spacing);
-			x = x + MAX (0, allocation.width - (max_width * 2 + view->spacing * 3)) / 2;
-			if (right_page)
-				x = x + (max_width - width - border->left - border->right);
-		} else {
-			x = view->spacing;
-			x = x + MAX (0, allocation.width - (width + border->left + border->right + view->spacing * 2)) / 2;
-		}
-
-		get_page_y_offset (view, page, &y, border);
-
-		page_area->x = x;
-		page_area->y = y;
-	} else {
-		gint x, y;
-		gboolean odd_left;
-
-		if (is_dual_page (view, &odd_left)) {
-			gint width_2, height_2;
-			gint max_width = width;
-			gint max_height = height;
-			GtkBorder overall_border;
-			gint other_page;
-
-			other_page = (page % 2 == !odd_left) ? page + 1: page - 1;
-
-			/* First, we get the bounding box of the two pages */
-			if (other_page < ev_document_get_n_pages (view->document)
-			    && (0 <= other_page)) {
-				ev_view_get_page_size (view, other_page,
-						       &width_2, &height_2);
-				if (width_2 > width)
-					max_width = width_2;
-				if (height_2 > height)
-					max_height = height_2;
-			}
-			if (!use_passed_border)
-				compute_border (view, &overall_border);
-			else
-				overall_border = *border;
-
-			/* Find the offsets */
-			x = view->spacing;
-			y = view->spacing;
-
-			/* Adjust for being the left or right page */
-			if ((gtk_widget_get_direction (widget) == GTK_TEXT_DIR_LTR && page % 2 == !odd_left) ||
-			    (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL && page % 2 == odd_left))
-				x = x + max_width - width;
-			else
-				x = x + (max_width + overall_border.left + overall_border.right) + view->spacing;
-
-			y = y + (max_height - height)/2;
-
-			/* Adjust for extra allocation */
-			x = x + MAX (0, allocation.width -
-				     ((max_width + overall_border.left + overall_border.right) * 2 + view->spacing * 3))/2;
-			y = y + MAX (0, allocation.height - (height + view->spacing * 2))/2;
-		} else {
-			x = view->spacing;
-			y = view->spacing;
-
-			/* Adjust for extra allocation */
-			x = x + MAX (0, allocation.width - (width + border->left + border->right + view->spacing * 2))/2;
-			y = y + MAX (0, allocation.height - (height + border->top + border->bottom +  view->spacing * 2))/2;
-		}
-
-		page_area->x = x;
-		page_area->y = y;
-	}
-
-	return TRUE;
+                               gint          page,
+                               GdkRectangle *page_area,
+                               GtkBorder    *border,
+                               gboolean      use_passed_border) {
+  GtkWidget *widget;
+  int width, height;
+  GtkAllocation allocation;
+
+  widget = GTK_WIDGET (view);
+  gtk_widget_get_allocation (widget, &allocation);
+
+  /* Get the size of the page */
+  ev_view_get_page_size (view, page, &width, &height);
+  if (!use_passed_border)
+    compute_border (view, border);
+  page_area->width = width + border->left + border->right;
+  page_area->height = height + border->top + border->bottom;
+
+  if (view->continuous) {
+    gint max_width;
+    gint x, y;
+    gboolean odd_left;
+
+    ev_view_get_max_page_size (view, &max_width, NULL);
+    max_width = max_width + border->left + border->right;
+    /* Get the location of the bounding box */
+    if (is_dual_page (view, &odd_left)) {
+      gboolean right_page;
+
+      right_page = (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_LTR && page % 2 == !odd_left) ||
+                   (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL && page % 2 == odd_left);
+
+      x = view->spacing + (right_page ? 0 : 1) * (max_width + view->spacing);
+      x = x + MAX (0, allocation.width - (max_width * 2 + view->spacing * 3)) / 2;
+      if (right_page)
+        x = x + (max_width - width - border->left - border->right);
+    } else {
+      x = view->spacing;
+      x = x + MAX (0, allocation.width - (width + border->left + border->right + view->spacing * 2)) / 2;
+    }
+
+    get_page_y_offset (view, page, &y, border);
+
+    page_area->x = x;
+    page_area->y = y;
+  } else {
+    gint x, y;
+    gboolean odd_left;
+
+    if (is_dual_page (view, &odd_left)) {
+      gint width_2, height_2;
+      gint max_width = width;
+      gint max_height = height;
+      GtkBorder overall_border;
+      gint other_page;
+
+      other_page = (page % 2 == !odd_left) ? page + 1 : page - 1;
+
+      /* First, we get the bounding box of the two pages */
+      if (other_page < ev_document_get_n_pages (view->document)
+          && (0 <= other_page)) {
+        ev_view_get_page_size (view, other_page,
+                               &width_2, &height_2);
+        if (width_2 > width)
+          max_width = width_2;
+        if (height_2 > height)
+          max_height = height_2;
+      }
+      if (!use_passed_border)
+        compute_border (view, &overall_border);
+      else
+        overall_border = *border;
+
+      /* Find the offsets */
+      x = view->spacing;
+      y = view->spacing;
+
+      /* Adjust for being the left or right page */
+      if ((gtk_widget_get_direction (widget) == GTK_TEXT_DIR_LTR && page % 2 == !odd_left) ||
+          (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL && page % 2 == odd_left))
+        x = x + max_width - width;
+      else
+        x = x + (max_width + overall_border.left + overall_border.right) + view->spacing;
+
+      y = y + (max_height - height) / 2;
+
+      /* Adjust for extra allocation */
+      x = x + MAX (0, allocation.width -
+                   ((max_width + overall_border.left + overall_border.right) * 2 + view->spacing * 3)) / 2;
+      y = y + MAX (0, allocation.height - (height + view->spacing * 2)) / 2;
+    } else {
+      x = view->spacing;
+      y = view->spacing;
+
+      /* Adjust for extra allocation */
+      x = x + MAX (0, allocation.width - (width + border->left + border->right + view->spacing * 2)) / 2;
+      y = y + MAX (0, allocation.height - (height + border->top + border->bottom +  view->spacing * 2)) / 2;
+    }
+
+    page_area->x = x;
+    page_area->y = y;
+  }
+
+  return TRUE;
 }
 
 static void
 get_doc_page_size (EvView  *view,
-		   gint     page,
-		   gdouble *width,
-		   gdouble *height)
-{
-	double w, h;
-
-	ev_document_get_page_size (view->document, page, &w, &h);
-	if (view->rotation == 0 || view->rotation == 180) {
-		if (width) *width = w;
-		if (height) *height = h;
-	} else {
-		if (width) *width = h;
-		if (height) *height = w;
-	}
+                   gint     page,
+                   gdouble *width,
+                   gdouble *height) {
+  double w, h;
+
+  ev_document_get_page_size (view->document, page, &w, &h);
+  if (view->rotation == 0 || view->rotation == 180) {
+    if (width) *width = w;
+    if (height) *height = h;
+  } else {
+    if (width) *width = h;
+    if (height) *height = w;
+  }
 }
 
 void
 _ev_view_transform_view_point_to_doc_point (EvView       *view,
-					    GdkPoint     *view_point,
-					    GdkRectangle *page_area,
-					    GtkBorder    *border,
-					    double       *doc_point_x,
-					    double       *doc_point_y)
-{
-	*doc_point_x = MAX ((double) (view_point->x - page_area->x - border->left) / view->scale, 0);
-	*doc_point_y = MAX ((double) (view_point->y - page_area->y - border->top) / view->scale, 0);
+                                            GdkPoint     *view_point,
+                                            GdkRectangle *page_area,
+                                            GtkBorder    *border,
+                                            double       *doc_point_x,
+                                            double       *doc_point_y) {
+  *doc_point_x = MAX ((double) (view_point->x - page_area->x - border->left) / view->scale, 0);
+  *doc_point_y = MAX ((double) (view_point->y - page_area->y - border->top) / view->scale, 0);
 }
 
 void
 _ev_view_transform_view_rect_to_doc_rect (EvView       *view,
-					  GdkRectangle *view_rect,
-					  GdkRectangle *page_area,
-					  GtkBorder    *border,
-					  EvRectangle  *doc_rect)
-{
-	doc_rect->x1 = MAX ((double) (view_rect->x - page_area->x - border->left) / view->scale, 0);
-	doc_rect->y1 = MAX ((double) (view_rect->y - page_area->y - border->top) / view->scale, 0);
-	doc_rect->x2 = doc_rect->x1 + (double) view_rect->width / view->scale;
-	doc_rect->y2 = doc_rect->y1 + (double) view_rect->height / view->scale;
+                                          GdkRectangle *view_rect,
+                                          GdkRectangle *page_area,
+                                          GtkBorder    *border,
+                                          EvRectangle  *doc_rect) {
+  doc_rect->x1 = MAX ((double) (view_rect->x - page_area->x - border->left) / view->scale, 0);
+  doc_rect->y1 = MAX ((double) (view_rect->y - page_area->y - border->top) / view->scale, 0);
+  doc_rect->x2 = doc_rect->x1 + (double) view_rect->width / view->scale;
+  doc_rect->y2 = doc_rect->y1 + (double) view_rect->height / view->scale;
 }
 
 void
 _ev_view_transform_doc_point_to_view_point (EvView   *view,
-					    int       page,
-					    EvPoint  *doc_point,
-					    GdkPoint *view_point)
-{
-	GdkRectangle page_area;
-	GtkBorder border;
-	double x, y, view_x, view_y;
-
-	switch (view->rotation) {
-	case 0:
-		x = doc_point->x;
-		y = doc_point->y;
-
-		break;
-	case 90: {
-		gdouble width;
-
-		get_doc_page_size (view, page, &width, NULL);
-		x = width - doc_point->y;
-		y = doc_point->x;
-	}
-		break;
-	case 180: {
-		gdouble width, height;
-
-		get_doc_page_size (view, page, &width, &height);
-		x = width - doc_point->x;
-		y = height - doc_point->y;
-	}
-		break;
-	case 270: {
-		gdouble height;
-
-		get_doc_page_size (view, page, NULL, &height);
-		x = doc_point->y;
-		y = height - doc_point->x;
-	}
-		break;
-	default:
-		g_assert_not_reached ();
-	}
-
-	ev_view_get_page_extents (view, page, &page_area, &border);
-
-	view_x = CLAMP ((gint)(x * view->scale + 0.5), 0, page_area.width);
-	view_y = CLAMP ((gint)(y * view->scale + 0.5), 0, page_area.height);
-	view_point->x = view_x + page_area.x + border.left;
-	view_point->y = view_y + page_area.y + border.top;
+                                            int       page,
+                                            EvPoint  *doc_point,
+                                            GdkPoint *view_point) {
+  GdkRectangle page_area;
+  GtkBorder border;
+  double x, y, view_x, view_y;
+
+  switch (view->rotation) {
+    case 0:
+      x = doc_point->x;
+      y = doc_point->y;
+
+      break;
+    case 90: {
+      gdouble width;
+
+      get_doc_page_size (view, page, &width, NULL);
+      x = width - doc_point->y;
+      y = doc_point->x;
+    }
+    break;
+    case 180: {
+      gdouble width, height;
+
+      get_doc_page_size (view, page, &width, &height);
+      x = width - doc_point->x;
+      y = height - doc_point->y;
+    }
+    break;
+    case 270: {
+      gdouble height;
+
+      get_doc_page_size (view, page, NULL, &height);
+      x = doc_point->y;
+      y = height - doc_point->x;
+    }
+    break;
+    default:
+      g_assert_not_reached ();
+  }
+
+  ev_view_get_page_extents (view, page, &page_area, &border);
+
+  view_x = CLAMP ((gint)(x * view->scale + 0.5), 0, page_area.width);
+  view_y = CLAMP ((gint)(y * view->scale + 0.5), 0, page_area.height);
+  view_point->x = view_x + page_area.x + border.left;
+  view_point->y = view_y + page_area.y + border.top;
 }
 
 void
 _ev_view_transform_doc_rect_to_view_rect (EvView       *view,
-					  int           page,
-					  EvRectangle  *doc_rect,
-					  GdkRectangle *view_rect)
-{
-	GdkRectangle page_area;
-	GtkBorder border;
-	double x, y, w, h;
-
-	switch (view->rotation) {
-	case 0:
-		x = doc_rect->x1;
-		y = doc_rect->y1;
-		w = doc_rect->x2 - doc_rect->x1;
-		h = doc_rect->y2 - doc_rect->y1;
-
-		break;
-	case 90: {
-		gdouble width;
-
-		get_doc_page_size (view, page, &width, NULL);
-		x = width - doc_rect->y2;
-		y = doc_rect->x1;
-		w = doc_rect->y2 - doc_rect->y1;
-		h = doc_rect->x2 - doc_rect->x1;
-	}
-		break;
-	case 180: {
-		gdouble width, height;
-
-		get_doc_page_size (view, page, &width, &height);
-		x = width - doc_rect->x2;
-		y = height - doc_rect->y2;
-		w = doc_rect->x2 - doc_rect->x1;
-		h = doc_rect->y2 - doc_rect->y1;
-	}
-		break;
-	case 270: {
-		gdouble height;
-
-		get_doc_page_size (view, page, NULL, &height);
-		x = doc_rect->y1;
-		y = height - doc_rect->x2;
-		w = doc_rect->y2 - doc_rect->y1;
-		h = doc_rect->x2 - doc_rect->x1;
-	}
-		break;
-	default:
-		g_assert_not_reached ();
-	}
-
-	ev_view_get_page_extents (view, page, &page_area, &border);
-
-	view_rect->x = (gint)(x * view->scale + 0.5) + page_area.x + border.left;
-	view_rect->y = (gint)(y * view->scale + 0.5) + page_area.y + border.top;
-	view_rect->width = (gint)(w * view->scale + 0.5);
-	view_rect->height = (gint)(h * view->scale + 0.5);
+                                          int           page,
+                                          EvRectangle  *doc_rect,
+                                          GdkRectangle *view_rect) {
+  GdkRectangle page_area;
+  GtkBorder border;
+  double x, y, w, h;
+
+  switch (view->rotation) {
+    case 0:
+      x = doc_rect->x1;
+      y = doc_rect->y1;
+      w = doc_rect->x2 - doc_rect->x1;
+      h = doc_rect->y2 - doc_rect->y1;
+
+      break;
+    case 90: {
+      gdouble width;
+
+      get_doc_page_size (view, page, &width, NULL);
+      x = width - doc_rect->y2;
+      y = doc_rect->x1;
+      w = doc_rect->y2 - doc_rect->y1;
+      h = doc_rect->x2 - doc_rect->x1;
+    }
+    break;
+    case 180: {
+      gdouble width, height;
+
+      get_doc_page_size (view, page, &width, &height);
+      x = width - doc_rect->x2;
+      y = height - doc_rect->y2;
+      w = doc_rect->x2 - doc_rect->x1;
+      h = doc_rect->y2 - doc_rect->y1;
+    }
+    break;
+    case 270: {
+      gdouble height;
+
+      get_doc_page_size (view, page, NULL, &height);
+      x = doc_rect->y1;
+      y = height - doc_rect->x2;
+      w = doc_rect->y2 - doc_rect->y1;
+      h = doc_rect->x2 - doc_rect->x1;
+    }
+    break;
+    default:
+      g_assert_not_reached ();
+  }
+
+  ev_view_get_page_extents (view, page, &page_area, &border);
+
+  view_rect->x = (gint)(x * view->scale + 0.5) + page_area.x + border.left;
+  view_rect->y = (gint)(y * view->scale + 0.5) + page_area.y + border.top;
+  view_rect->width = (gint)(w * view->scale + 0.5);
+  view_rect->height = (gint)(h * view->scale + 0.5);
 }
 
 static void
 find_page_at_location (EvView  *view,
-		       gdouble  x,
-		       gdouble  y,
-		       gint    *page,
-		       gint    *x_offset,
-		       gint    *y_offset)
-{
-	int i;
-	GtkBorder border;
-
-	if (view->document == NULL)
-		return;
-
-	g_assert (page);
-	g_assert (x_offset);
-	g_assert (y_offset);
-
-	compute_border (view, &border);
-	for (i = view->start_page; i >= 0 && i <= view->end_page; i++) {
-		GdkRectangle page_area;
-
-		if (! ev_view_get_page_extents_for_border (view, i, &border, &page_area))
-			continue;
-
-		if ((x >= page_area.x + border.left) &&
-		    (x < page_area.x + page_area.width - border.right) &&
-		    (y >= page_area.y + border.top) &&
-		    (y < page_area.y + page_area.height - border.bottom)) {
-			*page = i;
-			*x_offset = x - (page_area.x + border.left);
-			*y_offset = y - (page_area.y + border.top);
-			return;
-		}
-	}
-
-	*page = -1;
+                       gdouble  x,
+                       gdouble  y,
+                       gint    *page,
+                       gint    *x_offset,
+                       gint    *y_offset) {
+  int i;
+  GtkBorder border;
+
+  if (view->document == NULL)
+    return;
+
+  g_assert (page);
+  g_assert (x_offset);
+  g_assert (y_offset);
+
+  compute_border (view, &border);
+  for (i = view->start_page; i >= 0 && i <= view->end_page; i++) {
+    GdkRectangle page_area;
+
+    if (! ev_view_get_page_extents_for_border (view, i, &border, &page_area))
+      continue;
+
+    if ((x >= page_area.x + border.left) &&
+        (x < page_area.x + page_area.width - border.right) &&
+        (y >= page_area.y + border.top) &&
+        (y < page_area.y + page_area.height - border.bottom)) {
+      *page = i;
+      *x_offset = x - (page_area.x + border.left);
+      *y_offset = y - (page_area.y + border.top);
+      return;
+    }
+  }
+
+  *page = -1;
 }
 
 static gboolean
 location_in_text (EvView  *view,
-		  gdouble  x,
-		  gdouble  y)
-{
-	cairo_region_t *region;
-	gint page = -1;
-	gint x_offset = 0, y_offset = 0;
+                  gdouble  x,
+                  gdouble  y) {
+  cairo_region_t *region;
+  gint page = -1;
+  gint x_offset = 0, y_offset = 0;
+
+  find_page_at_location (view, x, y, &page, &x_offset, &y_offset);
 
-	find_page_at_location (view, x, y, &page, &x_offset, &y_offset);
+  if (page == -1)
+    return FALSE;
 
-	if (page == -1)
-		return FALSE;
-	
-	region = ev_page_cache_get_text_mapping (view->page_cache, page);
+  region = ev_page_cache_get_text_mapping (view->page_cache, page);
 
-	if (region)
-		return cairo_region_contains_point (region, x_offset / view->scale, y_offset / view->scale);
-	else
-		return FALSE;
+  if (region)
+    return cairo_region_contains_point (region, x_offset / view->scale, y_offset / view->scale);
+  else
+    return FALSE;
 }
 
 static gboolean
 location_in_selected_text (EvView  *view,
-			   gdouble  x,
-			   gdouble  y)
-{
-	cairo_region_t *region;
-	gint page = -1;
-	gint x_offset = 0, y_offset = 0;
+                           gdouble  x,
+                           gdouble  y) {
+  cairo_region_t *region;
+  gint page = -1;
+  gint x_offset = 0, y_offset = 0;
 
-	find_page_at_location (view, x, y, &page, &x_offset, &y_offset);
+  find_page_at_location (view, x, y, &page, &x_offset, &y_offset);
 
-	if (page == -1)
-		return FALSE;
+  if (page == -1)
+    return FALSE;
 
-	region = ev_pixbuf_cache_get_selection_region (view->pixbuf_cache, page, view->scale);
+  region = ev_pixbuf_cache_get_selection_region (view->pixbuf_cache, page, view->scale);
 
-	if (region)
-		return cairo_region_contains_point (region, x_offset, y_offset);
-	else
-		return FALSE;
+  if (region)
+    return cairo_region_contains_point (region, x_offset, y_offset);
+  else
+    return FALSE;
 }
 
 static gboolean
-get_doc_point_from_offset (EvView *view, 
-			   gint    page, 
-			   gint    x_offset, 
-			   gint    y_offset, 
-			   gint   *x_new, 
-			   gint   *y_new)
-{
-        gdouble width, height;
-	double x, y;
-
-	get_doc_page_size (view, page, &width, &height);
-
-	x_offset = x_offset / view->scale;
-	y_offset = y_offset / view->scale;
-
-        if (view->rotation == 0) {
-                x = x_offset;
-                y = y_offset;
-        } else if (view->rotation == 90) {
-                x = y_offset;
-                y = width - x_offset;
-        } else if (view->rotation == 180) {
-                x = width - x_offset;
-                y = height - y_offset;
-        } else if (view->rotation == 270) {
-                x = height - y_offset; 
-                y = x_offset;
-        } else {
-                g_assert_not_reached ();
-        }
-
-	*x_new = x;
-	*y_new = y;
-	
-	return TRUE;
+get_doc_point_from_offset (EvView *view,
+                           gint    page,
+                           gint    x_offset,
+                           gint    y_offset,
+                           gint   *x_new,
+                           gint   *y_new) {
+  gdouble width, height;
+  double x, y;
+
+  get_doc_page_size (view, page, &width, &height);
+
+  x_offset = x_offset / view->scale;
+  y_offset = y_offset / view->scale;
+
+  if (view->rotation == 0) {
+    x = x_offset;
+    y = y_offset;
+  } else if (view->rotation == 90) {
+    x = y_offset;
+    y = width - x_offset;
+  } else if (view->rotation == 180) {
+    x = width - x_offset;
+    y = height - y_offset;
+  } else if (view->rotation == 270) {
+    x = height - y_offset;
+    y = x_offset;
+  } else {
+    g_assert_not_reached ();
+  }
+
+  *x_new = x;
+  *y_new = y;
+
+  return TRUE;
 }
 
 static gboolean
 get_doc_point_from_location (EvView  *view,
-			     gdouble  x,
-			     gdouble  y,
-			     gint    *page,
-			     gint    *x_new,
-			     gint    *y_new)
-{
-	gint x_offset = 0, y_offset = 0;
+                             gdouble  x,
+                             gdouble  y,
+                             gint    *page,
+                             gint    *x_new,
+                             gint    *y_new) {
+  gint x_offset = 0, y_offset = 0;
 
-	x += view->scroll_x;
-	y += view->scroll_y;
-	find_page_at_location (view, x, y, page, &x_offset, &y_offset);
-	if (*page == -1)
-		return FALSE;
+  x += view->scroll_x;
+  y += view->scroll_y;
+  find_page_at_location (view, x, y, page, &x_offset, &y_offset);
+  if (*page == -1)
+    return FALSE;
 
-	return get_doc_point_from_offset (view, *page, x_offset, y_offset, x_new, y_new);
+  return get_doc_point_from_offset (view, *page, x_offset, y_offset, x_new, y_new);
 }
 
 static void
 ev_view_get_area_from_mapping (EvView        *view,
-			       guint          page,
-			       EvMappingList *mapping_list,
-			       gconstpointer  data,
-			       GdkRectangle  *area)
-{
-	EvMapping *mapping;
+                               guint          page,
+                               EvMappingList *mapping_list,
+                               gconstpointer  data,
+                               GdkRectangle  *area) {
+  EvMapping *mapping;
 
-	mapping = ev_mapping_list_find (mapping_list, data);
-	_ev_view_transform_doc_rect_to_view_rect (view, page, &mapping->area, area);
-	area->x -= view->scroll_x;
-	area->y -= view->scroll_y;
+  mapping = ev_mapping_list_find (mapping_list, data);
+  _ev_view_transform_doc_rect_to_view_rect (view, page, &mapping->area, area);
+  area->x -= view->scroll_x;
+  area->y -= view->scroll_y;
 }
 
 static void
 ev_view_put (EvView      *view,
-	     GtkWidget   *child_widget,
-	     gint         x,
-	     gint         y,
-	     guint        page,
-	     EvRectangle *doc_rect)
-{
-	EvViewChild *child;
+             GtkWidget   *child_widget,
+             gint         x,
+             gint         y,
+             guint        page,
+             EvRectangle *doc_rect) {
+  EvViewChild *child;
 
-	child = g_slice_new (EvViewChild);
+  child = g_slice_new (EvViewChild);
 
-	child->widget = child_widget;
-	child->x = x;
-	child->y = y;
-	child->page = page;
-	child->doc_rect = *doc_rect;
+  child->widget = child_widget;
+  child->x = x;
+  child->y = y;
+  child->page = page;
+  child->doc_rect = *doc_rect;
 
-	gtk_widget_set_parent (child_widget, GTK_WIDGET (view));
-	view->children = g_list_append (view->children, child);
+  gtk_widget_set_parent (child_widget, GTK_WIDGET (view));
+  view->children = g_list_append (view->children, child);
 }
 
 static void
 ev_view_put_to_doc_rect (EvView      *view,
-			 GtkWidget   *child_widget,
-			 guint        page,
-			 EvRectangle *doc_rect)
-{
-	GdkRectangle area;
+                         GtkWidget   *child_widget,
+                         guint        page,
+                         EvRectangle *doc_rect) {
+  GdkRectangle area;
 
-	_ev_view_transform_doc_rect_to_view_rect (view, page, doc_rect, &area);
-	area.x -= view->scroll_x;
-	area.y -= view->scroll_y;
-	ev_view_put (view, child_widget, area.x, area.y, page, doc_rect);
+  _ev_view_transform_doc_rect_to_view_rect (view, page, doc_rect, &area);
+  area.x -= view->scroll_x;
+  area.y -= view->scroll_y;
+  ev_view_put (view, child_widget, area.x, area.y, page, doc_rect);
 }
 
 /*** Hyperref ***/
 static EvMapping *
 get_link_mapping_at_location (EvView  *view,
-			      gdouble  x,
-			      gdouble  y,
-			      gint    *page)
-{
-	gint x_new = 0, y_new = 0;
-	EvMappingList *link_mapping;
+                              gdouble  x,
+                              gdouble  y,
+                              gint    *page) {
+  gint x_new = 0, y_new = 0;
+  EvMappingList *link_mapping;
 
-	if (!EV_IS_DOCUMENT_LINKS (view->document))
-		return NULL;
+  if (!EV_IS_DOCUMENT_LINKS (view->document))
+    return NULL;
 
-	if (!get_doc_point_from_location (view, x, y, page, &x_new, &y_new))
-		return NULL;
+  if (!get_doc_point_from_location (view, x, y, page, &x_new, &y_new))
+    return NULL;
 
-	link_mapping = ev_page_cache_get_link_mapping (view->page_cache, *page);
-	if (link_mapping)
-		return ev_mapping_list_get (link_mapping, x_new, y_new);
+  link_mapping = ev_page_cache_get_link_mapping (view->page_cache, *page);
+  if (link_mapping)
+    return ev_mapping_list_get (link_mapping, x_new, y_new);
 
-	return NULL;
+  return NULL;
 }
 
 static EvLink *
 ev_view_get_link_at_location (EvView  *view,
-			      gdouble  x,
-			      gdouble  y)
-{
-	EvMapping *mapping;
-	gint page;
+                              gdouble  x,
+                              gdouble  y) {
+  EvMapping *mapping;
+  gint page;
 
-	mapping = get_link_mapping_at_location (view, x, y, &page);
+  mapping = get_link_mapping_at_location (view, x, y, &page);
 
-	return mapping ? mapping->data : NULL;
+  return mapping ? mapping->data : NULL;
 }
 
 static void
-goto_fitr_dest (EvView *view, EvLinkDest *dest)
-{
-	EvPoint doc_point;
-	gdouble left, top;
-	gboolean change_left, change_top;
+goto_fitr_dest (EvView *view, EvLinkDest *dest) {
+  EvPoint doc_point;
+  gdouble left, top;
+  gboolean change_left, change_top;
 
-	left = ev_link_dest_get_left (dest, &change_left);
-	top = ev_link_dest_get_top (dest, &change_top);
+  left = ev_link_dest_get_left (dest, &change_left);
+  top = ev_link_dest_get_top (dest, &change_top);
 
-	if (view->allow_links_change_zoom) {
-		gdouble doc_width, doc_height;
-		gdouble zoom;
-		GtkAllocation allocation;
+  if (view->allow_links_change_zoom) {
+    gdouble doc_width, doc_height;
+    gdouble zoom;
+    GtkAllocation allocation;
 
-		gtk_widget_get_allocation (GTK_WIDGET (view), &allocation);
+    gtk_widget_get_allocation (GTK_WIDGET (view), &allocation);
 
-		doc_width = ev_link_dest_get_right (dest) - left;
-		doc_height = ev_link_dest_get_bottom (dest) - top;
+    doc_width = ev_link_dest_get_right (dest) - left;
+    doc_height = ev_link_dest_get_bottom (dest) - top;
 
-		zoom = zoom_for_size_fit_page (doc_width,
-					       doc_height,
-					       allocation.width,
-					       allocation.height);
+    zoom = zoom_for_size_fit_page (doc_width,
+                                   doc_height,
+                                   allocation.width,
+                                   allocation.height);
 
-		ev_document_model_set_sizing_mode (view->model, EV_SIZING_FREE);
-		ev_document_model_set_scale (view->model, zoom);
+    ev_document_model_set_sizing_mode (view->model, EV_SIZING_FREE);
+    ev_document_model_set_scale (view->model, zoom);
 
-		/* center the target box within the view */
-		left -= (allocation.width / zoom - doc_width) / 2;
-		top -= (allocation.height / zoom - doc_height) / 2;
-	}
+    /* center the target box within the view */
+    left -= (allocation.width / zoom - doc_width) / 2;
+    top -= (allocation.height / zoom - doc_height) / 2;
+  }
 
-	doc_point.x = change_left ? left : 0;
-	doc_point.y = change_top ? top : 0;
-	view->pending_point = doc_point;
+  doc_point.x = change_left ? left : 0;
+  doc_point.y = change_top ? top : 0;
+  view->pending_point = doc_point;
 
-	ev_view_change_page (view, ev_link_dest_get_page (dest));
+  ev_view_change_page (view, ev_link_dest_get_page (dest));
 }
 
 static void
-goto_fitv_dest (EvView *view, EvLinkDest *dest)
-{
-	EvPoint doc_point;
-	gint page;
-	double left;
-	gboolean change_left;
+goto_fitv_dest (EvView *view, EvLinkDest *dest) {
+  EvPoint doc_point;
+  gint page;
+  double left;
+  gboolean change_left;
 
-	page = ev_link_dest_get_page (dest);
+  page = ev_link_dest_get_page (dest);
 
-	left = ev_link_dest_get_left (dest, &change_left);
-	doc_point.x = change_left ? left : 0;
-	doc_point.y = 0;
+  left = ev_link_dest_get_left (dest, &change_left);
+  doc_point.x = change_left ? left : 0;
+  doc_point.y = 0;
 
-	if (view->allow_links_change_zoom) {
-		GtkAllocation allocation;
-		gdouble doc_width, doc_height;
-		double zoom;
+  if (view->allow_links_change_zoom) {
+    GtkAllocation allocation;
+    gdouble doc_width, doc_height;
+    double zoom;
 
-		gtk_widget_get_allocation (GTK_WIDGET (view), &allocation);
+    gtk_widget_get_allocation (GTK_WIDGET (view), &allocation);
 
-		ev_document_get_page_size (view->document, page, &doc_width, &doc_height);
+    ev_document_get_page_size (view->document, page, &doc_width, &doc_height);
 
-		zoom = zoom_for_size_fit_height (doc_width - doc_point.x, doc_height,
-						 allocation.width,
-						 allocation.height);
+    zoom = zoom_for_size_fit_height (doc_width - doc_point.x, doc_height,
+                                     allocation.width,
+                                     allocation.height);
 
-		ev_document_model_set_sizing_mode (view->model, EV_SIZING_FREE);
-		ev_document_model_set_scale (view->model, zoom);
-	}
+    ev_document_model_set_sizing_mode (view->model, EV_SIZING_FREE);
+    ev_document_model_set_scale (view->model, zoom);
+  }
 
-	view->pending_point = doc_point;
+  view->pending_point = doc_point;
 
-	ev_view_change_page (view, page);
+  ev_view_change_page (view, page);
 }
 
 static void
-goto_fith_dest (EvView *view, EvLinkDest *dest)
-{
-	EvPoint doc_point;
-	gint page;
-	gdouble top;
-	gboolean change_top;
+goto_fith_dest (EvView *view, EvLinkDest *dest) {
+  EvPoint doc_point;
+  gint page;
+  gdouble top;
+  gboolean change_top;
 
-	page = ev_link_dest_get_page (dest);
+  page = ev_link_dest_get_page (dest);
 
-	top = ev_link_dest_get_top (dest, &change_top);
-	doc_point.x = 0;
-	doc_point.y = change_top ? top : 0;
+  top = ev_link_dest_get_top (dest, &change_top);
+  doc_point.x = 0;
+  doc_point.y = change_top ? top : 0;
 
-	if (view->allow_links_change_zoom) {
-		GtkAllocation allocation;
-		gdouble doc_width;
-		gdouble zoom;
+  if (view->allow_links_change_zoom) {
+    GtkAllocation allocation;
+    gdouble doc_width;
+    gdouble zoom;
 
-		gtk_widget_get_allocation (GTK_WIDGET (view), &allocation);
+    gtk_widget_get_allocation (GTK_WIDGET (view), &allocation);
 
-		ev_document_get_page_size (view->document, page, &doc_width, NULL);
+    ev_document_get_page_size (view->document, page, &doc_width, NULL);
 
-		zoom = zoom_for_size_fit_width (doc_width, top,
-						allocation.width,
-						allocation.height);
+    zoom = zoom_for_size_fit_width (doc_width, top,
+                                    allocation.width,
+                                    allocation.height);
 
-		ev_document_model_set_sizing_mode (view->model, EV_SIZING_FIT_WIDTH);
-		ev_document_model_set_scale (view->model, zoom);
-	}
+    ev_document_model_set_sizing_mode (view->model, EV_SIZING_FIT_WIDTH);
+    ev_document_model_set_scale (view->model, zoom);
+  }
 
-	view->pending_point = doc_point;
+  view->pending_point = doc_point;
 
-	ev_view_change_page (view, page);
+  ev_view_change_page (view, page);
 }
 
 static void
-goto_fit_dest (EvView *view, EvLinkDest *dest)
-{
-	int page;
+goto_fit_dest (EvView *view, EvLinkDest *dest) {
+  int page;
 
-	page = ev_link_dest_get_page (dest);
+  page = ev_link_dest_get_page (dest);
 
-	if (view->allow_links_change_zoom) {
-		double zoom;
-		gdouble doc_width, doc_height;
-		GtkAllocation allocation;
+  if (view->allow_links_change_zoom) {
+    double zoom;
+    gdouble doc_width, doc_height;
+    GtkAllocation allocation;
 
-		gtk_widget_get_allocation (GTK_WIDGET (view), &allocation);
+    gtk_widget_get_allocation (GTK_WIDGET (view), &allocation);
 
-		ev_document_get_page_size (view->document, page, &doc_width, &doc_height);
+    ev_document_get_page_size (view->document, page, &doc_width, &doc_height);
 
-		zoom = zoom_for_size_fit_page (doc_width, doc_height,
-					       allocation.width,
-					       allocation.height);
+    zoom = zoom_for_size_fit_page (doc_width, doc_height,
+                                   allocation.width,
+                                   allocation.height);
 
-		ev_document_model_set_sizing_mode (view->model, EV_SIZING_FIT_PAGE);
-		ev_document_model_set_scale (view->model, zoom);
-	}
+    ev_document_model_set_sizing_mode (view->model, EV_SIZING_FIT_PAGE);
+    ev_document_model_set_scale (view->model, zoom);
+  }
 
-	ev_view_change_page (view, page);
+  ev_view_change_page (view, page);
 }
 
 static void
-goto_xyz_dest (EvView *view, EvLinkDest *dest)
-{
-	EvPoint doc_point;
-	gint page;
-	gdouble zoom, left, top;
-	gboolean change_zoom, change_left, change_top; 
+goto_xyz_dest (EvView *view, EvLinkDest *dest) {
+  EvPoint doc_point;
+  gint page;
+  gdouble zoom, left, top;
+  gboolean change_zoom, change_left, change_top;
 
-	zoom = ev_link_dest_get_zoom (dest, &change_zoom);
-	page = ev_link_dest_get_page (dest);
+  zoom = ev_link_dest_get_zoom (dest, &change_zoom);
+  page = ev_link_dest_get_page (dest);
 
-	if (view->allow_links_change_zoom && change_zoom && zoom > 1) {
-		ev_document_model_set_sizing_mode (view->model, EV_SIZING_FREE);
-		ev_document_model_set_scale (view->model, zoom);
-	}
+  if (view->allow_links_change_zoom && change_zoom && zoom > 1) {
+    ev_document_model_set_sizing_mode (view->model, EV_SIZING_FREE);
+    ev_document_model_set_scale (view->model, zoom);
+  }
 
-	left = ev_link_dest_get_left (dest, &change_left);
-	top = ev_link_dest_get_top (dest, &change_top);
+  left = ev_link_dest_get_left (dest, &change_left);
+  top = ev_link_dest_get_top (dest, &change_top);
 
-	doc_point.x = change_left ? left : 0;
-	doc_point.y = change_top ? top : 0;
-	view->pending_point = doc_point;
+  doc_point.x = change_left ? left : 0;
+  doc_point.y = change_top ? top : 0;
+  view->pending_point = doc_point;
 
-	ev_view_change_page (view, page);
+  ev_view_change_page (view, page);
 }
 
 static void
-goto_dest (EvView *view, EvLinkDest *dest)
-{
-	EvLinkDestType type;
-	int page, n_pages, current_page;
+goto_dest (EvView *view, EvLinkDest *dest) {
+  EvLinkDestType type;
+  int page, n_pages, current_page;
 
-	page = ev_link_dest_get_page (dest);
-	n_pages = ev_document_get_n_pages (view->document);
+  page = ev_link_dest_get_page (dest);
+  n_pages = ev_document_get_n_pages (view->document);
 
-	if (page < 0 || page >= n_pages)
-		return;
+  if (page < 0 || page >= n_pages)
+    return;
 
-	current_page = view->current_page;
-	
-	type = ev_link_dest_get_dest_type (dest);
+  current_page = view->current_page;
 
-	switch (type) {
-		case EV_LINK_DEST_TYPE_PAGE:
-			ev_document_model_set_page (view->model, page);
-			break;
-		case EV_LINK_DEST_TYPE_FIT:
-			goto_fit_dest (view, dest);
-			break;
-		case EV_LINK_DEST_TYPE_FITH:
-			goto_fith_dest (view, dest);
-			break;
-		case EV_LINK_DEST_TYPE_FITV:
-			goto_fitv_dest (view, dest);
-			break;
-		case EV_LINK_DEST_TYPE_FITR:
-			goto_fitr_dest (view, dest);
-			break;
-		case EV_LINK_DEST_TYPE_XYZ:
-			goto_xyz_dest (view, dest);
-			break;
-		case EV_LINK_DEST_TYPE_PAGE_LABEL:
-			ev_document_model_set_page_by_label (view->model, ev_link_dest_get_page_label (dest));
-			break;
-		default:
-			g_assert_not_reached ();
- 	}
+  type = ev_link_dest_get_dest_type (dest);
 
-	if (current_page != view->current_page)
-		ev_document_model_set_page (view->model, view->current_page);
+  switch (type) {
+    case EV_LINK_DEST_TYPE_PAGE:
+      ev_document_model_set_page (view->model, page);
+      break;
+    case EV_LINK_DEST_TYPE_FIT:
+      goto_fit_dest (view, dest);
+      break;
+    case EV_LINK_DEST_TYPE_FITH:
+      goto_fith_dest (view, dest);
+      break;
+    case EV_LINK_DEST_TYPE_FITV:
+      goto_fitv_dest (view, dest);
+      break;
+    case EV_LINK_DEST_TYPE_FITR:
+      goto_fitr_dest (view, dest);
+      break;
+    case EV_LINK_DEST_TYPE_XYZ:
+      goto_xyz_dest (view, dest);
+      break;
+    case EV_LINK_DEST_TYPE_PAGE_LABEL:
+      ev_document_model_set_page_by_label (view->model, ev_link_dest_get_page_label (dest));
+      break;
+    default:
+      g_assert_not_reached ();
+  }
+
+  if (current_page != view->current_page)
+    ev_document_model_set_page (view->model, view->current_page);
 }
 
 static void
-ev_view_goto_dest (EvView *view, EvLinkDest *dest)
-{
-	EvLinkDestType type;
+ev_view_goto_dest (EvView *view, EvLinkDest *dest) {
+  EvLinkDestType type;
 
-	type = ev_link_dest_get_dest_type (dest);
+  type = ev_link_dest_get_dest_type (dest);
 
-	if (type == EV_LINK_DEST_TYPE_NAMED) {
-		EvLinkDest  *dest2;	
-		const gchar *named_dest;
+  if (type == EV_LINK_DEST_TYPE_NAMED) {
+    EvLinkDest  *dest2;
+    const gchar *named_dest;
 
-		named_dest = ev_link_dest_get_named_dest (dest);
-		dest2 = ev_document_links_find_link_dest (EV_DOCUMENT_LINKS (view->document),
-							  named_dest);
-		if (dest2) {
-			goto_dest (view, dest2);
-			g_object_unref (dest2);
-		}
+    named_dest = ev_link_dest_get_named_dest (dest);
+    dest2 = ev_document_links_find_link_dest (EV_DOCUMENT_LINKS (view->document),
+                                              named_dest);
+    if (dest2) {
+      goto_dest (view, dest2);
+      g_object_unref (dest2);
+    }
 
-		return;
-	}
+    return;
+  }
 
-	goto_dest (view, dest);
+  goto_dest (view, dest);
 }
-	
+
 void
-ev_view_handle_link (EvView *view, EvLink *link)
-{
-	EvLinkAction    *action = NULL;
-	EvLinkActionType type;
-
-	action = ev_link_get_action (link);
-	if (!action)
-		return;
-
-	type = ev_link_action_get_action_type (action);
-
-	switch (type) {
-	        case EV_LINK_ACTION_TYPE_GOTO_DEST: {
-			EvLinkDest *dest;
-			
-			g_signal_emit (view, signals[SIGNAL_HANDLE_LINK], 0, link);
-		
-			dest = ev_link_action_get_dest (action);
-			ev_view_goto_dest (view, dest);
-		}
-			break;
-	        case EV_LINK_ACTION_TYPE_LAYERS_STATE: {
-			GList            *show, *hide, *toggle;
-			GList            *l;
-			EvDocumentLayers *document_layers;
-
-			document_layers = EV_DOCUMENT_LAYERS (view->document);
-
-			show = ev_link_action_get_show_list (action);
-			for (l = show; l; l = g_list_next (l)) {
-				ev_document_layers_show_layer (document_layers, EV_LAYER (l->data));
-			}
-
-			hide = ev_link_action_get_hide_list (action);
-			for (l = hide; l; l = g_list_next (l)) {
-				ev_document_layers_hide_layer (document_layers, EV_LAYER (l->data));
-			}
-
-			toggle = ev_link_action_get_toggle_list (action);
-			for (l = toggle; l; l = g_list_next (l)) {
-				EvLayer *layer = EV_LAYER (l->data);
-
-				if (ev_document_layers_layer_is_visible (document_layers, layer)) {
-					ev_document_layers_hide_layer (document_layers, layer);
-				} else {
-					ev_document_layers_show_layer (document_layers, layer);
-				}
-			}
-
-			g_signal_emit (view, signals[SIGNAL_LAYERS_CHANGED], 0);
-			ev_view_reload (view);
-		}
-			break;
-	        case EV_LINK_ACTION_TYPE_GOTO_REMOTE:
-	        case EV_LINK_ACTION_TYPE_EXTERNAL_URI:
-	        case EV_LINK_ACTION_TYPE_LAUNCH:
-	        case EV_LINK_ACTION_TYPE_NAMED:
-			g_signal_emit (view, signals[SIGNAL_EXTERNAL_LINK], 0, action);
-			break;
-	}
+ev_view_handle_link (EvView *view, EvLink *link) {
+  EvLinkAction    *action = NULL;
+  EvLinkActionType type;
+
+  action = ev_link_get_action (link);
+  if (!action)
+    return;
+
+  type = ev_link_action_get_action_type (action);
+
+  switch (type) {
+    case EV_LINK_ACTION_TYPE_GOTO_DEST: {
+      EvLinkDest *dest;
+
+      g_signal_emit (view, signals[SIGNAL_HANDLE_LINK], 0, link);
+
+      dest = ev_link_action_get_dest (action);
+      ev_view_goto_dest (view, dest);
+    }
+    break;
+    case EV_LINK_ACTION_TYPE_LAYERS_STATE: {
+      GList            *show, *hide, *toggle;
+      GList            *l;
+      EvDocumentLayers *document_layers;
+
+      document_layers = EV_DOCUMENT_LAYERS (view->document);
+
+      show = ev_link_action_get_show_list (action);
+      for (l = show; l; l = g_list_next (l)) {
+        ev_document_layers_show_layer (document_layers, EV_LAYER (l->data));
+      }
+
+      hide = ev_link_action_get_hide_list (action);
+      for (l = hide; l; l = g_list_next (l)) {
+        ev_document_layers_hide_layer (document_layers, EV_LAYER (l->data));
+      }
+
+      toggle = ev_link_action_get_toggle_list (action);
+      for (l = toggle; l; l = g_list_next (l)) {
+        EvLayer *layer = EV_LAYER (l->data);
+
+        if (ev_document_layers_layer_is_visible (document_layers, layer)) {
+          ev_document_layers_hide_layer (document_layers, layer);
+        } else {
+          ev_document_layers_show_layer (document_layers, layer);
+        }
+      }
+
+      g_signal_emit (view, signals[SIGNAL_LAYERS_CHANGED], 0);
+      ev_view_reload (view);
+    }
+    break;
+    case EV_LINK_ACTION_TYPE_GOTO_REMOTE:
+    case EV_LINK_ACTION_TYPE_EXTERNAL_URI:
+    case EV_LINK_ACTION_TYPE_LAUNCH:
+    case EV_LINK_ACTION_TYPE_NAMED:
+      g_signal_emit (view, signals[SIGNAL_EXTERNAL_LINK], 0, action);
+      break;
+  }
 }
 
 static char *
-tip_from_action_named (EvLinkAction *action)
-{
-	const gchar *name = ev_link_action_get_name (action);
-	
-	if (g_ascii_strcasecmp (name, "FirstPage") == 0) {
-		return g_strdup (_("Go to first page"));
-	} else if (g_ascii_strcasecmp (name, "PrevPage") == 0) {
-		return g_strdup (_("Go to previous page"));
-	} else if (g_ascii_strcasecmp (name, "NextPage") == 0) {
-		return g_strdup (_("Go to next page"));
-	} else if (g_ascii_strcasecmp (name, "LastPage") == 0) {
-		return g_strdup (_("Go to last page"));
-	} else if (g_ascii_strcasecmp (name, "GoToPage") == 0) {
-		return g_strdup (_("Go to page"));
-	} else if (g_ascii_strcasecmp (name, "Find") == 0) {
-		return g_strdup (_("Find"));
-	}
-	
-	return NULL;
+tip_from_action_named (EvLinkAction *action) {
+  const gchar *name = ev_link_action_get_name (action);
+
+  if (g_ascii_strcasecmp (name, "FirstPage") == 0) {
+    return g_strdup (_("Go to first page"));
+  } else if (g_ascii_strcasecmp (name, "PrevPage") == 0) {
+    return g_strdup (_("Go to previous page"));
+  } else if (g_ascii_strcasecmp (name, "NextPage") == 0) {
+    return g_strdup (_("Go to next page"));
+  } else if (g_ascii_strcasecmp (name, "LastPage") == 0) {
+    return g_strdup (_("Go to last page"));
+  } else if (g_ascii_strcasecmp (name, "GoToPage") == 0) {
+    return g_strdup (_("Go to page"));
+  } else if (g_ascii_strcasecmp (name, "Find") == 0) {
+    return g_strdup (_("Find"));
+  }
+
+  return NULL;
 }
 
 static char *
-tip_from_link (EvView *view, EvLink *link)
-{
-	EvLinkAction *action;
-	EvLinkActionType type;
-	char *msg = NULL;
-	char *page_label;
-	const char *title;
-
-	action = ev_link_get_action (link);
-	title = ev_link_get_title (link);
-	
-	if (!action)
-		return title ? g_strdup (title) : NULL;
-		
-	type = ev_link_action_get_action_type (action);
-
-	switch (type) {
-	        case EV_LINK_ACTION_TYPE_GOTO_DEST:
-			page_label = ev_document_links_get_dest_page_label (EV_DOCUMENT_LINKS (view->document),
-									    ev_link_action_get_dest (action));
-			if (page_label) {
-    				msg = g_strdup_printf (_("Go to page %s"), page_label);
-				g_free (page_label);
-			}
-			break;
-	        case EV_LINK_ACTION_TYPE_GOTO_REMOTE:
-			if (title) {
-				msg = g_strdup_printf (_("Go to %s on file “%s”"), title,
-						       ev_link_action_get_filename (action));
-			} else {
-				msg = g_strdup_printf (_("Go to file “%s”"),
-						       ev_link_action_get_filename (action));
-			}
-			break;
-	        case EV_LINK_ACTION_TYPE_EXTERNAL_URI:
-			msg = g_strdup (ev_link_action_get_uri (action));
-			break;
-	        case EV_LINK_ACTION_TYPE_LAUNCH:
-			msg = g_strdup_printf (_("Launch %s"),
-					       ev_link_action_get_filename (action));
-			break;
-	        case EV_LINK_ACTION_TYPE_NAMED:
-			msg = tip_from_action_named (action);
-			break;
-	        default:
-			if (title)
-				msg = g_strdup (title);
-			break;
-	}
-	
-	return msg;
-}
-
-static void
-ev_view_handle_cursor_over_xy (EvView *view, gint x, gint y)
-{
-	EvLink       *link;
-	EvFormField  *field;
-	EvAnnotation *annot = NULL;
-	EvMedia      *media;
-
-	if (view->cursor == EV_VIEW_CURSOR_HIDDEN)
-		return;
-
-	if (view->adding_annot_info.adding_annot) {
-		if (view->adding_annot_info.type == EV_ANNOTATION_TYPE_TEXT_MARKUP) {
-			ev_view_set_cursor (view, EV_VIEW_CURSOR_IBEAM);
-		} else if (!view->adding_annot_info.annot) {
-			ev_view_set_cursor (view, EV_VIEW_CURSOR_ADD);
-		}
-		return;
-	}
-
-	if (view->drag_info.in_drag) {
-		if (view->cursor != EV_VIEW_CURSOR_DRAG)
-			ev_view_set_cursor (view, EV_VIEW_CURSOR_DRAG);
-		return;
-	}
-
-	if (view->scroll_info.autoscrolling) {
-		if (view->cursor != EV_VIEW_CURSOR_AUTOSCROLL)
-			ev_view_set_cursor (view, EV_VIEW_CURSOR_AUTOSCROLL);
-		return;
-	}
-
-	link = ev_view_get_link_at_location (view, x, y);
-        if (link) {
-		ev_view_set_cursor (view, EV_VIEW_CURSOR_LINK);
-	} else if ((field = ev_view_get_form_field_at_location (view, x, y))) {
-		if (field->is_read_only) {
-			if (view->cursor == EV_VIEW_CURSOR_LINK ||
-			    view->cursor == EV_VIEW_CURSOR_IBEAM ||
-			    view->cursor == EV_VIEW_CURSOR_DRAG)
-				ev_view_set_cursor (view, EV_VIEW_CURSOR_NORMAL);
-		} else if (EV_IS_FORM_FIELD_TEXT (field)) {
-			ev_view_set_cursor (view, EV_VIEW_CURSOR_IBEAM);
-		} else {
-			ev_view_set_cursor (view, EV_VIEW_CURSOR_LINK);
-		}
-	} else if ((media = ev_view_get_media_at_location (view, x, y))) {
-		if (!ev_view_find_player_for_media (view, media))
-			ev_view_set_cursor (view, EV_VIEW_CURSOR_LINK);
-		else
-			ev_view_set_cursor (view, EV_VIEW_CURSOR_NORMAL);
-	} else if ((annot = ev_view_get_annotation_at_location (view, x, y))) {
-		ev_view_set_cursor (view, EV_VIEW_CURSOR_LINK);
-	} else if (location_in_text (view, x + view->scroll_x, y + view->scroll_y)) {
-		ev_view_set_cursor (view, EV_VIEW_CURSOR_IBEAM);
-	} else {
-		if (view->cursor == EV_VIEW_CURSOR_LINK ||
-		    view->cursor == EV_VIEW_CURSOR_IBEAM ||
-		    view->cursor == EV_VIEW_CURSOR_DRAG ||
-		    view->cursor == EV_VIEW_CURSOR_AUTOSCROLL ||
-		    view->cursor == EV_VIEW_CURSOR_ADD)
-			ev_view_set_cursor (view, EV_VIEW_CURSOR_NORMAL);
-	}
-
-	if (link || annot)
-		g_object_set (view, "has-tooltip", TRUE, NULL);
+tip_from_link (EvView *view, EvLink *link) {
+  EvLinkAction *action;
+  EvLinkActionType type;
+  char *msg = NULL;
+  char *page_label;
+  const char *title;
+
+  action = ev_link_get_action (link);
+  title = ev_link_get_title (link);
+
+  if (!action)
+    return title ? g_strdup (title) : NULL;
+
+  type = ev_link_action_get_action_type (action);
+
+  switch (type) {
+    case EV_LINK_ACTION_TYPE_GOTO_DEST:
+      page_label = ev_document_links_get_dest_page_label (EV_DOCUMENT_LINKS (view->document),
+                                                          ev_link_action_get_dest (action));
+      if (page_label) {
+        msg = g_strdup_printf (_("Go to page %s"), page_label);
+        g_free (page_label);
+      }
+      break;
+    case EV_LINK_ACTION_TYPE_GOTO_REMOTE:
+      if (title) {
+        msg = g_strdup_printf (_("Go to %s on file “%s”"), title,
+                               ev_link_action_get_filename (action));
+      } else {
+        msg = g_strdup_printf (_("Go to file “%s”"),
+                               ev_link_action_get_filename (action));
+      }
+      break;
+    case EV_LINK_ACTION_TYPE_EXTERNAL_URI:
+      msg = g_strdup (ev_link_action_get_uri (action));
+      break;
+    case EV_LINK_ACTION_TYPE_LAUNCH:
+      msg = g_strdup_printf (_("Launch %s"),
+                             ev_link_action_get_filename (action));
+      break;
+    case EV_LINK_ACTION_TYPE_NAMED:
+      msg = tip_from_action_named (action);
+      break;
+    default:
+      if (title)
+        msg = g_strdup (title);
+      break;
+  }
+
+  return msg;
+}
+
+static void
+ev_view_handle_cursor_over_xy (EvView *view, gint x, gint y) {
+  EvLink       *link;
+  EvFormField  *field;
+  EvAnnotation *annot = NULL;
+  EvMedia      *media;
+
+  if (view->cursor == EV_VIEW_CURSOR_HIDDEN)
+    return;
+
+  if (view->adding_annot_info.adding_annot) {
+    if (view->adding_annot_info.type == EV_ANNOTATION_TYPE_TEXT_MARKUP) {
+      ev_view_set_cursor (view, EV_VIEW_CURSOR_IBEAM);
+    } else if (!view->adding_annot_info.annot) {
+      ev_view_set_cursor (view, EV_VIEW_CURSOR_ADD);
+    }
+    return;
+  }
+
+  if (view->drag_info.in_drag) {
+    if (view->cursor != EV_VIEW_CURSOR_DRAG)
+      ev_view_set_cursor (view, EV_VIEW_CURSOR_DRAG);
+    return;
+  }
+
+  if (view->scroll_info.autoscrolling) {
+    if (view->cursor != EV_VIEW_CURSOR_AUTOSCROLL)
+      ev_view_set_cursor (view, EV_VIEW_CURSOR_AUTOSCROLL);
+    return;
+  }
+
+  link = ev_view_get_link_at_location (view, x, y);
+  if (link) {
+    ev_view_set_cursor (view, EV_VIEW_CURSOR_LINK);
+  } else if ((field = ev_view_get_form_field_at_location (view, x, y))) {
+    if (field->is_read_only) {
+      if (view->cursor == EV_VIEW_CURSOR_LINK ||
+          view->cursor == EV_VIEW_CURSOR_IBEAM ||
+          view->cursor == EV_VIEW_CURSOR_DRAG)
+        ev_view_set_cursor (view, EV_VIEW_CURSOR_NORMAL);
+    } else if (EV_IS_FORM_FIELD_TEXT (field)) {
+      ev_view_set_cursor (view, EV_VIEW_CURSOR_IBEAM);
+    } else {
+      ev_view_set_cursor (view, EV_VIEW_CURSOR_LINK);
+    }
+  } else if ((media = ev_view_get_media_at_location (view, x, y))) {
+    if (!ev_view_find_player_for_media (view, media))
+      ev_view_set_cursor (view, EV_VIEW_CURSOR_LINK);
+    else
+      ev_view_set_cursor (view, EV_VIEW_CURSOR_NORMAL);
+  } else if ((annot = ev_view_get_annotation_at_location (view, x, y))) {
+    ev_view_set_cursor (view, EV_VIEW_CURSOR_LINK);
+  } else if (location_in_text (view, x + view->scroll_x, y + view->scroll_y)) {
+    ev_view_set_cursor (view, EV_VIEW_CURSOR_IBEAM);
+  } else {
+    if (view->cursor == EV_VIEW_CURSOR_LINK ||
+        view->cursor == EV_VIEW_CURSOR_IBEAM ||
+        view->cursor == EV_VIEW_CURSOR_DRAG ||
+        view->cursor == EV_VIEW_CURSOR_AUTOSCROLL ||
+        view->cursor == EV_VIEW_CURSOR_ADD)
+      ev_view_set_cursor (view, EV_VIEW_CURSOR_NORMAL);
+  }
+
+  if (link || annot)
+    g_object_set (view, "has-tooltip", TRUE, NULL);
 }
 
 /*** Images ***/
 static EvImage *
 ev_view_get_image_at_location (EvView  *view,
-			       gdouble  x,
-			       gdouble  y)
-{
-	gint page = -1;
-	gint x_new = 0, y_new = 0;
-	EvMappingList *image_mapping;
+                               gdouble  x,
+                               gdouble  y) {
+  gint page = -1;
+  gint x_new = 0, y_new = 0;
+  EvMappingList *image_mapping;
 
-	if (!EV_IS_DOCUMENT_IMAGES (view->document))
-		return NULL;
+  if (!EV_IS_DOCUMENT_IMAGES (view->document))
+    return NULL;
 
-	if (!get_doc_point_from_location (view, x, y, &page, &x_new, &y_new))
-		return NULL;
+  if (!get_doc_point_from_location (view, x, y, &page, &x_new, &y_new))
+    return NULL;
 
-	image_mapping = ev_page_cache_get_image_mapping (view->page_cache, page);
+  image_mapping = ev_page_cache_get_image_mapping (view->page_cache, page);
 
-	if (image_mapping)
-		return ev_mapping_list_get_data (image_mapping, x_new, y_new);
-	else
-		return NULL;
+  if (image_mapping)
+    return ev_mapping_list_get_data (image_mapping, x_new, y_new);
+  else
+    return NULL;
 }
 
 /*** Focus ***/
 static gboolean
 ev_view_get_focused_area (EvView       *view,
-			  GdkRectangle *area)
-{
-	if (!view->focused_element)
-		return FALSE;
+                          GdkRectangle *area) {
+  if (!view->focused_element)
+    return FALSE;
 
-	_ev_view_transform_doc_rect_to_view_rect (view,
-						  view->focused_element_page,
-						  &view->focused_element->area,
-						  area);
-	area->x -= view->scroll_x + 1;
-	area->y -= view->scroll_y + 1;
-	area->width += 1;
-	area->height += 1;
+  _ev_view_transform_doc_rect_to_view_rect (view,
+                                            view->focused_element_page,
+                                            &view->focused_element->area,
+                                            area);
+  area->x -= view->scroll_x + 1;
+  area->y -= view->scroll_y + 1;
+  area->width += 1;
+  area->height += 1;
 
-	return TRUE;
+  return TRUE;
 }
 
 void
 _ev_view_set_focused_element (EvView *view,
-			     EvMapping *element_mapping,
-			     gint page)
-{
-	GdkRectangle    view_rect;
-	cairo_region_t *region = NULL;
+                              EvMapping *element_mapping,
+                              gint page) {
+  GdkRectangle    view_rect;
+  cairo_region_t *region = NULL;
 
-	if (view->accessible)
-		ev_view_accessible_set_focused_element (EV_VIEW_ACCESSIBLE (view->accessible), element_mapping, page);
+  if (view->accessible)
+    ev_view_accessible_set_focused_element (EV_VIEW_ACCESSIBLE (view->accessible), element_mapping, page);
 
-	if (ev_view_get_focused_area (view, &view_rect))
-		region = cairo_region_create_rectangle (&view_rect);
+  if (ev_view_get_focused_area (view, &view_rect))
+    region = cairo_region_create_rectangle (&view_rect);
 
-	view->focused_element = element_mapping;
-	view->focused_element_page = page;
+  view->focused_element = element_mapping;
+  view->focused_element_page = page;
 
-	if (ev_view_get_focused_area (view, &view_rect)) {
-		if (!region)
-			region = cairo_region_create_rectangle (&view_rect);
-		else
-			cairo_region_union_rectangle (region, &view_rect);
+  if (ev_view_get_focused_area (view, &view_rect)) {
+    if (!region)
+      region = cairo_region_create_rectangle (&view_rect);
+    else
+      cairo_region_union_rectangle (region, &view_rect);
 
-		ev_document_model_set_page (view->model, page);
-		view_rect.x += view->scroll_x;
-		view_rect.y += view->scroll_y;
-		_ev_view_ensure_rectangle_is_visible (view, &view_rect);
-	}
+    ev_document_model_set_page (view->model, page);
+    view_rect.x += view->scroll_x;
+    view_rect.y += view->scroll_y;
+    _ev_view_ensure_rectangle_is_visible (view, &view_rect);
+  }
 
-	if (region) {
-		gdk_window_invalidate_region (gtk_widget_get_window (GTK_WIDGET (view)),
-					      region, TRUE);
-		cairo_region_destroy (region);
-	}
+  if (region) {
+    gdk_window_invalidate_region (gtk_widget_get_window (GTK_WIDGET (view)),
+                                  region, TRUE);
+    cairo_region_destroy (region);
+  }
 }
 
 /*** Forms ***/
 static EvMapping *
 get_form_field_mapping_at_location (EvView  *view,
-				    gdouble  x,
-				    gdouble  y,
-				    gint    *page)
-{
-	gint x_new = 0, y_new = 0;
-	EvMappingList *forms_mapping;
+                                    gdouble  x,
+                                    gdouble  y,
+                                    gint    *page) {
+  gint x_new = 0, y_new = 0;
+  EvMappingList *forms_mapping;
 
-	if (!EV_IS_DOCUMENT_FORMS (view->document))
-		return NULL;
+  if (!EV_IS_DOCUMENT_FORMS (view->document))
+    return NULL;
 
-	if (!get_doc_point_from_location (view, x, y, page, &x_new, &y_new))
-		return NULL;
+  if (!get_doc_point_from_location (view, x, y, page, &x_new, &y_new))
+    return NULL;
 
-	forms_mapping = ev_page_cache_get_form_field_mapping (view->page_cache, *page);
+  forms_mapping = ev_page_cache_get_form_field_mapping (view->page_cache, *page);
 
-	if (forms_mapping)
-		return ev_mapping_list_get (forms_mapping, x_new, y_new);
+  if (forms_mapping)
+    return ev_mapping_list_get (forms_mapping, x_new, y_new);
 
-	return NULL;
+  return NULL;
 }
 
 static EvFormField *
 ev_view_get_form_field_at_location (EvView  *view,
-				    gdouble  x,
-				    gdouble  y)
-{
-	EvMapping *field_mapping;
-	gint page;
+                                    gdouble  x,
+                                    gdouble  y) {
+  EvMapping *field_mapping;
+  gint page;
 
-	field_mapping = get_form_field_mapping_at_location (view, x, y, &page);
+  field_mapping = get_form_field_mapping_at_location (view, x, y, &page);
 
-	return field_mapping ? field_mapping->data : NULL;
+  return field_mapping ? field_mapping->data : NULL;
 }
 
 static cairo_region_t *
 ev_view_form_field_get_region (EvView      *view,
-			       EvFormField *field)
-{
-	GdkRectangle   view_area;
-	EvMappingList *forms_mapping;
+                               EvFormField *field) {
+  GdkRectangle   view_area;
+  EvMappingList *forms_mapping;
 
-	forms_mapping = ev_page_cache_get_form_field_mapping (view->page_cache,
-							      field->page->index);
-	ev_view_get_area_from_mapping (view, field->page->index,
-				       forms_mapping,
-				       field, &view_area);
+  forms_mapping = ev_page_cache_get_form_field_mapping (view->page_cache,
+                                                        field->page->index);
+  ev_view_get_area_from_mapping (view, field->page->index,
+                                 forms_mapping,
+                                 field, &view_area);
 
-	return cairo_region_create_rectangle (&view_area);
+  return cairo_region_create_rectangle (&view_area);
 }
 
 static gboolean
-ev_view_forms_remove_widgets (EvView *view)
-{
-	ev_view_remove_all_form_fields (view);
+ev_view_forms_remove_widgets (EvView *view) {
+  ev_view_remove_all_form_fields (view);
 
-	return FALSE;
+  return FALSE;
 }
 
 static void
 ev_view_form_field_destroy (GtkWidget *widget,
-			    EvView    *view)
-{
-	g_idle_add ((GSourceFunc)ev_view_forms_remove_widgets, view);
+                            EvView    *view) {
+  g_idle_add ((GSourceFunc)ev_view_forms_remove_widgets, view);
 }
 
 static void
 ev_view_form_field_button_toggle (EvView      *view,
-				  EvFormField *field)
-{
-	EvMappingList     *forms_mapping;
-	cairo_region_t    *region;
-	gboolean           state;
-	GList             *l;
-	EvFormFieldButton *field_button = EV_FORM_FIELD_BUTTON (field);
+                                  EvFormField *field) {
+  EvMappingList     *forms_mapping;
+  cairo_region_t    *region;
+  gboolean           state;
+  GList             *l;
+  EvFormFieldButton *field_button = EV_FORM_FIELD_BUTTON (field);
 
-	if (field_button->type == EV_FORM_FIELD_BUTTON_PUSH)
-		return;
+  if (field_button->type == EV_FORM_FIELD_BUTTON_PUSH)
+    return;
 
-	state = ev_document_forms_form_field_button_get_state (EV_DOCUMENT_FORMS (view->document),
-							       field);
+  state = ev_document_forms_form_field_button_get_state (EV_DOCUMENT_FORMS (view->document),
+                                                         field);
 
-	/* FIXME: it actually depends on NoToggleToOff flags */
-	if (field_button->type == EV_FORM_FIELD_BUTTON_RADIO && state && field_button->state)
-		return;
+  /* FIXME: it actually depends on NoToggleToOff flags */
+  if (field_button->type == EV_FORM_FIELD_BUTTON_RADIO && state && field_button->state)
+    return;
 
-	region = ev_view_form_field_get_region (view, field);
+  region = ev_view_form_field_get_region (view, field);
 
-	/* For radio buttons and checkbox buttons that are in a set
-	 * we need to update also the region for the current selected item
-	 */
-	forms_mapping = ev_page_cache_get_form_field_mapping (view->page_cache,
-							      field->page->index);
+  /* For radio buttons and checkbox buttons that are in a set
+   * we need to update also the region for the current selected item
+   */
+  forms_mapping = ev_page_cache_get_form_field_mapping (view->page_cache,
+                                                        field->page->index);
 
-	for (l = ev_mapping_list_get_list (forms_mapping); l; l = g_list_next (l)) {
-		EvFormField *button = ((EvMapping *)(l->data))->data;
-		cairo_region_t *button_region;
+  for (l = ev_mapping_list_get_list (forms_mapping); l; l = g_list_next (l)) {
+    EvFormField *button = ((EvMapping *)(l->data))->data;
+    cairo_region_t *button_region;
 
-		if (button->id == field->id)
-			continue;
+    if (button->id == field->id)
+      continue;
 
-		/* FIXME: only buttons in the same group should be updated */
-		if (!EV_IS_FORM_FIELD_BUTTON (button) ||
-		    EV_FORM_FIELD_BUTTON (button)->type != field_button->type ||
-		    EV_FORM_FIELD_BUTTON (button)->state != TRUE)
-			continue;
+    /* FIXME: only buttons in the same group should be updated */
+    if (!EV_IS_FORM_FIELD_BUTTON (button) ||
+        EV_FORM_FIELD_BUTTON (button)->type != field_button->type ||
+        EV_FORM_FIELD_BUTTON (button)->state != TRUE)
+      continue;
 
-		button_region = ev_view_form_field_get_region (view, button);
-		cairo_region_union (region, button_region);
-		cairo_region_destroy (button_region);
-	}
+    button_region = ev_view_form_field_get_region (view, button);
+    cairo_region_union (region, button_region);
+    cairo_region_destroy (button_region);
+  }
 
-	/* Update state */
-	ev_document_forms_form_field_button_set_state (EV_DOCUMENT_FORMS (view->document),
-						       field,
-						       !state);
-	field_button->state = !state;
+  /* Update state */
+  ev_document_forms_form_field_button_set_state (EV_DOCUMENT_FORMS (view->document),
+                                                 field,
+                                                 !state);
+  field_button->state = !state;
 
-	if (view->accessible)
-		ev_view_accessible_update_element_state (EV_VIEW_ACCESSIBLE (view->accessible),
-							 ev_mapping_list_find (forms_mapping, field),
-							 field->page->index);
+  if (view->accessible)
+    ev_view_accessible_update_element_state (EV_VIEW_ACCESSIBLE (view->accessible),
+                                             ev_mapping_list_find (forms_mapping, field),
+                                             field->page->index);
 
-	ev_view_reload_page (view, field->page->index, region);
-	cairo_region_destroy (region);
+  ev_view_reload_page (view, field->page->index, region);
+  cairo_region_destroy (region);
 }
 
 static GtkWidget *
 ev_view_form_field_button_create_widget (EvView      *view,
-					 EvFormField *field)
-{
-	EvMappingList *form_mapping;
-	EvMapping     *mapping;
+                                         EvFormField *field) {
+  EvMappingList *form_mapping;
+  EvMapping     *mapping;
 
-	/* We need to do this focus grab prior to setting the focused element for accessibility */
-	if (!gtk_widget_has_focus (GTK_WIDGET (view)))
-		gtk_widget_grab_focus (GTK_WIDGET (view));
+  /* We need to do this focus grab prior to setting the focused element for accessibility */
+  if (!gtk_widget_has_focus (GTK_WIDGET (view)))
+    gtk_widget_grab_focus (GTK_WIDGET (view));
 
-	form_mapping = ev_page_cache_get_form_field_mapping (view->page_cache,
-							     field->page->index);
-	mapping = ev_mapping_list_find (form_mapping, field);
-	_ev_view_set_focused_element (view, mapping, field->page->index);
+  form_mapping = ev_page_cache_get_form_field_mapping (view->page_cache,
+                                                       field->page->index);
+  mapping = ev_mapping_list_find (form_mapping, field);
+  _ev_view_set_focused_element (view, mapping, field->page->index);
 
-	return NULL;
+  return NULL;
 }
 
 static void
 ev_view_form_field_text_save (EvView    *view,
-			      GtkWidget *widget)
-{
-	EvFormField *field;
-
-	if (!view->document)
-		return;
-	
-	field = g_object_get_data (G_OBJECT (widget), "form-field");
-	
-	if (field->changed) {
-		EvFormFieldText *field_text = EV_FORM_FIELD_TEXT (field);
-		cairo_region_t  *field_region;
-
-		field_region = ev_view_form_field_get_region (view, field);
-		
-		ev_document_forms_form_field_text_set_text (EV_DOCUMENT_FORMS (view->document),
-							    field, field_text->text);
-		field->changed = FALSE;
-		ev_view_reload_page (view, field->page->index, field_region);
-		cairo_region_destroy (field_region);
-	}
+                              GtkWidget *widget) {
+  EvFormField *field;
+
+  if (!view->document)
+    return;
+
+  field = g_object_get_data (G_OBJECT (widget), "form-field");
+
+  if (field->changed) {
+    EvFormFieldText *field_text = EV_FORM_FIELD_TEXT (field);
+    cairo_region_t  *field_region;
+
+    field_region = ev_view_form_field_get_region (view, field);
+
+    ev_document_forms_form_field_text_set_text (EV_DOCUMENT_FORMS (view->document),
+                                                field, field_text->text);
+    field->changed = FALSE;
+    ev_view_reload_page (view, field->page->index, field_region);
+    cairo_region_destroy (field_region);
+  }
 }
 
 static void
 ev_view_form_field_text_changed (GtkWidget   *widget,
-				 EvFormField *field)
-{
-	EvFormFieldText *field_text = EV_FORM_FIELD_TEXT (field);
-	gchar           *text = NULL;
+                                 EvFormField *field) {
+  EvFormFieldText *field_text = EV_FORM_FIELD_TEXT (field);
+  gchar           *text = NULL;
 
-	if (GTK_IS_ENTRY (widget)) {
-		text = g_strdup (gtk_entry_get_text (GTK_ENTRY (widget)));
-	} else if (GTK_IS_TEXT_BUFFER (widget)) {
-		GtkTextIter start, end;
+  if (GTK_IS_ENTRY (widget)) {
+    text = g_strdup (gtk_entry_get_text (GTK_ENTRY (widget)));
+  } else if (GTK_IS_TEXT_BUFFER (widget)) {
+    GtkTextIter start, end;
 
-		gtk_text_buffer_get_bounds (GTK_TEXT_BUFFER (widget), &start, &end);
-		text = gtk_text_buffer_get_text (GTK_TEXT_BUFFER (widget),
-						 &start, &end, FALSE);
-	}
+    gtk_text_buffer_get_bounds (GTK_TEXT_BUFFER (widget), &start, &end);
+    text = gtk_text_buffer_get_text (GTK_TEXT_BUFFER (widget),
+                                     &start, &end, FALSE);
+  }
 
-	if (!field_text->text ||
-	    (field_text->text && g_ascii_strcasecmp (field_text->text, text) != 0)) {
-		g_free (field_text->text);
-		field_text->text = text;
-		field->changed = TRUE;
-	}
+  if (!field_text->text ||
+      (field_text->text && g_ascii_strcasecmp (field_text->text, text) != 0)) {
+    g_free (field_text->text);
+    field_text->text = text;
+    field->changed = TRUE;
+  }
 }
 
 static gboolean
 ev_view_form_field_text_focus_out (GtkWidget     *widget,
-				   GdkEventFocus *event,
-				   EvView        *view)
-{
-	ev_view_form_field_text_save (view, widget);
+                                   GdkEventFocus *event,
+                                   EvView        *view) {
+  ev_view_form_field_text_save (view, widget);
 
-	return FALSE;
+  return FALSE;
 }
 
 static GtkWidget *
 ev_view_form_field_text_create_widget (EvView      *view,
-				       EvFormField *field)
-{
-	EvFormFieldText *field_text = EV_FORM_FIELD_TEXT (field);
-	GtkWidget       *text = NULL;
-	gchar           *txt;
-	GtkStyleContext *context;
-
-	txt = ev_document_forms_form_field_text_get_text (EV_DOCUMENT_FORMS (view->document),
-							  field);
-
-	switch (field_text->type) {
-	        case EV_FORM_FIELD_TEXT_FILE_SELECT:
-			/* TODO */
-	        case EV_FORM_FIELD_TEXT_NORMAL:
-			text = gtk_entry_new ();
-			gtk_entry_set_has_frame (GTK_ENTRY (text), FALSE);
-			/* Remove '.flat' style added by previous call
-			 * gtk_entry_set_has_frame(FALSE) which caused bug #687 */
-			context = gtk_widget_get_style_context (text);
-			gtk_style_context_remove_class (context, GTK_STYLE_CLASS_FLAT);
-			gtk_entry_set_max_length (GTK_ENTRY (text), field_text->max_len);
-			gtk_entry_set_visibility (GTK_ENTRY (text), !field_text->is_password);
-			
-			if (txt) {
-				gtk_entry_set_text (GTK_ENTRY (text), txt);
-				g_free (txt);
-			}
-
-			g_signal_connect (text, "focus-out-event",
-					  G_CALLBACK (ev_view_form_field_text_focus_out),
-					  view);
-			g_signal_connect (text, "changed",
-					  G_CALLBACK (ev_view_form_field_text_changed),
-					  field);
-			g_signal_connect_after (text, "activate",
-						G_CALLBACK (ev_view_form_field_destroy),
-						view);
-			break;
-	        case EV_FORM_FIELD_TEXT_MULTILINE: {
-			GtkTextBuffer *buffer;
-		
-			text = gtk_text_view_new ();
-			buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (text));
-			
-			if (txt) {
-				gtk_text_buffer_set_text (buffer, txt, -1);
-				g_free (txt);
-			}
-
-			g_signal_connect (text, "focus-out-event",
-					  G_CALLBACK (ev_view_form_field_text_focus_out),
-					  view);
-			g_signal_connect (buffer, "changed",
-					  G_CALLBACK (ev_view_form_field_text_changed),
-					  field);
-		}
-			break;
-	}			
-
-	g_object_weak_ref (G_OBJECT (text),
-			   (GWeakNotify)ev_view_form_field_text_save,
-			   view);
-
-	return text;
+                                       EvFormField *field) {
+  EvFormFieldText *field_text = EV_FORM_FIELD_TEXT (field);
+  GtkWidget       *text = NULL;
+  gchar           *txt;
+  GtkStyleContext *context;
+
+  txt = ev_document_forms_form_field_text_get_text (EV_DOCUMENT_FORMS (view->document),
+                                                    field);
+
+  switch (field_text->type) {
+    case EV_FORM_FIELD_TEXT_FILE_SELECT:
+    /* TODO */
+    case EV_FORM_FIELD_TEXT_NORMAL:
+      text = gtk_entry_new ();
+      gtk_entry_set_has_frame (GTK_ENTRY (text), FALSE);
+      /* Remove '.flat' style added by previous call
+       * gtk_entry_set_has_frame(FALSE) which caused bug #687 */
+      context = gtk_widget_get_style_context (text);
+      gtk_style_context_remove_class (context, GTK_STYLE_CLASS_FLAT);
+      gtk_entry_set_max_length (GTK_ENTRY (text), field_text->max_len);
+      gtk_entry_set_visibility (GTK_ENTRY (text), !field_text->is_password);
+
+      if (txt) {
+        gtk_entry_set_text (GTK_ENTRY (text), txt);
+        g_free (txt);
+      }
+
+      g_signal_connect (text, "focus-out-event",
+                        G_CALLBACK (ev_view_form_field_text_focus_out),
+                        view);
+      g_signal_connect (text, "changed",
+                        G_CALLBACK (ev_view_form_field_text_changed),
+                        field);
+      g_signal_connect_after (text, "activate",
+                              G_CALLBACK (ev_view_form_field_destroy),
+                              view);
+      break;
+    case EV_FORM_FIELD_TEXT_MULTILINE: {
+      GtkTextBuffer *buffer;
+
+      text = gtk_text_view_new ();
+      buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (text));
+
+      if (txt) {
+        gtk_text_buffer_set_text (buffer, txt, -1);
+        g_free (txt);
+      }
+
+      g_signal_connect (text, "focus-out-event",
+                        G_CALLBACK (ev_view_form_field_text_focus_out),
+                        view);
+      g_signal_connect (buffer, "changed",
+                        G_CALLBACK (ev_view_form_field_text_changed),
+                        field);
+    }
+    break;
+  }
+
+  g_object_weak_ref (G_OBJECT (text),
+                     (GWeakNotify)ev_view_form_field_text_save,
+                     view);
+
+  return text;
 }
 
 static void
 ev_view_form_field_choice_save (EvView    *view,
-				GtkWidget *widget)
-{
-	EvFormField *field;
-
-	if (!view->document)
-		return;
-	
-	field = g_object_get_data (G_OBJECT (widget), "form-field");
-
-	if (field->changed) {
-		GList             *l;
-		EvFormFieldChoice *field_choice = EV_FORM_FIELD_CHOICE (field);
-		cairo_region_t    *field_region;
-
-		field_region = ev_view_form_field_get_region (view, field);
-
-		if (field_choice->is_editable) {
-			ev_document_forms_form_field_choice_set_text (EV_DOCUMENT_FORMS (view->document),
-								      field, field_choice->text);
-		} else {
-			ev_document_forms_form_field_choice_unselect_all (EV_DOCUMENT_FORMS (view->document), field);
-			for (l = field_choice->selected_items; l; l = g_list_next (l)) {
-				ev_document_forms_form_field_choice_select_item (EV_DOCUMENT_FORMS (view->document),
-										 field,
-										 GPOINTER_TO_INT (l->data));
-			}
-		}
-		field->changed = FALSE;
-		ev_view_reload_page (view, field->page->index, field_region);
-		cairo_region_destroy (field_region);
-	}
+                                GtkWidget *widget) {
+  EvFormField *field;
+
+  if (!view->document)
+    return;
+
+  field = g_object_get_data (G_OBJECT (widget), "form-field");
+
+  if (field->changed) {
+    GList             *l;
+    EvFormFieldChoice *field_choice = EV_FORM_FIELD_CHOICE (field);
+    cairo_region_t    *field_region;
+
+    field_region = ev_view_form_field_get_region (view, field);
+
+    if (field_choice->is_editable) {
+      ev_document_forms_form_field_choice_set_text (EV_DOCUMENT_FORMS (view->document),
+                                                    field, field_choice->text);
+    } else {
+      ev_document_forms_form_field_choice_unselect_all (EV_DOCUMENT_FORMS (view->document), field);
+      for (l = field_choice->selected_items; l; l = g_list_next (l)) {
+        ev_document_forms_form_field_choice_select_item (EV_DOCUMENT_FORMS (view->document),
+                                                         field,
+                                                         GPOINTER_TO_INT (l->data));
+      }
+    }
+    field->changed = FALSE;
+    ev_view_reload_page (view, field->page->index, field_region);
+    cairo_region_destroy (field_region);
+  }
 }
 
 static void
 ev_view_form_field_choice_changed (GtkWidget   *widget,
-				   EvFormField *field)
-{
-	EvFormFieldChoice *field_choice = EV_FORM_FIELD_CHOICE (field);
-	
-	if (GTK_IS_COMBO_BOX (widget)) {
-		gint item;
-		
-		item = gtk_combo_box_get_active (GTK_COMBO_BOX (widget));
-		if (item != -1 && (!field_choice->selected_items ||
-		    GPOINTER_TO_INT (field_choice->selected_items->data) != item)) {
-			g_list_free (field_choice->selected_items);
-			field_choice->selected_items = NULL;
-			field_choice->selected_items = g_list_prepend (field_choice->selected_items,
-								       GINT_TO_POINTER (item));
-			field->changed = TRUE;
-		}
-
-		if (gtk_combo_box_get_has_entry (GTK_COMBO_BOX (widget))) {
-			const gchar *text;
-
-			text = gtk_entry_get_text (GTK_ENTRY (gtk_bin_get_child (GTK_BIN (widget))));
-			if (!field_choice->text ||
-			    (field_choice->text && g_ascii_strcasecmp (field_choice->text, text) != 0)) {
-				g_free (field_choice->text);
-				field_choice->text = g_strdup (text);
-				field->changed = TRUE;
-			}
-		}
-	} else if (GTK_IS_TREE_SELECTION (widget)) {
-		GtkTreeSelection *selection = GTK_TREE_SELECTION (widget);
-		GtkTreeModel     *model;
-		GList            *items, *l;
-		
-		items = gtk_tree_selection_get_selected_rows (selection, &model);
-		g_list_free (field_choice->selected_items);
-		field_choice->selected_items = NULL;
-
-		for (l = items; l && l->data; l = g_list_next (l)) {
-			GtkTreeIter  iter;
-			GtkTreePath *path = (GtkTreePath *)l->data;
-			gint         item;
-			
-			gtk_tree_model_get_iter (model, &iter, path);
-			gtk_tree_model_get (model, &iter, 1, &item, -1);
-
-			field_choice->selected_items = g_list_prepend (field_choice->selected_items,
-								       GINT_TO_POINTER (item));
-
-			gtk_tree_path_free (path);
-		}
-
-		g_list_free (items);
-
-		field->changed = TRUE;
-	}
+                                   EvFormField *field) {
+  EvFormFieldChoice *field_choice = EV_FORM_FIELD_CHOICE (field);
+
+  if (GTK_IS_COMBO_BOX (widget)) {
+    gint item;
+
+    item = gtk_combo_box_get_active (GTK_COMBO_BOX (widget));
+    if (item != -1 && (!field_choice->selected_items ||
+                       GPOINTER_TO_INT (field_choice->selected_items->data) != item)) {
+      g_list_free (field_choice->selected_items);
+      field_choice->selected_items = NULL;
+      field_choice->selected_items = g_list_prepend (field_choice->selected_items,
+                                                     GINT_TO_POINTER (item));
+      field->changed = TRUE;
+    }
+
+    if (gtk_combo_box_get_has_entry (GTK_COMBO_BOX (widget))) {
+      const gchar *text;
+
+      text = gtk_entry_get_text (GTK_ENTRY (gtk_bin_get_child (GTK_BIN (widget))));
+      if (!field_choice->text ||
+          (field_choice->text && g_ascii_strcasecmp (field_choice->text, text) != 0)) {
+        g_free (field_choice->text);
+        field_choice->text = g_strdup (text);
+        field->changed = TRUE;
+      }
+    }
+  } else if (GTK_IS_TREE_SELECTION (widget)) {
+    GtkTreeSelection *selection = GTK_TREE_SELECTION (widget);
+    GtkTreeModel     *model;
+    GList            *items, *l;
+
+    items = gtk_tree_selection_get_selected_rows (selection, &model);
+    g_list_free (field_choice->selected_items);
+    field_choice->selected_items = NULL;
+
+    for (l = items; l && l->data; l = g_list_next (l)) {
+      GtkTreeIter  iter;
+      GtkTreePath *path = (GtkTreePath *)l->data;
+      gint         item;
+
+      gtk_tree_model_get_iter (model, &iter, path);
+      gtk_tree_model_get (model, &iter, 1, &item, -1);
+
+      field_choice->selected_items = g_list_prepend (field_choice->selected_items,
+                                                     GINT_TO_POINTER (item));
+
+      gtk_tree_path_free (path);
+    }
+
+    g_list_free (items);
+
+    field->changed = TRUE;
+  }
 }
 
 typedef struct _PopupShownData {
-	GtkWidget   *choice;
-	EvFormField *field;
-	EvView      *view;
+  GtkWidget   *choice;
+  EvFormField *field;
+  EvView      *view;
 } PopupShownData;
 
 static gboolean
-ev_view_form_field_choice_popup_shown_real (PopupShownData *data)
-{
-	ev_view_form_field_choice_changed (data->choice, data->field);
-	ev_view_form_field_destroy (data->choice, data->view);
+ev_view_form_field_choice_popup_shown_real (PopupShownData *data) {
+  ev_view_form_field_choice_changed (data->choice, data->field);
+  ev_view_form_field_destroy (data->choice, data->view);
 
-	g_object_unref (data->choice);
-	g_object_unref (data->field);
-	g_free (data);
+  g_object_unref (data->choice);
+  g_object_unref (data->field);
+  g_free (data);
 
-	return FALSE;
+  return FALSE;
 }
 
 static void
 ev_view_form_field_choice_popup_shown_cb (GObject    *self,
-					  GParamSpec *pspec,
-					  EvView     *view)
-{
-	EvFormField *field;
-	GtkWidget *choice;
-	gboolean shown;
-	PopupShownData *data;
-
-	g_object_get (self, "popup-shown", &shown, NULL);
-	if (shown)
-		return; /* popup is already opened */
-
-	/* Popup has been closed */
-	field = g_object_get_data (self, "form-field");
-	choice = GTK_WIDGET (self);
-
-	data = g_new0 (PopupShownData, 1);
-	data->choice = g_object_ref (choice);
-	data->field = g_object_ref (field);
-	data->view = view;
-	/* We need to use an idle here because combobox "active" item is not updated yet */
-	g_idle_add ((GSourceFunc) ev_view_form_field_choice_popup_shown_real, (gpointer) data);
+                                          GParamSpec *pspec,
+                                          EvView     *view) {
+  EvFormField *field;
+  GtkWidget *choice;
+  gboolean shown;
+  PopupShownData *data;
+
+  g_object_get (self, "popup-shown", &shown, NULL);
+  if (shown)
+    return; /* popup is already opened */
+
+  /* Popup has been closed */
+  field = g_object_get_data (self, "form-field");
+  choice = GTK_WIDGET (self);
+
+  data = g_new0 (PopupShownData, 1);
+  data->choice = g_object_ref (choice);
+  data->field = g_object_ref (field);
+  data->view = view;
+  /* We need to use an idle here because combobox "active" item is not updated yet */
+  g_idle_add ((GSourceFunc) ev_view_form_field_choice_popup_shown_real, (gpointer) data);
 }
 
 static GtkWidget *
 ev_view_form_field_choice_create_widget (EvView      *view,
-					 EvFormField *field)
-{
-	EvFormFieldChoice *field_choice = EV_FORM_FIELD_CHOICE (field);
-	GtkWidget         *choice;
-	GtkTreeModel      *model;
-	gint               n_items, i;
-	gint               selected_item = -1;
-
-	n_items = ev_document_forms_form_field_choice_get_n_items (EV_DOCUMENT_FORMS (view->document),
-								   field);
-	model = GTK_TREE_MODEL (gtk_list_store_new (2, G_TYPE_STRING, G_TYPE_INT));
-	for (i = 0; i < n_items; i++) {
-		GtkTreeIter iter;
-		gchar      *item;
-
-		item = ev_document_forms_form_field_choice_get_item (EV_DOCUMENT_FORMS (view->document),
-								     field, i);
-		if (ev_document_forms_form_field_choice_is_item_selected (
-			    EV_DOCUMENT_FORMS (view->document), field, i)) {
-			selected_item = i;
-			/* FIXME: we need a get_selected_items function in poppler */
-			field_choice->selected_items = g_list_prepend (field_choice->selected_items,
-								       GINT_TO_POINTER (i));
-		}
-		
-		if (item) {
-			gtk_list_store_append (GTK_LIST_STORE (model), &iter);
-			gtk_list_store_set (GTK_LIST_STORE (model), &iter,
-					    0, item,
-					    1, i,
-					    -1);
-			g_free (item);
-		}
-	}
-
-	if (field_choice->type == EV_FORM_FIELD_CHOICE_LIST) {
-		GtkCellRenderer  *renderer;
-		GtkWidget        *tree_view;
-		GtkTreeSelection *selection;
-
-		tree_view = gtk_tree_view_new_with_model (model);
-		gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (tree_view), FALSE);
-
-		selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (tree_view));
-		if (field_choice->multi_select) {
-			gtk_tree_selection_set_mode (selection, GTK_SELECTION_MULTIPLE);
-		}
-
-		/* TODO: set selected items */
-
-		renderer = gtk_cell_renderer_text_new ();
-		gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW (tree_view),
-							     0,
-							     "choix", renderer,
-							     "text", 0,
-							     NULL);
-
-		choice = gtk_scrolled_window_new (NULL, NULL);
-		gtk_container_add (GTK_CONTAINER (choice), tree_view);
-		gtk_widget_show (tree_view);
-
-		g_signal_connect (selection, "changed",
-				  G_CALLBACK (ev_view_form_field_choice_changed),
-				  field);
-		g_signal_connect_after (selection, "changed",
-					G_CALLBACK (ev_view_form_field_destroy),
-					view);
-	} else if (field_choice->is_editable) { /* ComboBoxEntry */
-		GtkEntry *combo_entry;
-		gchar *text;
-
-		choice = gtk_combo_box_new_with_model_and_entry (model);
-		combo_entry = GTK_ENTRY (gtk_bin_get_child (GTK_BIN (choice)));
-		/* This sets GtkEntry's minimum-width to be 1 char long, short enough
-		 * to workaround gtk issue gtk#1422 . Evince issue #1002 */
-		gtk_entry_set_width_chars (combo_entry, 1);
-		gtk_combo_box_set_entry_text_column (GTK_COMBO_BOX (choice), 0);
-
-		text = ev_document_forms_form_field_choice_get_text (EV_DOCUMENT_FORMS (view->document), field);
-		if (text) {
-			gtk_entry_set_text (combo_entry, text);
-			g_free (text);
-		}
-
-		g_signal_connect (choice, "changed",
-				  G_CALLBACK (ev_view_form_field_choice_changed),
-				  field);
-		g_signal_connect_after (gtk_bin_get_child (GTK_BIN (choice)),
-					"activate",
-					G_CALLBACK (ev_view_form_field_destroy),
-					view);
-	} else { /* ComboBoxText */
-		GtkCellRenderer *renderer;
-
-		choice = gtk_combo_box_new_with_model (model);
-		renderer = gtk_cell_renderer_text_new ();
-		gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (choice),
-					    renderer, TRUE);
-		gtk_cell_layout_set_attributes (GTK_CELL_LAYOUT (choice),
-						renderer,
-						"text", 0,
-						NULL);
-		gtk_combo_box_set_active (GTK_COMBO_BOX (choice), selected_item);
-		gtk_combo_box_popup (GTK_COMBO_BOX (choice));
-		
-		/* See issue #294 for why we use this instead of "changed" signal */
-		g_signal_connect (choice, "notify::popup-shown",
-				  G_CALLBACK (ev_view_form_field_choice_popup_shown_cb),
-				  view);
-	}
-
-	g_object_unref (model);
-
-	g_object_weak_ref (G_OBJECT (choice),
-			   (GWeakNotify)ev_view_form_field_choice_save,
-			   view);
-
-	return choice;
+                                         EvFormField *field) {
+  EvFormFieldChoice *field_choice = EV_FORM_FIELD_CHOICE (field);
+  GtkWidget         *choice;
+  GtkTreeModel      *model;
+  gint               n_items, i;
+  gint               selected_item = -1;
+
+  n_items = ev_document_forms_form_field_choice_get_n_items (EV_DOCUMENT_FORMS (view->document),
+                                                             field);
+  model = GTK_TREE_MODEL (gtk_list_store_new (2, G_TYPE_STRING, G_TYPE_INT));
+  for (i = 0; i < n_items; i++) {
+    GtkTreeIter iter;
+    gchar      *item;
+
+    item = ev_document_forms_form_field_choice_get_item (EV_DOCUMENT_FORMS (view->document),
+                                                         field, i);
+    if (ev_document_forms_form_field_choice_is_item_selected (
+          EV_DOCUMENT_FORMS (view->document), field, i)) {
+      selected_item = i;
+      /* FIXME: we need a get_selected_items function in poppler */
+      field_choice->selected_items = g_list_prepend (field_choice->selected_items,
+                                                     GINT_TO_POINTER (i));
+    }
+
+    if (item) {
+      gtk_list_store_append (GTK_LIST_STORE (model), &iter);
+      gtk_list_store_set (GTK_LIST_STORE (model), &iter,
+                          0, item,
+                          1, i,
+                          -1);
+      g_free (item);
+    }
+  }
+
+  if (field_choice->type == EV_FORM_FIELD_CHOICE_LIST) {
+    GtkCellRenderer  *renderer;
+    GtkWidget        *tree_view;
+    GtkTreeSelection *selection;
+
+    tree_view = gtk_tree_view_new_with_model (model);
+    gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (tree_view), FALSE);
+
+    selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (tree_view));
+    if (field_choice->multi_select) {
+      gtk_tree_selection_set_mode (selection, GTK_SELECTION_MULTIPLE);
+    }
+
+    /* TODO: set selected items */
+
+    renderer = gtk_cell_renderer_text_new ();
+    gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW (tree_view),
+                                                 0,
+                                                 "choix", renderer,
+                                                 "text", 0,
+                                                 NULL);
+
+    choice = gtk_scrolled_window_new (NULL, NULL);
+    gtk_container_add (GTK_CONTAINER (choice), tree_view);
+    gtk_widget_show (tree_view);
+
+    g_signal_connect (selection, "changed",
+                      G_CALLBACK (ev_view_form_field_choice_changed),
+                      field);
+    g_signal_connect_after (selection, "changed",
+                            G_CALLBACK (ev_view_form_field_destroy),
+                            view);
+  } else if (field_choice->is_editable) { /* ComboBoxEntry */
+    GtkEntry *combo_entry;
+    gchar *text;
+
+    choice = gtk_combo_box_new_with_model_and_entry (model);
+    combo_entry = GTK_ENTRY (gtk_bin_get_child (GTK_BIN (choice)));
+    /* This sets GtkEntry's minimum-width to be 1 char long, short enough
+     * to workaround gtk issue gtk#1422 . Evince issue #1002 */
+    gtk_entry_set_width_chars (combo_entry, 1);
+    gtk_combo_box_set_entry_text_column (GTK_COMBO_BOX (choice), 0);
+
+    text = ev_document_forms_form_field_choice_get_text (EV_DOCUMENT_FORMS (view->document), field);
+    if (text) {
+      gtk_entry_set_text (combo_entry, text);
+      g_free (text);
+    }
+
+    g_signal_connect (choice, "changed",
+                      G_CALLBACK (ev_view_form_field_choice_changed),
+                      field);
+    g_signal_connect_after (gtk_bin_get_child (GTK_BIN (choice)),
+                            "activate",
+                            G_CALLBACK (ev_view_form_field_destroy),
+                            view);
+  } else { /* ComboBoxText */
+    GtkCellRenderer *renderer;
+
+    choice = gtk_combo_box_new_with_model (model);
+    renderer = gtk_cell_renderer_text_new ();
+    gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (choice),
+                                renderer, TRUE);
+    gtk_cell_layout_set_attributes (GTK_CELL_LAYOUT (choice),
+                                    renderer,
+                                    "text", 0,
+                                    NULL);
+    gtk_combo_box_set_active (GTK_COMBO_BOX (choice), selected_item);
+    gtk_combo_box_popup (GTK_COMBO_BOX (choice));
+
+    /* See issue #294 for why we use this instead of "changed" signal */
+    g_signal_connect (choice, "notify::popup-shown",
+                      G_CALLBACK (ev_view_form_field_choice_popup_shown_cb),
+                      view);
+  }
+
+  g_object_unref (model);
+
+  g_object_weak_ref (G_OBJECT (choice),
+                     (GWeakNotify)ev_view_form_field_choice_save,
+                     view);
+
+  return choice;
 }
 
 void
 _ev_view_focus_form_field (EvView      *view,
-			  EvFormField *field)
-{
-	GtkWidget     *field_widget = NULL;
-	EvMappingList *form_field_mapping;
-	EvMapping     *mapping;
-
-	_ev_view_set_focused_element (view, NULL, -1);
-
-	if (field->is_read_only)
-		return;
-
-	if (EV_IS_FORM_FIELD_BUTTON (field)) {
-		field_widget = ev_view_form_field_button_create_widget (view, field);
-	} else if (EV_IS_FORM_FIELD_TEXT (field)) {
-		field_widget = ev_view_form_field_text_create_widget (view, field);
-	} else if (EV_IS_FORM_FIELD_CHOICE (field)) {
-		field_widget = ev_view_form_field_choice_create_widget (view, field);
-	} else if (EV_IS_FORM_FIELD_SIGNATURE (field)) {
-		/* TODO */
-	}
-
-	/* Form field doesn't require a widget */
-	if (!field_widget) {
-		if (!gtk_widget_has_focus (GTK_WIDGET (view)))
-			gtk_widget_grab_focus (GTK_WIDGET (view));
-		return;
-	}
-
-	g_object_set_data_full (G_OBJECT (field_widget), "form-field",
-				g_object_ref (field),
-				(GDestroyNotify)g_object_unref);
-
-	form_field_mapping = ev_page_cache_get_form_field_mapping (view->page_cache,
-								   field->page->index);
-	mapping = ev_mapping_list_find (form_field_mapping, field);
-	_ev_view_set_focused_element (view, mapping, field->page->index);
-	ev_view_put_to_doc_rect (view, field_widget, field->page->index, &mapping->area);
-	gtk_widget_show (field_widget);
-	gtk_widget_grab_focus (field_widget);
+                           EvFormField *field) {
+  GtkWidget     *field_widget = NULL;
+  EvMappingList *form_field_mapping;
+  EvMapping     *mapping;
+
+  _ev_view_set_focused_element (view, NULL, -1);
+
+  if (field->is_read_only)
+    return;
+
+  if (EV_IS_FORM_FIELD_BUTTON (field)) {
+    field_widget = ev_view_form_field_button_create_widget (view, field);
+  } else if (EV_IS_FORM_FIELD_TEXT (field)) {
+    field_widget = ev_view_form_field_text_create_widget (view, field);
+  } else if (EV_IS_FORM_FIELD_CHOICE (field)) {
+    field_widget = ev_view_form_field_choice_create_widget (view, field);
+  } else if (EV_IS_FORM_FIELD_SIGNATURE (field)) {
+    /* TODO */
+  }
+
+  /* Form field doesn't require a widget */
+  if (!field_widget) {
+    if (!gtk_widget_has_focus (GTK_WIDGET (view)))
+      gtk_widget_grab_focus (GTK_WIDGET (view));
+    return;
+  }
+
+  g_object_set_data_full (G_OBJECT (field_widget), "form-field",
+                          g_object_ref (field),
+                          (GDestroyNotify)g_object_unref);
+
+  form_field_mapping = ev_page_cache_get_form_field_mapping (view->page_cache,
+                                                             field->page->index);
+  mapping = ev_mapping_list_find (form_field_mapping, field);
+  _ev_view_set_focused_element (view, mapping, field->page->index);
+  ev_view_put_to_doc_rect (view, field_widget, field->page->index, &mapping->area);
+  gtk_widget_show (field_widget);
+  gtk_widget_grab_focus (field_widget);
 }
 
 static void
 ev_view_handle_form_field (EvView      *view,
-			   EvFormField *field)
-{
-	if (field->is_read_only)
-		return;
+                           EvFormField *field) {
+  if (field->is_read_only)
+    return;
 
-	_ev_view_focus_form_field (view, field);
+  _ev_view_focus_form_field (view, field);
 
-	if (field->activation_link)
-		ev_view_handle_link (view, field->activation_link);
+  if (field->activation_link)
+    ev_view_handle_link (view, field->activation_link);
 
-	if (EV_IS_FORM_FIELD_BUTTON (field))
-		ev_view_form_field_button_toggle (view, field);
+  if (EV_IS_FORM_FIELD_BUTTON (field))
+    ev_view_form_field_button_toggle (view, field);
 
 }
 
 /* Media */
 static EvMapping *
 get_media_mapping_at_location (EvView *view,
-			       gdouble x,
-			       gdouble y,
-			       gint *page)
-{
+                               gdouble x,
+                               gdouble y,
+                               gint *page) {
 #ifdef ENABLE_MULTIMEDIA
-	gint x_new = 0, y_new = 0;
-	EvMappingList *media_mapping;
+  gint x_new = 0, y_new = 0;
+  EvMappingList *media_mapping;
 
-	if (!EV_IS_DOCUMENT_MEDIA (view->document))
-		return NULL;
+  if (!EV_IS_DOCUMENT_MEDIA (view->document))
+    return NULL;
 
-	if (!get_doc_point_from_location (view, x, y, page, &x_new, &y_new))
-		return NULL;
+  if (!get_doc_point_from_location (view, x, y, page, &x_new, &y_new))
+    return NULL;
 
-	media_mapping = ev_page_cache_get_media_mapping (view->page_cache, *page);
+  media_mapping = ev_page_cache_get_media_mapping (view->page_cache, *page);
 
-	return media_mapping ? ev_mapping_list_get (media_mapping, x_new, y_new) : NULL;
+  return media_mapping ? ev_mapping_list_get (media_mapping, x_new, y_new) : NULL;
 #else
-	return NULL;
+  return NULL;
 #endif
 }
 
 static EvMedia *
 ev_view_get_media_at_location (EvView  *view,
-			       gdouble  x,
-			       gdouble  y)
-{
-	EvMapping *media_mapping;
-	gint       page;
+                               gdouble  x,
+                               gdouble  y) {
+  EvMapping *media_mapping;
+  gint       page;
 
-	media_mapping = get_media_mapping_at_location (view, x, y, &page);
+  media_mapping = get_media_mapping_at_location (view, x, y, &page);
 
-	return media_mapping ? media_mapping->data : NULL;
+  return media_mapping ? media_mapping->data : NULL;
 }
 
 static gboolean
 ev_view_find_player_for_media (EvView  *view,
-			       EvMedia *media)
-{
+                               EvMedia *media) {
 #ifdef ENABLE_MULTIMEDIA
-	GList *l;
+  GList *l;
 
-	for (l = view->children; l; l = g_list_next (l)) {
-		EvViewChild *child = (EvViewChild *)l->data;
+  for (l = view->children; l; l = g_list_next (l)) {
+    EvViewChild *child = (EvViewChild *)l->data;
 
-		if (!EV_IS_MEDIA_PLAYER (child->widget))
-			continue;
+    if (!EV_IS_MEDIA_PLAYER (child->widget))
+      continue;
 
-		if (ev_media_player_get_media (EV_MEDIA_PLAYER (child->widget)) == media)
-			return TRUE;
-	}
+    if (ev_media_player_get_media (EV_MEDIA_PLAYER (child->widget)) == media)
+      return TRUE;
+  }
 #endif
 
-	return FALSE;
+  return FALSE;
 }
 
 static void
 ev_view_handle_media (EvView  *view,
-		      EvMedia *media)
-{
+                      EvMedia *media) {
 #ifdef ENABLE_MULTIMEDIA
-	GtkWidget     *player;
-	EvMappingList *media_mapping;
-	EvMapping     *mapping;
-	GdkRectangle   render_area;
-	guint          page;
+  GtkWidget     *player;
+  EvMappingList *media_mapping;
+  EvMapping     *mapping;
+  GdkRectangle   render_area;
+  guint          page;
 
-	page = ev_media_get_page_index (media);
-	media_mapping = ev_page_cache_get_media_mapping (view->page_cache, page);
+  page = ev_media_get_page_index (media);
+  media_mapping = ev_page_cache_get_media_mapping (view->page_cache, page);
 
-	/* TODO: focus? */
+  /* TODO: focus? */
 
-	if (ev_view_find_player_for_media (view, media))
-		return;
+  if (ev_view_find_player_for_media (view, media))
+    return;
 
-	player = ev_media_player_new (media);
+  player = ev_media_player_new (media);
 
-	mapping = ev_mapping_list_find (media_mapping, media);
-	_ev_view_transform_doc_rect_to_view_rect (view, page, &mapping->area, &render_area);
-	render_area.x -= view->scroll_x;
-	render_area.y -= view->scroll_y;
+  mapping = ev_mapping_list_find (media_mapping, media);
+  _ev_view_transform_doc_rect_to_view_rect (view, page, &mapping->area, &render_area);
+  render_area.x -= view->scroll_x;
+  render_area.y -= view->scroll_y;
 
-	ev_view_put (view, player, render_area.x, render_area.y, page, &mapping->area);
-	gtk_widget_show (player);
+  ev_view_put (view, player, render_area.x, render_area.y, page, &mapping->area);
+  gtk_widget_show (player);
 #endif /* ENABLE_MULTIMEDIA */
 }
 
 /* Annotations */
 static GtkWidget *
 get_window_for_annot (EvView       *view,
-		      EvAnnotation *annot)
-{
-	if (view->annot_window_map == NULL)
-		return NULL;
+                      EvAnnotation *annot) {
+  if (view->annot_window_map == NULL)
+    return NULL;
 
-	return g_hash_table_lookup (view->annot_window_map, annot);
+  return g_hash_table_lookup (view->annot_window_map, annot);
 }
 
 static void
 map_annot_to_window (EvView       *view,
                      EvAnnotation *annot,
-		     GtkWidget    *window)
-{
-	if (view->annot_window_map == NULL)
-		view->annot_window_map = g_hash_table_new (g_direct_hash, NULL);
+                     GtkWidget    *window) {
+  if (view->annot_window_map == NULL)
+    view->annot_window_map = g_hash_table_new (g_direct_hash, NULL);
 
-	g_hash_table_insert (view->annot_window_map, annot, window);
+  g_hash_table_insert (view->annot_window_map, annot, window);
 }
 
 static EvViewWindowChild *
 ev_view_get_window_child (EvView    *view,
-			  GtkWidget *window)
-{
-	GList *children = view->window_children;
+                          GtkWidget *window) {
+  GList *children = view->window_children;
 
-	while (children) {
-		EvViewWindowChild *child;
+  while (children) {
+    EvViewWindowChild *child;
 
-		child = (EvViewWindowChild *)children->data;
-		children = children->next;
+    child = (EvViewWindowChild *)children->data;
+    children = children->next;
 
-		if (child->window == window)
-			return child;
-	}
+    if (child->window == window)
+      return child;
+  }
 
-	return NULL;
+  return NULL;
 }
 
 static void
 ev_view_window_child_move (EvView            *view,
-			   EvViewWindowChild *child,
-			   gint               x,
-			   gint               y)
-{
-	GtkAllocation allocation;
-	gint          width, height;
+                           EvViewWindowChild *child,
+                           gint               x,
+                           gint               y) {
+  GtkAllocation allocation;
+  gint          width, height;
 
-	gtk_widget_get_allocation (GTK_WIDGET (view), &allocation);
-	gtk_window_get_size (GTK_WINDOW (child->window), &width, &height);
+  gtk_widget_get_allocation (GTK_WIDGET (view), &allocation);
+  gtk_window_get_size (GTK_WINDOW (child->window), &width, &height);
 
-	child->x = x;
-	child->y = y;
-	gtk_window_move (GTK_WINDOW (child->window),
-			 CLAMP (x, child->parent_x,
-				child->parent_x + allocation.width - width),
-			 CLAMP (y, child->parent_y,
-				child->parent_y + allocation.height - height));
+  child->x = x;
+  child->y = y;
+  gtk_window_move (GTK_WINDOW (child->window),
+                   CLAMP (x, child->parent_x,
+                          child->parent_x + allocation.width - width),
+                   CLAMP (y, child->parent_y,
+                          child->parent_y + allocation.height - height));
 }
 
 static void
 ev_view_window_child_move_with_parent (EvView    *view,
-				       GtkWidget *window)
-{
-	EvViewWindowChild *child;
-	gint               root_x, root_y;
+                                       GtkWidget *window) {
+  EvViewWindowChild *child;
+  gint               root_x, root_y;
 
-	child = ev_view_get_window_child (view, window);
-	gdk_window_get_origin (gtk_widget_get_window (GTK_WIDGET (view)),
-			       &root_x, &root_y);
-	if (root_x != child->parent_x || root_y != child->parent_y) {
-		gint dest_x, dest_y;
+  child = ev_view_get_window_child (view, window);
+  gdk_window_get_origin (gtk_widget_get_window (GTK_WIDGET (view)),
+                         &root_x, &root_y);
+  if (root_x != child->parent_x || root_y != child->parent_y) {
+    gint dest_x, dest_y;
 
-		dest_x = child->x + (root_x - child->parent_x);
-		dest_y = child->y + (root_y - child->parent_y);
-		child->parent_x = root_x;
-		child->parent_y = root_y;
-		ev_view_window_child_move (view, child, dest_x, dest_y);
-	}
+    dest_x = child->x + (root_x - child->parent_x);
+    dest_y = child->y + (root_y - child->parent_y);
+    child->parent_x = root_x;
+    child->parent_y = root_y;
+    ev_view_window_child_move (view, child, dest_x, dest_y);
+  }
 
-	if (child->visible && !gtk_widget_get_visible (window))
-		gtk_widget_show (window);
+  if (child->visible && !gtk_widget_get_visible (window))
+    gtk_widget_show (window);
 }
 
 static void
 ev_view_window_child_put (EvView    *view,
-			  GtkWidget *window,
-			  guint      page,
-			  gint       x,
-			  gint       y,
-			  gdouble    orig_x,
-			  gdouble    orig_y)
-{
-	EvViewWindowChild *child;
-	gint               root_x, root_y;
-
-	gdk_window_get_origin (gtk_widget_get_window (GTK_WIDGET (view)),
-			       &root_x, &root_y);
-
-	child = g_new0 (EvViewWindowChild, 1);
-	child->window = window;
-	child->page = page;
-	child->orig_x = orig_x;
-	child->orig_y = orig_y;
-	child->parent_x = root_x;
-	child->parent_y = root_y;
-	child->visible = ev_annotation_window_is_open (EV_ANNOTATION_WINDOW (window));
-	ev_view_window_child_move (view, child, x + root_x, y + root_y);
-
-	if (child->visible)
-		gtk_widget_show (window);
-	else
-		gtk_widget_hide (window);
-
-	view->window_children = g_list_append (view->window_children, child);
+                          GtkWidget *window,
+                          guint      page,
+                          gint       x,
+                          gint       y,
+                          gdouble    orig_x,
+                          gdouble    orig_y) {
+  EvViewWindowChild *child;
+  gint               root_x, root_y;
+
+  gdk_window_get_origin (gtk_widget_get_window (GTK_WIDGET (view)),
+                         &root_x, &root_y);
+
+  child = g_new0 (EvViewWindowChild, 1);
+  child->window = window;
+  child->page = page;
+  child->orig_x = orig_x;
+  child->orig_y = orig_y;
+  child->parent_x = root_x;
+  child->parent_y = root_y;
+  child->visible = ev_annotation_window_is_open (EV_ANNOTATION_WINDOW (window));
+  ev_view_window_child_move (view, child, x + root_x, y + root_y);
+
+  if (child->visible)
+    gtk_widget_show (window);
+  else
+    gtk_widget_hide (window);
+
+  view->window_children = g_list_append (view->window_children, child);
 }
 
 static void
 ev_view_remove_window_child_for_annot (EvView       *view,
-				       guint         page,
-				       EvAnnotation *annot)
-{
-	GList *children = view->window_children;
+                                       guint         page,
+                                       EvAnnotation *annot) {
+  GList *children = view->window_children;
 
-	while (children) {
-		EvViewWindowChild *child;
-		EvAnnotation      *wannot;
+  while (children) {
+    EvViewWindowChild *child;
+    EvAnnotation      *wannot;
 
-		child = (EvViewWindowChild *)children->data;
+    child = (EvViewWindowChild *)children->data;
 
-		if (child->page != page) {
-			children = children->next;
-			continue;
-		}
-		wannot = ev_annotation_window_get_annotation (EV_ANNOTATION_WINDOW (child->window));
-		if (ev_annotation_equal (wannot, annot)) {
-			gtk_widget_destroy (child->window);
-			view->window_children = g_list_delete_link (view->window_children, children);
-			break;
-		}
-		children = children->next;
-	}
+    if (child->page != page) {
+      children = children->next;
+      continue;
+    }
+    wannot = ev_annotation_window_get_annotation (EV_ANNOTATION_WINDOW (child->window));
+    if (ev_annotation_equal (wannot, annot)) {
+      gtk_widget_destroy (child->window);
+      view->window_children = g_list_delete_link (view->window_children, children);
+      break;
+    }
+    children = children->next;
+  }
 }
 
 static void
-ev_view_window_children_free (EvView *view)
-{
-	GList *l;
+ev_view_window_children_free (EvView *view) {
+  GList *l;
 
-	if (!view->window_children)
-		return;
+  if (!view->window_children)
+    return;
 
-	for (l = view->window_children; l && l->data; l = g_list_next (l)) {
-		EvViewWindowChild *child;
+  for (l = view->window_children; l && l->data; l = g_list_next (l)) {
+    EvViewWindowChild *child;
 
-		child = (EvViewWindowChild *)l->data;
-		gtk_widget_destroy (GTK_WIDGET (child->window));
-		g_free (child);
-	}
-	g_list_free (view->window_children);
-	view->window_children = NULL;
-	view->window_child_focus = NULL;
+    child = (EvViewWindowChild *)l->data;
+    gtk_widget_destroy (GTK_WIDGET (child->window));
+    g_free (child);
+  }
+  g_list_free (view->window_children);
+  view->window_children = NULL;
+  view->window_child_focus = NULL;
 }
 
 static void
 annotation_window_grab_focus (GtkWidget *widget,
-			      EvView    *view)
-{
-	if (view->window_child_focus)
-		ev_annotation_window_ungrab_focus (EV_ANNOTATION_WINDOW (view->window_child_focus->window));
-	view->window_child_focus = ev_view_get_window_child (view, widget);
+                              EvView    *view) {
+  if (view->window_child_focus)
+    ev_annotation_window_ungrab_focus (EV_ANNOTATION_WINDOW (view->window_child_focus->window));
+  view->window_child_focus = ev_view_get_window_child (view, widget);
 }
 
 static void
 annotation_window_closed (EvAnnotationWindow *window,
-			  EvView             *view)
-{
-	EvViewWindowChild *child;
+                          EvView             *view) {
+  EvViewWindowChild *child;
 
-	child = ev_view_get_window_child (view, GTK_WIDGET (window));
-	child->visible = FALSE;
+  child = ev_view_get_window_child (view, GTK_WIDGET (window));
+  child->visible = FALSE;
 }
 
 static void
 annotation_window_moved (EvAnnotationWindow *window,
-			 gint                x,
-			 gint                y,
-			 EvView             *view)
-{
-	EvViewWindowChild *child;
-	GdkRectangle       page_area;
-	GtkBorder          border;
-	GdkRectangle       view_rect;
-	EvRectangle        doc_rect;
-	gint               width, height;
-
-	child = ev_view_get_window_child (view, GTK_WIDGET (window));
-	if (child->x == x && child->y == y)
-		return;
-
-	child->moved = TRUE;
-	child->x = x;
-	child->y = y;
-
-	/* Window has been moved by the user,
-	 * we have to set a new origin in doc coords
-	 */
-	gtk_window_get_size (GTK_WINDOW (window), &width, &height);
-	view_rect.x = (x - child->parent_x) + view->scroll_x;
-	view_rect.y = (y - child->parent_y) + view->scroll_y;
-	view_rect.width = width;
-	view_rect.height = height;
-
-	ev_view_get_page_extents (view, child->page, &page_area, &border);
-	_ev_view_transform_view_rect_to_doc_rect (view, &view_rect, &page_area, &border, &doc_rect);
-	child->orig_x = doc_rect.x1;
-	child->orig_y = doc_rect.y1;
+                         gint                x,
+                         gint                y,
+                         EvView             *view) {
+  EvViewWindowChild *child;
+  GdkRectangle       page_area;
+  GtkBorder          border;
+  GdkRectangle       view_rect;
+  EvRectangle        doc_rect;
+  gint               width, height;
+
+  child = ev_view_get_window_child (view, GTK_WIDGET (window));
+  if (child->x == x && child->y == y)
+    return;
+
+  child->moved = TRUE;
+  child->x = x;
+  child->y = y;
+
+  /* Window has been moved by the user,
+   * we have to set a new origin in doc coords
+   */
+  gtk_window_get_size (GTK_WINDOW (window), &width, &height);
+  view_rect.x = (x - child->parent_x) + view->scroll_x;
+  view_rect.y = (y - child->parent_y) + view->scroll_y;
+  view_rect.width = width;
+  view_rect.height = height;
+
+  ev_view_get_page_extents (view, child->page, &page_area, &border);
+  _ev_view_transform_view_rect_to_doc_rect (view, &view_rect, &page_area, &border, &doc_rect);
+  child->orig_x = doc_rect.x1;
+  child->orig_y = doc_rect.y1;
 }
 
 static void
 ev_view_annotation_save_contents (EvView       *view,
-				  GParamSpec   *pspec,
-				  EvAnnotation *annot)
-{
-	if (!view->document)
-		return;
+                                  GParamSpec   *pspec,
+                                  EvAnnotation *annot) {
+  if (!view->document)
+    return;
 
-	ev_document_doc_mutex_lock ();
-	ev_document_annotations_save_annotation (EV_DOCUMENT_ANNOTATIONS (view->document),
-						 annot, EV_ANNOTATIONS_SAVE_CONTENTS);
-	ev_document_doc_mutex_unlock ();
+  ev_document_doc_mutex_lock ();
+  ev_document_annotations_save_annotation (EV_DOCUMENT_ANNOTATIONS (view->document),
+                                           annot, EV_ANNOTATIONS_SAVE_CONTENTS);
+  ev_document_doc_mutex_unlock ();
 }
 
 static GtkWidget *
 ev_view_create_annotation_window (EvView       *view,
-				  EvAnnotation *annot,
-				  GtkWindow    *parent)
-{
-	GtkWidget   *window;
-	EvRectangle  doc_rect;
-	GdkRectangle view_rect;
-	guint        page;
-
-	window = ev_annotation_window_new (annot, parent);
-	g_signal_connect (window, "grab_focus",
-			  G_CALLBACK (annotation_window_grab_focus),
-			  view);
-	g_signal_connect (window, "closed",
-			  G_CALLBACK (annotation_window_closed),
-			  view);
-	g_signal_connect (window, "moved",
-			  G_CALLBACK (annotation_window_moved),
-			  view);
-	g_signal_connect_swapped (annot, "notify::contents",
-				  G_CALLBACK (ev_view_annotation_save_contents),
-				  view);
-	map_annot_to_window (view, annot, window);
-
-	page = ev_annotation_get_page_index (annot);
-	ev_annotation_window_get_rectangle (EV_ANNOTATION_WINDOW (window), &doc_rect);
-	_ev_view_transform_doc_rect_to_view_rect (view, page, &doc_rect, &view_rect);
-	view_rect.x -= view->scroll_x;
-	view_rect.y -= view->scroll_y;
-
-	ev_view_window_child_put (view, window, page,
-				  view_rect.x, view_rect.y,
-				  doc_rect.x1, doc_rect.y1);
-        ev_annotation_window_set_enable_spellchecking (EV_ANNOTATION_WINDOW (window), ev_view_get_enable_spellchecking (view));
-	return window;
+                                  EvAnnotation *annot,
+                                  GtkWindow    *parent) {
+  GtkWidget   *window;
+  EvRectangle  doc_rect;
+  GdkRectangle view_rect;
+  guint        page;
+
+  window = ev_annotation_window_new (annot, parent);
+  g_signal_connect (window, "grab_focus",
+                    G_CALLBACK (annotation_window_grab_focus),
+                    view);
+  g_signal_connect (window, "closed",
+                    G_CALLBACK (annotation_window_closed),
+                    view);
+  g_signal_connect (window, "moved",
+                    G_CALLBACK (annotation_window_moved),
+                    view);
+  g_signal_connect_swapped (annot, "notify::contents",
+                            G_CALLBACK (ev_view_annotation_save_contents),
+                            view);
+  map_annot_to_window (view, annot, window);
+
+  page = ev_annotation_get_page_index (annot);
+  ev_annotation_window_get_rectangle (EV_ANNOTATION_WINDOW (window), &doc_rect);
+  _ev_view_transform_doc_rect_to_view_rect (view, page, &doc_rect, &view_rect);
+  view_rect.x -= view->scroll_x;
+  view_rect.y -= view->scroll_y;
+
+  ev_view_window_child_put (view, window, page,
+                            view_rect.x, view_rect.y,
+                            doc_rect.x1, doc_rect.y1);
+  ev_annotation_window_set_enable_spellchecking (EV_ANNOTATION_WINDOW (window), ev_view_get_enable_spellchecking (view));
+  return window;
 }
 
 static void
 show_annotation_windows (EvView *view,
-			 gint    page)
-{
-	EvMappingList *annots;
-	GList         *l;
-	GtkWindow     *parent;
+                         gint    page) {
+  EvMappingList *annots;
+  GList         *l;
+  GtkWindow     *parent;
 
-	parent = GTK_WINDOW (gtk_widget_get_toplevel (GTK_WIDGET (view)));
+  parent = GTK_WINDOW (gtk_widget_get_toplevel (GTK_WIDGET (view)));
 
-	annots = ev_page_cache_get_annot_mapping (view->page_cache, page);
+  annots = ev_page_cache_get_annot_mapping (view->page_cache, page);
 
-	for (l = ev_mapping_list_get_list (annots); l && l->data; l = g_list_next (l)) {
-		EvAnnotation      *annot;
-		GtkWidget         *window;
+  for (l = ev_mapping_list_get_list (annots); l && l->data; l = g_list_next (l)) {
+    EvAnnotation      *annot;
+    GtkWidget         *window;
 
-		annot = ((EvMapping *)(l->data))->data;
+    annot = ((EvMapping *)(l->data))->data;
 
-		if (!EV_IS_ANNOTATION_MARKUP (annot))
-			continue;
+    if (!EV_IS_ANNOTATION_MARKUP (annot))
+      continue;
 
-		if (!ev_annotation_markup_has_popup (EV_ANNOTATION_MARKUP (annot)))
-			continue;
+    if (!ev_annotation_markup_has_popup (EV_ANNOTATION_MARKUP (annot)))
+      continue;
 
-		window = get_window_for_annot (view, annot);
-		if (window) {
-			ev_view_window_child_move_with_parent (view, window);
-		}
-	}
+    window = get_window_for_annot (view, annot);
+    if (window) {
+      ev_view_window_child_move_with_parent (view, window);
+    }
+  }
 }
 
 static void
 hide_annotation_windows (EvView *view,
-			 gint    page)
-{
-	EvMappingList *annots;
-	GList         *l;
+                         gint    page) {
+  EvMappingList *annots;
+  GList         *l;
 
-	annots = ev_page_cache_get_annot_mapping (view->page_cache, page);
+  annots = ev_page_cache_get_annot_mapping (view->page_cache, page);
 
-	for (l = ev_mapping_list_get_list (annots); l && l->data; l = g_list_next (l)) {
-		EvAnnotation *annot;
-		GtkWidget    *window;
+  for (l = ev_mapping_list_get_list (annots); l && l->data; l = g_list_next (l)) {
+    EvAnnotation *annot;
+    GtkWidget    *window;
 
-		annot = ((EvMapping *)(l->data))->data;
+    annot = ((EvMapping *)(l->data))->data;
 
-		if (!EV_IS_ANNOTATION_MARKUP (annot))
-			continue;
+    if (!EV_IS_ANNOTATION_MARKUP (annot))
+      continue;
 
-		window = get_window_for_annot (view, annot);
-		if (window)
-			gtk_widget_hide (window);
-	}
+    window = get_window_for_annot (view, annot);
+    if (window)
+      gtk_widget_hide (window);
+  }
 }
 
 static EvMapping *
 get_annotation_mapping_at_location (EvView *view,
-				    gdouble x,
-				    gdouble y,
-				    gint *page)
-{
-	gint x_new = 0, y_new = 0;
-	EvMappingList *annotations_mapping;
+                                    gdouble x,
+                                    gdouble y,
+                                    gint *page) {
+  gint x_new = 0, y_new = 0;
+  EvMappingList *annotations_mapping;
 
-	if (!EV_IS_DOCUMENT_ANNOTATIONS (view->document))
-		return NULL;
+  if (!EV_IS_DOCUMENT_ANNOTATIONS (view->document))
+    return NULL;
 
-	if (!get_doc_point_from_location (view, x, y, page, &x_new, &y_new))
-		return NULL;
+  if (!get_doc_point_from_location (view, x, y, page, &x_new, &y_new))
+    return NULL;
 
-	annotations_mapping = ev_page_cache_get_annot_mapping (view->page_cache, *page);
+  annotations_mapping = ev_page_cache_get_annot_mapping (view->page_cache, *page);
 
-	if (annotations_mapping)
-		return ev_mapping_list_get (annotations_mapping, x_new, y_new);
+  if (annotations_mapping)
+    return ev_mapping_list_get (annotations_mapping, x_new, y_new);
 
-	return NULL;
+  return NULL;
 }
 
 static EvAnnotation *
 ev_view_get_annotation_at_location (EvView  *view,
-				    gdouble  x,
-				    gdouble  y)
-{
-	EvMapping *annotation_mapping;
-	gint page;
+                                    gdouble  x,
+                                    gdouble  y) {
+  EvMapping *annotation_mapping;
+  gint page;
 
-	annotation_mapping = get_annotation_mapping_at_location (view, x, y, &page);
+  annotation_mapping = get_annotation_mapping_at_location (view, x, y, &page);
 
-	return annotation_mapping ? annotation_mapping->data : NULL;
+  return annotation_mapping ? annotation_mapping->data : NULL;
 }
 
 static void
 ev_view_annotation_show_popup_window (EvView    *view,
-				      GtkWidget *window)
-{
-	EvViewWindowChild *child;
+                                      GtkWidget *window) {
+  EvViewWindowChild *child;
 
-	if (!window)
-		return;
+  if (!window)
+    return;
 
-	child = ev_view_get_window_child (view, window);
-	if (!child->visible) {
-		child->visible = TRUE;
-		ev_view_window_child_move (view, child, child->x, child->y);
-		gtk_widget_show (window);
-	}
+  child = ev_view_get_window_child (view, window);
+  if (!child->visible) {
+    child->visible = TRUE;
+    ev_view_window_child_move (view, child, child->x, child->y);
+    gtk_widget_show (window);
+  }
 }
 
 static void
 ev_view_handle_annotation (EvView       *view,
-			   EvAnnotation *annot,
-			   gdouble       x,
-			   gdouble       y,
-			   guint32       timestamp)
-{
-	if (EV_IS_ANNOTATION_MARKUP (annot)) {
-		GtkWidget *window;
-
-		window = get_window_for_annot (view, annot);
-		if (!window && ev_annotation_markup_can_have_popup (EV_ANNOTATION_MARKUP (annot))) {
-			EvRectangle    popup_rect;
-			GtkWindow     *parent;
-			EvMappingList *annots;
-			EvMapping     *mapping;
-
-			annots = ev_page_cache_get_annot_mapping (view->page_cache,
-								  ev_annotation_get_page_index (annot));
-			mapping = ev_mapping_list_find (annots, annot);
-
-			popup_rect.x1 = mapping->area.x2;
-			popup_rect.y1 = mapping->area.y2;
-			popup_rect.x2 = popup_rect.x1 + ANNOT_POPUP_WINDOW_DEFAULT_WIDTH;
-			popup_rect.y2 = popup_rect.y1 + ANNOT_POPUP_WINDOW_DEFAULT_HEIGHT;
-			g_object_set (annot,
-				      "rectangle", &popup_rect,
-				      "has_popup", TRUE,
-				      "popup_is_open", TRUE,
-				      NULL);
-
-			parent = GTK_WINDOW (gtk_widget_get_toplevel (GTK_WIDGET (view)));
-			window = ev_view_create_annotation_window (view, annot, parent);
-		}
-		ev_view_annotation_show_popup_window (view, window);
-	}
-
-	if (EV_IS_ANNOTATION_ATTACHMENT (annot)) {
-		EvAttachment *attachment;
-
-		attachment = ev_annotation_attachment_get_attachment (EV_ANNOTATION_ATTACHMENT (annot));
-		if (attachment) {
-			GError *error = NULL;
-
-			ev_attachment_open (attachment,
-					    gtk_widget_get_screen (GTK_WIDGET (view)),
-					    timestamp,
-					    &error);
-
-			if (error) {
-				g_warning ("%s", error->message);
-				g_error_free (error);
-			}
-		}
-	}
+                           EvAnnotation *annot,
+                           gdouble       x,
+                           gdouble       y,
+                           guint32       timestamp) {
+  if (EV_IS_ANNOTATION_MARKUP (annot)) {
+    GtkWidget *window;
+
+    window = get_window_for_annot (view, annot);
+    if (!window && ev_annotation_markup_can_have_popup (EV_ANNOTATION_MARKUP (annot))) {
+      EvRectangle    popup_rect;
+      GtkWindow     *parent;
+      EvMappingList *annots;
+      EvMapping     *mapping;
+
+      annots = ev_page_cache_get_annot_mapping (view->page_cache,
+                                                ev_annotation_get_page_index (annot));
+      mapping = ev_mapping_list_find (annots, annot);
+
+      popup_rect.x1 = mapping->area.x2;
+      popup_rect.y1 = mapping->area.y2;
+      popup_rect.x2 = popup_rect.x1 + ANNOT_POPUP_WINDOW_DEFAULT_WIDTH;
+      popup_rect.y2 = popup_rect.y1 + ANNOT_POPUP_WINDOW_DEFAULT_HEIGHT;
+      g_object_set (annot,
+                    "rectangle", &popup_rect,
+                    "has_popup", TRUE,
+                    "popup_is_open", TRUE,
+                    NULL);
+
+      parent = GTK_WINDOW (gtk_widget_get_toplevel (GTK_WIDGET (view)));
+      window = ev_view_create_annotation_window (view, annot, parent);
+    }
+    ev_view_annotation_show_popup_window (view, window);
+  }
+
+  if (EV_IS_ANNOTATION_ATTACHMENT (annot)) {
+    EvAttachment *attachment;
+
+    attachment = ev_annotation_attachment_get_attachment (EV_ANNOTATION_ATTACHMENT (annot));
+    if (attachment) {
+      GError *error = NULL;
+
+      ev_attachment_open (attachment,
+                          gtk_widget_get_screen (GTK_WIDGET (view)),
+                          timestamp,
+                          &error);
+
+      if (error) {
+        g_warning ("%s", error->message);
+        g_error_free (error);
+      }
+    }
+  }
 }
 
 static void
 ev_view_create_annotation_real (EvView *view,
-				gint    annot_page,
-				EvPoint start,
-				EvPoint end)
-{
-	EvAnnotation   *annot;
-	EvRectangle     doc_rect, popup_rect;
-	EvPage         *page;
-	GdkColor        color = { 0, 65535, 65535, 0 };
-	GdkRectangle    view_rect;
-	cairo_region_t *region;
-
-	ev_document_doc_mutex_lock ();
-	page = ev_document_get_page (view->document, annot_page);
-        switch (view->adding_annot_info.type) {
-        case EV_ANNOTATION_TYPE_TEXT:
-                doc_rect.x1 = end.x;
-                doc_rect.y1 = end.y;
-                doc_rect.x2 = doc_rect.x1 + ANNOTATION_ICON_SIZE;
-                doc_rect.y2 = doc_rect.y1 + ANNOTATION_ICON_SIZE;
-                annot = ev_annotation_text_new (page);
-                break;
-	case EV_ANNOTATION_TYPE_TEXT_MARKUP:
-		doc_rect.x1 = start.x;
-		doc_rect.y1 = start.y;
-		doc_rect.x2 = end.x;
-		doc_rect.y2 = end.y;
-		annot = ev_annotation_text_markup_highlight_new (page);
-		break;
-	case EV_ANNOTATION_TYPE_ATTACHMENT:
-		/* TODO */
-		g_object_unref (page);
-		ev_document_doc_mutex_unlock ();
-		return;
-	default:
-		g_assert_not_reached ();
-	}
-	g_object_unref (page);
-
-	ev_annotation_set_area (annot, &doc_rect);
-	ev_annotation_set_color (annot, &color);
-
-	if (EV_IS_ANNOTATION_MARKUP (annot)) {
-		popup_rect.x1 = doc_rect.x2;
-		popup_rect.x2 = popup_rect.x1 + ANNOT_POPUP_WINDOW_DEFAULT_WIDTH;
-		popup_rect.y1 = doc_rect.y2;
-		popup_rect.y2 = popup_rect.y1 + ANNOT_POPUP_WINDOW_DEFAULT_HEIGHT;
-		g_object_set (annot,
-			      "rectangle", &popup_rect,
-			      "has_popup", TRUE,
-			      "popup_is_open", FALSE,
-			      "label", g_get_real_name (),
-			      "opacity", 1.0,
-			      NULL);
-	}
-	ev_document_annotations_add_annotation (EV_DOCUMENT_ANNOTATIONS (view->document),
-						annot, &doc_rect);
-	/* Re-fetch area as eg. adding Text Markup annots updates area for its bounding box */
-	ev_annotation_get_area (annot, &doc_rect);
-	ev_document_doc_mutex_unlock ();
-
-	/* If the page didn't have annots, mark the cache as dirty */
-	if (!ev_page_cache_get_annot_mapping (view->page_cache, annot_page))
-		ev_page_cache_mark_dirty (view->page_cache, annot_page, EV_PAGE_DATA_INCLUDE_ANNOTS);
-
-	_ev_view_transform_doc_rect_to_view_rect (view, annot_page, &doc_rect, &view_rect);
-	view_rect.x -= view->scroll_x;
-	view_rect.y -= view->scroll_y;
-	region = cairo_region_create_rectangle (&view_rect);
-	ev_view_reload_page (view, annot_page, region);
-	cairo_region_destroy (region);
-
-	view->adding_annot_info.annot = annot;
-}
-
-static void
-ev_view_create_annotation (EvView *view)
-{
-	EvPoint         start;
-	EvPoint         end;
-	gint            annot_page;
-	gint            offset;
-	GdkRectangle    page_area;
-	GtkBorder       border;
-
-	find_page_at_location (view, view->adding_annot_info.start.x, view->adding_annot_info.start.y, &annot_page, &offset, &offset);
-	if (annot_page == -1) {
-		ev_view_cancel_add_annotation (view);
-		return;
-	}
-
-	ev_view_get_page_extents (view, annot_page, &page_area, &border);
-	_ev_view_transform_view_point_to_doc_point (view, &view->adding_annot_info.start, &page_area, &border,
-						    &start.x, &start.y);
-	_ev_view_transform_view_point_to_doc_point (view, &view->adding_annot_info.stop, &page_area, &border,
-						    &end.x, &end.y);
-
-	ev_view_create_annotation_real (view, annot_page, start, end);
+                                gint    annot_page,
+                                EvPoint start,
+                                EvPoint end) {
+  EvAnnotation   *annot;
+  EvRectangle     doc_rect, popup_rect;
+  EvPage         *page;
+  GdkColor        color = { 0, 65535, 65535, 0 };
+  GdkRectangle    view_rect;
+  cairo_region_t *region;
+
+  ev_document_doc_mutex_lock ();
+  page = ev_document_get_page (view->document, annot_page);
+  switch (view->adding_annot_info.type) {
+    case EV_ANNOTATION_TYPE_TEXT:
+      doc_rect.x1 = end.x;
+      doc_rect.y1 = end.y;
+      doc_rect.x2 = doc_rect.x1 + ANNOTATION_ICON_SIZE;
+      doc_rect.y2 = doc_rect.y1 + ANNOTATION_ICON_SIZE;
+      annot = ev_annotation_text_new (page);
+      break;
+    case EV_ANNOTATION_TYPE_TEXT_MARKUP:
+      doc_rect.x1 = start.x;
+      doc_rect.y1 = start.y;
+      doc_rect.x2 = end.x;
+      doc_rect.y2 = end.y;
+      annot = ev_annotation_text_markup_highlight_new (page);
+      break;
+    case EV_ANNOTATION_TYPE_ATTACHMENT:
+      /* TODO */
+      g_object_unref (page);
+      ev_document_doc_mutex_unlock ();
+      return;
+    default:
+      g_assert_not_reached ();
+  }
+  g_object_unref (page);
+
+  ev_annotation_set_area (annot, &doc_rect);
+  ev_annotation_set_color (annot, &color);
+
+  if (EV_IS_ANNOTATION_MARKUP (annot)) {
+    popup_rect.x1 = doc_rect.x2;
+    popup_rect.x2 = popup_rect.x1 + ANNOT_POPUP_WINDOW_DEFAULT_WIDTH;
+    popup_rect.y1 = doc_rect.y2;
+    popup_rect.y2 = popup_rect.y1 + ANNOT_POPUP_WINDOW_DEFAULT_HEIGHT;
+    g_object_set (annot,
+                  "rectangle", &popup_rect,
+                  "has_popup", TRUE,
+                  "popup_is_open", FALSE,
+                  "label", g_get_real_name (),
+                  "opacity", 1.0,
+                  NULL);
+  }
+  ev_document_annotations_add_annotation (EV_DOCUMENT_ANNOTATIONS (view->document),
+                                          annot, &doc_rect);
+  /* Re-fetch area as eg. adding Text Markup annots updates area for its bounding box */
+  ev_annotation_get_area (annot, &doc_rect);
+  ev_document_doc_mutex_unlock ();
+
+  /* If the page didn't have annots, mark the cache as dirty */
+  if (!ev_page_cache_get_annot_mapping (view->page_cache, annot_page))
+    ev_page_cache_mark_dirty (view->page_cache, annot_page, EV_PAGE_DATA_INCLUDE_ANNOTS);
+
+  _ev_view_transform_doc_rect_to_view_rect (view, annot_page, &doc_rect, &view_rect);
+  view_rect.x -= view->scroll_x;
+  view_rect.y -= view->scroll_y;
+  region = cairo_region_create_rectangle (&view_rect);
+  ev_view_reload_page (view, annot_page, region);
+  cairo_region_destroy (region);
+
+  view->adding_annot_info.annot = annot;
+}
+
+static void
+ev_view_create_annotation (EvView *view) {
+  EvPoint         start;
+  EvPoint         end;
+  gint            annot_page;
+  gint            offset;
+  GdkRectangle    page_area;
+  GtkBorder       border;
+
+  find_page_at_location (view, view->adding_annot_info.start.x, view->adding_annot_info.start.y, &annot_page, &offset, &offset);
+  if (annot_page == -1) {
+    ev_view_cancel_add_annotation (view);
+    return;
+  }
+
+  ev_view_get_page_extents (view, annot_page, &page_area, &border);
+  _ev_view_transform_view_point_to_doc_point (view, &view->adding_annot_info.start, &page_area, &border,
+                                              &start.x, &start.y);
+  _ev_view_transform_view_point_to_doc_point (view, &view->adding_annot_info.stop, &page_area, &border,
+                                              &end.x, &end.y);
+
+  ev_view_create_annotation_real (view, annot_page, start, end);
 }
 
 static gboolean
 ev_view_get_doc_points_from_selection_region (EvView  *view,
-					      gint     page,
-					      EvPoint *begin,
-					      EvPoint *end)
-{
-	cairo_rectangle_int_t first, last;
-	GdkPoint start, stop;
-	cairo_region_t *region = NULL;
+                                              gint     page,
+                                              EvPoint *begin,
+                                              EvPoint *end) {
+  cairo_rectangle_int_t first, last;
+  GdkPoint start, stop;
+  cairo_region_t *region = NULL;
 
-	if (!view->pixbuf_cache)
-		return FALSE;
+  if (!view->pixbuf_cache)
+    return FALSE;
 
-	region = ev_pixbuf_cache_get_selection_region (view->pixbuf_cache, page, view->scale);
+  region = ev_pixbuf_cache_get_selection_region (view->pixbuf_cache, page, view->scale);
 
-	if (!region)
-		return FALSE;
+  if (!region)
+    return FALSE;
 
-	cairo_region_get_rectangle (region, 0, &first);
-	cairo_region_get_rectangle (region, cairo_region_num_rectangles(region) - 1, &last);
+  cairo_region_get_rectangle (region, 0, &first);
+  cairo_region_get_rectangle (region, cairo_region_num_rectangles(region) - 1, &last);
 
-	if (!get_doc_point_from_offset (view, page, first.x, first.y + (first.height / 2),
-					&(start.x), &(start.y)))
-		return FALSE;
+  if (!get_doc_point_from_offset (view, page, first.x, first.y + (first.height / 2),
+                                  &(start.x), &(start.y)))
+    return FALSE;
 
-	if (!get_doc_point_from_offset (view, page, last.x + last.width, last.y + (last.height / 2),
-					&(stop.x), &(stop.y)))
-		return FALSE;
+  if (!get_doc_point_from_offset (view, page, last.x + last.width, last.y + (last.height / 2),
+                                  &(stop.x), &(stop.y)))
+    return FALSE;
 
-	begin->x = start.x;
-	begin->y = start.y;
-	end->x = stop.x;
-	end->y = stop.y;
+  begin->x = start.x;
+  begin->y = start.y;
+  end->x = stop.x;
+  end->y = stop.y;
 
-	return TRUE;
+  return TRUE;
 }
 
 static void
 ev_view_create_annotation_from_selection (EvView          *view,
-					  EvViewSelection *selection)
-{
-	EvPoint doc_point_start;
-	EvPoint doc_point_end;
-
-	/* Check if selection is of double/triple click type (STYLE_WORD and STYLE_LINE) and in that
-	 * case get the start/end points from the selection region of pixbuf cache. Issue #1119 */
-	if (selection->style == EV_SELECTION_STYLE_WORD || selection->style == EV_SELECTION_STYLE_LINE) {
-
-		if (!ev_view_get_doc_points_from_selection_region (view, selection->page,
-								   &doc_point_start, &doc_point_end))
-			return;
-	} else {
-		doc_point_start.x = selection->rect.x1;
-		doc_point_start.y = selection->rect.y1;
-		doc_point_end.x = selection->rect.x2;
-		doc_point_end.y = selection->rect.y2;
-	}
-
-	ev_view_create_annotation_real (view, selection->page, doc_point_start, doc_point_end);
+                                          EvViewSelection *selection) {
+  EvPoint doc_point_start;
+  EvPoint doc_point_end;
+
+  /* Check if selection is of double/triple click type (STYLE_WORD and STYLE_LINE) and in that
+   * case get the start/end points from the selection region of pixbuf cache. Issue #1119 */
+  if (selection->style == EV_SELECTION_STYLE_WORD || selection->style == EV_SELECTION_STYLE_LINE) {
+
+    if (!ev_view_get_doc_points_from_selection_region (view, selection->page,
+                                                       &doc_point_start, &doc_point_end))
+      return;
+  } else {
+    doc_point_start.x = selection->rect.x1;
+    doc_point_start.y = selection->rect.y1;
+    doc_point_end.x = selection->rect.x2;
+    doc_point_end.y = selection->rect.y2;
+  }
+
+  ev_view_create_annotation_real (view, selection->page, doc_point_start, doc_point_end);
 }
 void
 ev_view_focus_annotation (EvView    *view,
-			  EvMapping *annot_mapping)
-{
+                          EvMapping *annot_mapping) {
 
-	if (!EV_IS_DOCUMENT_ANNOTATIONS (view->document))
-		return;
+  if (!EV_IS_DOCUMENT_ANNOTATIONS (view->document))
+    return;
 
-	_ev_view_set_focused_element (view, annot_mapping,
-				     ev_annotation_get_page_index (EV_ANNOTATION (annot_mapping->data)));
+  _ev_view_set_focused_element (view, annot_mapping,
+                                ev_annotation_get_page_index (EV_ANNOTATION (annot_mapping->data)));
 }
 
 void
 ev_view_begin_add_annotation (EvView          *view,
-			      EvAnnotationType annot_type)
-{
-	if (annot_type == EV_ANNOTATION_TYPE_UNKNOWN)
-		return;
+                              EvAnnotationType annot_type) {
+  if (annot_type == EV_ANNOTATION_TYPE_UNKNOWN)
+    return;
 
-	if (view->adding_annot_info.adding_annot)
-		return;
+  if (view->adding_annot_info.adding_annot)
+    return;
 
-	view->adding_annot_info.adding_annot = TRUE;
-	view->adding_annot_info.type = annot_type;
-	ev_view_set_cursor (view, EV_VIEW_CURSOR_ADD);
+  view->adding_annot_info.adding_annot = TRUE;
+  view->adding_annot_info.type = annot_type;
+  ev_view_set_cursor (view, EV_VIEW_CURSOR_ADD);
 }
 
 void
-ev_view_cancel_add_annotation (EvView *view)
-{
-	gint x, y;
+ev_view_cancel_add_annotation (EvView *view) {
+  gint x, y;
 
-	if (!view->adding_annot_info.adding_annot)
-		return;
+  if (!view->adding_annot_info.adding_annot)
+    return;
 
-	view->adding_annot_info.adding_annot = FALSE;
-	g_assert(!view->adding_annot_info.annot);
-	ev_document_misc_get_pointer_position (GTK_WIDGET (view), &x, &y);
-	ev_view_handle_cursor_over_xy (view, x, y);
+  view->adding_annot_info.adding_annot = FALSE;
+  g_assert(!view->adding_annot_info.annot);
+  ev_document_misc_get_pointer_position (GTK_WIDGET (view), &x, &y);
+  ev_view_handle_cursor_over_xy (view, x, y);
 }
 
 void
 ev_view_remove_annotation (EvView       *view,
-                           EvAnnotation *annot)
-{
-        guint page;
+                           EvAnnotation *annot) {
+  guint page;
 
-        g_return_if_fail (EV_IS_VIEW (view));
-        g_return_if_fail (EV_IS_ANNOTATION (annot));
+  g_return_if_fail (EV_IS_VIEW (view));
+  g_return_if_fail (EV_IS_ANNOTATION (annot));
 
-	g_object_ref (annot);
+  g_object_ref (annot);
 
-        page = ev_annotation_get_page_index (annot);
+  page = ev_annotation_get_page_index (annot);
 
-        if (EV_IS_ANNOTATION_MARKUP (annot))
-		ev_view_remove_window_child_for_annot (view, page, annot);
-	if (view->annot_window_map != NULL)
-		g_hash_table_remove (view->annot_window_map, annot);
+  if (EV_IS_ANNOTATION_MARKUP (annot))
+    ev_view_remove_window_child_for_annot (view, page, annot);
+  if (view->annot_window_map != NULL)
+    g_hash_table_remove (view->annot_window_map, annot);
 
-        _ev_view_set_focused_element (view, NULL, -1);
+  _ev_view_set_focused_element (view, NULL, -1);
 
-        ev_document_doc_mutex_lock ();
-        ev_document_annotations_remove_annotation (EV_DOCUMENT_ANNOTATIONS (view->document),
-                                                   annot);
-        ev_document_doc_mutex_unlock ();
+  ev_document_doc_mutex_lock ();
+  ev_document_annotations_remove_annotation (EV_DOCUMENT_ANNOTATIONS (view->document),
+                                             annot);
+  ev_document_doc_mutex_unlock ();
 
-        ev_page_cache_mark_dirty (view->page_cache, page, EV_PAGE_DATA_INCLUDE_ANNOTS);
+  ev_page_cache_mark_dirty (view->page_cache, page, EV_PAGE_DATA_INCLUDE_ANNOTS);
 
-	/* FIXME: only redraw the annot area */
-        ev_view_reload_page (view, page, NULL);
+  /* FIXME: only redraw the annot area */
+  ev_view_reload_page (view, page, NULL);
 
-	g_signal_emit (view, signals[SIGNAL_ANNOT_REMOVED], 0, annot);
-	g_object_unref (annot);
+  g_signal_emit (view, signals[SIGNAL_ANNOT_REMOVED], 0, annot);
+  g_object_unref (annot);
 }
 
 static gboolean
 ev_view_synctex_backward_search (EvView *view,
-				 gdouble x,
-				 gdouble y)
-{
-	gint page = -1;
-	gint x_new = 0, y_new = 0;
-	EvSourceLink *link;
+                                 gdouble x,
+                                 gdouble y) {
+  gint page = -1;
+  gint x_new = 0, y_new = 0;
+  EvSourceLink *link;
 
-	if (!ev_document_has_synctex (view->document))
-		return FALSE;
+  if (!ev_document_has_synctex (view->document))
+    return FALSE;
 
-	if (!get_doc_point_from_location (view, x, y, &page, &x_new, &y_new))
-		return FALSE;
+  if (!get_doc_point_from_location (view, x, y, &page, &x_new, &y_new))
+    return FALSE;
 
-	link = ev_document_synctex_backward_search (view->document, page, x_new, y_new);
-	if (link) {
-		g_signal_emit (view, signals[SIGNAL_SYNC_SOURCE], 0, link);
-		ev_source_link_free (link);
+  link = ev_document_synctex_backward_search (view->document, page, x_new, y_new);
+  if (link) {
+    g_signal_emit (view, signals[SIGNAL_SYNC_SOURCE], 0, link);
+    ev_source_link_free (link);
 
-		return TRUE;
-	}
+    return TRUE;
+  }
 
-	return FALSE;
+  return FALSE;
 }
 
 /* Caret navigation */
@@ -3683,240 +3578,229 @@ ev_view_synctex_backward_search (EvView *view,
 #define CURSOR_DIVIDER 3
 
 static inline gboolean
-cursor_is_in_visible_page (EvView *view)
-{
-	return (view->cursor_page == view->current_page ||
-		(view->cursor_page >= view->start_page &&
-		 view->cursor_page <= view->end_page));
+cursor_is_in_visible_page (EvView *view) {
+  return (view->cursor_page == view->current_page ||
+          (view->cursor_page >= view->start_page &&
+           view->cursor_page <= view->end_page));
 }
 
 static gboolean
-cursor_should_blink (EvView *view)
-{
-	if (view->caret_enabled &&
-	    view->rotation == 0 &&
-	    cursor_is_in_visible_page (view) &&
-	    gtk_widget_has_focus (GTK_WIDGET (view)) &&
-	    view->pixbuf_cache &&
-	    !ev_pixbuf_cache_get_selection_region (view->pixbuf_cache, view->cursor_page, view->scale)) {
-		GtkSettings *settings;
-		gboolean blink;
+cursor_should_blink (EvView *view) {
+  if (view->caret_enabled &&
+      view->rotation == 0 &&
+      cursor_is_in_visible_page (view) &&
+      gtk_widget_has_focus (GTK_WIDGET (view)) &&
+      view->pixbuf_cache &&
+      !ev_pixbuf_cache_get_selection_region (view->pixbuf_cache, view->cursor_page, view->scale)) {
+    GtkSettings *settings;
+    gboolean blink;
 
-		settings = gtk_widget_get_settings (GTK_WIDGET (view));
-		g_object_get (settings, "gtk-cursor-blink", &blink, NULL);
+    settings = gtk_widget_get_settings (GTK_WIDGET (view));
+    g_object_get (settings, "gtk-cursor-blink", &blink, NULL);
 
-		return blink;
-	}
+    return blink;
+  }
 
-	return FALSE;
+  return FALSE;
 }
 
 static gint
-get_cursor_blink_time (EvView *view)
-{
-	GtkSettings *settings = gtk_widget_get_settings (GTK_WIDGET (view));
-	gint time;
+get_cursor_blink_time (EvView *view) {
+  GtkSettings *settings = gtk_widget_get_settings (GTK_WIDGET (view));
+  gint time;
 
-	g_object_get (settings, "gtk-cursor-blink-time", &time, NULL);
+  g_object_get (settings, "gtk-cursor-blink-time", &time, NULL);
 
-	return time;
+  return time;
 }
 
 static gint
-get_cursor_blink_timeout_id (EvView *view)
-{
-	GtkSettings *settings = gtk_widget_get_settings (GTK_WIDGET (view));
-	gint timeout;
+get_cursor_blink_timeout_id (EvView *view) {
+  GtkSettings *settings = gtk_widget_get_settings (GTK_WIDGET (view));
+  gint timeout;
 
-	g_object_get (settings, "gtk-cursor-blink-timeout", &timeout, NULL);
+  g_object_get (settings, "gtk-cursor-blink-timeout", &timeout, NULL);
 
-	return timeout;
+  return timeout;
 }
 
 static gboolean
 get_caret_cursor_area (EvView       *view,
-		       gint          page,
-		       gint          offset,
-		       GdkRectangle *area)
-{
-	EvRectangle *areas = NULL;
-	EvRectangle *doc_rect;
-	guint        n_areas = 0;
-	gfloat       cursor_aspect_ratio;
-	gint         stem_width;
-
-	if (!view->caret_enabled || view->rotation != 0)
-		return FALSE;
-
-	if (!view->page_cache)
-		return FALSE;
-
-	ev_page_cache_get_text_layout (view->page_cache, page, &areas, &n_areas);
-	if (!areas)
-		return FALSE;
-
-	if (offset > n_areas)
-		return FALSE;
-
-	doc_rect = areas + offset;
-	if (offset == n_areas ||
-	    ((doc_rect->x1 == doc_rect->x2 || doc_rect->y1 == doc_rect->y2) && offset > 0)) {
-		EvRectangle *prev;
-		EvRectangle  last_rect;
-
-		/* Special characters like \n have an empty bounding box
-		 * and the end of a page doesn't have any bounding box,
-		 * use the size of the previous area.
-		 */
-		prev = areas + offset - 1;
-		last_rect.x1 = prev->x2;
-		last_rect.y1 = prev->y1;
-		last_rect.x2 = prev->x2 + (prev->x2 - prev->x1);
-		last_rect.y2 = prev->y2;
-
-		_ev_view_transform_doc_rect_to_view_rect (view, page, &last_rect, area);
-	} else {
-		_ev_view_transform_doc_rect_to_view_rect (view, page, doc_rect, area);
-	}
-
-	area->x -= view->scroll_x;
-	area->y -= view->scroll_y;
-
-	gtk_style_context_get_style (gtk_widget_get_style_context (GTK_WIDGET (view)),
-				     "cursor-aspect-ratio", &cursor_aspect_ratio,
-				     NULL);
-	stem_width = area->height * cursor_aspect_ratio + 1;
-	area->x -= (stem_width / 2);
-	area->width = stem_width;
-
-	return TRUE;
-}
-
-static void
-show_cursor (EvView *view)
-{
-	GtkWidget   *widget;
-	GdkRectangle view_rect;
-
-	if (view->cursor_visible)
-		return;
-
-	widget = GTK_WIDGET (view);
-	view->cursor_visible = TRUE;
-	if (gtk_widget_has_focus (widget) &&
-	    get_caret_cursor_area (view, view->cursor_page, view->cursor_offset, &view_rect)) {
-		gtk_widget_queue_draw_area (widget,
-					    view_rect.x, view_rect.y,
-					    view_rect.width, view_rect.height);
-	}
-}
-
-static void
-hide_cursor (EvView *view)
-{
-	GtkWidget   *widget;
-	GdkRectangle view_rect;
-
-	if (!view->cursor_visible)
-		return;
-
-	widget = GTK_WIDGET (view);
-	view->cursor_visible = FALSE;
-	if (gtk_widget_has_focus (widget) &&
-	    get_caret_cursor_area (view, view->cursor_page, view->cursor_offset, &view_rect)) {
-		gtk_widget_queue_draw_area (widget,
-					    view_rect.x, view_rect.y,
-					    view_rect.width, view_rect.height);
-	}
+                       gint          page,
+                       gint          offset,
+                       GdkRectangle *area) {
+  EvRectangle *areas = NULL;
+  EvRectangle *doc_rect;
+  guint        n_areas = 0;
+  gfloat       cursor_aspect_ratio;
+  gint         stem_width;
+
+  if (!view->caret_enabled || view->rotation != 0)
+    return FALSE;
+
+  if (!view->page_cache)
+    return FALSE;
+
+  ev_page_cache_get_text_layout (view->page_cache, page, &areas, &n_areas);
+  if (!areas)
+    return FALSE;
+
+  if (offset > n_areas)
+    return FALSE;
+
+  doc_rect = areas + offset;
+  if (offset == n_areas ||
+      ((doc_rect->x1 == doc_rect->x2 || doc_rect->y1 == doc_rect->y2) && offset > 0)) {
+    EvRectangle *prev;
+    EvRectangle  last_rect;
+
+    /* Special characters like \n have an empty bounding box
+     * and the end of a page doesn't have any bounding box,
+     * use the size of the previous area.
+     */
+    prev = areas + offset - 1;
+    last_rect.x1 = prev->x2;
+    last_rect.y1 = prev->y1;
+    last_rect.x2 = prev->x2 + (prev->x2 - prev->x1);
+    last_rect.y2 = prev->y2;
+
+    _ev_view_transform_doc_rect_to_view_rect (view, page, &last_rect, area);
+  } else {
+    _ev_view_transform_doc_rect_to_view_rect (view, page, doc_rect, area);
+  }
+
+  area->x -= view->scroll_x;
+  area->y -= view->scroll_y;
+
+  gtk_style_context_get_style (gtk_widget_get_style_context (GTK_WIDGET (view)),
+                               "cursor-aspect-ratio", &cursor_aspect_ratio,
+                               NULL);
+  stem_width = area->height * cursor_aspect_ratio + 1;
+  area->x -= (stem_width / 2);
+  area->width = stem_width;
+
+  return TRUE;
+}
+
+static void
+show_cursor (EvView *view) {
+  GtkWidget   *widget;
+  GdkRectangle view_rect;
+
+  if (view->cursor_visible)
+    return;
+
+  widget = GTK_WIDGET (view);
+  view->cursor_visible = TRUE;
+  if (gtk_widget_has_focus (widget) &&
+      get_caret_cursor_area (view, view->cursor_page, view->cursor_offset, &view_rect)) {
+    gtk_widget_queue_draw_area (widget,
+                                view_rect.x, view_rect.y,
+                                view_rect.width, view_rect.height);
+  }
+}
+
+static void
+hide_cursor (EvView *view) {
+  GtkWidget   *widget;
+  GdkRectangle view_rect;
+
+  if (!view->cursor_visible)
+    return;
+
+  widget = GTK_WIDGET (view);
+  view->cursor_visible = FALSE;
+  if (gtk_widget_has_focus (widget) &&
+      get_caret_cursor_area (view, view->cursor_page, view->cursor_offset, &view_rect)) {
+    gtk_widget_queue_draw_area (widget,
+                                view_rect.x, view_rect.y,
+                                view_rect.width, view_rect.height);
+  }
 }
 
 static gboolean
-blink_cb (EvView *view)
-{
-	gint blink_timeout;
-	guint blink_time;
+blink_cb (EvView *view) {
+  gint blink_timeout;
+  guint blink_time;
 
-	blink_timeout = get_cursor_blink_timeout_id (view);
-	if (view->cursor_blink_time > 1000 * blink_timeout && blink_timeout < G_MAXINT / 1000) {
-		/* We've blinked enough without the user doing anything, stop blinking */
-		show_cursor (view);
-		view->cursor_blink_timeout_id = 0;
+  blink_timeout = get_cursor_blink_timeout_id (view);
+  if (view->cursor_blink_time > 1000 * blink_timeout && blink_timeout < G_MAXINT / 1000) {
+    /* We've blinked enough without the user doing anything, stop blinking */
+    show_cursor (view);
+    view->cursor_blink_timeout_id = 0;
 
-		return FALSE;
-	}
+    return FALSE;
+  }
 
-	blink_time = get_cursor_blink_time (view);
-	if (view->cursor_visible) {
-		hide_cursor (view);
-		blink_time *= CURSOR_OFF_MULTIPLIER;
-	} else {
-		show_cursor (view);
-		view->cursor_blink_time += blink_time;
-		blink_time *= CURSOR_ON_MULTIPLIER;
-	}
+  blink_time = get_cursor_blink_time (view);
+  if (view->cursor_visible) {
+    hide_cursor (view);
+    blink_time *= CURSOR_OFF_MULTIPLIER;
+  } else {
+    show_cursor (view);
+    view->cursor_blink_time += blink_time;
+    blink_time *= CURSOR_ON_MULTIPLIER;
+  }
 
-	view->cursor_blink_timeout_id = gdk_threads_add_timeout (blink_time / CURSOR_DIVIDER, (GSourceFunc)blink_cb, view);
+  view->cursor_blink_timeout_id = gdk_threads_add_timeout (blink_time / CURSOR_DIVIDER, (GSourceFunc)blink_cb, view);
 
-	return FALSE;
+  return FALSE;
 }
 
 static void
-ev_view_check_cursor_blink (EvView *view)
-{
-	if (cursor_should_blink (view))	{
-		if (view->cursor_blink_timeout_id == 0) {
-			show_cursor (view);
-			view->cursor_blink_timeout_id = gdk_threads_add_timeout (get_cursor_blink_time (view) * CURSOR_ON_MULTIPLIER / CURSOR_DIVIDER,
-										 (GSourceFunc)blink_cb, view);
-		}
+ev_view_check_cursor_blink (EvView *view) {
+  if (cursor_should_blink (view))	{
+    if (view->cursor_blink_timeout_id == 0) {
+      show_cursor (view);
+      view->cursor_blink_timeout_id = gdk_threads_add_timeout (get_cursor_blink_time (view) * CURSOR_ON_MULTIPLIER / CURSOR_DIVIDER,
+                                                               (GSourceFunc)blink_cb, view);
+    }
 
-		return;
-	}
+    return;
+  }
 
-	if (view->cursor_blink_timeout_id > 0) {
-		g_source_remove (view->cursor_blink_timeout_id);
-		view->cursor_blink_timeout_id = 0;
-	}
+  if (view->cursor_blink_timeout_id > 0) {
+    g_source_remove (view->cursor_blink_timeout_id);
+    view->cursor_blink_timeout_id = 0;
+  }
 
-	view->cursor_visible = TRUE;
-	view->cursor_blink_time = 0;
+  view->cursor_visible = TRUE;
+  view->cursor_blink_time = 0;
 }
 
 static void
-ev_view_pend_cursor_blink (EvView *view)
-{
-	if (!cursor_should_blink (view))
-		return;
+ev_view_pend_cursor_blink (EvView *view) {
+  if (!cursor_should_blink (view))
+    return;
 
-	if (view->cursor_blink_timeout_id > 0)
-		g_source_remove (view->cursor_blink_timeout_id);
+  if (view->cursor_blink_timeout_id > 0)
+    g_source_remove (view->cursor_blink_timeout_id);
 
-	show_cursor (view);
-	view->cursor_blink_timeout_id = gdk_threads_add_timeout (get_cursor_blink_time (view) * CURSOR_PEND_MULTIPLIER / CURSOR_DIVIDER,
-								 (GSourceFunc)blink_cb, view);
+  show_cursor (view);
+  view->cursor_blink_timeout_id = gdk_threads_add_timeout (get_cursor_blink_time (view) * CURSOR_PEND_MULTIPLIER / CURSOR_DIVIDER,
+                                                           (GSourceFunc)blink_cb, view);
 }
 
 static void
-preload_pages_for_caret_navigation (EvView *view)
-{
-	gint n_pages;
+preload_pages_for_caret_navigation (EvView *view) {
+  gint n_pages;
 
-	if (!view->document)
-		return;
+  if (!view->document)
+    return;
 
-	/* Upload to the cache the first and last pages,
-	 * this information is needed to position the cursor
-	 * in the beginning/end of the document, for example
-	 * when pressing <Ctr>Home/End
-	 */
-	n_pages = ev_document_get_n_pages (view->document);
+  /* Upload to the cache the first and last pages,
+   * this information is needed to position the cursor
+   * in the beginning/end of the document, for example
+   * when pressing <Ctr>Home/End
+   */
+  n_pages = ev_document_get_n_pages (view->document);
 
-	/* For documents with at least 3 pages, those are already cached anyway */
-	if (n_pages > 0 && n_pages <= 3)
-		return;
+  /* For documents with at least 3 pages, those are already cached anyway */
+  if (n_pages > 0 && n_pages <= 3)
+    return;
 
-	ev_page_cache_ensure_page (view->page_cache, 0);
-	ev_page_cache_ensure_page (view->page_cache, n_pages - 1);
+  ev_page_cache_ensure_page (view->page_cache, 0);
+  ev_page_cache_ensure_page (view->page_cache, n_pages - 1);
 }
 
 /**
@@ -3928,18 +3812,17 @@ preload_pages_for_caret_navigation (EvView *view)
  * Since: 3.10
  */
 gboolean
-ev_view_supports_caret_navigation (EvView *view)
-{
-	EvDocumentTextInterface *iface;
+ev_view_supports_caret_navigation (EvView *view) {
+  EvDocumentTextInterface *iface;
 
-	if (!view->document || !EV_IS_DOCUMENT_TEXT (view->document))
-		return FALSE;
+  if (!view->document || !EV_IS_DOCUMENT_TEXT (view->document))
+    return FALSE;
 
-	iface = EV_DOCUMENT_TEXT_GET_IFACE (view->document);
-	if (!iface->get_text_layout || !iface->get_text)
-		return FALSE;
+  iface = EV_DOCUMENT_TEXT_GET_IFACE (view->document);
+  if (!iface->get_text_layout || !iface->get_text)
+    return FALSE;
 
-	return TRUE;
+  return TRUE;
 }
 
 /**
@@ -3953,20 +3836,19 @@ ev_view_supports_caret_navigation (EvView *view)
  */
 void
 ev_view_set_caret_navigation_enabled (EvView   *view,
-				      gboolean enabled)
-{
-	g_return_if_fail (EV_IS_VIEW (view));
+                                      gboolean enabled) {
+  g_return_if_fail (EV_IS_VIEW (view));
 
-	if (view->caret_enabled != enabled) {
-		view->caret_enabled = enabled;
-		if (view->caret_enabled)
-			preload_pages_for_caret_navigation (view);
+  if (view->caret_enabled != enabled) {
+    view->caret_enabled = enabled;
+    if (view->caret_enabled)
+      preload_pages_for_caret_navigation (view);
 
-		ev_view_check_cursor_blink (view);
+    ev_view_check_cursor_blink (view);
 
-		if (cursor_is_in_visible_page (view))
-			gtk_widget_queue_draw (GTK_WIDGET (view));
-	}
+    if (cursor_is_in_visible_page (view))
+      gtk_widget_queue_draw (GTK_WIDGET (view));
+  }
 }
 
 /**
@@ -3978,11 +3860,10 @@ ev_view_set_caret_navigation_enabled (EvView   *view,
  * Since: 3.10
  */
 gboolean
-ev_view_is_caret_navigation_enabled (EvView *view)
-{
-	g_return_val_if_fail (EV_IS_VIEW (view), FALSE);
+ev_view_is_caret_navigation_enabled (EvView *view) {
+  g_return_val_if_fail (EV_IS_VIEW (view), FALSE);
 
-	return view->caret_enabled;
+  return view->caret_enabled;
 }
 
 /**
@@ -3995,1826 +3876,1776 @@ ev_view_is_caret_navigation_enabled (EvView *view)
  */
 void
 ev_view_set_caret_cursor_position (EvView *view,
-				   guint   page,
-				   guint   offset)
-{
-	g_return_if_fail (EV_IS_VIEW (view));
-	g_return_if_fail (EV_IS_DOCUMENT (view->document));
-	g_return_if_fail (page < ev_document_get_n_pages (view->document));
+                                   guint   page,
+                                   guint   offset) {
+  g_return_if_fail (EV_IS_VIEW (view));
+  g_return_if_fail (EV_IS_DOCUMENT (view->document));
+  g_return_if_fail (page < ev_document_get_n_pages (view->document));
 
-	if (view->cursor_page != page || view->cursor_offset != offset) {
-		view->cursor_page = page;
-		view->cursor_offset = offset;
+  if (view->cursor_page != page || view->cursor_offset != offset) {
+    view->cursor_page = page;
+    view->cursor_offset = offset;
 
-		g_signal_emit (view, signals[SIGNAL_CURSOR_MOVED], 0,
-			       view->cursor_page, view->cursor_offset);
+    g_signal_emit (view, signals[SIGNAL_CURSOR_MOVED], 0,
+                   view->cursor_page, view->cursor_offset);
 
-		if (view->caret_enabled && cursor_is_in_visible_page (view))
-			gtk_widget_queue_draw (GTK_WIDGET (view));
-	}
+    if (view->caret_enabled && cursor_is_in_visible_page (view))
+      gtk_widget_queue_draw (GTK_WIDGET (view));
+  }
 }
 /*** GtkWidget implementation ***/
 
 static void
 ev_view_size_request_continuous_dual_page (EvView         *view,
-			     	           GtkRequisition *requisition)
-{
-	gint n_pages;
-	GtkBorder border;
-
-	n_pages = ev_document_get_n_pages (view->document) + 1;
-	compute_border (view, &border);
-	get_page_y_offset (view, n_pages, &requisition->height, &border);
-
-	switch (view->sizing_mode) {
-	        case EV_SIZING_FIT_WIDTH:
-	        case EV_SIZING_FIT_PAGE:
-	        case EV_SIZING_AUTOMATIC:
-			requisition->width = 1;
-
-			break;
-	        case EV_SIZING_FREE: {
-			gint max_width;
-
-			ev_view_get_max_page_size (view, &max_width, NULL);
-			requisition->width = (max_width + border.left + border.right) * 2 + (view->spacing * 3);
-		}
-			break;
-	        default:
-			g_assert_not_reached ();
-	}
+                                           GtkRequisition *requisition) {
+  gint n_pages;
+  GtkBorder border;
+
+  n_pages = ev_document_get_n_pages (view->document) + 1;
+  compute_border (view, &border);
+  get_page_y_offset (view, n_pages, &requisition->height, &border);
+
+  switch (view->sizing_mode) {
+    case EV_SIZING_FIT_WIDTH:
+    case EV_SIZING_FIT_PAGE:
+    case EV_SIZING_AUTOMATIC:
+      requisition->width = 1;
+
+      break;
+    case EV_SIZING_FREE: {
+      gint max_width;
+
+      ev_view_get_max_page_size (view, &max_width, NULL);
+      requisition->width = (max_width + border.left + border.right) * 2 + (view->spacing * 3);
+    }
+    break;
+    default:
+      g_assert_not_reached ();
+  }
 }
 
 static void
 ev_view_size_request_continuous (EvView         *view,
-				 GtkRequisition *requisition)
-{
-	gint n_pages;
-	GtkBorder border;
-
-	n_pages = ev_document_get_n_pages (view->document);
-	compute_border (view, &border);
-	get_page_y_offset (view, n_pages, &requisition->height, &border);
-
-	switch (view->sizing_mode) {
-	        case EV_SIZING_FIT_WIDTH:
-	        case EV_SIZING_FIT_PAGE:
-	        case EV_SIZING_AUTOMATIC:
-			requisition->width = 1;
-
-			break;
-	        case EV_SIZING_FREE: {
-			gint max_width;
-
-			ev_view_get_max_page_size (view, &max_width, NULL);
-			requisition->width = max_width + (view->spacing * 2) + border.left + border.right;
-		}
-			break;
-	        default:
-			g_assert_not_reached ();
-	}
+                                 GtkRequisition *requisition) {
+  gint n_pages;
+  GtkBorder border;
+
+  n_pages = ev_document_get_n_pages (view->document);
+  compute_border (view, &border);
+  get_page_y_offset (view, n_pages, &requisition->height, &border);
+
+  switch (view->sizing_mode) {
+    case EV_SIZING_FIT_WIDTH:
+    case EV_SIZING_FIT_PAGE:
+    case EV_SIZING_AUTOMATIC:
+      requisition->width = 1;
+
+      break;
+    case EV_SIZING_FREE: {
+      gint max_width;
+
+      ev_view_get_max_page_size (view, &max_width, NULL);
+      requisition->width = max_width + (view->spacing * 2) + border.left + border.right;
+    }
+    break;
+    default:
+      g_assert_not_reached ();
+  }
 }
 
 static void
 ev_view_size_request_dual_page (EvView         *view,
-				GtkRequisition *requisition)
-{
-	GtkBorder border;
-	gint width, height;
-
-	if (view->sizing_mode == EV_SIZING_FIT_PAGE) {
-		requisition->width = 1;
-		requisition->height = 1;
-
-		return;
-	}
-
-	/* Find the largest of the two. */
-	ev_view_get_page_size (view,
-			       view->current_page,
-			       &width, &height);
-	if (view->current_page + 1 < ev_document_get_n_pages (view->document)) {
-		gint width_2, height_2;
-		ev_view_get_page_size (view,
-				       view->current_page + 1,
-				       &width_2, &height_2);
-		if (width_2 > width) {
-			width = width_2;
-			height = height_2;
-		}
-	}
-	compute_border (view, &border);
-
-	requisition->width = view->sizing_mode == EV_SIZING_FIT_WIDTH ? 1 :
-		((width + border.left + border.right) * 2) + (view->spacing * 3);
-	requisition->height = (height + border.top + border.bottom) + (view->spacing * 2);
+                                GtkRequisition *requisition) {
+  GtkBorder border;
+  gint width, height;
+
+  if (view->sizing_mode == EV_SIZING_FIT_PAGE) {
+    requisition->width = 1;
+    requisition->height = 1;
+
+    return;
+  }
+
+  /* Find the largest of the two. */
+  ev_view_get_page_size (view,
+                         view->current_page,
+                         &width, &height);
+  if (view->current_page + 1 < ev_document_get_n_pages (view->document)) {
+    gint width_2, height_2;
+    ev_view_get_page_size (view,
+                           view->current_page + 1,
+                           &width_2, &height_2);
+    if (width_2 > width) {
+      width = width_2;
+      height = height_2;
+    }
+  }
+  compute_border (view, &border);
+
+  requisition->width = view->sizing_mode == EV_SIZING_FIT_WIDTH ? 1 :
+                       ((width + border.left + border.right) * 2) + (view->spacing * 3);
+  requisition->height = (height + border.top + border.bottom) + (view->spacing * 2);
 }
 
 static void
 ev_view_size_request_single_page (EvView         *view,
-				  GtkRequisition *requisition)
-{
-	GtkBorder border;
-	gint width, height;
+                                  GtkRequisition *requisition) {
+  GtkBorder border;
+  gint width, height;
 
-	if (view->sizing_mode == EV_SIZING_FIT_PAGE) {
-		requisition->width = 1;
-		requisition->height = 1;
+  if (view->sizing_mode == EV_SIZING_FIT_PAGE) {
+    requisition->width = 1;
+    requisition->height = 1;
 
-		return;
-	}
+    return;
+  }
 
-	ev_view_get_page_size (view, view->current_page, &width, &height);
-	compute_border (view, &border);
+  ev_view_get_page_size (view, view->current_page, &width, &height);
+  compute_border (view, &border);
 
-	requisition->width = view->sizing_mode == EV_SIZING_FIT_WIDTH ? 1 :
-		width + border.left + border.right + (2 * view->spacing);
-	requisition->height = height + border.top + border.bottom + (2 * view->spacing);
+  requisition->width = view->sizing_mode == EV_SIZING_FIT_WIDTH ? 1 :
+                       width + border.left + border.right + (2 * view->spacing);
+  requisition->height = height + border.top + border.bottom + (2 * view->spacing);
 }
 
 static void
 ev_view_size_request (GtkWidget      *widget,
-		      GtkRequisition *requisition)
-{
-	EvView *view = EV_VIEW (widget);
-	gboolean dual_page;
+                      GtkRequisition *requisition) {
+  EvView *view = EV_VIEW (widget);
+  gboolean dual_page;
 
-	if (view->document == NULL) {
-		view->requisition.width = 1;
-		view->requisition.height = 1;
+  if (view->document == NULL) {
+    view->requisition.width = 1;
+    view->requisition.height = 1;
 
-		*requisition = view->requisition;
+    *requisition = view->requisition;
 
-		return;
-	}
+    return;
+  }
 
-	/* Get zoom for size here when not called from
-	 * ev_view_size_allocate()
-	 */
-	if (!view->internal_size_request &&
-	    (view->sizing_mode == EV_SIZING_FIT_WIDTH ||
-	     view->sizing_mode == EV_SIZING_FIT_PAGE ||
-	     view->sizing_mode == EV_SIZING_AUTOMATIC)) {
-		GtkAllocation allocation;
+  /* Get zoom for size here when not called from
+   * ev_view_size_allocate()
+   */
+  if (!view->internal_size_request &&
+      (view->sizing_mode == EV_SIZING_FIT_WIDTH ||
+       view->sizing_mode == EV_SIZING_FIT_PAGE ||
+       view->sizing_mode == EV_SIZING_AUTOMATIC)) {
+    GtkAllocation allocation;
 
-		gtk_widget_get_allocation (widget, &allocation);
-		ev_view_zoom_for_size (view,
-				       allocation.width,
-				       allocation.height);
-	}
+    gtk_widget_get_allocation (widget, &allocation);
+    ev_view_zoom_for_size (view,
+                           allocation.width,
+                           allocation.height);
+  }
 
-	dual_page = is_dual_page (view, NULL);
-	if (view->continuous && dual_page)
-		ev_view_size_request_continuous_dual_page (view, &view->requisition);
-	else if (view->continuous)
-		ev_view_size_request_continuous (view, &view->requisition);
-	else if (dual_page)
-		ev_view_size_request_dual_page (view, &view->requisition);
-	else
-		ev_view_size_request_single_page (view, &view->requisition);
+  dual_page = is_dual_page (view, NULL);
+  if (view->continuous && dual_page)
+    ev_view_size_request_continuous_dual_page (view, &view->requisition);
+  else if (view->continuous)
+    ev_view_size_request_continuous (view, &view->requisition);
+  else if (dual_page)
+    ev_view_size_request_dual_page (view, &view->requisition);
+  else
+    ev_view_size_request_single_page (view, &view->requisition);
 
-	*requisition = view->requisition;
+  *requisition = view->requisition;
 }
 
 static void
 ev_view_get_preferred_width (GtkWidget *widget,
                              gint      *minimum,
-                             gint      *natural)
-{
-        GtkRequisition requisition;
+                             gint      *natural) {
+  GtkRequisition requisition;
 
-        ev_view_size_request (widget, &requisition);
+  ev_view_size_request (widget, &requisition);
 
-        *minimum = *natural = requisition.width;
+  *minimum = *natural = requisition.width;
 }
 
 static void
 ev_view_get_preferred_height (GtkWidget *widget,
                               gint      *minimum,
-                              gint      *natural)
-{
-        GtkRequisition requisition;
+                              gint      *natural) {
+  GtkRequisition requisition;
 
-        ev_view_size_request (widget, &requisition);
+  ev_view_size_request (widget, &requisition);
 
-        *minimum = *natural = requisition.height;
+  *minimum = *natural = requisition.height;
 }
 
 static void
 ev_view_size_allocate (GtkWidget      *widget,
-		       GtkAllocation  *allocation)
-{
-	EvView *view = EV_VIEW (widget);
-	GList  *l;
-	gint    root_x, root_y;
-
-	gtk_widget_set_allocation (widget, allocation);
-
-	if (gtk_widget_get_realized (widget))
-		gdk_window_move_resize (gtk_widget_get_window (widget),
-					allocation->x,
-					allocation->y,
-					allocation->width,
-					allocation->height);
-
-	if (!view->document)
-		return;
-
-	if (view->sizing_mode == EV_SIZING_FIT_WIDTH ||
-	    view->sizing_mode == EV_SIZING_FIT_PAGE ||
-	    view->sizing_mode == EV_SIZING_AUTOMATIC) {
-		GtkRequisition req;
-
-		ev_view_zoom_for_size (view,
-				       allocation->width,
-				       allocation->height);
-		view->internal_size_request = TRUE;
-		ev_view_size_request (widget, &req);
-		view->internal_size_request = FALSE;
-	}
-
-	ev_view_set_adjustment_values (view, GTK_ORIENTATION_HORIZONTAL);
-	ev_view_set_adjustment_values (view, GTK_ORIENTATION_VERTICAL);
-
-	if (view->document)
-		view_update_range_and_current_page (view);
-
-	view->pending_scroll = SCROLL_TO_KEEP_POSITION;
-	view->pending_resize = FALSE;
-	view->pending_point.x = 0;
-	view->pending_point.y = 0;
-
-	for (l = view->children; l && l->data; l = g_list_next (l)) {
-		GdkRectangle view_area;
-		EvViewChild *child = (EvViewChild *)l->data;
-
-		if (!gtk_widget_get_visible (child->widget))
-			continue;
-
-		_ev_view_transform_doc_rect_to_view_rect (view, child->page, &child->doc_rect, &view_area);
-		view_area.x -= view->scroll_x;
-		view_area.y -= view->scroll_y;
-
-		gtk_widget_set_size_request (child->widget, view_area.width, view_area.height);
-		gtk_widget_size_allocate (child->widget, &view_area);
-	}
-
-	if (view->window_children)
-		gdk_window_get_origin (gtk_widget_get_window (GTK_WIDGET (view)),
-				       &root_x, &root_y);
-
-	for (l = view->window_children; l && l->data; l = g_list_next (l)) {
-		EvViewWindowChild *child;
-		EvRectangle        doc_rect;
-		GdkRectangle       view_rect;
-
-		child = (EvViewWindowChild *)l->data;
-
-		ev_annotation_window_get_rectangle (EV_ANNOTATION_WINDOW (child->window), &doc_rect);
-		if (child->moved) {
-			doc_rect.x1 = child->orig_x;
-			doc_rect.y1 = child->orig_y;
-		}
-		_ev_view_transform_doc_rect_to_view_rect (view, child->page, &doc_rect, &view_rect);
-		view_rect.x -= view->scroll_x;
-		view_rect.y -= view->scroll_y;
-
-		if (view_rect.x != child->orig_x || view_rect.y != child->orig_y) {
-			child->parent_x = root_x;
-			child->parent_y = root_y;
-			ev_view_window_child_move (view, child, view_rect.x + root_x, view_rect.y + root_y);
-		}
-	}
+                       GtkAllocation  *allocation) {
+  EvView *view = EV_VIEW (widget);
+  GList  *l;
+  gint    root_x, root_y;
+
+  gtk_widget_set_allocation (widget, allocation);
+
+  if (gtk_widget_get_realized (widget))
+    gdk_window_move_resize (gtk_widget_get_window (widget),
+                            allocation->x,
+                            allocation->y,
+                            allocation->width,
+                            allocation->height);
+
+  if (!view->document)
+    return;
+
+  if (view->sizing_mode == EV_SIZING_FIT_WIDTH ||
+      view->sizing_mode == EV_SIZING_FIT_PAGE ||
+      view->sizing_mode == EV_SIZING_AUTOMATIC) {
+    GtkRequisition req;
+
+    ev_view_zoom_for_size (view,
+                           allocation->width,
+                           allocation->height);
+    view->internal_size_request = TRUE;
+    ev_view_size_request (widget, &req);
+    view->internal_size_request = FALSE;
+  }
+
+  ev_view_set_adjustment_values (view, GTK_ORIENTATION_HORIZONTAL);
+  ev_view_set_adjustment_values (view, GTK_ORIENTATION_VERTICAL);
+
+  if (view->document)
+    view_update_range_and_current_page (view);
+
+  view->pending_scroll = SCROLL_TO_KEEP_POSITION;
+  view->pending_resize = FALSE;
+  view->pending_point.x = 0;
+  view->pending_point.y = 0;
+
+  for (l = view->children; l && l->data; l = g_list_next (l)) {
+    GdkRectangle view_area;
+    EvViewChild *child = (EvViewChild *)l->data;
+
+    if (!gtk_widget_get_visible (child->widget))
+      continue;
+
+    _ev_view_transform_doc_rect_to_view_rect (view, child->page, &child->doc_rect, &view_area);
+    view_area.x -= view->scroll_x;
+    view_area.y -= view->scroll_y;
+
+    gtk_widget_set_size_request (child->widget, view_area.width, view_area.height);
+    gtk_widget_size_allocate (child->widget, &view_area);
+  }
+
+  if (view->window_children)
+    gdk_window_get_origin (gtk_widget_get_window (GTK_WIDGET (view)),
+                           &root_x, &root_y);
+
+  for (l = view->window_children; l && l->data; l = g_list_next (l)) {
+    EvViewWindowChild *child;
+    EvRectangle        doc_rect;
+    GdkRectangle       view_rect;
+
+    child = (EvViewWindowChild *)l->data;
+
+    ev_annotation_window_get_rectangle (EV_ANNOTATION_WINDOW (child->window), &doc_rect);
+    if (child->moved) {
+      doc_rect.x1 = child->orig_x;
+      doc_rect.y1 = child->orig_y;
+    }
+    _ev_view_transform_doc_rect_to_view_rect (view, child->page, &doc_rect, &view_rect);
+    view_rect.x -= view->scroll_x;
+    view_rect.y -= view->scroll_y;
+
+    if (view_rect.x != child->orig_x || view_rect.y != child->orig_y) {
+      child->parent_x = root_x;
+      child->parent_y = root_y;
+      ev_view_window_child_move (view, child, view_rect.x + root_x, view_rect.y + root_y);
+    }
+  }
 }
 
 static gboolean
-ev_view_scroll_event (GtkWidget *widget, GdkEventScroll *event)
-{
-	EvView *view = EV_VIEW (widget);
-	guint state;
-	gboolean fit_width, fit_height;
-
-	state = event->state & gtk_accelerator_get_default_mod_mask ();
-
-	if (state == GDK_CONTROL_MASK) {
-		ev_document_model_set_sizing_mode (view->model, EV_SIZING_FREE);
-		view->zoom_center_x = event->x;
-		view->zoom_center_y = event->y;
-
-		switch (event->direction) {
-		case GDK_SCROLL_DOWN:
-		case GDK_SCROLL_RIGHT:
-			if (ev_view_can_zoom_out (view))
-				ev_view_zoom_out (view);
-			break;
-		case GDK_SCROLL_UP:
-		case GDK_SCROLL_LEFT:
-			if (ev_view_can_zoom_in (view))
-				ev_view_zoom_in (view);
-			break;
-		case GDK_SCROLL_SMOOTH: {
-			gdouble delta = event->delta_x + event->delta_y;
-			gdouble factor = pow (delta < 0 ? ZOOM_IN_FACTOR : ZOOM_OUT_FACTOR, fabs (delta));
-
-			if (ev_view_can_zoom (view, factor))
-				ev_view_zoom (view, factor);
-		}
-			break;
-		}
-
-		return TRUE;
-	}
-
-	view->jump_to_find_result = FALSE;
-
-	/* Shift+Wheel scrolls the in the perpendicular direction */
-	if (state & GDK_SHIFT_MASK) {
-		if (event->direction == GDK_SCROLL_UP)
-			event->direction = GDK_SCROLL_LEFT;
-		else if (event->direction == GDK_SCROLL_LEFT)
-			event->direction = GDK_SCROLL_UP;
-		else if (event->direction == GDK_SCROLL_DOWN)
-			event->direction = GDK_SCROLL_RIGHT;
-		else if (event->direction == GDK_SCROLL_RIGHT)
-			event->direction = GDK_SCROLL_DOWN;
-		else if (event->direction == GDK_SCROLL_SMOOTH) {
-			/* Swap the deltas for perpendicular direction */
-			gdouble tmp_delta = event->delta_x;
-
-			event->delta_x = event->delta_y;
-			event->delta_y = tmp_delta;
-		}
-
-		event->state &= ~GDK_SHIFT_MASK;
-		state &= ~GDK_SHIFT_MASK;
-	}
-
-	fit_width = ev_view_page_fits (view, GTK_ORIENTATION_HORIZONTAL);
-	fit_height = ev_view_page_fits (view, GTK_ORIENTATION_VERTICAL);
-	if (state == 0 && !view->continuous && (fit_width || fit_height)) {
-		switch (event->direction) {
-		case GDK_SCROLL_DOWN:
-			if (fit_height) {
-				ev_view_next_page (view);
-				return TRUE;
-			}
-			break;
-		case GDK_SCROLL_RIGHT:
-			if (fit_width) {
-				ev_view_next_page (view);
-				return TRUE;
-			}
-			break;
-		case GDK_SCROLL_UP:
-			if (fit_height) {
-				ev_view_previous_page (view);
-				return TRUE;
-			}
-			break;
-		case GDK_SCROLL_LEFT:
-			if (fit_width) {
-				ev_view_previous_page (view);
-				return TRUE;
-			}
-			break;
-		case GDK_SCROLL_SMOOTH: {
-			gdouble decrement;
-			if ((fit_width && fit_height) ||
-			    ((fit_height && event->delta_x == 0.0) ||
-			     (fit_width && event->delta_y == 0.0))) {
-				/* Emulate normal scrolling by summing the deltas */
-				view->total_delta += event->delta_x + event->delta_y;
-
-				decrement = view->total_delta < 0 ? -1.0 : 1.0;
-				for (; fabs (view->total_delta) >= 1.0; view->total_delta -= decrement) {
-					if (decrement < 0)
-						ev_view_previous_page (view);
-					else
-						ev_view_next_page (view);
-				}
-
-				return TRUE;
-			}
-		}
-			break;
-		}
-
-		return FALSE;
-	}
-
-	/* Do scroll only on one axis at a time. Issue #866 */
-	if (event->direction == GDK_SCROLL_SMOOTH &&
-	    event->delta_x != 0.0 && event->delta_y != 0.0) {
-		gdouble abs_x, abs_y;
-		abs_x = fabs (event->delta_x);
-		abs_y = fabs (event->delta_y);
-
-		if (abs_y > abs_x)
-			event->delta_x = 0.0;
-		else if (abs_x > abs_y)
-			event->delta_y = 0.0;
-	}
-
-	return FALSE;
+ev_view_scroll_event (GtkWidget *widget, GdkEventScroll *event) {
+  EvView *view = EV_VIEW (widget);
+  guint state;
+  gboolean fit_width, fit_height;
+
+  state = event->state & gtk_accelerator_get_default_mod_mask ();
+
+  if (state == GDK_CONTROL_MASK) {
+    ev_document_model_set_sizing_mode (view->model, EV_SIZING_FREE);
+    view->zoom_center_x = event->x;
+    view->zoom_center_y = event->y;
+
+    switch (event->direction) {
+      case GDK_SCROLL_DOWN:
+      case GDK_SCROLL_RIGHT:
+        if (ev_view_can_zoom_out (view))
+          ev_view_zoom_out (view);
+        break;
+      case GDK_SCROLL_UP:
+      case GDK_SCROLL_LEFT:
+        if (ev_view_can_zoom_in (view))
+          ev_view_zoom_in (view);
+        break;
+      case GDK_SCROLL_SMOOTH: {
+        gdouble delta = event->delta_x + event->delta_y;
+        gdouble factor = pow (delta < 0 ? ZOOM_IN_FACTOR : ZOOM_OUT_FACTOR, fabs (delta));
+
+        if (ev_view_can_zoom (view, factor))
+          ev_view_zoom (view, factor);
+      }
+      break;
+    }
+
+    return TRUE;
+  }
+
+  view->jump_to_find_result = FALSE;
+
+  /* Shift+Wheel scrolls the in the perpendicular direction */
+  if (state & GDK_SHIFT_MASK) {
+    if (event->direction == GDK_SCROLL_UP)
+      event->direction = GDK_SCROLL_LEFT;
+    else if (event->direction == GDK_SCROLL_LEFT)
+      event->direction = GDK_SCROLL_UP;
+    else if (event->direction == GDK_SCROLL_DOWN)
+      event->direction = GDK_SCROLL_RIGHT;
+    else if (event->direction == GDK_SCROLL_RIGHT)
+      event->direction = GDK_SCROLL_DOWN;
+    else if (event->direction == GDK_SCROLL_SMOOTH) {
+      /* Swap the deltas for perpendicular direction */
+      gdouble tmp_delta = event->delta_x;
+
+      event->delta_x = event->delta_y;
+      event->delta_y = tmp_delta;
+    }
+
+    event->state &= ~GDK_SHIFT_MASK;
+    state &= ~GDK_SHIFT_MASK;
+  }
+
+  fit_width = ev_view_page_fits (view, GTK_ORIENTATION_HORIZONTAL);
+  fit_height = ev_view_page_fits (view, GTK_ORIENTATION_VERTICAL);
+  if (state == 0 && !view->continuous && (fit_width || fit_height)) {
+    switch (event->direction) {
+      case GDK_SCROLL_DOWN:
+        if (fit_height) {
+          ev_view_next_page (view);
+          return TRUE;
+        }
+        break;
+      case GDK_SCROLL_RIGHT:
+        if (fit_width) {
+          ev_view_next_page (view);
+          return TRUE;
+        }
+        break;
+      case GDK_SCROLL_UP:
+        if (fit_height) {
+          ev_view_previous_page (view);
+          return TRUE;
+        }
+        break;
+      case GDK_SCROLL_LEFT:
+        if (fit_width) {
+          ev_view_previous_page (view);
+          return TRUE;
+        }
+        break;
+      case GDK_SCROLL_SMOOTH: {
+        gdouble decrement;
+        if ((fit_width && fit_height) ||
+            ((fit_height && event->delta_x == 0.0) ||
+             (fit_width && event->delta_y == 0.0))) {
+          /* Emulate normal scrolling by summing the deltas */
+          view->total_delta += event->delta_x + event->delta_y;
+
+          decrement = view->total_delta < 0 ? -1.0 : 1.0;
+          for (; fabs (view->total_delta) >= 1.0; view->total_delta -= decrement) {
+            if (decrement < 0)
+              ev_view_previous_page (view);
+            else
+              ev_view_next_page (view);
+          }
+
+          return TRUE;
+        }
+      }
+      break;
+    }
+
+    return FALSE;
+  }
+
+  /* Do scroll only on one axis at a time. Issue #866 */
+  if (event->direction == GDK_SCROLL_SMOOTH &&
+      event->delta_x != 0.0 && event->delta_y != 0.0) {
+    gdouble abs_x, abs_y;
+    abs_x = fabs (event->delta_x);
+    abs_y = fabs (event->delta_y);
+
+    if (abs_y > abs_x)
+      event->delta_x = 0.0;
+    else if (abs_x > abs_y)
+      event->delta_y = 0.0;
+  }
+
+  return FALSE;
 }
 
 static EvViewSelection *
 find_selection_for_page (EvView *view,
-			 gint    page)
-{
-	GList *list;
+                         gint    page) {
+  GList *list;
 
-	for (list = view->selection_info.selections; list != NULL; list = list->next) {
-		EvViewSelection *selection;
+  for (list = view->selection_info.selections; list != NULL; list = list->next) {
+    EvViewSelection *selection;
 
-		selection = (EvViewSelection *) list->data;
+    selection = (EvViewSelection *) list->data;
 
-		if (selection->page == page)
-			return selection;
-	}
+    if (selection->page == page)
+      return selection;
+  }
 
-	return NULL;
+  return NULL;
 }
 
 static void
-ev_view_realize (GtkWidget *widget)
-{
-	GtkAllocation allocation;
-	GdkWindow *window;
-	GdkWindowAttr attributes;
-	gint attributes_mask;
+ev_view_realize (GtkWidget *widget) {
+  GtkAllocation allocation;
+  GdkWindow *window;
+  GdkWindowAttr attributes;
+  gint attributes_mask;
 
-	gtk_widget_set_realized (widget, TRUE);
+  gtk_widget_set_realized (widget, TRUE);
 
-	gtk_widget_get_allocation (widget, &allocation);
+  gtk_widget_get_allocation (widget, &allocation);
 
-	attributes.window_type = GDK_WINDOW_CHILD;
-	attributes.x = allocation.x;
-	attributes.y = allocation.y;
-	attributes.width = allocation.width;
-	attributes.height = allocation.height;
-	attributes.wclass = GDK_INPUT_OUTPUT;
-	attributes.visual = gtk_widget_get_visual (widget);
-	attributes.event_mask = gtk_widget_get_events (widget);
+  attributes.window_type = GDK_WINDOW_CHILD;
+  attributes.x = allocation.x;
+  attributes.y = allocation.y;
+  attributes.width = allocation.width;
+  attributes.height = allocation.height;
+  attributes.wclass = GDK_INPUT_OUTPUT;
+  attributes.visual = gtk_widget_get_visual (widget);
+  attributes.event_mask = gtk_widget_get_events (widget);
 
-	attributes_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL;
+  attributes_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL;
 
-	window = gdk_window_new (gtk_widget_get_parent_window (widget),
-				 &attributes, attributes_mask);
-	gtk_widget_set_window (widget, window);
-	gdk_window_set_user_data (window, widget);
+  window = gdk_window_new (gtk_widget_get_parent_window (widget),
+                           &attributes, attributes_mask);
+  gtk_widget_set_window (widget, window);
+  gdk_window_set_user_data (window, widget);
 
-	gtk_style_context_set_background (gtk_widget_get_style_context (widget),
-					  window);
+  gtk_style_context_set_background (gtk_widget_get_style_context (widget),
+                                    window);
 }
 
 static void
 get_cursor_color (GtkStyleContext *context,
-		  GdkRGBA         *color)
-{
-	GdkColor *style_color;
+                  GdkRGBA         *color) {
+  GdkColor *style_color;
 
-	gtk_style_context_get_style (context,
-				     "cursor-color",
-				     &style_color,
-				     NULL);
+  gtk_style_context_get_style (context,
+                               "cursor-color",
+                               &style_color,
+                               NULL);
 
-	if (style_color) {
-		color->red = style_color->red / 65535.0;
-		color->green = style_color->green / 65535.0;
-		color->blue = style_color->blue / 65535.0;
-		color->alpha = 1;
+  if (style_color) {
+    color->red = style_color->red / 65535.0;
+    color->green = style_color->green / 65535.0;
+    color->blue = style_color->blue / 65535.0;
+    color->alpha = 1;
 
-		gdk_color_free (style_color);
-	} else {
-		gtk_style_context_save (context);
-		gtk_style_context_get_color (context, GTK_STATE_FLAG_NORMAL, color);
-		gtk_style_context_restore (context);
-	}
+    gdk_color_free (style_color);
+  } else {
+    gtk_style_context_save (context);
+    gtk_style_context_get_color (context, GTK_STATE_FLAG_NORMAL, color);
+    gtk_style_context_restore (context);
+  }
 }
 
 /* This is based on the deprecated function gtk_draw_insertion_cursor. */
 static void
 draw_caret_cursor (EvView  *view,
-		   cairo_t *cr)
-{
-	GdkRectangle view_rect;
-	GdkRGBA      cursor_color;
+                   cairo_t *cr) {
+  GdkRectangle view_rect;
+  GdkRGBA      cursor_color;
 
-	if (!get_caret_cursor_area (view, view->cursor_page, view->cursor_offset, &view_rect))
-		return;
+  if (!get_caret_cursor_area (view, view->cursor_page, view->cursor_offset, &view_rect))
+    return;
 
-	get_cursor_color (gtk_widget_get_style_context (GTK_WIDGET (view)), &cursor_color);
+  get_cursor_color (gtk_widget_get_style_context (GTK_WIDGET (view)), &cursor_color);
 
-	cairo_save (cr);
-	gdk_cairo_set_source_rgba (cr, &cursor_color);
-	cairo_rectangle (cr, view_rect.x, view_rect.y, view_rect.width, view_rect.height);
-	cairo_fill (cr);
-	cairo_restore (cr);
+  cairo_save (cr);
+  gdk_cairo_set_source_rgba (cr, &cursor_color);
+  cairo_rectangle (cr, view_rect.x, view_rect.y, view_rect.width, view_rect.height);
+  cairo_fill (cr);
+  cairo_restore (cr);
 }
 
 static gboolean
 should_draw_caret_cursor (EvView  *view,
-			  gint     page)
-{
-	return (view->caret_enabled &&
-		view->cursor_page == page &&
-		view->cursor_visible &&
-		gtk_widget_has_focus (GTK_WIDGET (view)) &&
-		!ev_pixbuf_cache_get_selection_region (view->pixbuf_cache, page, view->scale));
+                          gint     page) {
+  return (view->caret_enabled &&
+          view->cursor_page == page &&
+          view->cursor_visible &&
+          gtk_widget_has_focus (GTK_WIDGET (view)) &&
+          !ev_pixbuf_cache_get_selection_region (view->pixbuf_cache, page, view->scale));
 }
 
 static void
 draw_focus (EvView       *view,
-	    cairo_t      *cr,
-	    gint          page,
-	    GdkRectangle *clip)
-{
-	GtkWidget   *widget = GTK_WIDGET (view);
-	GdkRectangle rect;
-	GdkRectangle intersect;
+            cairo_t      *cr,
+            gint          page,
+            GdkRectangle *clip) {
+  GtkWidget   *widget = GTK_WIDGET (view);
+  GdkRectangle rect;
+  GdkRectangle intersect;
 
-	if (view->focused_element_page != page)
-		return;
+  if (view->focused_element_page != page)
+    return;
 
-	if (!gtk_widget_has_focus (GTK_WIDGET (view)))
-		return;
+  if (!gtk_widget_has_focus (GTK_WIDGET (view)))
+    return;
 
-	if (!ev_view_get_focused_area (view, &rect))
-		return;
+  if (!ev_view_get_focused_area (view, &rect))
+    return;
 
-	if (gdk_rectangle_intersect (&rect, clip, &intersect)) {
-		gtk_render_focus (gtk_widget_get_style_context (widget),
-				  cr,
-				  intersect.x,
-				  intersect.y,
-				  intersect.width,
-				  intersect.height);
-	}
+  if (gdk_rectangle_intersect (&rect, clip, &intersect)) {
+    gtk_render_focus (gtk_widget_get_style_context (widget),
+                      cr,
+                      intersect.x,
+                      intersect.y,
+                      intersect.width,
+                      intersect.height);
+  }
 }
 
 #ifdef EV_ENABLE_DEBUG
 static void
 stroke_view_rect (cairo_t      *cr,
-		  GdkRectangle *clip,
-		  GdkRectangle *view_rect)
-{
-	GdkRectangle intersect;
+                  GdkRectangle *clip,
+                  GdkRectangle *view_rect) {
+  GdkRectangle intersect;
 
-	if (gdk_rectangle_intersect (view_rect, clip, &intersect)) {
-		cairo_rectangle (cr,
-				 intersect.x, intersect.y,
-				 intersect.width, intersect.height);
-		cairo_stroke (cr);
-	}
+  if (gdk_rectangle_intersect (view_rect, clip, &intersect)) {
+    cairo_rectangle (cr,
+                     intersect.x, intersect.y,
+                     intersect.width, intersect.height);
+    cairo_stroke (cr);
+  }
 }
 
 static void
 stroke_doc_rect (EvView       *view,
-		 cairo_t      *cr,
-		 gint          page,
-		 GdkRectangle *clip,
-		 EvRectangle  *doc_rect)
-{
-	GdkRectangle view_rect;
+                 cairo_t      *cr,
+                 gint          page,
+                 GdkRectangle *clip,
+                 EvRectangle  *doc_rect) {
+  GdkRectangle view_rect;
 
-	_ev_view_transform_doc_rect_to_view_rect (view, page, doc_rect, &view_rect);
-	view_rect.x -= view->scroll_x;
-	view_rect.y -= view->scroll_y;
-	stroke_view_rect (cr, clip, &view_rect);
+  _ev_view_transform_doc_rect_to_view_rect (view, page, doc_rect, &view_rect);
+  view_rect.x -= view->scroll_x;
+  view_rect.y -= view->scroll_y;
+  stroke_view_rect (cr, clip, &view_rect);
 }
 
 static void
 show_chars_border (EvView       *view,
-		   cairo_t      *cr,
-		   gint          page,
-		   GdkRectangle *clip)
-{
-	EvRectangle *areas = NULL;
-	guint        n_areas = 0;
-	guint        i;
+                   cairo_t      *cr,
+                   gint          page,
+                   GdkRectangle *clip) {
+  EvRectangle *areas = NULL;
+  guint        n_areas = 0;
+  guint        i;
 
-	ev_page_cache_get_text_layout (view->page_cache, page, &areas, &n_areas);
-	if (!areas)
-		return;
+  ev_page_cache_get_text_layout (view->page_cache, page, &areas, &n_areas);
+  if (!areas)
+    return;
 
-	cairo_set_source_rgb (cr, 1., 0., 0.);
+  cairo_set_source_rgb (cr, 1., 0., 0.);
 
-	for (i = 0; i < n_areas; i++) {
-		EvRectangle  *doc_rect = areas + i;
+  for (i = 0; i < n_areas; i++) {
+    EvRectangle  *doc_rect = areas + i;
 
-		stroke_doc_rect (view, cr, page, clip, doc_rect);
-	}
+    stroke_doc_rect (view, cr, page, clip, doc_rect);
+  }
 }
 
 static void
 show_mapping_list_border (EvView        *view,
-			  cairo_t       *cr,
-			  gint           page,
-			  GdkRectangle  *clip,
-			  EvMappingList *mapping_list)
-{
-	GList *l;
+                          cairo_t       *cr,
+                          gint           page,
+                          GdkRectangle  *clip,
+                          EvMappingList *mapping_list) {
+  GList *l;
 
-	for (l = ev_mapping_list_get_list (mapping_list); l; l = g_list_next (l)) {
-		EvMapping *mapping = (EvMapping *)l->data;
+  for (l = ev_mapping_list_get_list (mapping_list); l; l = g_list_next (l)) {
+    EvMapping *mapping = (EvMapping *)l->data;
 
-		stroke_doc_rect (view, cr, page, clip, &mapping->area);
-	}
+    stroke_doc_rect (view, cr, page, clip, &mapping->area);
+  }
 }
 
 static void
 show_links_border (EvView       *view,
-		   cairo_t      *cr,
-		   gint          page,
-		   GdkRectangle *clip)
-{
-	cairo_set_source_rgb (cr, 0., 0., 1.);
-	show_mapping_list_border (view,cr, page, clip,
-				  ev_page_cache_get_link_mapping (view->page_cache, page));
+                   cairo_t      *cr,
+                   gint          page,
+                   GdkRectangle *clip) {
+  cairo_set_source_rgb (cr, 0., 0., 1.);
+  show_mapping_list_border (view, cr, page, clip,
+                            ev_page_cache_get_link_mapping (view->page_cache, page));
 }
 
 static void
 show_forms_border (EvView       *view,
-		   cairo_t      *cr,
-		   gint          page,
-		   GdkRectangle *clip)
-{
-	cairo_set_source_rgb (cr, 0., 1., 0.);
-	show_mapping_list_border (view, cr, page, clip,
-				  ev_page_cache_get_form_field_mapping (view->page_cache, page));
+                   cairo_t      *cr,
+                   gint          page,
+                   GdkRectangle *clip) {
+  cairo_set_source_rgb (cr, 0., 1., 0.);
+  show_mapping_list_border (view, cr, page, clip,
+                            ev_page_cache_get_form_field_mapping (view->page_cache, page));
 }
 
 static void
 show_annots_border (EvView       *view,
-		    cairo_t      *cr,
-		    gint          page,
-		    GdkRectangle *clip)
-{
-	cairo_set_source_rgb (cr, 0., 1., 1.);
-	show_mapping_list_border (view, cr, page, clip,
-				  ev_page_cache_get_annot_mapping (view->page_cache, page));
+                    cairo_t      *cr,
+                    gint          page,
+                    GdkRectangle *clip) {
+  cairo_set_source_rgb (cr, 0., 1., 1.);
+  show_mapping_list_border (view, cr, page, clip,
+                            ev_page_cache_get_annot_mapping (view->page_cache, page));
 }
 
 static void
 show_images_border (EvView       *view,
-		    cairo_t      *cr,
-		    gint          page,
-		    GdkRectangle *clip)
-{
-	cairo_set_source_rgb (cr, 1., 0., 1.);
-	show_mapping_list_border (view, cr, page, clip,
-				  ev_page_cache_get_image_mapping (view->page_cache, page));
+                    cairo_t      *cr,
+                    gint          page,
+                    GdkRectangle *clip) {
+  cairo_set_source_rgb (cr, 1., 0., 1.);
+  show_mapping_list_border (view, cr, page, clip,
+                            ev_page_cache_get_image_mapping (view->page_cache, page));
 }
 
 static void
 show_media_border (EvView       *view,
-		   cairo_t      *cr,
-		   gint          page,
-		   GdkRectangle *clip)
-{
-	cairo_set_source_rgb (cr, 1., 1., 0.);
-	show_mapping_list_border (view, cr, page, clip,
-				  ev_page_cache_get_media_mapping (view->page_cache, page));
+                   cairo_t      *cr,
+                   gint          page,
+                   GdkRectangle *clip) {
+  cairo_set_source_rgb (cr, 1., 1., 0.);
+  show_mapping_list_border (view, cr, page, clip,
+                            ev_page_cache_get_media_mapping (view->page_cache, page));
 }
 
 
 static void
 show_selections_border (EvView       *view,
-			cairo_t      *cr,
-			gint          page,
-			GdkRectangle *clip)
-{
-	cairo_region_t *region;
-	guint           i, n_rects;
+                        cairo_t      *cr,
+                        gint          page,
+                        GdkRectangle *clip) {
+  cairo_region_t *region;
+  guint           i, n_rects;
 
-	region = ev_page_cache_get_text_mapping (view->page_cache, page);
-	if (!region)
-		return;
+  region = ev_page_cache_get_text_mapping (view->page_cache, page);
+  if (!region)
+    return;
 
-	cairo_set_source_rgb (cr, 0.75, 0.50, 0.25);
+  cairo_set_source_rgb (cr, 0.75, 0.50, 0.25);
 
-	region = cairo_region_copy (region);
-	n_rects = cairo_region_num_rectangles (region);
-	for (i = 0; i < n_rects; i++) {
-		GdkRectangle doc_rect_int;
-		EvRectangle doc_rect_float;
+  region = cairo_region_copy (region);
+  n_rects = cairo_region_num_rectangles (region);
+  for (i = 0; i < n_rects; i++) {
+    GdkRectangle doc_rect_int;
+    EvRectangle doc_rect_float;
 
-		cairo_region_get_rectangle (region, i, &doc_rect_int);
+    cairo_region_get_rectangle (region, i, &doc_rect_int);
 
-		/* Convert the doc rect to a EvRectangle */
-		doc_rect_float.x1 = doc_rect_int.x;
-		doc_rect_float.y1 = doc_rect_int.y;
-		doc_rect_float.x2 = doc_rect_int.x + doc_rect_int.width;
-		doc_rect_float.y2 = doc_rect_int.y + doc_rect_int.height;
+    /* Convert the doc rect to a EvRectangle */
+    doc_rect_float.x1 = doc_rect_int.x;
+    doc_rect_float.y1 = doc_rect_int.y;
+    doc_rect_float.x2 = doc_rect_int.x + doc_rect_int.width;
+    doc_rect_float.y2 = doc_rect_int.y + doc_rect_int.height;
 
-		stroke_doc_rect (view, cr, page, clip, &doc_rect_float);
-	}
-	cairo_region_destroy (region);
+    stroke_doc_rect (view, cr, page, clip, &doc_rect_float);
+  }
+  cairo_region_destroy (region);
 }
 
 static void
 draw_debug_borders (EvView       *view,
-		    cairo_t      *cr,
-		    gint          page,
-		    GdkRectangle *clip)
-{
-	EvDebugBorders borders = ev_debug_get_debug_borders();
-
-	cairo_save (cr);
-	cairo_set_line_width (cr, 0.5);
-
-	if (borders & EV_DEBUG_BORDER_CHARS)
-		show_chars_border (view, cr, page, clip);
-	if (borders & EV_DEBUG_BORDER_LINKS)
-		show_links_border (view, cr, page, clip);
-	if (borders & EV_DEBUG_BORDER_FORMS)
-		show_forms_border (view, cr, page, clip);
-	if (borders & EV_DEBUG_BORDER_ANNOTS)
-		show_annots_border (view, cr, page, clip);
-	if (borders & EV_DEBUG_BORDER_IMAGES)
-		show_images_border (view, cr, page, clip);
-	if (borders & EV_DEBUG_BORDER_MEDIA)
-		show_media_border (view, cr, page, clip);
-	if (borders & EV_DEBUG_BORDER_SELECTIONS)
-		show_selections_border (view, cr, page, clip);
-
-	cairo_restore (cr);
+                    cairo_t      *cr,
+                    gint          page,
+                    GdkRectangle *clip) {
+  EvDebugBorders borders = ev_debug_get_debug_borders();
+
+  cairo_save (cr);
+  cairo_set_line_width (cr, 0.5);
+
+  if (borders & EV_DEBUG_BORDER_CHARS)
+    show_chars_border (view, cr, page, clip);
+  if (borders & EV_DEBUG_BORDER_LINKS)
+    show_links_border (view, cr, page, clip);
+  if (borders & EV_DEBUG_BORDER_FORMS)
+    show_forms_border (view, cr, page, clip);
+  if (borders & EV_DEBUG_BORDER_ANNOTS)
+    show_annots_border (view, cr, page, clip);
+  if (borders & EV_DEBUG_BORDER_IMAGES)
+    show_images_border (view, cr, page, clip);
+  if (borders & EV_DEBUG_BORDER_MEDIA)
+    show_media_border (view, cr, page, clip);
+  if (borders & EV_DEBUG_BORDER_SELECTIONS)
+    show_selections_border (view, cr, page, clip);
+
+  cairo_restore (cr);
 }
 #endif
 
 static gboolean
 ev_view_draw (GtkWidget *widget,
-              cairo_t   *cr)
-{
-	EvView      *view = EV_VIEW (widget);
-	gint         i;
-	GdkRectangle clip_rect;
-	GtkBorder border;
-
-	gtk_render_background (gtk_widget_get_style_context (widget),
-			       cr,
-			       0, 0,
-			       gtk_widget_get_allocated_width (widget),
-			       gtk_widget_get_allocated_height (widget));
-
-	if (view->document == NULL)
-		return FALSE;
-
-        if (!gdk_cairo_get_clip_rectangle (cr, &clip_rect))
-                return FALSE;
-
-	compute_border (view, &border);
-	for (i = view->start_page; i >= 0 && i <= view->end_page; i++) {
-		GdkRectangle page_area;
-		gboolean page_ready = TRUE;
-
-		if (!ev_view_get_page_extents_for_border (view, i, &border, &page_area))
-			continue;
-
-		page_area.x -= view->scroll_x;
-		page_area.y -= view->scroll_y;
-
-		draw_one_page (view, i, cr, &page_area, &border, &clip_rect, &page_ready);
-
-		if (page_ready && should_draw_caret_cursor (view, i))
-			draw_caret_cursor (view, cr);
-		if (page_ready && view->find_pages && view->highlight_find_results)
-			highlight_find_results (view, cr, i);
-		if (page_ready && EV_IS_DOCUMENT_ANNOTATIONS (view->document))
-			show_annotation_windows (view, i);
-		if (page_ready && view->focused_element)
-			draw_focus (view, cr, i, &clip_rect);
-		if (page_ready && view->synctex_result)
-			highlight_forward_search_results (view, cr, i);
+              cairo_t   *cr) {
+  EvView      *view = EV_VIEW (widget);
+  gint         i;
+  GdkRectangle clip_rect;
+  GtkBorder border;
+
+  gtk_render_background (gtk_widget_get_style_context (widget),
+                         cr,
+                         0, 0,
+                         gtk_widget_get_allocated_width (widget),
+                         gtk_widget_get_allocated_height (widget));
+
+  if (view->document == NULL)
+    return FALSE;
+
+  if (!gdk_cairo_get_clip_rectangle (cr, &clip_rect))
+    return FALSE;
+
+  compute_border (view, &border);
+  for (i = view->start_page; i >= 0 && i <= view->end_page; i++) {
+    GdkRectangle page_area;
+    gboolean page_ready = TRUE;
+
+    if (!ev_view_get_page_extents_for_border (view, i, &border, &page_area))
+      continue;
+
+    page_area.x -= view->scroll_x;
+    page_area.y -= view->scroll_y;
+
+    draw_one_page (view, i, cr, &page_area, &border, &clip_rect, &page_ready);
+
+    if (page_ready && should_draw_caret_cursor (view, i))
+      draw_caret_cursor (view, cr);
+    if (page_ready && view->find_pages && view->highlight_find_results)
+      highlight_find_results (view, cr, i);
+    if (page_ready && EV_IS_DOCUMENT_ANNOTATIONS (view->document))
+      show_annotation_windows (view, i);
+    if (page_ready && view->focused_element)
+      draw_focus (view, cr, i, &clip_rect);
+    if (page_ready && view->synctex_result)
+      highlight_forward_search_results (view, cr, i);
 #ifdef EV_ENABLE_DEBUG
-		if (page_ready)
-			draw_debug_borders (view, cr, i, &clip_rect);
+    if (page_ready)
+      draw_debug_borders (view, cr, i, &clip_rect);
 #endif
-	}
+  }
 
-        if (GTK_WIDGET_CLASS (ev_view_parent_class)->draw)
-                GTK_WIDGET_CLASS (ev_view_parent_class)->draw (widget, cr);
+  if (GTK_WIDGET_CLASS (ev_view_parent_class)->draw)
+    GTK_WIDGET_CLASS (ev_view_parent_class)->draw (widget, cr);
 
-	return FALSE;
+  return FALSE;
 }
 
 static void
 ev_view_set_focused_element_at_location (EvView *view,
-					 gdouble x,
-					 gdouble y)
-{
-	EvMapping *mapping;
-	EvFormField *field;
-	gint page;
-
-	mapping = get_annotation_mapping_at_location (view, x, y, &page);
-	if (mapping) {
-		_ev_view_set_focused_element (view, mapping, page);
-		return;
-	}
-
-	mapping = get_link_mapping_at_location (view, x, y, &page);
-	if (mapping) {
-		_ev_view_set_focused_element (view, mapping, page);
-		return;
-	}
-
-	if ((field = ev_view_get_form_field_at_location (view, x, y))) {
-		ev_view_remove_all_form_fields (view);
-		_ev_view_focus_form_field (view, field);
-		return;
-	}
+                                         gdouble x,
+                                         gdouble y) {
+  EvMapping *mapping;
+  EvFormField *field;
+  gint page;
 
-        _ev_view_set_focused_element (view, NULL, -1);
+  mapping = get_annotation_mapping_at_location (view, x, y, &page);
+  if (mapping) {
+    _ev_view_set_focused_element (view, mapping, page);
+    return;
+  }
+
+  mapping = get_link_mapping_at_location (view, x, y, &page);
+  if (mapping) {
+    _ev_view_set_focused_element (view, mapping, page);
+    return;
+  }
+
+  if ((field = ev_view_get_form_field_at_location (view, x, y))) {
+    ev_view_remove_all_form_fields (view);
+    _ev_view_focus_form_field (view, field);
+    return;
+  }
+
+  _ev_view_set_focused_element (view, NULL, -1);
 }
 
 static gboolean
 ev_view_do_popup_menu (EvView *view,
-		       gdouble x,
-		       gdouble y)
-{
-	GList        *items = NULL;
-	EvLink       *link;
-	EvImage      *image;
-	EvAnnotation *annot;
+                       gdouble x,
+                       gdouble y) {
+  GList        *items = NULL;
+  EvLink       *link;
+  EvImage      *image;
+  EvAnnotation *annot;
 
-	image = ev_view_get_image_at_location (view, x, y);
-	if (image)
-		items = g_list_prepend (items, image);
+  image = ev_view_get_image_at_location (view, x, y);
+  if (image)
+    items = g_list_prepend (items, image);
 
-	link = ev_view_get_link_at_location (view, x, y);
-	if (link)
-		items = g_list_prepend (items, link);
+  link = ev_view_get_link_at_location (view, x, y);
+  if (link)
+    items = g_list_prepend (items, link);
 
-	annot = ev_view_get_annotation_at_location (view, x, y);
-	if (annot)
-		items = g_list_prepend (items, annot);
+  annot = ev_view_get_annotation_at_location (view, x, y);
+  if (annot)
+    items = g_list_prepend (items, annot);
 
-	g_signal_emit (view, signals[SIGNAL_POPUP_MENU], 0, items);
+  g_signal_emit (view, signals[SIGNAL_POPUP_MENU], 0, items);
 
-	g_list_free (items);
+  g_list_free (items);
 
-	return TRUE;
+  return TRUE;
 }
 
 static gboolean
-ev_view_popup_menu (GtkWidget *widget)
-{
-	gint x, y;
+ev_view_popup_menu (GtkWidget *widget) {
+  gint x, y;
 
-	ev_document_misc_get_pointer_position (widget, &x, &y);
-	return ev_view_do_popup_menu (EV_VIEW (widget), x, y);
+  ev_document_misc_get_pointer_position (widget, &x, &y);
+  return ev_view_do_popup_menu (EV_VIEW (widget), x, y);
 }
 
 static void
 get_link_area (EvView       *view,
-	       gint          x,
-	       gint          y,
-	       EvLink       *link,
-	       GdkRectangle *area)
-{
-	EvMappingList *link_mapping;
-	gint           page;
-	gint           x_offset = 0, y_offset = 0;
-
-	x += view->scroll_x;
-	y += view->scroll_y;
-	
-	find_page_at_location (view, x, y, &page, &x_offset, &y_offset);
-	
-	link_mapping = ev_page_cache_get_link_mapping (view->page_cache, page);
-	ev_view_get_area_from_mapping (view, page,
-				       link_mapping,
-				       link, area);
+               gint          x,
+               gint          y,
+               EvLink       *link,
+               GdkRectangle *area) {
+  EvMappingList *link_mapping;
+  gint           page;
+  gint           x_offset = 0, y_offset = 0;
+
+  x += view->scroll_x;
+  y += view->scroll_y;
+
+  find_page_at_location (view, x, y, &page, &x_offset, &y_offset);
+
+  link_mapping = ev_page_cache_get_link_mapping (view->page_cache, page);
+  ev_view_get_area_from_mapping (view, page,
+                                 link_mapping,
+                                 link, area);
 }
 
 static void
 get_annot_area (EvView       *view,
-	       gint          x,
-	       gint          y,
-	       EvAnnotation *annot,
-	       GdkRectangle *area)
-{
-	EvMappingList *annot_mapping;
-	gint           page;
-	gint           x_offset = 0, y_offset = 0;
+                gint          x,
+                gint          y,
+                EvAnnotation *annot,
+                GdkRectangle *area) {
+  EvMappingList *annot_mapping;
+  gint           page;
+  gint           x_offset = 0, y_offset = 0;
 
-	x += view->scroll_x;
-	y += view->scroll_y;
+  x += view->scroll_x;
+  y += view->scroll_y;
 
-	find_page_at_location (view, x, y, &page, &x_offset, &y_offset);
+  find_page_at_location (view, x, y, &page, &x_offset, &y_offset);
 
-	annot_mapping = ev_page_cache_get_annot_mapping (view->page_cache, page);
-	ev_view_get_area_from_mapping (view, page,
-				       annot_mapping,
-				       annot, area);
+  annot_mapping = ev_page_cache_get_annot_mapping (view->page_cache, page);
+  ev_view_get_area_from_mapping (view, page,
+                                 annot_mapping,
+                                 annot, area);
 }
 
 static gboolean
 ev_view_query_tooltip (GtkWidget  *widget,
-		       gint        x,
-		       gint        y,
-		       gboolean    keyboard_tip,
-		       GtkTooltip *tooltip)
-{
-	EvView       *view = EV_VIEW (widget);
-	EvLink       *link;
-	EvAnnotation *annot;
-	gchar        *text;
-
-	annot = ev_view_get_annotation_at_location (view, x, y);
-	if (annot) {
-		const gchar *contents;
-
-		contents = ev_annotation_get_contents (annot);
-		if (contents && *contents != '\0') {
-			GdkRectangle annot_area;
-
-			get_annot_area (view, x, y, annot, &annot_area);
-			gtk_tooltip_set_text (tooltip, contents);
-			gtk_tooltip_set_tip_area (tooltip, &annot_area);
-
-			return TRUE;
-		}
-	}
+                       gint        x,
+                       gint        y,
+                       gboolean    keyboard_tip,
+                       GtkTooltip *tooltip) {
+  EvView       *view = EV_VIEW (widget);
+  EvLink       *link;
+  EvAnnotation *annot;
+  gchar        *text;
+
+  annot = ev_view_get_annotation_at_location (view, x, y);
+  if (annot) {
+    const gchar *contents;
+
+    contents = ev_annotation_get_contents (annot);
+    if (contents && *contents != '\0') {
+      GdkRectangle annot_area;
+
+      get_annot_area (view, x, y, annot, &annot_area);
+      gtk_tooltip_set_text (tooltip, contents);
+      gtk_tooltip_set_tip_area (tooltip, &annot_area);
+
+      return TRUE;
+    }
+  }
 
-	link = ev_view_get_link_at_location (view, x, y);
-	if (!link)
-		return FALSE;
+  link = ev_view_get_link_at_location (view, x, y);
+  if (!link)
+    return FALSE;
 
-	text = tip_from_link (view, link);
-	if (text && g_utf8_validate (text, -1, NULL)) {
-		GdkRectangle link_area;
+  text = tip_from_link (view, link);
+  if (text && g_utf8_validate (text, -1, NULL)) {
+    GdkRectangle link_area;
 
-		get_link_area (view, x, y, link, &link_area);
-		gtk_tooltip_set_text (tooltip, text);
-		gtk_tooltip_set_tip_area (tooltip, &link_area);
-		g_free (text);
+    get_link_area (view, x, y, link, &link_area);
+    gtk_tooltip_set_text (tooltip, text);
+    gtk_tooltip_set_tip_area (tooltip, &link_area);
+    g_free (text);
 
-		return TRUE;
-	}
-	g_free (text);
+    return TRUE;
+  }
+  g_free (text);
 
-	return FALSE;
+  return FALSE;
 }
 
 static void
 start_selection_for_event (EvView         *view,
-			   GdkEventButton *event)
-{
-	clear_selection (view);
-
-	view->selection_info.start.x = event->x + view->scroll_x;
-	view->selection_info.start.y = event->y + view->scroll_y;
-
-	switch (event->type) {
-	        case GDK_2BUTTON_PRESS:
-			view->selection_info.style = EV_SELECTION_STYLE_WORD;
-			break;
-	        case GDK_3BUTTON_PRESS:
-			view->selection_info.style = EV_SELECTION_STYLE_LINE;
-			break;
-	        default:
-			view->selection_info.style = EV_SELECTION_STYLE_GLYPH;
-			return;
-	}
-
-	/* In case of WORD or LINE, compute selections now */
-	compute_selections (view,
-			    view->selection_info.style,
-			    &(view->selection_info.start),
-			    &(view->selection_info.start));
+                           GdkEventButton *event) {
+  clear_selection (view);
+
+  view->selection_info.start.x = event->x + view->scroll_x;
+  view->selection_info.start.y = event->y + view->scroll_y;
+
+  switch (event->type) {
+    case GDK_2BUTTON_PRESS:
+      view->selection_info.style = EV_SELECTION_STYLE_WORD;
+      break;
+    case GDK_3BUTTON_PRESS:
+      view->selection_info.style = EV_SELECTION_STYLE_LINE;
+      break;
+    default:
+      view->selection_info.style = EV_SELECTION_STYLE_GLYPH;
+      return;
+  }
+
+  /* In case of WORD or LINE, compute selections now */
+  compute_selections (view,
+                      view->selection_info.style,
+                      &(view->selection_info.start),
+                      &(view->selection_info.start));
 }
 
 gint
 _ev_view_get_caret_cursor_offset_at_doc_point (EvView *view,
-					       gint    page,
-					       gdouble doc_x,
-					       gdouble doc_y)
-{
-	EvRectangle *areas = NULL;
-	guint        n_areas = 0;
-	gint         offset = -1;
-	gint         first_line_offset;
-	gint         last_line_offset = -1;
-	EvRectangle *rect;
-	guint        i;
-
-	ev_page_cache_get_text_layout (view->page_cache, page, &areas, &n_areas);
-	if (!areas)
-		return -1;
-
-	i = 0;
-	while (i < n_areas && offset == -1) {
-		rect = areas + i;
-
-		first_line_offset = -1;
-		while (doc_y >= rect->y1 && doc_y <= rect->y2) {
-			if (first_line_offset == -1) {
-				if (doc_x <= rect->x1) {
-					/* Location is before the start of the line */
-					if (last_line_offset != -1) {
-						EvRectangle *last = areas + last_line_offset;
-						gint         dx1, dx2;
-
-						/* If there's a previous line, check distances */
-
-						dx1 = doc_x - last->x2;
-						dx2 = rect->x1 - doc_x;
-
-						if (dx1 < dx2)
-							offset = last_line_offset;
-						else
-							offset = i;
-					} else {
-						offset = i;
-					}
-
-					last_line_offset = i + 1;
-					break;
-				}
-				first_line_offset = i;
-			}
-			last_line_offset = i + 1;
-
-			if (doc_x >= rect->x1 && doc_x <= rect->x2) {
-				/* Location is inside the line. Position the caret before
-				 * or after the character, depending on whether the point
-				 * falls within the left or right half of the bounding box.
-				 */
-				if (doc_x <= rect->x1 + (rect->x2 - rect->x1) / 2)
-					offset = i;
-				else
-					offset = i + 1;
-				break;
-			}
-
-			i++;
-			rect = areas + i;
-		}
-
-		if (first_line_offset == -1)
-			i++;
-	}
-
-	if (last_line_offset == -1)
-		return -1;
-
-	if (offset == -1)
-		offset = last_line_offset;
-
-	return offset;
+                                               gint    page,
+                                               gdouble doc_x,
+                                               gdouble doc_y) {
+  EvRectangle *areas = NULL;
+  guint        n_areas = 0;
+  gint         offset = -1;
+  gint         first_line_offset;
+  gint         last_line_offset = -1;
+  EvRectangle *rect;
+  guint        i;
+
+  ev_page_cache_get_text_layout (view->page_cache, page, &areas, &n_areas);
+  if (!areas)
+    return -1;
+
+  i = 0;
+  while (i < n_areas && offset == -1) {
+    rect = areas + i;
+
+    first_line_offset = -1;
+    while (doc_y >= rect->y1 && doc_y <= rect->y2) {
+      if (first_line_offset == -1) {
+        if (doc_x <= rect->x1) {
+          /* Location is before the start of the line */
+          if (last_line_offset != -1) {
+            EvRectangle *last = areas + last_line_offset;
+            gint         dx1, dx2;
+
+            /* If there's a previous line, check distances */
+
+            dx1 = doc_x - last->x2;
+            dx2 = rect->x1 - doc_x;
+
+            if (dx1 < dx2)
+              offset = last_line_offset;
+            else
+              offset = i;
+          } else {
+            offset = i;
+          }
+
+          last_line_offset = i + 1;
+          break;
+        }
+        first_line_offset = i;
+      }
+      last_line_offset = i + 1;
+
+      if (doc_x >= rect->x1 && doc_x <= rect->x2) {
+        /* Location is inside the line. Position the caret before
+         * or after the character, depending on whether the point
+         * falls within the left or right half of the bounding box.
+         */
+        if (doc_x <= rect->x1 + (rect->x2 - rect->x1) / 2)
+          offset = i;
+        else
+          offset = i + 1;
+        break;
+      }
+
+      i++;
+      rect = areas + i;
+    }
+
+    if (first_line_offset == -1)
+      i++;
+  }
+
+  if (last_line_offset == -1)
+    return -1;
+
+  if (offset == -1)
+    offset = last_line_offset;
+
+  return offset;
 }
 
 static gboolean
 position_caret_cursor_at_doc_point (EvView *view,
-				    gint    page,
-				    gdouble doc_x,
-				    gdouble doc_y)
-{
-	gint offset;
+                                    gint    page,
+                                    gdouble doc_x,
+                                    gdouble doc_y) {
+  gint offset;
 
-	offset = _ev_view_get_caret_cursor_offset_at_doc_point (view, page, doc_x, doc_y);
-	if (offset == -1)
-		return FALSE;
+  offset = _ev_view_get_caret_cursor_offset_at_doc_point (view, page, doc_x, doc_y);
+  if (offset == -1)
+    return FALSE;
 
-	if (view->cursor_offset != offset || view->cursor_page != page) {
-		view->cursor_offset = offset;
-		view->cursor_page = page;
+  if (view->cursor_offset != offset || view->cursor_page != page) {
+    view->cursor_offset = offset;
+    view->cursor_page = page;
 
-		return TRUE;
-	}
+    return TRUE;
+  }
 
-	return FALSE;
+  return FALSE;
 }
 
 static gboolean
 position_caret_cursor_at_location (EvView *view,
-				   gdouble x,
-				   gdouble y)
-{
-	gint page;
-	gint doc_x, doc_y;
+                                   gdouble x,
+                                   gdouble y) {
+  gint page;
+  gint doc_x, doc_y;
 
-	if (!view->caret_enabled || view->rotation != 0)
-		return FALSE;
+  if (!view->caret_enabled || view->rotation != 0)
+    return FALSE;
 
-	if (!view->page_cache)
-		return FALSE;
+  if (!view->page_cache)
+    return FALSE;
 
-	/* Get the offset from the doc point */
-	if (!get_doc_point_from_location (view, x, y, &page, &doc_x, &doc_y))
-		return FALSE;
+  /* Get the offset from the doc point */
+  if (!get_doc_point_from_location (view, x, y, &page, &doc_x, &doc_y))
+    return FALSE;
 
-	return position_caret_cursor_at_doc_point (view, page, doc_x, doc_y);
+  return position_caret_cursor_at_doc_point (view, page, doc_x, doc_y);
 }
 
 static gboolean
 position_caret_cursor_for_event (EvView         *view,
-				 GdkEventButton *event,
-				 gboolean        redraw)
-{
-	GdkRectangle area;
-	GdkRectangle prev_area = { 0, 0, 0, 0 };
+                                 GdkEventButton *event,
+                                 gboolean        redraw) {
+  GdkRectangle area;
+  GdkRectangle prev_area = { 0, 0, 0, 0 };
 
-	if (redraw)
-		get_caret_cursor_area (view, view->cursor_page, view->cursor_offset, &prev_area);
+  if (redraw)
+    get_caret_cursor_area (view, view->cursor_page, view->cursor_offset, &prev_area);
 
-	if (!position_caret_cursor_at_location (view, event->x, event->y))
-		return FALSE;
+  if (!position_caret_cursor_at_location (view, event->x, event->y))
+    return FALSE;
 
-	if (!get_caret_cursor_area (view, view->cursor_page, view->cursor_offset, &area))
-		return FALSE;
+  if (!get_caret_cursor_area (view, view->cursor_page, view->cursor_offset, &area))
+    return FALSE;
 
-	view->cursor_line_offset = area.x;
+  view->cursor_line_offset = area.x;
 
-	g_signal_emit (view, signals[SIGNAL_CURSOR_MOVED], 0, view->cursor_page, view->cursor_offset);
+  g_signal_emit (view, signals[SIGNAL_CURSOR_MOVED], 0, view->cursor_page, view->cursor_offset);
 
-	if (redraw) {
-		cairo_region_t *damage_region;
+  if (redraw) {
+    cairo_region_t *damage_region;
 
-		damage_region = cairo_region_create_rectangle (&prev_area);
-		cairo_region_union_rectangle (damage_region, &area);
-		gdk_window_invalidate_region (gtk_widget_get_window (GTK_WIDGET (view)),
-					      damage_region, TRUE);
-		cairo_region_destroy (damage_region);
-	}
+    damage_region = cairo_region_create_rectangle (&prev_area);
+    cairo_region_union_rectangle (damage_region, &area);
+    gdk_window_invalidate_region (gtk_widget_get_window (GTK_WIDGET (view)),
+                                  damage_region, TRUE);
+    cairo_region_destroy (damage_region);
+  }
 
-	return TRUE;
+  return TRUE;
 }
 
 static gboolean
 ev_view_button_press_event (GtkWidget      *widget,
-			    GdkEventButton *event)
-{
-	EvView *view = EV_VIEW (widget);
-
-	if (!view->document || ev_document_get_n_pages (view->document) <= 0)
-		return FALSE;
-
-	if (gtk_gesture_is_recognized (view->zoom_gesture))
-		return TRUE;
-
-	if (!gtk_widget_has_focus (widget)) {
-		gtk_widget_grab_focus (widget);
-	}
-
-	if (view->window_child_focus) {
-		EvAnnotationWindow *window;
-
-		window = EV_ANNOTATION_WINDOW (view->window_child_focus->window);
-		ev_annotation_window_ungrab_focus (window);
-		view->window_child_focus = NULL;
-	}
-	
-	view->pressed_button = event->button;
-	view->selection_info.in_drag = FALSE;
-
-	if (view->scroll_info.autoscrolling)
-		return TRUE;
-
-	if (view->adding_annot_info.adding_annot && !view->adding_annot_info.annot) {
-		if (event->button != 1)
-			return TRUE;
-
-		view->adding_annot_info.start.x = event->x + view->scroll_x;
-		view->adding_annot_info.start.y = event->y + view->scroll_y;
-		view->adding_annot_info.stop = view->adding_annot_info.start;
-		ev_view_create_annotation (view);
-
-		return TRUE;
-	}
-
-	switch (event->button) {
-	        case 1: {
-			EvImage *image;
-			EvAnnotation *annot;
-			EvFormField *field;
-			EvMapping *link;
-			EvMedia *media;
-			gint page;
-
-			if (event->state & GDK_CONTROL_MASK)
-				return ev_view_synctex_backward_search (view, event->x , event->y);
-
-			if (EV_IS_SELECTION (view->document) && view->selection_info.selections) {
-				if (event->type == GDK_3BUTTON_PRESS) {
-					start_selection_for_event (view, event);
-				} else if (event->state & GDK_SHIFT_MASK) {
-					GdkPoint end_point;
-
-					end_point.x = event->x + view->scroll_x;
-					end_point.y = event->y + view->scroll_y;
-					extend_selection (view, &view->selection_info.start, &end_point);
-				} else if (location_in_selected_text (view,
-							       event->x + view->scroll_x,
-							       event->y + view->scroll_y)) {
-					view->selection_info.in_drag = TRUE;
-				} else {
-					start_selection_for_event (view, event);
-					if (position_caret_cursor_for_event (view, event, TRUE)) {
-						view->cursor_blink_time = 0;
-						ev_view_pend_cursor_blink (view);
-					}
-				}
-			} else if ((media = ev_view_get_media_at_location (view, event->x, event->y))) {
-				ev_view_handle_media (view, media);
-			} else if ((annot = ev_view_get_annotation_at_location (view, event->x, event->y))) {
-				if (EV_IS_ANNOTATION_TEXT (annot)) {
-					EvRectangle  current_area;
-					GdkPoint     view_point;
-					EvPoint      doc_point;
-					GdkRectangle page_area;
-					GtkBorder    border;
-					guint        annot_page;
-
-					/* annot_clicked remembers that we clicked
-					 * on an annotation. We need moving_annot
-					 * to distinguish moving an annotation from
-					 * showing its popup upon button release. */
-					view->moving_annot_info.annot_clicked = TRUE;
-					view->moving_annot_info.moving_annot = FALSE;
-					view->moving_annot_info.annot = annot;
-					ev_annotation_get_area (annot, &current_area);
-
-					view_point.x = event->x + view->scroll_x;
-					view_point.y = event->y + view->scroll_y;
-
-					/* Remember the coordinates of the button press event
-					 * in order to implement a minimum threshold for moving
-					 * annotations. */
-					view->moving_annot_info.start = view_point;
-					annot_page = ev_annotation_get_page_index (annot);
-					ev_view_get_page_extents (view, annot_page, &page_area, &border);
-					_ev_view_transform_view_point_to_doc_point (view, &view_point,
-										    &page_area, &border,
-										    &doc_point.x, &doc_point.y);
-
-					/* Remember the offset of the cursor with respect to
-					 * the annotation area in order to prevent the annotation from
-					 * jumping under the cursor while moving it. */
-					view->moving_annot_info.cursor_offset.x = doc_point.x - current_area.x1;
-					view->moving_annot_info.cursor_offset.y = doc_point.y - current_area.y1;
-				}
-			} else if ((field = ev_view_get_form_field_at_location (view, event->x, event->y))) {
-				ev_view_remove_all_form_fields (view);
-				ev_view_handle_form_field (view, field);
-			} else if ((link = get_link_mapping_at_location (view, event->x, event->y, &page))){
-				_ev_view_set_focused_element (view, link, page);
-			} else if (!location_in_text (view, event->x + view->scroll_x, event->y + view->scroll_y) &&
-				   (image = ev_view_get_image_at_location (view, event->x, event->y))) {
-				if (view->image_dnd_info.image)
-					g_object_unref (view->image_dnd_info.image);
-				view->image_dnd_info.image = g_object_ref (image);
-				view->image_dnd_info.in_drag = TRUE;
-
-				view->image_dnd_info.start.x = event->x + view->scroll_x;
-				view->image_dnd_info.start.y = event->y + view->scroll_y;
-			} else {
-				ev_view_remove_all_form_fields (view);
-				_ev_view_set_focused_element (view, NULL, -1);
-
-				if (view->synctex_result) {
-					g_free (view->synctex_result);
-					view->synctex_result = NULL;
-					gtk_widget_queue_draw (widget);
-				}
-
-				if (EV_IS_SELECTION (view->document))
-					start_selection_for_event (view, event);
-
-				if (position_caret_cursor_for_event (view, event, TRUE)) {
-					view->cursor_blink_time = 0;
-					ev_view_pend_cursor_blink (view);
-				}
-			}
-		}			
-			return TRUE;
-		case 2:
-			/* use root coordinates as reference point because
-			 * scrolling changes window relative coordinates */
-			view->drag_info.start.x = event->x_root;
-			view->drag_info.start.y = event->y_root;
-			view->drag_info.hadj = gtk_adjustment_get_value (view->hadjustment);
-			view->drag_info.vadj = gtk_adjustment_get_value (view->vadjustment);
-
-			ev_view_set_cursor (view, EV_VIEW_CURSOR_DRAG);
-			ev_view_set_focused_element_at_location (view, event->x, event->y);
-			return TRUE;
-		case 3:
-			view->scroll_info.start_y = event->y;
-			ev_view_set_focused_element_at_location (view, event->x, event->y);
-			return ev_view_do_popup_menu (view, event->x, event->y);
-	}
-	
-	return FALSE;
-}
-
-static void
-ev_view_remove_all (EvView *view)
-{
-	gtk_container_foreach (GTK_CONTAINER (view), (GtkCallback) gtk_widget_destroy, NULL);
-}
-
-static void
-destroy_child_if_form_widget (GtkWidget *widget)
-{
-	if (g_object_get_data (G_OBJECT (widget), "form-field"))
-		gtk_widget_destroy (widget);
-}
-
-static void
-ev_view_remove_all_form_fields (EvView *view)
-{
-	gtk_container_foreach (GTK_CONTAINER (view), (GtkCallback)destroy_child_if_form_widget, NULL);
+                            GdkEventButton *event) {
+  EvView *view = EV_VIEW (widget);
+
+  if (!view->document || ev_document_get_n_pages (view->document) <= 0)
+    return FALSE;
+
+  if (gtk_gesture_is_recognized (view->zoom_gesture))
+    return TRUE;
+
+  if (!gtk_widget_has_focus (widget)) {
+    gtk_widget_grab_focus (widget);
+  }
+
+  if (view->window_child_focus) {
+    EvAnnotationWindow *window;
+
+    window = EV_ANNOTATION_WINDOW (view->window_child_focus->window);
+    ev_annotation_window_ungrab_focus (window);
+    view->window_child_focus = NULL;
+  }
+
+  view->pressed_button = event->button;
+  view->selection_info.in_drag = FALSE;
+
+  if (view->scroll_info.autoscrolling)
+    return TRUE;
+
+  if (view->adding_annot_info.adding_annot && !view->adding_annot_info.annot) {
+    if (event->button != 1)
+      return TRUE;
+
+    view->adding_annot_info.start.x = event->x + view->scroll_x;
+    view->adding_annot_info.start.y = event->y + view->scroll_y;
+    view->adding_annot_info.stop = view->adding_annot_info.start;
+    ev_view_create_annotation (view);
+
+    return TRUE;
+  }
+
+  switch (event->button) {
+    case 1: {
+      EvImage *image;
+      EvAnnotation *annot;
+      EvFormField *field;
+      EvMapping *link;
+      EvMedia *media;
+      gint page;
+
+      if (event->state & GDK_CONTROL_MASK)
+        return ev_view_synctex_backward_search (view, event->x, event->y);
+
+      if (EV_IS_SELECTION (view->document) && view->selection_info.selections) {
+        if (event->type == GDK_3BUTTON_PRESS) {
+          start_selection_for_event (view, event);
+        } else if (event->state & GDK_SHIFT_MASK) {
+          GdkPoint end_point;
+
+          end_point.x = event->x + view->scroll_x;
+          end_point.y = event->y + view->scroll_y;
+          extend_selection (view, &view->selection_info.start, &end_point);
+        } else if (location_in_selected_text (view,
+                                              event->x + view->scroll_x,
+                                              event->y + view->scroll_y)) {
+          view->selection_info.in_drag = TRUE;
+        } else {
+          start_selection_for_event (view, event);
+          if (position_caret_cursor_for_event (view, event, TRUE)) {
+            view->cursor_blink_time = 0;
+            ev_view_pend_cursor_blink (view);
+          }
+        }
+      } else if ((media = ev_view_get_media_at_location (view, event->x, event->y))) {
+        ev_view_handle_media (view, media);
+      } else if ((annot = ev_view_get_annotation_at_location (view, event->x, event->y))) {
+        if (EV_IS_ANNOTATION_TEXT (annot)) {
+          EvRectangle  current_area;
+          GdkPoint     view_point;
+          EvPoint      doc_point;
+          GdkRectangle page_area;
+          GtkBorder    border;
+          guint        annot_page;
+
+          /* annot_clicked remembers that we clicked
+           * on an annotation. We need moving_annot
+           * to distinguish moving an annotation from
+           * showing its popup upon button release. */
+          view->moving_annot_info.annot_clicked = TRUE;
+          view->moving_annot_info.moving_annot = FALSE;
+          view->moving_annot_info.annot = annot;
+          ev_annotation_get_area (annot, &current_area);
+
+          view_point.x = event->x + view->scroll_x;
+          view_point.y = event->y + view->scroll_y;
+
+          /* Remember the coordinates of the button press event
+           * in order to implement a minimum threshold for moving
+           * annotations. */
+          view->moving_annot_info.start = view_point;
+          annot_page = ev_annotation_get_page_index (annot);
+          ev_view_get_page_extents (view, annot_page, &page_area, &border);
+          _ev_view_transform_view_point_to_doc_point (view, &view_point,
+                                                      &page_area, &border,
+                                                      &doc_point.x, &doc_point.y);
+
+          /* Remember the offset of the cursor with respect to
+           * the annotation area in order to prevent the annotation from
+           * jumping under the cursor while moving it. */
+          view->moving_annot_info.cursor_offset.x = doc_point.x - current_area.x1;
+          view->moving_annot_info.cursor_offset.y = doc_point.y - current_area.y1;
+        }
+      } else if ((field = ev_view_get_form_field_at_location (view, event->x, event->y))) {
+        ev_view_remove_all_form_fields (view);
+        ev_view_handle_form_field (view, field);
+      } else if ((link = get_link_mapping_at_location (view, event->x, event->y, &page))) {
+        _ev_view_set_focused_element (view, link, page);
+      } else if (!location_in_text (view, event->x + view->scroll_x, event->y + view->scroll_y) &&
+                 (image = ev_view_get_image_at_location (view, event->x, event->y))) {
+        if (view->image_dnd_info.image)
+          g_object_unref (view->image_dnd_info.image);
+        view->image_dnd_info.image = g_object_ref (image);
+        view->image_dnd_info.in_drag = TRUE;
+
+        view->image_dnd_info.start.x = event->x + view->scroll_x;
+        view->image_dnd_info.start.y = event->y + view->scroll_y;
+      } else {
+        ev_view_remove_all_form_fields (view);
+        _ev_view_set_focused_element (view, NULL, -1);
+
+        if (view->synctex_result) {
+          g_free (view->synctex_result);
+          view->synctex_result = NULL;
+          gtk_widget_queue_draw (widget);
+        }
+
+        if (EV_IS_SELECTION (view->document))
+          start_selection_for_event (view, event);
+
+        if (position_caret_cursor_for_event (view, event, TRUE)) {
+          view->cursor_blink_time = 0;
+          ev_view_pend_cursor_blink (view);
+        }
+      }
+    }
+    return TRUE;
+    case 2:
+      /* use root coordinates as reference point because
+       * scrolling changes window relative coordinates */
+      view->drag_info.start.x = event->x_root;
+      view->drag_info.start.y = event->y_root;
+      view->drag_info.hadj = gtk_adjustment_get_value (view->hadjustment);
+      view->drag_info.vadj = gtk_adjustment_get_value (view->vadjustment);
+
+      ev_view_set_cursor (view, EV_VIEW_CURSOR_DRAG);
+      ev_view_set_focused_element_at_location (view, event->x, event->y);
+      return TRUE;
+    case 3:
+      view->scroll_info.start_y = event->y;
+      ev_view_set_focused_element_at_location (view, event->x, event->y);
+      return ev_view_do_popup_menu (view, event->x, event->y);
+  }
+
+  return FALSE;
+}
+
+static void
+ev_view_remove_all (EvView *view) {
+  gtk_container_foreach (GTK_CONTAINER (view), (GtkCallback) gtk_widget_destroy, NULL);
+}
+
+static void
+destroy_child_if_form_widget (GtkWidget *widget) {
+  if (g_object_get_data (G_OBJECT (widget), "form-field"))
+    gtk_widget_destroy (widget);
+}
+
+static void
+ev_view_remove_all_form_fields (EvView *view) {
+  gtk_container_foreach (GTK_CONTAINER (view), (GtkCallback)destroy_child_if_form_widget, NULL);
 }
 
 /*** Drag and Drop ***/
 static void
 ev_view_drag_data_get (GtkWidget        *widget,
-		       GdkDragContext   *context,
-		       GtkSelectionData *selection_data,
-		       guint             info,
-		       guint             time)
-{
-	EvView *view = EV_VIEW (widget);
-
-	switch (info) {
-	        case TARGET_DND_TEXT:
-			if (EV_IS_SELECTION (view->document) &&
-			    view->selection_info.selections) {
-				gchar *text;
-
-				text = get_selected_text (view);
-				gtk_selection_data_set_text (selection_data,
-							     text,
-							     strlen (text));
-				g_free (text);
-			}
-			break;
-	        case TARGET_DND_IMAGE:
-			if (view->image_dnd_info.image) {
-				GdkPixbuf *pixbuf;
-
-				ev_document_doc_mutex_lock ();
-				pixbuf = ev_document_images_get_image (EV_DOCUMENT_IMAGES (view->document),
-								       view->image_dnd_info.image);
-				ev_document_doc_mutex_unlock ();
-				
-				gtk_selection_data_set_pixbuf (selection_data, pixbuf);
-				g_object_unref (pixbuf);
-			}
-			break;
-	        case TARGET_DND_URI:
-			if (view->image_dnd_info.image) {
-				GdkPixbuf   *pixbuf;
-				const gchar *tmp_uri;
-				gchar       *uris[2];
-
-				ev_document_doc_mutex_lock ();
-				pixbuf = ev_document_images_get_image (EV_DOCUMENT_IMAGES (view->document),
-								       view->image_dnd_info.image);
-				ev_document_doc_mutex_unlock ();
-				
-				tmp_uri = ev_image_save_tmp (view->image_dnd_info.image, pixbuf);
-				g_object_unref (pixbuf);
-
-				uris[0] = (gchar *)tmp_uri;
-                                uris[1] = NULL;
-				gtk_selection_data_set_uris (selection_data, uris);
-			}
-	}
+                       GdkDragContext   *context,
+                       GtkSelectionData *selection_data,
+                       guint             info,
+                       guint             time) {
+  EvView *view = EV_VIEW (widget);
+
+  switch (info) {
+    case TARGET_DND_TEXT:
+      if (EV_IS_SELECTION (view->document) &&
+          view->selection_info.selections) {
+        gchar *text;
+
+        text = get_selected_text (view);
+        gtk_selection_data_set_text (selection_data,
+                                     text,
+                                     strlen (text));
+        g_free (text);
+      }
+      break;
+    case TARGET_DND_IMAGE:
+      if (view->image_dnd_info.image) {
+        GdkPixbuf *pixbuf;
+
+        ev_document_doc_mutex_lock ();
+        pixbuf = ev_document_images_get_image (EV_DOCUMENT_IMAGES (view->document),
+                                               view->image_dnd_info.image);
+        ev_document_doc_mutex_unlock ();
+
+        gtk_selection_data_set_pixbuf (selection_data, pixbuf);
+        g_object_unref (pixbuf);
+      }
+      break;
+    case TARGET_DND_URI:
+      if (view->image_dnd_info.image) {
+        GdkPixbuf   *pixbuf;
+        const gchar *tmp_uri;
+        gchar       *uris[2];
+
+        ev_document_doc_mutex_lock ();
+        pixbuf = ev_document_images_get_image (EV_DOCUMENT_IMAGES (view->document),
+                                               view->image_dnd_info.image);
+        ev_document_doc_mutex_unlock ();
+
+        tmp_uri = ev_image_save_tmp (view->image_dnd_info.image, pixbuf);
+        g_object_unref (pixbuf);
+
+        uris[0] = (gchar *)tmp_uri;
+        uris[1] = NULL;
+        gtk_selection_data_set_uris (selection_data, uris);
+      }
+  }
 }
 
 static gboolean
 ev_view_drag_motion (GtkWidget      *widget,
-		     GdkDragContext *context,
-		     gint            x,
-		     gint            y,
-		     guint           time)
-{
-	if (gtk_drag_get_source_widget (context) == widget)
-		gdk_drag_status (context, 0, time);
-	else
-		gdk_drag_status (context, gdk_drag_context_get_suggested_action (context), time);
-	
-	return TRUE;
-}
-		     
+                     GdkDragContext *context,
+                     gint            x,
+                     gint            y,
+                     guint           time) {
+  if (gtk_drag_get_source_widget (context) == widget)
+    gdk_drag_status (context, 0, time);
+  else
+    gdk_drag_status (context, gdk_drag_context_get_suggested_action (context), time);
+
+  return TRUE;
+}
+
 static gboolean
-selection_update_idle_cb (EvView *view)
-{
-	compute_selections (view,
-			    view->selection_info.style,
-			    &view->selection_info.start,
-			    &view->motion);
-	view->selection_update_id = 0;
-	return FALSE;
+selection_update_idle_cb (EvView *view) {
+  compute_selections (view,
+                      view->selection_info.style,
+                      &view->selection_info.start,
+                      &view->motion);
+  view->selection_update_id = 0;
+  return FALSE;
 }
 
 static gboolean
-selection_scroll_timeout_cb (EvView *view)
-{	
-	gint x, y, shift = 0;
-	GtkWidget *widget = GTK_WIDGET (view);
-	GtkAllocation allocation;
-
-	gtk_widget_get_allocation (widget, &allocation);
-	ev_document_misc_get_pointer_position (widget, &x, &y);
-
-	if (y > allocation.height) {
-		shift = (y - allocation.height) / 2;
-	} else if (y < 0) {
-		shift = y / 2;
-	}
-
-	if (shift)
-		gtk_adjustment_set_value (view->vadjustment,
-					  CLAMP (gtk_adjustment_get_value (view->vadjustment) + shift,
-						 gtk_adjustment_get_lower (view->vadjustment),
-						 gtk_adjustment_get_upper (view->vadjustment) -
-						 gtk_adjustment_get_page_size (view->vadjustment)));
-
-	if (x > allocation.width) {
-		shift = (x - allocation.width) / 2;
-	} else if (x < 0) {
-		shift = x / 2;
-	}
-
-	if (shift)
-		gtk_adjustment_set_value (view->hadjustment,
-					  CLAMP (gtk_adjustment_get_value (view->hadjustment) + shift,
-						 gtk_adjustment_get_lower (view->hadjustment),
-						 gtk_adjustment_get_upper (view->hadjustment) -
-						 gtk_adjustment_get_page_size (view->hadjustment)));
-
-	return TRUE;
+selection_scroll_timeout_cb (EvView *view) {
+  gint x, y, shift = 0;
+  GtkWidget *widget = GTK_WIDGET (view);
+  GtkAllocation allocation;
+
+  gtk_widget_get_allocation (widget, &allocation);
+  ev_document_misc_get_pointer_position (widget, &x, &y);
+
+  if (y > allocation.height) {
+    shift = (y - allocation.height) / 2;
+  } else if (y < 0) {
+    shift = y / 2;
+  }
+
+  if (shift)
+    gtk_adjustment_set_value (view->vadjustment,
+                              CLAMP (gtk_adjustment_get_value (view->vadjustment) + shift,
+                                     gtk_adjustment_get_lower (view->vadjustment),
+                                     gtk_adjustment_get_upper (view->vadjustment) -
+                                     gtk_adjustment_get_page_size (view->vadjustment)));
+
+  if (x > allocation.width) {
+    shift = (x - allocation.width) / 2;
+  } else if (x < 0) {
+    shift = x / 2;
+  }
+
+  if (shift)
+    gtk_adjustment_set_value (view->hadjustment,
+                              CLAMP (gtk_adjustment_get_value (view->hadjustment) + shift,
+                                     gtk_adjustment_get_lower (view->hadjustment),
+                                     gtk_adjustment_get_upper (view->hadjustment) -
+                                     gtk_adjustment_get_page_size (view->hadjustment)));
+
+  return TRUE;
 }
 
 static gboolean
-ev_view_drag_update_momentum (EvView *view)
-{
-	int i;
-	if (!view->drag_info.in_drag)
-		return FALSE;
-	
-	for (i = DRAG_HISTORY - 1; i > 0; i--) {
-		view->drag_info.buffer[i].x = view->drag_info.buffer[i-1].x;
-		view->drag_info.buffer[i].y = view->drag_info.buffer[i-1].y;
-	}
-
-	/* Momentum is a moving average of 10ms granularity over
-	 * the last 100ms with each 10ms stored in buffer. 
-	 */
-	
-	view->drag_info.momentum.x = (view->drag_info.buffer[DRAG_HISTORY - 1].x - view->drag_info.buffer[0].x);
-	view->drag_info.momentum.y = (view->drag_info.buffer[DRAG_HISTORY - 1].y - view->drag_info.buffer[0].y);
-
-	return TRUE;
+ev_view_drag_update_momentum (EvView *view) {
+  int i;
+  if (!view->drag_info.in_drag)
+    return FALSE;
+
+  for (i = DRAG_HISTORY - 1; i > 0; i--) {
+    view->drag_info.buffer[i].x = view->drag_info.buffer[i - 1].x;
+    view->drag_info.buffer[i].y = view->drag_info.buffer[i - 1].y;
+  }
+
+  /* Momentum is a moving average of 10ms granularity over
+   * the last 100ms with each 10ms stored in buffer.
+   */
+
+  view->drag_info.momentum.x = (view->drag_info.buffer[DRAG_HISTORY - 1].x - view->drag_info.buffer[0].x);
+  view->drag_info.momentum.y = (view->drag_info.buffer[DRAG_HISTORY - 1].y - view->drag_info.buffer[0].y);
+
+  return TRUE;
 }
 
 static gboolean
-ev_view_scroll_drag_release (EvView *view)
-{
-	gdouble dhadj_value, dvadj_value;
-	gdouble oldhadjustment, oldvadjustment;
-	gdouble h_page_size, v_page_size;
-	gdouble h_upper, v_upper;
-	GtkAllocation allocation;
-
-	view->drag_info.momentum.x /= 1.2;
-	view->drag_info.momentum.y /= 1.2; /* Alter these constants to change "friction" */
-
-	gtk_widget_get_allocation (GTK_WIDGET (view), &allocation);
-
-	h_page_size = gtk_adjustment_get_page_size (view->hadjustment);
-	v_page_size = gtk_adjustment_get_page_size (view->vadjustment);
-
-	dhadj_value = h_page_size *
-		      (gdouble)view->drag_info.momentum.x / allocation.width;
-	dvadj_value = v_page_size *
-		      (gdouble)view->drag_info.momentum.y / allocation.height;
-
-	oldhadjustment = gtk_adjustment_get_value (view->hadjustment);
-	oldvadjustment = gtk_adjustment_get_value (view->vadjustment);
-
-	h_upper = gtk_adjustment_get_upper (view->hadjustment);
-	v_upper = gtk_adjustment_get_upper (view->vadjustment);
-
-	/* When we reach the edges, we need either to absorb some momentum and bounce by
-	 * multiplying it on -0.5 or stop scrolling by setting momentum to 0. */
-	if (((oldhadjustment + dhadj_value) > (h_upper - h_page_size)) ||
-	    ((oldhadjustment + dhadj_value) < 0))
-		view->drag_info.momentum.x = 0;
-	if (((oldvadjustment + dvadj_value) > (v_upper - v_page_size)) ||
-	    ((oldvadjustment + dvadj_value) < 0))
-		view->drag_info.momentum.y = 0;
-
-	gtk_adjustment_set_value (view->hadjustment,
-				  MIN (oldhadjustment + dhadj_value,
-				       h_upper - h_page_size));
-	gtk_adjustment_set_value (view->vadjustment,
-				  MIN (oldvadjustment + dvadj_value,
-				       v_upper - v_page_size));
-
-	if (((view->drag_info.momentum.x < 1) && (view->drag_info.momentum.x > -1)) &&
-	    ((view->drag_info.momentum.y < 1) && (view->drag_info.momentum.y > -1)))
-		return FALSE;
-	else
-		return TRUE;
+ev_view_scroll_drag_release (EvView *view) {
+  gdouble dhadj_value, dvadj_value;
+  gdouble oldhadjustment, oldvadjustment;
+  gdouble h_page_size, v_page_size;
+  gdouble h_upper, v_upper;
+  GtkAllocation allocation;
+
+  view->drag_info.momentum.x /= 1.2;
+  view->drag_info.momentum.y /= 1.2; /* Alter these constants to change "friction" */
+
+  gtk_widget_get_allocation (GTK_WIDGET (view), &allocation);
+
+  h_page_size = gtk_adjustment_get_page_size (view->hadjustment);
+  v_page_size = gtk_adjustment_get_page_size (view->vadjustment);
+
+  dhadj_value = h_page_size *
+                (gdouble)view->drag_info.momentum.x / allocation.width;
+  dvadj_value = v_page_size *
+                (gdouble)view->drag_info.momentum.y / allocation.height;
+
+  oldhadjustment = gtk_adjustment_get_value (view->hadjustment);
+  oldvadjustment = gtk_adjustment_get_value (view->vadjustment);
+
+  h_upper = gtk_adjustment_get_upper (view->hadjustment);
+  v_upper = gtk_adjustment_get_upper (view->vadjustment);
+
+  /* When we reach the edges, we need either to absorb some momentum and bounce by
+   * multiplying it on -0.5 or stop scrolling by setting momentum to 0. */
+  if (((oldhadjustment + dhadj_value) > (h_upper - h_page_size)) ||
+      ((oldhadjustment + dhadj_value) < 0))
+    view->drag_info.momentum.x = 0;
+  if (((oldvadjustment + dvadj_value) > (v_upper - v_page_size)) ||
+      ((oldvadjustment + dvadj_value) < 0))
+    view->drag_info.momentum.y = 0;
+
+  gtk_adjustment_set_value (view->hadjustment,
+                            MIN (oldhadjustment + dhadj_value,
+                                 h_upper - h_page_size));
+  gtk_adjustment_set_value (view->vadjustment,
+                            MIN (oldvadjustment + dvadj_value,
+                                 v_upper - v_page_size));
+
+  if (((view->drag_info.momentum.x < 1) && (view->drag_info.momentum.x > -1)) &&
+      ((view->drag_info.momentum.y < 1) && (view->drag_info.momentum.y > -1)))
+    return FALSE;
+  else
+    return TRUE;
 }
 
 static gboolean
 ev_view_motion_notify_event (GtkWidget      *widget,
-			     GdkEventMotion *event)
-{
-	EvView    *view = EV_VIEW (widget);
-	GdkWindow *window;
-	gint       x, y;
+                             GdkEventMotion *event) {
+  EvView    *view = EV_VIEW (widget);
+  GdkWindow *window;
+  gint       x, y;
 
-	if (!view->document)
-		return FALSE;
+  if (!view->document)
+    return FALSE;
 
-	if (gtk_gesture_is_recognized (view->zoom_gesture))
-		return TRUE;
+  if (gtk_gesture_is_recognized (view->zoom_gesture))
+    return TRUE;
 
-	window = gtk_widget_get_window (widget);
+  window = gtk_widget_get_window (widget);
 
-        if (event->is_hint || event->window != window) {
-	    ev_document_misc_get_pointer_position (widget, &x, &y);
-        } else {
-	    x = event->x;
-	    y = event->y;
-	}
-
-	if (view->scroll_info.autoscrolling) {
-		if (y >= 0)
-			view->scroll_info.last_y = y;
-		return TRUE;
-	}
-
-	if (view->selection_info.in_drag) {
-		if (gtk_drag_check_threshold (widget,
-					      view->selection_info.start.x,
-					      view->selection_info.start.y,
-					      x, y)) {
-			GtkTargetList *target_list = gtk_target_list_new (NULL, 0);
-
-			gtk_target_list_add_text_targets (target_list, TARGET_DND_TEXT);
-
-			gtk_drag_begin (widget, target_list,
-					GDK_ACTION_COPY,
-					1, (GdkEvent *)event);
-
-			view->selection_info.in_drag = FALSE;
-			view->pressed_button = -1;
-
-			gtk_target_list_unref (target_list);
-
-			return TRUE;
-		}
-	} else if (view->image_dnd_info.in_drag) {
-		if (gtk_drag_check_threshold (widget,
-					      view->selection_info.start.x,
-					      view->selection_info.start.y,
-					      x, y)) {
-			GtkTargetList *target_list = gtk_target_list_new (NULL, 0);
-
-			gtk_target_list_add_uri_targets (target_list, TARGET_DND_URI);
-			gtk_target_list_add_image_targets (target_list, TARGET_DND_IMAGE, TRUE);
-
-			gtk_drag_begin (widget, target_list,
-					GDK_ACTION_COPY,
-					1, (GdkEvent *)event);
-
-			view->image_dnd_info.in_drag = FALSE;
-			view->pressed_button = -1;
-
-			gtk_target_list_unref (target_list);
-
-			return TRUE;
-		}
-	}
-	
-	switch (view->pressed_button) {
-	case 1:
-		/* For the Evince 0.4.x release, we limit selection to un-rotated
-		 * documents only.
-		 */
-		if (view->rotation != 0)
-			return FALSE;
-
-		if (view->adding_annot_info.adding_annot) {
-			EvRectangle  rect;
-			EvRectangle  current_area;
-			EvPoint      start;
-			EvPoint      end;
-			GdkRectangle page_area;
-			GtkBorder    border;
-			guint        annot_page;
-
-			if (!view->adding_annot_info.annot)
-				return TRUE;
-
-			ev_annotation_get_area (view->adding_annot_info.annot, &current_area);
-
-			view->adding_annot_info.stop.x = event->x + view->scroll_x;
-			view->adding_annot_info.stop.y = event->y + view->scroll_y;
-			annot_page = ev_annotation_get_page_index (view->adding_annot_info.annot);
-			ev_view_get_page_extents (view, annot_page, &page_area, &border);
-			_ev_view_transform_view_point_to_doc_point (view, &view->adding_annot_info.start, &page_area, &border,
-								    &start.x, &start.y);
-			_ev_view_transform_view_point_to_doc_point (view, &view->adding_annot_info.stop, &page_area, &border,
-								    &end.x, &end.y);
-
-			switch (view->adding_annot_info.type) {
-			case EV_ANNOTATION_TYPE_TEXT:
-				rect.x1 = end.x;
-				rect.y1 = end.y;
-				rect.x2 = rect.x1 + current_area.x2 - current_area.x1;
-				rect.y2 = rect.y1 + current_area.y2 - current_area.y1;
-				break;
-			case EV_ANNOTATION_TYPE_TEXT_MARKUP:
-				rect.x1 = start.x;
-				rect.y1 = start.y;
-				rect.x2 = end.x;
-				rect.y2 = end.y;
-				break;
-			default:
-				g_assert_not_reached ();
-			}
-
-			/* Take the mutex before set_area, because the notify signal
-			 * updates the mappings in the backend */
-			ev_document_doc_mutex_lock ();
-			if (ev_annotation_set_area (view->adding_annot_info.annot, &rect)) {
-				ev_document_annotations_save_annotation (EV_DOCUMENT_ANNOTATIONS (view->document),
-									 view->adding_annot_info.annot,
-									 EV_ANNOTATIONS_SAVE_AREA);
-			}
-			ev_document_doc_mutex_unlock ();
-
-
-			/* FIXME: reload only annotation area */
-			ev_view_reload_page (view, annot_page, NULL);
-		} else if (view->moving_annot_info.annot_clicked) {
-			EvRectangle  rect;
-			EvRectangle  current_area;
-			GdkPoint     view_point;
-			EvPoint      doc_point;
-			GdkRectangle page_area;
-			GtkBorder    border;
-			guint        annot_page;
-			double       page_width;
-			double       page_height;
-
-			if (!view->moving_annot_info.annot)
-				return TRUE;
-
-			view_point.x = event->x + view->scroll_x;
-			view_point.y = event->y + view->scroll_y;
-
-			if (!view->moving_annot_info.moving_annot) {
-				/* Only move the annotation if the threshold is exceeded */
-				if (!gtk_drag_check_threshold (widget,
-							       view->moving_annot_info.start.x,
-							       view->moving_annot_info.start.y,
-							       view_point.x,
-							       view_point.y))
-					return TRUE;
-				view->moving_annot_info.moving_annot = TRUE;
-			}
-
-			ev_annotation_get_area (view->moving_annot_info.annot, &current_area);
-			annot_page = ev_annotation_get_page_index (view->moving_annot_info.annot);
-			ev_view_get_page_extents (view, annot_page, &page_area, &border);
-			_ev_view_transform_view_point_to_doc_point (view, &view_point, &page_area, &border,
-								    &doc_point.x, &doc_point.y);
-
-			ev_document_get_page_size (view->document, annot_page, &page_width, &page_height);
-
-			rect.x1 = MAX (0, doc_point.x - view->moving_annot_info.cursor_offset.x);
-			rect.y1 = MAX (0, doc_point.y - view->moving_annot_info.cursor_offset.y);
-			rect.x2 = rect.x1 + current_area.x2 - current_area.x1;
-			rect.y2 = rect.y1 + current_area.y2 - current_area.y1;
-
-			/* Prevent the annotation from being moved off the page */
-			if (rect.x2 > page_width) {
-				rect.x2 = page_width;
-				rect.x1 = page_width - current_area.x2 + current_area.x1;
-			}
-			if (rect.y2 > page_height) {
-				rect.y2 = page_height;
-				rect.y1 = page_height - current_area.y2 + current_area.y1;
-			}
-
-			/* Take the mutex before set_area, because the notify signal
-			 * updates the mappings in the backend */
-			ev_document_doc_mutex_lock ();
-			if (ev_annotation_set_area (view->moving_annot_info.annot, &rect)) {
-				ev_document_annotations_save_annotation (EV_DOCUMENT_ANNOTATIONS (view->document),
-									 view->moving_annot_info.annot,
-									 EV_ANNOTATIONS_SAVE_AREA);
-			}
-			ev_document_doc_mutex_unlock ();
-
-			/* FIXME: reload only annotation area */
-			ev_view_reload_page (view, annot_page, NULL);
-		} else if (ev_document_has_synctex (view->document) && (event->state & GDK_CONTROL_MASK)) {
-			/* Ignore spurious motion event triggered by slightly moving mouse
-			 * while clicking for launching synctex. Issue #951 */
-			return TRUE;
-		} else {
-			/* Schedule timeout to scroll during selection and additionally
-			 * scroll once to allow arbitrary speed. */
-			if (!view->selection_scroll_id)
-				view->selection_scroll_id = g_timeout_add (SCROLL_TIME,
-									   (GSourceFunc)selection_scroll_timeout_cb,
-									   view);
-			else
-				selection_scroll_timeout_cb (view);
-
-			view->motion.x = x + view->scroll_x;
-			view->motion.y = y + view->scroll_y;
-
-			/* Queue an idle to handle the motion.  We do this because
-			 * handling any selection events in the motion could be slower
-			 * than new motion events reach us.  We always put it in the
-			 * idle to make sure we catch up and don't visibly lag the
-			 * mouse. */
-			if (!view->selection_update_id)
-				view->selection_update_id = g_idle_add ((GSourceFunc)selection_update_idle_cb, view);
-		}
-
-		return TRUE;
-	case 2:
-		if (!view->drag_info.in_drag) {
-			gboolean start;
-			int i;
-
-			start = gtk_drag_check_threshold (widget,
-							  view->drag_info.start.x,
-							  view->drag_info.start.y,
-							  event->x_root,
-							  event->y_root);
-			view->drag_info.in_drag = start;
-			view->drag_info.drag_timeout_id = g_timeout_add (10,
-				(GSourceFunc)ev_view_drag_update_momentum, view);
-			/* Set 100 to choose how long it takes to build up momentum */
-			/* Clear out previous momentum info: */
-			for (i = 0; i < DRAG_HISTORY; i++) {
-				view->drag_info.buffer[i].x = event->x;
-				view->drag_info.buffer[i].y = event->y;
-			}
-			view->drag_info.momentum.x = 0;
-			view->drag_info.momentum.y = 0;
-		}
-
-		if (view->drag_info.in_drag) {
-			int dx, dy;
-			gdouble dhadj_value, dvadj_value;
-			GtkAllocation allocation;
-
-			view->drag_info.buffer[0].x = event->x;
-			view->drag_info.buffer[0].y = event->y;
-
-			dx = event->x_root - view->drag_info.start.x;
-			dy = event->y_root - view->drag_info.start.y;
-
-			gtk_widget_get_allocation (widget, &allocation);
-
-			dhadj_value = gtk_adjustment_get_page_size (view->hadjustment) *
-				      (gdouble)dx / allocation.width;
-			dvadj_value = gtk_adjustment_get_page_size (view->vadjustment) *
-				      (gdouble)dy / allocation.height;
-
-			/* We will update the drag event's start position if
-			 * the adjustment value is changed, but only if the
-			 * change was not caused by this function. */
-			view->drag_info.in_notify = TRUE;
-
-			/* clamp scrolling to visible area */
-			gtk_adjustment_set_value (view->hadjustment,
-						  MIN (view->drag_info.hadj - dhadj_value,
-						       gtk_adjustment_get_upper (view->hadjustment) -
-						       gtk_adjustment_get_page_size (view->hadjustment)));
-			gtk_adjustment_set_value (view->vadjustment,
-						  MIN (view->drag_info.vadj - dvadj_value,
-						       gtk_adjustment_get_upper (view->vadjustment) -
-						       gtk_adjustment_get_page_size (view->vadjustment)));
-
-			view->drag_info.in_notify = FALSE;
-
-			return TRUE;
-		}
-
-		break;
-	default:
-		ev_view_handle_cursor_over_xy (view, x, y);
-	} 
-
-	return FALSE;
+  if (event->is_hint || event->window != window) {
+    ev_document_misc_get_pointer_position (widget, &x, &y);
+  } else {
+    x = event->x;
+    y = event->y;
+  }
+
+  if (view->scroll_info.autoscrolling) {
+    if (y >= 0)
+      view->scroll_info.last_y = y;
+    return TRUE;
+  }
+
+  if (view->selection_info.in_drag) {
+    if (gtk_drag_check_threshold (widget,
+                                  view->selection_info.start.x,
+                                  view->selection_info.start.y,
+                                  x, y)) {
+      GtkTargetList *target_list = gtk_target_list_new (NULL, 0);
+
+      gtk_target_list_add_text_targets (target_list, TARGET_DND_TEXT);
+
+      gtk_drag_begin (widget, target_list,
+                      GDK_ACTION_COPY,
+                      1, (GdkEvent *)event);
+
+      view->selection_info.in_drag = FALSE;
+      view->pressed_button = -1;
+
+      gtk_target_list_unref (target_list);
+
+      return TRUE;
+    }
+  } else if (view->image_dnd_info.in_drag) {
+    if (gtk_drag_check_threshold (widget,
+                                  view->selection_info.start.x,
+                                  view->selection_info.start.y,
+                                  x, y)) {
+      GtkTargetList *target_list = gtk_target_list_new (NULL, 0);
+
+      gtk_target_list_add_uri_targets (target_list, TARGET_DND_URI);
+      gtk_target_list_add_image_targets (target_list, TARGET_DND_IMAGE, TRUE);
+
+      gtk_drag_begin (widget, target_list,
+                      GDK_ACTION_COPY,
+                      1, (GdkEvent *)event);
+
+      view->image_dnd_info.in_drag = FALSE;
+      view->pressed_button = -1;
+
+      gtk_target_list_unref (target_list);
+
+      return TRUE;
+    }
+  }
+
+  switch (view->pressed_button) {
+    case 1:
+      /* For the Evince 0.4.x release, we limit selection to un-rotated
+       * documents only.
+       */
+      if (view->rotation != 0)
+        return FALSE;
+
+      if (view->adding_annot_info.adding_annot) {
+        EvRectangle  rect;
+        EvRectangle  current_area;
+        EvPoint      start;
+        EvPoint      end;
+        GdkRectangle page_area;
+        GtkBorder    border;
+        guint        annot_page;
+
+        if (!view->adding_annot_info.annot)
+          return TRUE;
+
+        ev_annotation_get_area (view->adding_annot_info.annot, &current_area);
+
+        view->adding_annot_info.stop.x = event->x + view->scroll_x;
+        view->adding_annot_info.stop.y = event->y + view->scroll_y;
+        annot_page = ev_annotation_get_page_index (view->adding_annot_info.annot);
+        ev_view_get_page_extents (view, annot_page, &page_area, &border);
+        _ev_view_transform_view_point_to_doc_point (view, &view->adding_annot_info.start, &page_area, &border,
+                                                    &start.x, &start.y);
+        _ev_view_transform_view_point_to_doc_point (view, &view->adding_annot_info.stop, &page_area, &border,
+                                                    &end.x, &end.y);
+
+        switch (view->adding_annot_info.type) {
+          case EV_ANNOTATION_TYPE_TEXT:
+            rect.x1 = end.x;
+            rect.y1 = end.y;
+            rect.x2 = rect.x1 + current_area.x2 - current_area.x1;
+            rect.y2 = rect.y1 + current_area.y2 - current_area.y1;
+            break;
+          case EV_ANNOTATION_TYPE_TEXT_MARKUP:
+            rect.x1 = start.x;
+            rect.y1 = start.y;
+            rect.x2 = end.x;
+            rect.y2 = end.y;
+            break;
+          default:
+            g_assert_not_reached ();
+        }
+
+        /* Take the mutex before set_area, because the notify signal
+         * updates the mappings in the backend */
+        ev_document_doc_mutex_lock ();
+        if (ev_annotation_set_area (view->adding_annot_info.annot, &rect)) {
+          ev_document_annotations_save_annotation (EV_DOCUMENT_ANNOTATIONS (view->document),
+                                                   view->adding_annot_info.annot,
+                                                   EV_ANNOTATIONS_SAVE_AREA);
+        }
+        ev_document_doc_mutex_unlock ();
+
+
+        /* FIXME: reload only annotation area */
+        ev_view_reload_page (view, annot_page, NULL);
+      } else if (view->moving_annot_info.annot_clicked) {
+        EvRectangle  rect;
+        EvRectangle  current_area;
+        GdkPoint     view_point;
+        EvPoint      doc_point;
+        GdkRectangle page_area;
+        GtkBorder    border;
+        guint        annot_page;
+        double       page_width;
+        double       page_height;
+
+        if (!view->moving_annot_info.annot)
+          return TRUE;
+
+        view_point.x = event->x + view->scroll_x;
+        view_point.y = event->y + view->scroll_y;
+
+        if (!view->moving_annot_info.moving_annot) {
+          /* Only move the annotation if the threshold is exceeded */
+          if (!gtk_drag_check_threshold (widget,
+                                         view->moving_annot_info.start.x,
+                                         view->moving_annot_info.start.y,
+                                         view_point.x,
+                                         view_point.y))
+            return TRUE;
+          view->moving_annot_info.moving_annot = TRUE;
+        }
+
+        ev_annotation_get_area (view->moving_annot_info.annot, &current_area);
+        annot_page = ev_annotation_get_page_index (view->moving_annot_info.annot);
+        ev_view_get_page_extents (view, annot_page, &page_area, &border);
+        _ev_view_transform_view_point_to_doc_point (view, &view_point, &page_area, &border,
+                                                    &doc_point.x, &doc_point.y);
+
+        ev_document_get_page_size (view->document, annot_page, &page_width, &page_height);
+
+        rect.x1 = MAX (0, doc_point.x - view->moving_annot_info.cursor_offset.x);
+        rect.y1 = MAX (0, doc_point.y - view->moving_annot_info.cursor_offset.y);
+        rect.x2 = rect.x1 + current_area.x2 - current_area.x1;
+        rect.y2 = rect.y1 + current_area.y2 - current_area.y1;
+
+        /* Prevent the annotation from being moved off the page */
+        if (rect.x2 > page_width) {
+          rect.x2 = page_width;
+          rect.x1 = page_width - current_area.x2 + current_area.x1;
+        }
+        if (rect.y2 > page_height) {
+          rect.y2 = page_height;
+          rect.y1 = page_height - current_area.y2 + current_area.y1;
+        }
+
+        /* Take the mutex before set_area, because the notify signal
+         * updates the mappings in the backend */
+        ev_document_doc_mutex_lock ();
+        if (ev_annotation_set_area (view->moving_annot_info.annot, &rect)) {
+          ev_document_annotations_save_annotation (EV_DOCUMENT_ANNOTATIONS (view->document),
+                                                   view->moving_annot_info.annot,
+                                                   EV_ANNOTATIONS_SAVE_AREA);
+        }
+        ev_document_doc_mutex_unlock ();
+
+        /* FIXME: reload only annotation area */
+        ev_view_reload_page (view, annot_page, NULL);
+      } else if (ev_document_has_synctex (view->document) && (event->state & GDK_CONTROL_MASK)) {
+        /* Ignore spurious motion event triggered by slightly moving mouse
+         * while clicking for launching synctex. Issue #951 */
+        return TRUE;
+      } else {
+        /* Schedule timeout to scroll during selection and additionally
+         * scroll once to allow arbitrary speed. */
+        if (!view->selection_scroll_id)
+          view->selection_scroll_id = g_timeout_add (SCROLL_TIME,
+                                                     (GSourceFunc)selection_scroll_timeout_cb,
+                                                     view);
+        else
+          selection_scroll_timeout_cb (view);
+
+        view->motion.x = x + view->scroll_x;
+        view->motion.y = y + view->scroll_y;
+
+        /* Queue an idle to handle the motion.  We do this because
+         * handling any selection events in the motion could be slower
+         * than new motion events reach us.  We always put it in the
+         * idle to make sure we catch up and don't visibly lag the
+         * mouse. */
+        if (!view->selection_update_id)
+          view->selection_update_id = g_idle_add ((GSourceFunc)selection_update_idle_cb, view);
+      }
+
+      return TRUE;
+    case 2:
+      if (!view->drag_info.in_drag) {
+        gboolean start;
+        int i;
+
+        start = gtk_drag_check_threshold (widget,
+                                          view->drag_info.start.x,
+                                          view->drag_info.start.y,
+                                          event->x_root,
+                                          event->y_root);
+        view->drag_info.in_drag = start;
+        view->drag_info.drag_timeout_id = g_timeout_add (10,
+                                                         (GSourceFunc)ev_view_drag_update_momentum, view);
+        /* Set 100 to choose how long it takes to build up momentum */
+        /* Clear out previous momentum info: */
+        for (i = 0; i < DRAG_HISTORY; i++) {
+          view->drag_info.buffer[i].x = event->x;
+          view->drag_info.buffer[i].y = event->y;
+        }
+        view->drag_info.momentum.x = 0;
+        view->drag_info.momentum.y = 0;
+      }
+
+      if (view->drag_info.in_drag) {
+        int dx, dy;
+        gdouble dhadj_value, dvadj_value;
+        GtkAllocation allocation;
+
+        view->drag_info.buffer[0].x = event->x;
+        view->drag_info.buffer[0].y = event->y;
+
+        dx = event->x_root - view->drag_info.start.x;
+        dy = event->y_root - view->drag_info.start.y;
+
+        gtk_widget_get_allocation (widget, &allocation);
+
+        dhadj_value = gtk_adjustment_get_page_size (view->hadjustment) *
+                      (gdouble)dx / allocation.width;
+        dvadj_value = gtk_adjustment_get_page_size (view->vadjustment) *
+                      (gdouble)dy / allocation.height;
+
+        /* We will update the drag event's start position if
+         * the adjustment value is changed, but only if the
+         * change was not caused by this function. */
+        view->drag_info.in_notify = TRUE;
+
+        /* clamp scrolling to visible area */
+        gtk_adjustment_set_value (view->hadjustment,
+                                  MIN (view->drag_info.hadj - dhadj_value,
+                                       gtk_adjustment_get_upper (view->hadjustment) -
+                                       gtk_adjustment_get_page_size (view->hadjustment)));
+        gtk_adjustment_set_value (view->vadjustment,
+                                  MIN (view->drag_info.vadj - dvadj_value,
+                                       gtk_adjustment_get_upper (view->vadjustment) -
+                                       gtk_adjustment_get_page_size (view->vadjustment)));
+
+        view->drag_info.in_notify = FALSE;
+
+        return TRUE;
+      }
+
+      break;
+    default:
+      ev_view_handle_cursor_over_xy (view, x, y);
+  }
+
+  return FALSE;
 }
 /**
  * ev_view_get_selected_text:
@@ -5830,9 +5661,8 @@ ev_view_motion_notify_event (GtkWidget      *widget,
  * Since: 3.30
  */
 char *
-ev_view_get_selected_text (EvView *view)
-{
-	return get_selected_text (view);
+ev_view_get_selected_text (EvView *view) {
+  return get_selected_text (view);
 }
 
 /**
@@ -5850,2437 +5680,2358 @@ ev_view_get_selected_text (EvView *view)
  * Since: 3.30
  */
 gboolean
-ev_view_add_text_markup_annotation_for_selected_text (EvView  *view)
-{
-	GList *l;
+ev_view_add_text_markup_annotation_for_selected_text (EvView  *view) {
+  GList *l;
 
-	if (view->adding_annot_info.annot || view->adding_annot_info.adding_annot ||
-	    view->selection_info.selections == NULL)
-		return FALSE;
+  if (view->adding_annot_info.annot || view->adding_annot_info.adding_annot ||
+      view->selection_info.selections == NULL)
+    return FALSE;
 
-	for (l = view->selection_info.selections; l != NULL; l = l->next) {
-		EvViewSelection *selection = (EvViewSelection *)l->data;
+  for (l = view->selection_info.selections; l != NULL; l = l->next) {
+    EvViewSelection *selection = (EvViewSelection *)l->data;
 
-		view->adding_annot_info.adding_annot = TRUE;
-		view->adding_annot_info.type = EV_ANNOTATION_TYPE_TEXT_MARKUP;
+    view->adding_annot_info.adding_annot = TRUE;
+    view->adding_annot_info.type = EV_ANNOTATION_TYPE_TEXT_MARKUP;
 
-		ev_view_create_annotation_from_selection (view, selection);
+    ev_view_create_annotation_from_selection (view, selection);
 
-		if (view->adding_annot_info.adding_annot)
-			g_signal_emit (view, signals[SIGNAL_ANNOT_ADDED], 0, view->adding_annot_info.annot);
-	}
+    if (view->adding_annot_info.adding_annot)
+      g_signal_emit (view, signals[SIGNAL_ANNOT_ADDED], 0, view->adding_annot_info.annot);
+  }
 
-	clear_selection (view);
+  clear_selection (view);
 
-	view->adding_annot_info.adding_annot = FALSE;
-	view->adding_annot_info.annot = NULL;
+  view->adding_annot_info.adding_annot = FALSE;
+  view->adding_annot_info.annot = NULL;
 
-	return TRUE;
+  return TRUE;
 }
 
 void
 ev_view_set_enable_spellchecking (EvView *view,
-                                  gboolean enabled)
-{
-        EvMappingList *annots;
-        GList         *l;
-        gint           n_pages = 0;
-        gint           current_page;
+                                  gboolean enabled) {
+  EvMappingList *annots;
+  GList         *l;
+  gint           n_pages = 0;
+  gint           current_page;
 
-        g_return_if_fail (EV_IS_VIEW (view));
+  g_return_if_fail (EV_IS_VIEW (view));
 
-        view->enable_spellchecking = enabled;
+  view->enable_spellchecking = enabled;
 
-        if (view->document)
-                n_pages = ev_document_get_n_pages (view->document);
+  if (view->document)
+    n_pages = ev_document_get_n_pages (view->document);
 
-        for (current_page = 0; current_page < n_pages; current_page++) {
-                annots = ev_page_cache_get_annot_mapping (view->page_cache, current_page);
+  for (current_page = 0; current_page < n_pages; current_page++) {
+    annots = ev_page_cache_get_annot_mapping (view->page_cache, current_page);
 
-                for (l = ev_mapping_list_get_list (annots); l && l->data; l = g_list_next (l)) {
-                        EvAnnotation      *annot;
-                        GtkWidget         *window;
+    for (l = ev_mapping_list_get_list (annots); l && l->data; l = g_list_next (l)) {
+      EvAnnotation      *annot;
+      GtkWidget         *window;
 
-                        annot = ((EvMapping *)(l->data))->data;
+      annot = ((EvMapping *)(l->data))->data;
 
-                        if (!EV_IS_ANNOTATION_MARKUP (annot))
-                                continue;
+      if (!EV_IS_ANNOTATION_MARKUP (annot))
+        continue;
 
-                        window = get_window_for_annot (view, annot);
+      window = get_window_for_annot (view, annot);
 
-                        if (window) {
-                                ev_annotation_window_set_enable_spellchecking (EV_ANNOTATION_WINDOW (window), view->enable_spellchecking);
-                        }
-                }
-        }
+      if (window) {
+        ev_annotation_window_set_enable_spellchecking (EV_ANNOTATION_WINDOW (window), view->enable_spellchecking);
+      }
+    }
+  }
 }
 
 gboolean
-ev_view_get_enable_spellchecking (EvView *view)
-{
-        g_return_val_if_fail (EV_IS_VIEW (view), FALSE);
+ev_view_get_enable_spellchecking (EvView *view) {
+  g_return_val_if_fail (EV_IS_VIEW (view), FALSE);
 
 #ifdef WITH_GSPELL
-        return view->enable_spellchecking;
+  return view->enable_spellchecking;
 #else
-        return FALSE;
+  return FALSE;
 #endif
 }
 
 static gboolean
 ev_view_button_release_event (GtkWidget      *widget,
-			      GdkEventButton *event)
-{
-	EvView *view = EV_VIEW (widget);
-	EvLink *link = NULL;
-
-	view->image_dnd_info.in_drag = FALSE;
-
-	if (gtk_gesture_is_recognized (view->zoom_gesture))
-		return TRUE;
-
-	if (view->scroll_info.autoscrolling) {
-		ev_view_autoscroll_stop (view);
-		view->pressed_button = -1;
-
-		return TRUE;
-	}
-
-	if (view->pressed_button == 1 && event->state & GDK_CONTROL_MASK) {
-		view->pressed_button = -1;
-		return TRUE;
-	}
-
-	if (view->drag_info.in_drag) {
-		view->drag_info.release_timeout_id =
-			g_timeout_add (20,
-				       (GSourceFunc)ev_view_scroll_drag_release, view);
-	}
-
-	if (view->document && !view->drag_info.in_drag &&
-	    (view->pressed_button == GDK_BUTTON_PRIMARY ||
-	     view->pressed_button == GDK_BUTTON_MIDDLE)) {
-		link = ev_view_get_link_at_location (view, event->x, event->y);
-	}
-
-	view->drag_info.in_drag = FALSE;
-
-	if (view->adding_annot_info.adding_annot) {
-		gboolean annot_added = TRUE;
-
-		/* We ignore right-click buttons while in annotation add mode */
-		if (view->pressed_button != 1)
-			return FALSE;
-		g_assert (view->adding_annot_info.annot);
-
-		if (EV_IS_ANNOTATION_MARKUP (view->adding_annot_info.annot)) {
-			GtkWindow  *parent;
-			GtkWidget  *window;
-			EvRectangle area;
-			EvRectangle popup_rect;
-
-			ev_annotation_get_area (view->adding_annot_info.annot, &area);
-
-			if (area.x1 == 0 && area.y1 == 0 && area.x2 == 0 && area.y2 == 0) {
-				/* Do not create empty annots */
-				annot_added = FALSE;
-
-				ev_document_doc_mutex_lock ();
-				ev_document_annotations_remove_annotation (EV_DOCUMENT_ANNOTATIONS (view->document),
-									   view->adding_annot_info.annot);
-				ev_document_doc_mutex_unlock ();
-
-				ev_page_cache_mark_dirty (view->page_cache,
-							  ev_annotation_get_page_index (view->adding_annot_info.annot),
-							  EV_PAGE_DATA_INCLUDE_ANNOTS);
-			} else {
-				popup_rect.x1 = area.x2;
-				popup_rect.x2 = popup_rect.x1 + ANNOT_POPUP_WINDOW_DEFAULT_WIDTH;
-				popup_rect.y1 = area.y2;
-				popup_rect.y2 = popup_rect.y1 + ANNOT_POPUP_WINDOW_DEFAULT_HEIGHT;
-
-				if (ev_annotation_markup_set_rectangle (EV_ANNOTATION_MARKUP (view->adding_annot_info.annot),
-									&popup_rect)) {
-					ev_document_doc_mutex_lock ();
-					ev_document_annotations_save_annotation (EV_DOCUMENT_ANNOTATIONS (view->document),
-										 view->adding_annot_info.annot,
-										 EV_ANNOTATIONS_SAVE_POPUP_RECT);
-					ev_document_doc_mutex_unlock ();
-				}
-				/* the annotation window might already exist */
-				window = get_window_for_annot (view, view->adding_annot_info.annot);
-
-				if (window == NULL) {
-					parent = GTK_WINDOW (gtk_widget_get_toplevel (GTK_WIDGET (view)));
-					window = ev_view_create_annotation_window (view, view->adding_annot_info.annot, parent);
-				}
-				/* Show the annot window the first time for text annotations */
-				if (view->adding_annot_info.type == EV_ANNOTATION_TYPE_TEXT)
-					ev_view_annotation_show_popup_window (view, window);
-			}
-		}
-
-		view->adding_annot_info.stop.x = event->x + view->scroll_x;
-		view->adding_annot_info.stop.y = event->y + view->scroll_y;
-		if (annot_added)
-			g_signal_emit (view, signals[SIGNAL_ANNOT_ADDED], 0, view->adding_annot_info.annot);
-
-		view->adding_annot_info.adding_annot = FALSE;
-		view->adding_annot_info.annot = NULL;
-		ev_view_handle_cursor_over_xy (view, event->x, event->y);
-		view->pressed_button = -1;
-
-		return FALSE;
-	}
-
-	if (view->moving_annot_info.annot_clicked) {
-		if (view->moving_annot_info.moving_annot)
-			ev_view_handle_cursor_over_xy (view, event->x, event->y);
-		else
-			ev_view_handle_annotation (view, view->moving_annot_info.annot, event->x, event->y, event->time);
-
-		view->moving_annot_info.annot_clicked = FALSE;
-		view->moving_annot_info.moving_annot = FALSE;
-		view->moving_annot_info.annot = NULL;
-		view->pressed_button = -1;
-
-		return FALSE;
-	}
-
-	if (view->pressed_button == 1) {
-		EvAnnotation *annot = ev_view_get_annotation_at_location (view, event->x, event->y);
-
-		if (annot)
-			ev_view_handle_annotation (view, annot, event->x, event->y, event->time);
-	}
-
-	if (view->pressed_button == 2) {
-		ev_view_handle_cursor_over_xy (view, event->x, event->y);
-	}
-
-	view->pressed_button = -1;
-
-	if (view->selection_scroll_id) {
-	    g_source_remove (view->selection_scroll_id);
-	    view->selection_scroll_id = 0;
-	}
-	if (view->selection_update_id) {
-	    g_source_remove (view->selection_update_id);
-	    view->selection_update_id = 0;
-	}
-
-	if (view->selection_info.selections) {
-		clear_link_selected (view);
-		ev_view_update_primary_selection (view);
-
-		position_caret_cursor_for_event (view, event, FALSE);
-
-		if (view->selection_info.in_drag)
-			clear_selection (view);
-		view->selection_info.in_drag = FALSE;
-	} else if (link) {
-		if (event->button == 2) {
-			EvLinkAction    *action;
-			EvLinkActionType type;
-
-			action = ev_link_get_action (link);
-			if (!action)
-				return FALSE;
-
-			type = ev_link_action_get_action_type (action);
-			if (type == EV_LINK_ACTION_TYPE_GOTO_DEST) {
-				g_signal_emit (view,
-					       signals[SIGNAL_EXTERNAL_LINK],
-					       0, action);
-			}
-		} else {
-			ev_view_handle_link (view, link);
-		}
-	}
-
-	return FALSE;
+                              GdkEventButton *event) {
+  EvView *view = EV_VIEW (widget);
+  EvLink *link = NULL;
+
+  view->image_dnd_info.in_drag = FALSE;
+
+  if (gtk_gesture_is_recognized (view->zoom_gesture))
+    return TRUE;
+
+  if (view->scroll_info.autoscrolling) {
+    ev_view_autoscroll_stop (view);
+    view->pressed_button = -1;
+
+    return TRUE;
+  }
+
+  if (view->pressed_button == 1 && event->state & GDK_CONTROL_MASK) {
+    view->pressed_button = -1;
+    return TRUE;
+  }
+
+  if (view->drag_info.in_drag) {
+    view->drag_info.release_timeout_id =
+      g_timeout_add (20,
+                     (GSourceFunc)ev_view_scroll_drag_release, view);
+  }
+
+  if (view->document && !view->drag_info.in_drag &&
+      (view->pressed_button == GDK_BUTTON_PRIMARY ||
+       view->pressed_button == GDK_BUTTON_MIDDLE)) {
+    link = ev_view_get_link_at_location (view, event->x, event->y);
+  }
+
+  view->drag_info.in_drag = FALSE;
+
+  if (view->adding_annot_info.adding_annot) {
+    gboolean annot_added = TRUE;
+
+    /* We ignore right-click buttons while in annotation add mode */
+    if (view->pressed_button != 1)
+      return FALSE;
+    g_assert (view->adding_annot_info.annot);
+
+    if (EV_IS_ANNOTATION_MARKUP (view->adding_annot_info.annot)) {
+      GtkWindow  *parent;
+      GtkWidget  *window;
+      EvRectangle area;
+      EvRectangle popup_rect;
+
+      ev_annotation_get_area (view->adding_annot_info.annot, &area);
+
+      if (area.x1 == 0 && area.y1 == 0 && area.x2 == 0 && area.y2 == 0) {
+        /* Do not create empty annots */
+        annot_added = FALSE;
+
+        ev_document_doc_mutex_lock ();
+        ev_document_annotations_remove_annotation (EV_DOCUMENT_ANNOTATIONS (view->document),
+                                                   view->adding_annot_info.annot);
+        ev_document_doc_mutex_unlock ();
+
+        ev_page_cache_mark_dirty (view->page_cache,
+                                  ev_annotation_get_page_index (view->adding_annot_info.annot),
+                                  EV_PAGE_DATA_INCLUDE_ANNOTS);
+      } else {
+        popup_rect.x1 = area.x2;
+        popup_rect.x2 = popup_rect.x1 + ANNOT_POPUP_WINDOW_DEFAULT_WIDTH;
+        popup_rect.y1 = area.y2;
+        popup_rect.y2 = popup_rect.y1 + ANNOT_POPUP_WINDOW_DEFAULT_HEIGHT;
+
+        if (ev_annotation_markup_set_rectangle (EV_ANNOTATION_MARKUP (view->adding_annot_info.annot),
+                                                &popup_rect)) {
+          ev_document_doc_mutex_lock ();
+          ev_document_annotations_save_annotation (EV_DOCUMENT_ANNOTATIONS (view->document),
+                                                   view->adding_annot_info.annot,
+                                                   EV_ANNOTATIONS_SAVE_POPUP_RECT);
+          ev_document_doc_mutex_unlock ();
+        }
+        /* the annotation window might already exist */
+        window = get_window_for_annot (view, view->adding_annot_info.annot);
+
+        if (window == NULL) {
+          parent = GTK_WINDOW (gtk_widget_get_toplevel (GTK_WIDGET (view)));
+          window = ev_view_create_annotation_window (view, view->adding_annot_info.annot, parent);
+        }
+        /* Show the annot window the first time for text annotations */
+        if (view->adding_annot_info.type == EV_ANNOTATION_TYPE_TEXT)
+          ev_view_annotation_show_popup_window (view, window);
+      }
+    }
+
+    view->adding_annot_info.stop.x = event->x + view->scroll_x;
+    view->adding_annot_info.stop.y = event->y + view->scroll_y;
+    if (annot_added)
+      g_signal_emit (view, signals[SIGNAL_ANNOT_ADDED], 0, view->adding_annot_info.annot);
+
+    view->adding_annot_info.adding_annot = FALSE;
+    view->adding_annot_info.annot = NULL;
+    ev_view_handle_cursor_over_xy (view, event->x, event->y);
+    view->pressed_button = -1;
+
+    return FALSE;
+  }
+
+  if (view->moving_annot_info.annot_clicked) {
+    if (view->moving_annot_info.moving_annot)
+      ev_view_handle_cursor_over_xy (view, event->x, event->y);
+    else
+      ev_view_handle_annotation (view, view->moving_annot_info.annot, event->x, event->y, event->time);
+
+    view->moving_annot_info.annot_clicked = FALSE;
+    view->moving_annot_info.moving_annot = FALSE;
+    view->moving_annot_info.annot = NULL;
+    view->pressed_button = -1;
+
+    return FALSE;
+  }
+
+  if (view->pressed_button == 1) {
+    EvAnnotation *annot = ev_view_get_annotation_at_location (view, event->x, event->y);
+
+    if (annot)
+      ev_view_handle_annotation (view, annot, event->x, event->y, event->time);
+  }
+
+  if (view->pressed_button == 2) {
+    ev_view_handle_cursor_over_xy (view, event->x, event->y);
+  }
+
+  view->pressed_button = -1;
+
+  if (view->selection_scroll_id) {
+    g_source_remove (view->selection_scroll_id);
+    view->selection_scroll_id = 0;
+  }
+  if (view->selection_update_id) {
+    g_source_remove (view->selection_update_id);
+    view->selection_update_id = 0;
+  }
+
+  if (view->selection_info.selections) {
+    clear_link_selected (view);
+    ev_view_update_primary_selection (view);
+
+    position_caret_cursor_for_event (view, event, FALSE);
+
+    if (view->selection_info.in_drag)
+      clear_selection (view);
+    view->selection_info.in_drag = FALSE;
+  } else if (link) {
+    if (event->button == 2) {
+      EvLinkAction    *action;
+      EvLinkActionType type;
+
+      action = ev_link_get_action (link);
+      if (!action)
+        return FALSE;
+
+      type = ev_link_action_get_action_type (action);
+      if (type == EV_LINK_ACTION_TYPE_GOTO_DEST) {
+        g_signal_emit (view,
+                       signals[SIGNAL_EXTERNAL_LINK],
+                       0, action);
+      }
+    } else {
+      ev_view_handle_link (view, link);
+    }
+  }
+
+  return FALSE;
 }
 
 static gboolean
 ev_view_forward_key_event_to_focused_child (EvView      *view,
-					    GdkEventKey *event)
-{
-	GtkWidget   *child_widget = NULL;
-	GdkEventKey *new_event;
-	gboolean     handled;
-
-	if (view->window_child_focus) {
-		child_widget = view->window_child_focus->window;
-	} else if (view->children) {
-		EvViewChild *child = (EvViewChild *)view->children->data;
-
-		child_widget = child->widget;
-	} else {
-		return FALSE;
-	}
-
-	new_event = (GdkEventKey *) gdk_event_copy ((GdkEvent *)event);
-	g_object_unref (new_event->window);
-	new_event->window = gtk_widget_get_window (child_widget);
-	if (new_event->window)
-		g_object_ref (new_event->window);
-	gtk_widget_realize (child_widget);
-	handled = gtk_widget_event (child_widget, (GdkEvent *)new_event);
-	gdk_event_free ((GdkEvent *)new_event);
-
-	return handled;
+                                            GdkEventKey *event) {
+  GtkWidget   *child_widget = NULL;
+  GdkEventKey *new_event;
+  gboolean     handled;
+
+  if (view->window_child_focus) {
+    child_widget = view->window_child_focus->window;
+  } else if (view->children) {
+    EvViewChild *child = (EvViewChild *)view->children->data;
+
+    child_widget = child->widget;
+  } else {
+    return FALSE;
+  }
+
+  new_event = (GdkEventKey *) gdk_event_copy ((GdkEvent *)event);
+  g_object_unref (new_event->window);
+  new_event->window = gtk_widget_get_window (child_widget);
+  if (new_event->window)
+    g_object_ref (new_event->window);
+  gtk_widget_realize (child_widget);
+  handled = gtk_widget_event (child_widget, (GdkEvent *)new_event);
+  gdk_event_free ((GdkEvent *)new_event);
+
+  return handled;
 }
 
 static gint
 go_to_next_page (EvView *view,
-		 gint    page)
-{
-	int      n_pages;
-	gboolean dual_page;
+                 gint    page) {
+  int      n_pages;
+  gboolean dual_page;
 
-	if (!view->document)
-		return -1;
+  if (!view->document)
+    return -1;
 
-	n_pages = ev_document_get_n_pages (view->document);
+  n_pages = ev_document_get_n_pages (view->document);
 
-	dual_page = is_dual_page (view, NULL);
-	page += dual_page ? 2 : 1;
+  dual_page = is_dual_page (view, NULL);
+  page += dual_page ? 2 : 1;
 
-	if (page < n_pages)
-		return page;
+  if (page < n_pages)
+    return page;
 
-	if (dual_page && page == n_pages)
-		return page - 1;
+  if (dual_page && page == n_pages)
+    return page - 1;
 
-	return -1;
+  return -1;
 }
 
 static gint
 go_to_previous_page (EvView *view,
-		     gint    page)
-{
-	gboolean dual_page;
+                     gint    page) {
+  gboolean dual_page;
 
-	if (!view->document)
-		return -1;
+  if (!view->document)
+    return -1;
 
-	dual_page = is_dual_page (view, NULL);
-	page -= dual_page ? 2 : 1;
+  dual_page = is_dual_page (view, NULL);
+  page -= dual_page ? 2 : 1;
 
-	if (page >= 0)
-		return page;
+  if (page >= 0)
+    return page;
 
-	if (dual_page && page == -1)
-		return 0;
+  if (dual_page && page == -1)
+    return 0;
 
-	return -1;
+  return -1;
 }
 
 static gboolean
-cursor_go_to_page_start (EvView *view)
-{
-	view->cursor_offset = 0;
+cursor_go_to_page_start (EvView *view) {
+  view->cursor_offset = 0;
 
-	return TRUE;
+  return TRUE;
 }
 
 static gboolean
-cursor_go_to_page_end (EvView *view)
-{
-	PangoLogAttr *log_attrs = NULL;
-	gulong        n_attrs;
+cursor_go_to_page_end (EvView *view) {
+  PangoLogAttr *log_attrs = NULL;
+  gulong        n_attrs;
 
-	if (!view->page_cache)
-		return FALSE;
+  if (!view->page_cache)
+    return FALSE;
 
-	ev_page_cache_get_text_log_attrs (view->page_cache, view->cursor_page, &log_attrs, &n_attrs);
-	if (!log_attrs)
-		return FALSE;
+  ev_page_cache_get_text_log_attrs (view->page_cache, view->cursor_page, &log_attrs, &n_attrs);
+  if (!log_attrs)
+    return FALSE;
 
-	view->cursor_offset = n_attrs;
+  view->cursor_offset = n_attrs;
 
-	return TRUE;
+  return TRUE;
 }
 
 static gboolean
-cursor_go_to_next_page (EvView *view)
-{
-	gint new_page;
+cursor_go_to_next_page (EvView *view) {
+  gint new_page;
 
-	new_page = go_to_next_page (view, view->cursor_page);
-	if (new_page != -1) {
-		view->cursor_page = new_page;
-		return cursor_go_to_page_start (view);
-	}
+  new_page = go_to_next_page (view, view->cursor_page);
+  if (new_page != -1) {
+    view->cursor_page = new_page;
+    return cursor_go_to_page_start (view);
+  }
 
-	return FALSE;
+  return FALSE;
 }
 
 static gboolean
-cursor_go_to_previous_page (EvView *view)
-{
-	gint new_page;
+cursor_go_to_previous_page (EvView *view) {
+  gint new_page;
 
-	new_page = go_to_previous_page (view, view->cursor_page);
-	if (new_page != -1) {
-		view->cursor_page = new_page;
-		return cursor_go_to_page_end (view);
-	}
-	return FALSE;
+  new_page = go_to_previous_page (view, view->cursor_page);
+  if (new_page != -1) {
+    view->cursor_page = new_page;
+    return cursor_go_to_page_end (view);
+  }
+  return FALSE;
 }
 
 static gboolean
-cursor_go_to_document_start (EvView *view)
-{
-	view->cursor_page = 0;
-	return cursor_go_to_page_start (view);
+cursor_go_to_document_start (EvView *view) {
+  view->cursor_page = 0;
+  return cursor_go_to_page_start (view);
 }
 
 static gboolean
-cursor_go_to_document_end (EvView *view)
-{
-	if (!view->document)
-		return FALSE;
+cursor_go_to_document_end (EvView *view) {
+  if (!view->document)
+    return FALSE;
 
-	view->cursor_page = ev_document_get_n_pages (view->document) - 1;
-	return cursor_go_to_page_end (view);
+  view->cursor_page = ev_document_get_n_pages (view->document) - 1;
+  return cursor_go_to_page_end (view);
 }
 
 static gboolean
-cursor_backward_char (EvView *view)
-{
-	PangoLogAttr *log_attrs = NULL;
-	gulong        n_attrs;
+cursor_backward_char (EvView *view) {
+  PangoLogAttr *log_attrs = NULL;
+  gulong        n_attrs;
 
-	if (!view->page_cache)
-		return FALSE;
+  if (!view->page_cache)
+    return FALSE;
 
-	ev_page_cache_get_text_log_attrs (view->page_cache, view->cursor_page, &log_attrs, &n_attrs);
-	if (!log_attrs)
-		return FALSE;
+  ev_page_cache_get_text_log_attrs (view->page_cache, view->cursor_page, &log_attrs, &n_attrs);
+  if (!log_attrs)
+    return FALSE;
 
-	if (view->cursor_offset == 0)
-		return cursor_go_to_previous_page (view);
+  if (view->cursor_offset == 0)
+    return cursor_go_to_previous_page (view);
 
-	do {
-		view->cursor_offset--;
-	} while (view->cursor_offset >= 0 && !log_attrs[view->cursor_offset].is_cursor_position);
+  do {
+    view->cursor_offset--;
+  } while (view->cursor_offset >= 0 && !log_attrs[view->cursor_offset].is_cursor_position);
 
-	return TRUE;
+  return TRUE;
 }
 
 static gboolean
-cursor_forward_char (EvView *view)
-{
-	PangoLogAttr *log_attrs = NULL;
-	gulong        n_attrs;
+cursor_forward_char (EvView *view) {
+  PangoLogAttr *log_attrs = NULL;
+  gulong        n_attrs;
 
-	if (!view->page_cache)
-		return FALSE;
+  if (!view->page_cache)
+    return FALSE;
 
-	ev_page_cache_get_text_log_attrs (view->page_cache, view->cursor_page, &log_attrs, &n_attrs);
-	if (!log_attrs)
-		return FALSE;
+  ev_page_cache_get_text_log_attrs (view->page_cache, view->cursor_page, &log_attrs, &n_attrs);
+  if (!log_attrs)
+    return FALSE;
 
-	if (view->cursor_offset >= n_attrs)
-		return cursor_go_to_next_page (view);
+  if (view->cursor_offset >= n_attrs)
+    return cursor_go_to_next_page (view);
 
-	do {
-		view->cursor_offset++;
-	} while (view->cursor_offset <= n_attrs && !log_attrs[view->cursor_offset].is_cursor_position);
+  do {
+    view->cursor_offset++;
+  } while (view->cursor_offset <= n_attrs && !log_attrs[view->cursor_offset].is_cursor_position);
 
-	return TRUE;
+  return TRUE;
 }
 
 static gboolean
-cursor_backward_word_start (EvView *view)
-{
-	PangoLogAttr *log_attrs = NULL;
-	gulong        n_attrs;
-	gint          i, j;
+cursor_backward_word_start (EvView *view) {
+  PangoLogAttr *log_attrs = NULL;
+  gulong        n_attrs;
+  gint          i, j;
 
-	if (!view->page_cache)
-		return FALSE;
+  if (!view->page_cache)
+    return FALSE;
 
-	ev_page_cache_get_text_log_attrs (view->page_cache, view->cursor_page, &log_attrs, &n_attrs);
-	if (!log_attrs)
-		return FALSE;
+  ev_page_cache_get_text_log_attrs (view->page_cache, view->cursor_page, &log_attrs, &n_attrs);
+  if (!log_attrs)
+    return FALSE;
 
-	/* Skip current word starts */
-	for (i = view->cursor_offset; i >= 0 && log_attrs[i].is_word_start; i--);
-	if (i <= 0) {
-		if (cursor_go_to_previous_page (view))
-			return cursor_backward_word_start (view);
-		return FALSE;
-	}
+  /* Skip current word starts */
+  for (i = view->cursor_offset; i >= 0 && log_attrs[i].is_word_start; i--);
+  if (i <= 0) {
+    if (cursor_go_to_previous_page (view))
+      return cursor_backward_word_start (view);
+    return FALSE;
+  }
 
-	/* Move to the beginning of the word */
-	for (j = i; j >= 0 && !log_attrs[j].is_word_start; j--);
-	view->cursor_offset = MAX (0, j);
+  /* Move to the beginning of the word */
+  for (j = i; j >= 0 && !log_attrs[j].is_word_start; j--);
+  view->cursor_offset = MAX (0, j);
 
-	return TRUE;
+  return TRUE;
 }
 
 static gboolean
-cursor_forward_word_end (EvView *view)
-{
-	PangoLogAttr *log_attrs = NULL;
-	gulong        n_attrs;
-	gint          i, j;
+cursor_forward_word_end (EvView *view) {
+  PangoLogAttr *log_attrs = NULL;
+  gulong        n_attrs;
+  gint          i, j;
 
-	if (!view->page_cache)
-		return FALSE;
+  if (!view->page_cache)
+    return FALSE;
 
-	ev_page_cache_get_text_log_attrs (view->page_cache, view->cursor_page, &log_attrs, &n_attrs);
-	if (!log_attrs)
-		return FALSE;
+  ev_page_cache_get_text_log_attrs (view->page_cache, view->cursor_page, &log_attrs, &n_attrs);
+  if (!log_attrs)
+    return FALSE;
 
-	/* Skip current current word ends */
-	for (i = view->cursor_offset; i < n_attrs && log_attrs[i].is_word_end; i++);
-	if (i >= n_attrs) {
-		if (cursor_go_to_next_page (view))
-			return cursor_forward_word_end (view);
-		return FALSE;
-	}
+  /* Skip current current word ends */
+  for (i = view->cursor_offset; i < n_attrs && log_attrs[i].is_word_end; i++);
+  if (i >= n_attrs) {
+    if (cursor_go_to_next_page (view))
+      return cursor_forward_word_end (view);
+    return FALSE;
+  }
 
-	/* Move to the end of the word. */
-	for (j = i; j < n_attrs && !log_attrs[j].is_word_end; j++);
-	view->cursor_offset = MIN (j, n_attrs);
+  /* Move to the end of the word. */
+  for (j = i; j < n_attrs && !log_attrs[j].is_word_end; j++);
+  view->cursor_offset = MIN (j, n_attrs);
 
-	return TRUE;
+  return TRUE;
 }
 
 static gboolean
-cursor_go_to_line_start (EvView *view)
-{
-	PangoLogAttr *log_attrs = NULL;
-	gulong        n_attrs;
-	gint          i;
+cursor_go_to_line_start (EvView *view) {
+  PangoLogAttr *log_attrs = NULL;
+  gulong        n_attrs;
+  gint          i;
 
-	if (!view->page_cache)
-		return FALSE;
+  if (!view->page_cache)
+    return FALSE;
 
-	ev_page_cache_get_text_log_attrs (view->page_cache, view->cursor_page, &log_attrs, &n_attrs);
-	if (!log_attrs)
-		return FALSE;
+  ev_page_cache_get_text_log_attrs (view->page_cache, view->cursor_page, &log_attrs, &n_attrs);
+  if (!log_attrs)
+    return FALSE;
 
-	for (i = view->cursor_offset; i >= 0 && !log_attrs[i].is_mandatory_break; i--);
-	view->cursor_offset = MAX (0, i);
+  for (i = view->cursor_offset; i >= 0 && !log_attrs[i].is_mandatory_break; i--);
+  view->cursor_offset = MAX (0, i);
 
-	return TRUE;
+  return TRUE;
 }
 
 static gboolean
-cursor_backward_line (EvView *view)
-{
-	PangoLogAttr *log_attrs = NULL;
-	gulong        n_attrs;
+cursor_backward_line (EvView *view) {
+  PangoLogAttr *log_attrs = NULL;
+  gulong        n_attrs;
 
-	if (!cursor_go_to_line_start (view))
-		return FALSE;
+  if (!cursor_go_to_line_start (view))
+    return FALSE;
 
-	if (view->cursor_offset == 0)
-		return cursor_go_to_previous_page (view);
+  if (view->cursor_offset == 0)
+    return cursor_go_to_previous_page (view);
 
-	ev_page_cache_get_text_log_attrs (view->page_cache, view->cursor_page, &log_attrs, &n_attrs);
+  ev_page_cache_get_text_log_attrs (view->page_cache, view->cursor_page, &log_attrs, &n_attrs);
 
-	do {
-		view->cursor_offset--;
-	} while (view->cursor_offset >= 0 && !log_attrs[view->cursor_offset].is_mandatory_break);
-	view->cursor_offset = MAX (0, view->cursor_offset);
+  do {
+    view->cursor_offset--;
+  } while (view->cursor_offset >= 0 && !log_attrs[view->cursor_offset].is_mandatory_break);
+  view->cursor_offset = MAX (0, view->cursor_offset);
 
-	return TRUE;
+  return TRUE;
 }
 
 static gboolean
-cursor_go_to_line_end (EvView *view)
-{
-	PangoLogAttr *log_attrs = NULL;
-	gulong        n_attrs;
-	gint          i;
+cursor_go_to_line_end (EvView *view) {
+  PangoLogAttr *log_attrs = NULL;
+  gulong        n_attrs;
+  gint          i;
 
-	if (!view->page_cache)
-		return FALSE;
+  if (!view->page_cache)
+    return FALSE;
 
-	ev_page_cache_get_text_log_attrs (view->page_cache, view->cursor_page, &log_attrs, &n_attrs);
-	if (!log_attrs)
-		return FALSE;
+  ev_page_cache_get_text_log_attrs (view->page_cache, view->cursor_page, &log_attrs, &n_attrs);
+  if (!log_attrs)
+    return FALSE;
 
-	for (i = view->cursor_offset + 1; i <= n_attrs && !log_attrs[i].is_mandatory_break; i++);
-	view->cursor_offset = MIN (i, n_attrs);
+  for (i = view->cursor_offset + 1; i <= n_attrs && !log_attrs[i].is_mandatory_break; i++);
+  view->cursor_offset = MIN (i, n_attrs);
 
-	if (view->cursor_offset == n_attrs)
-		return TRUE;
+  if (view->cursor_offset == n_attrs)
+    return TRUE;
 
-	do {
-		view->cursor_offset--;
-	} while (view->cursor_offset >= 0 && !log_attrs[view->cursor_offset].is_cursor_position);
+  do {
+    view->cursor_offset--;
+  } while (view->cursor_offset >= 0 && !log_attrs[view->cursor_offset].is_cursor_position);
 
-	return TRUE;
+  return TRUE;
 }
 
 static gboolean
-cursor_forward_line (EvView *view)
-{
-	PangoLogAttr *log_attrs = NULL;
-	gulong        n_attrs;
+cursor_forward_line (EvView *view) {
+  PangoLogAttr *log_attrs = NULL;
+  gulong        n_attrs;
 
-	if (!cursor_go_to_line_end (view))
-		return FALSE;
+  if (!cursor_go_to_line_end (view))
+    return FALSE;
 
-	ev_page_cache_get_text_log_attrs (view->page_cache, view->cursor_page, &log_attrs, &n_attrs);
+  ev_page_cache_get_text_log_attrs (view->page_cache, view->cursor_page, &log_attrs, &n_attrs);
 
-	if (view->cursor_offset == n_attrs)
-		return cursor_go_to_next_page (view);
+  if (view->cursor_offset == n_attrs)
+    return cursor_go_to_next_page (view);
 
-	do {
-		view->cursor_offset++;
-	} while (view->cursor_offset <= n_attrs && !log_attrs[view->cursor_offset].is_cursor_position);
+  do {
+    view->cursor_offset++;
+  } while (view->cursor_offset <= n_attrs && !log_attrs[view->cursor_offset].is_cursor_position);
 
-	return TRUE;
+  return TRUE;
 }
 
 static void
 extend_selection (EvView *view,
-		  GdkPoint *start_point,
-		  GdkPoint *end_point)
-{
-	if (!view->selection_info.selections) {
-		view->selection_info.start.x = start_point->x;
-		view->selection_info.start.y = start_point->y;
-	}
+                  GdkPoint *start_point,
+                  GdkPoint *end_point) {
+  if (!view->selection_info.selections) {
+    view->selection_info.start.x = start_point->x;
+    view->selection_info.start.y = start_point->y;
+  }
 
-	compute_selections (view,
-			    EV_SELECTION_STYLE_GLYPH,
-			    &(view->selection_info.start),
-			    end_point);
+  compute_selections (view,
+                      EV_SELECTION_STYLE_GLYPH,
+                      &(view->selection_info.start),
+                      end_point);
 }
 
 static gboolean
 cursor_clear_selection (EvView  *view,
-			gboolean forward)
-{
-	GList                *l;
-	EvViewSelection      *selection;
-	cairo_rectangle_int_t rect;
-	gint                  doc_x, doc_y;
+                        gboolean forward) {
+  GList                *l;
+  EvViewSelection      *selection;
+  cairo_rectangle_int_t rect;
+  gint                  doc_x, doc_y;
 
-	/* When clearing the selection, move the cursor to
-	 * the limits of the selection region.
-	 */
-	if (!view->selection_info.selections)
-		return FALSE;
+  /* When clearing the selection, move the cursor to
+   * the limits of the selection region.
+   */
+  if (!view->selection_info.selections)
+    return FALSE;
 
-	l = forward ? g_list_last (view->selection_info.selections) : view->selection_info.selections;
-	selection = (EvViewSelection *)l->data;
-	if (!selection->covered_region || cairo_region_is_empty (selection->covered_region))
-		return FALSE;
+  l = forward ? g_list_last (view->selection_info.selections) : view->selection_info.selections;
+  selection = (EvViewSelection *)l->data;
+  if (!selection->covered_region || cairo_region_is_empty (selection->covered_region))
+    return FALSE;
 
-	cairo_region_get_rectangle (selection->covered_region,
-				    forward ? cairo_region_num_rectangles (selection->covered_region) - 1 : 0,
-				    &rect);
+  cairo_region_get_rectangle (selection->covered_region,
+                              forward ? cairo_region_num_rectangles (selection->covered_region) - 1 : 0,
+                              &rect);
 
-	if (!get_doc_point_from_offset (view, selection->page,
-					forward ? rect.x + rect.width : rect.x,
-					rect.y + (rect.height / 2), &doc_x, &doc_y))
-		return FALSE;
+  if (!get_doc_point_from_offset (view, selection->page,
+                                  forward ? rect.x + rect.width : rect.x,
+                                  rect.y + (rect.height / 2), &doc_x, &doc_y))
+    return FALSE;
 
-	position_caret_cursor_at_doc_point (view, selection->page, doc_x, doc_y);
-	return TRUE;
+  position_caret_cursor_at_doc_point (view, selection->page, doc_x, doc_y);
+  return TRUE;
 }
 
 static gboolean
 ev_view_move_cursor (EvView         *view,
-		     GtkMovementStep step,
-		     gint            count,
-		     gboolean        extend_selections)
-{
-	GdkRectangle    rect;
-	GdkRectangle    prev_rect;
-	gint            prev_offset;
-	gint            prev_page;
-	cairo_region_t *damage_region;
-	gboolean        changed_page;
-	gboolean        clear_selections = FALSE;
-	const gboolean  forward = count >= 0;
-
-	if (!view->caret_enabled || view->rotation != 0)
-		return FALSE;
-
-	view->key_binding_handled = TRUE;
-	view->cursor_blink_time = 0;
-
-	prev_offset = view->cursor_offset;
-	prev_page = view->cursor_page;
-
-	clear_selections = !extend_selections && view->selection_info.selections != NULL;
-
-	switch (step) {
-	case GTK_MOVEMENT_VISUAL_POSITIONS:
-		if (!clear_selections || !cursor_clear_selection (view, count > 0)) {
-			while (count > 0) {
-				cursor_forward_char (view);
-				count--;
-			}
-			while (count < 0) {
-				cursor_backward_char (view);
-				count++;
-			}
-		}
-		break;
-	case GTK_MOVEMENT_WORDS:
-		while (count > 0) {
-			cursor_forward_word_end (view);
-			count--;
-		}
-		while (count < 0) {
-			cursor_backward_word_start (view);
-			count++;
-		}
-		break;
-	case GTK_MOVEMENT_DISPLAY_LINES:
-		while (count > 0) {
-			cursor_forward_line (view);
-			count--;
-		}
-		while (count < 0) {
-			cursor_backward_line (view);
-			count++;
-		}
-		break;
-	case GTK_MOVEMENT_DISPLAY_LINE_ENDS:
-		if (count > 0)
-			cursor_go_to_line_end (view);
-		else if (count < 0)
-			cursor_go_to_line_start (view);
-		break;
-	case GTK_MOVEMENT_BUFFER_ENDS:
-		if (count > 0)
-			cursor_go_to_document_end (view);
-		else if (count < 0)
-			cursor_go_to_document_start (view);
-		break;
-	default:
-		g_assert_not_reached ();
-	}
-
-	ev_view_pend_cursor_blink (view);
-
-	/* Notify the user that it was not possible to move the caret cursor */
-	if (!clear_selections &&
-	    prev_offset == view->cursor_offset && prev_page == view->cursor_page) {
-		gtk_widget_error_bell (GTK_WIDGET (view));
-		return TRUE;
-	}
-
-	/* Scroll to make the caret visible */
-	if (!get_caret_cursor_area (view, view->cursor_page, view->cursor_offset, &rect))
-		return TRUE;
-
-	if (!view->continuous) {
-		changed_page = FALSE;
-		if (prev_page < view->cursor_page) {
-			ev_view_next_page (view);
-			cursor_go_to_page_start (view);
-			changed_page = TRUE;
-		} else if (prev_page > view->cursor_page) {
-			ev_view_previous_page (view);
-			cursor_go_to_page_end (view);
-			_ev_view_ensure_rectangle_is_visible (view, &rect);
-			changed_page = TRUE;
-		}
-
-		if (changed_page) {
-                       rect.x += view->scroll_x;
-                       rect.y += view->scroll_y;
-                       _ev_view_ensure_rectangle_is_visible (view, &rect);
-			g_signal_emit (view, signals[SIGNAL_CURSOR_MOVED], 0, view->cursor_page, view->cursor_offset);
-			clear_selection (view);
-			return TRUE;
-		}
-	}
-
-	if (step == GTK_MOVEMENT_DISPLAY_LINES) {
-		const gint prev_cursor_offset = view->cursor_offset;
-
-		position_caret_cursor_at_location (view,
-						   MAX (rect.x, view->cursor_line_offset),
-						   rect.y + (rect.height / 2));
-		/* Make sure we didn't move the cursor in the wrong direction
-		 * in case the visual order isn't the same as the logical one,
-		 * in order to avoid cursor movement loops */
-		if ((forward && prev_cursor_offset > view->cursor_offset) ||
-		    (!forward && prev_cursor_offset < view->cursor_offset)) {
-			view->cursor_offset = prev_cursor_offset;
-		}
-		if (!clear_selections &&
-		    prev_offset == view->cursor_offset && prev_page == view->cursor_page) {
-			gtk_widget_error_bell (GTK_WIDGET (view));
-			return TRUE;
-		}
-
-		if (!get_caret_cursor_area (view, view->cursor_page, view->cursor_offset, &rect))
-			return TRUE;
-	} else {
-		view->cursor_line_offset = rect.x;
-	}
-
-	damage_region = cairo_region_create_rectangle (&rect);
-	if (get_caret_cursor_area (view, prev_page, prev_offset, &prev_rect))
-		cairo_region_union_rectangle (damage_region, &prev_rect);
-
-	rect.x += view->scroll_x;
-	rect.y += view->scroll_y;
-
-	ev_document_model_set_page (view->model, view->cursor_page);
-	_ev_view_ensure_rectangle_is_visible (view, &rect);
-
-	g_signal_emit (view, signals[SIGNAL_CURSOR_MOVED], 0, view->cursor_page, view->cursor_offset);
-
-	gdk_window_invalidate_region (gtk_widget_get_window (GTK_WIDGET (view)),
-				      damage_region, TRUE);
-	cairo_region_destroy (damage_region);
-
-	/* Select text */
-	if (extend_selections && EV_IS_SELECTION (view->document)) {
-		GdkPoint start_point, end_point;
-
-		start_point.x = prev_rect.x + view->scroll_x;
-		start_point.y = prev_rect.y + (prev_rect.height / 2) + view->scroll_y;
-
-		end_point.x = rect.x;
-		end_point.y = rect.y + rect.height / 2;
-
-		extend_selection (view, &start_point, &end_point);
-	} else if (clear_selections)
-		clear_selection (view);
-
-	return TRUE;
+                     GtkMovementStep step,
+                     gint            count,
+                     gboolean        extend_selections) {
+  GdkRectangle    rect;
+  GdkRectangle    prev_rect;
+  gint            prev_offset;
+  gint            prev_page;
+  cairo_region_t *damage_region;
+  gboolean        changed_page;
+  gboolean        clear_selections = FALSE;
+  const gboolean  forward = count >= 0;
+
+  if (!view->caret_enabled || view->rotation != 0)
+    return FALSE;
+
+  view->key_binding_handled = TRUE;
+  view->cursor_blink_time = 0;
+
+  prev_offset = view->cursor_offset;
+  prev_page = view->cursor_page;
+
+  clear_selections = !extend_selections && view->selection_info.selections != NULL;
+
+  switch (step) {
+    case GTK_MOVEMENT_VISUAL_POSITIONS:
+      if (!clear_selections || !cursor_clear_selection (view, count > 0)) {
+        while (count > 0) {
+          cursor_forward_char (view);
+          count--;
+        }
+        while (count < 0) {
+          cursor_backward_char (view);
+          count++;
+        }
+      }
+      break;
+    case GTK_MOVEMENT_WORDS:
+      while (count > 0) {
+        cursor_forward_word_end (view);
+        count--;
+      }
+      while (count < 0) {
+        cursor_backward_word_start (view);
+        count++;
+      }
+      break;
+    case GTK_MOVEMENT_DISPLAY_LINES:
+      while (count > 0) {
+        cursor_forward_line (view);
+        count--;
+      }
+      while (count < 0) {
+        cursor_backward_line (view);
+        count++;
+      }
+      break;
+    case GTK_MOVEMENT_DISPLAY_LINE_ENDS:
+      if (count > 0)
+        cursor_go_to_line_end (view);
+      else if (count < 0)
+        cursor_go_to_line_start (view);
+      break;
+    case GTK_MOVEMENT_BUFFER_ENDS:
+      if (count > 0)
+        cursor_go_to_document_end (view);
+      else if (count < 0)
+        cursor_go_to_document_start (view);
+      break;
+    default:
+      g_assert_not_reached ();
+  }
+
+  ev_view_pend_cursor_blink (view);
+
+  /* Notify the user that it was not possible to move the caret cursor */
+  if (!clear_selections &&
+      prev_offset == view->cursor_offset && prev_page == view->cursor_page) {
+    gtk_widget_error_bell (GTK_WIDGET (view));
+    return TRUE;
+  }
+
+  /* Scroll to make the caret visible */
+  if (!get_caret_cursor_area (view, view->cursor_page, view->cursor_offset, &rect))
+    return TRUE;
+
+  if (!view->continuous) {
+    changed_page = FALSE;
+    if (prev_page < view->cursor_page) {
+      ev_view_next_page (view);
+      cursor_go_to_page_start (view);
+      changed_page = TRUE;
+    } else if (prev_page > view->cursor_page) {
+      ev_view_previous_page (view);
+      cursor_go_to_page_end (view);
+      _ev_view_ensure_rectangle_is_visible (view, &rect);
+      changed_page = TRUE;
+    }
+
+    if (changed_page) {
+      rect.x += view->scroll_x;
+      rect.y += view->scroll_y;
+      _ev_view_ensure_rectangle_is_visible (view, &rect);
+      g_signal_emit (view, signals[SIGNAL_CURSOR_MOVED], 0, view->cursor_page, view->cursor_offset);
+      clear_selection (view);
+      return TRUE;
+    }
+  }
+
+  if (step == GTK_MOVEMENT_DISPLAY_LINES) {
+    const gint prev_cursor_offset = view->cursor_offset;
+
+    position_caret_cursor_at_location (view,
+                                       MAX (rect.x, view->cursor_line_offset),
+                                       rect.y + (rect.height / 2));
+    /* Make sure we didn't move the cursor in the wrong direction
+     * in case the visual order isn't the same as the logical one,
+     * in order to avoid cursor movement loops */
+    if ((forward && prev_cursor_offset > view->cursor_offset) ||
+        (!forward && prev_cursor_offset < view->cursor_offset)) {
+      view->cursor_offset = prev_cursor_offset;
+    }
+    if (!clear_selections &&
+        prev_offset == view->cursor_offset && prev_page == view->cursor_page) {
+      gtk_widget_error_bell (GTK_WIDGET (view));
+      return TRUE;
+    }
+
+    if (!get_caret_cursor_area (view, view->cursor_page, view->cursor_offset, &rect))
+      return TRUE;
+  } else {
+    view->cursor_line_offset = rect.x;
+  }
+
+  damage_region = cairo_region_create_rectangle (&rect);
+  if (get_caret_cursor_area (view, prev_page, prev_offset, &prev_rect))
+    cairo_region_union_rectangle (damage_region, &prev_rect);
+
+  rect.x += view->scroll_x;
+  rect.y += view->scroll_y;
+
+  ev_document_model_set_page (view->model, view->cursor_page);
+  _ev_view_ensure_rectangle_is_visible (view, &rect);
+
+  g_signal_emit (view, signals[SIGNAL_CURSOR_MOVED], 0, view->cursor_page, view->cursor_offset);
+
+  gdk_window_invalidate_region (gtk_widget_get_window (GTK_WIDGET (view)),
+                                damage_region, TRUE);
+  cairo_region_destroy (damage_region);
+
+  /* Select text */
+  if (extend_selections && EV_IS_SELECTION (view->document)) {
+    GdkPoint start_point, end_point;
+
+    start_point.x = prev_rect.x + view->scroll_x;
+    start_point.y = prev_rect.y + (prev_rect.height / 2) + view->scroll_y;
+
+    end_point.x = rect.x;
+    end_point.y = rect.y + rect.height / 2;
+
+    extend_selection (view, &start_point, &end_point);
+  } else if (clear_selections)
+    clear_selection (view);
+
+  return TRUE;
 }
 
 static gboolean
 ev_view_key_press_event (GtkWidget   *widget,
-			 GdkEventKey *event)
-{
-	EvView  *view = EV_VIEW (widget);
-	gboolean retval;
+                         GdkEventKey *event) {
+  EvView  *view = EV_VIEW (widget);
+  gboolean retval;
 
-	if (!view->document)
-		return FALSE;
+  if (!view->document)
+    return FALSE;
 
-	if (!gtk_widget_has_focus (widget))
-		return ev_view_forward_key_event_to_focused_child (view, event);
+  if (!gtk_widget_has_focus (widget))
+    return ev_view_forward_key_event_to_focused_child (view, event);
 
-	/* I expected GTK+ do this for me, but it doesn't cancel
-	 * the propagation of bindings handled for the same binding set
-	 */
-	view->key_binding_handled = FALSE;
-	retval = gtk_bindings_activate_event (G_OBJECT (widget), event);
-	view->key_binding_handled = FALSE;
+  /* I expected GTK+ do this for me, but it doesn't cancel
+   * the propagation of bindings handled for the same binding set
+   */
+  view->key_binding_handled = FALSE;
+  retval = gtk_bindings_activate_event (G_OBJECT (widget), event);
+  view->key_binding_handled = FALSE;
 
-	return retval;
+  return retval;
 }
 
 static gboolean
 ev_view_activate_form_field (EvView      *view,
-			     EvFormField *field)
-{
-	gboolean handled = FALSE;
+                             EvFormField *field) {
+  gboolean handled = FALSE;
 
-	if (field->is_read_only)
-		return handled;
+  if (field->is_read_only)
+    return handled;
 
-	if (field->activation_link) {
-		ev_view_handle_link (view, field->activation_link);
-		handled = TRUE;
-	}
+  if (field->activation_link) {
+    ev_view_handle_link (view, field->activation_link);
+    handled = TRUE;
+  }
 
-	if (EV_IS_FORM_FIELD_BUTTON (field)) {
-		ev_view_form_field_button_toggle (view, field);
-		handled = TRUE;
-	}
+  if (EV_IS_FORM_FIELD_BUTTON (field)) {
+    ev_view_form_field_button_toggle (view, field);
+    handled = TRUE;
+  }
 
-	return handled;
+  return handled;
 }
 
 static gboolean
-current_event_is_space_key_press (void)
-{
-	GdkEvent *current_event;
-	guint     keyval;
-	gboolean  is_space_key_press;
+current_event_is_space_key_press (void) {
+  GdkEvent *current_event;
+  guint     keyval;
+  gboolean  is_space_key_press;
 
-	current_event = gtk_get_current_event ();
-	if (!current_event)
-		return FALSE;
+  current_event = gtk_get_current_event ();
+  if (!current_event)
+    return FALSE;
 
-	is_space_key_press = current_event->type == GDK_KEY_PRESS &&
-		gdk_event_get_keyval (current_event, &keyval) &&
-		(keyval == GDK_KEY_space || keyval == GDK_KEY_KP_Space);
-	gdk_event_free (current_event);
+  is_space_key_press = current_event->type == GDK_KEY_PRESS &&
+                       gdk_event_get_keyval (current_event, &keyval) &&
+                       (keyval == GDK_KEY_space || keyval == GDK_KEY_KP_Space);
+  gdk_event_free (current_event);
 
-	return is_space_key_press;
+  return is_space_key_press;
 }
 
 static gboolean
 ev_view_activate_link (EvView *view,
-		       EvLink *link)
-{
-	/* Most of the GtkWidgets emit activate on both Space and Return key press,
-	 * but we don't want to activate links on Space for consistency with the Web.
-	 */
-	if (current_event_is_space_key_press ())
-		return FALSE;
+                       EvLink *link) {
+  /* Most of the GtkWidgets emit activate on both Space and Return key press,
+   * but we don't want to activate links on Space for consistency with the Web.
+   */
+  if (current_event_is_space_key_press ())
+    return FALSE;
 
-	ev_view_handle_link (view, link);
+  ev_view_handle_link (view, link);
 
-	return TRUE;
+  return TRUE;
 }
 
 static void
-ev_view_activate (EvView *view)
-{
-	if (!view->focused_element)
-		return;
+ev_view_activate (EvView *view) {
+  if (!view->focused_element)
+    return;
 
-	if (EV_IS_DOCUMENT_FORMS (view->document) &&
-	    EV_IS_FORM_FIELD (view->focused_element->data)) {
-		view->key_binding_handled = ev_view_activate_form_field (view, EV_FORM_FIELD (view->focused_element->data));
-		return;
-	}
+  if (EV_IS_DOCUMENT_FORMS (view->document) &&
+      EV_IS_FORM_FIELD (view->focused_element->data)) {
+    view->key_binding_handled = ev_view_activate_form_field (view, EV_FORM_FIELD (view->focused_element->data));
+    return;
+  }
 
-	if (EV_IS_DOCUMENT_LINKS (view->document) &&
-	    EV_IS_LINK (view->focused_element->data)) {
-		view->key_binding_handled = ev_view_activate_link (view, EV_LINK (view->focused_element->data));
-		return;
-	}
+  if (EV_IS_DOCUMENT_LINKS (view->document) &&
+      EV_IS_LINK (view->focused_element->data)) {
+    view->key_binding_handled = ev_view_activate_link (view, EV_LINK (view->focused_element->data));
+    return;
+  }
 }
 
 static gboolean
-ev_view_autoscroll_cb (EvView *view)
-{
-	gdouble speed, value;
+ev_view_autoscroll_cb (EvView *view) {
+  gdouble speed, value;
 
-	/* If the user stops autoscrolling, autoscrolling will be
-	 * set to false but the timeout will continue; stop the timeout: */
-	if (!view->scroll_info.autoscrolling) {
-		view->scroll_info.timeout_id = 0;
-		return FALSE;
-	}
+  /* If the user stops autoscrolling, autoscrolling will be
+   * set to false but the timeout will continue; stop the timeout: */
+  if (!view->scroll_info.autoscrolling) {
+    view->scroll_info.timeout_id = 0;
+    return FALSE;
+  }
 
-	/* Replace 100 with your speed of choice: The lower the faster.
-	 * Replace 3 with another speed of choice: The higher, the faster it accelerated
-	 * 	based on the distance of the starting point from the mouse
-	 * (All also effected by the timeout interval of this callback) */
+  /* Replace 100 with your speed of choice: The lower the faster.
+   * Replace 3 with another speed of choice: The higher, the faster it accelerated
+   * 	based on the distance of the starting point from the mouse
+   * (All also effected by the timeout interval of this callback) */
 
-	if (view->scroll_info.start_y > view->scroll_info.last_y)
-		speed = -pow ((((gdouble)view->scroll_info.start_y - view->scroll_info.last_y) / 100), 3);
-	else
-		speed = pow ((((gdouble)view->scroll_info.last_y - view->scroll_info.start_y) / 100), 3);
+  if (view->scroll_info.start_y > view->scroll_info.last_y)
+    speed = -pow ((((gdouble)view->scroll_info.start_y - view->scroll_info.last_y) / 100), 3);
+  else
+    speed = pow ((((gdouble)view->scroll_info.last_y - view->scroll_info.start_y) / 100), 3);
 
-	value = gtk_adjustment_get_value (view->vadjustment);
-	value = CLAMP (value + speed, 0,
-		       gtk_adjustment_get_upper (view->vadjustment) -
-		       gtk_adjustment_get_page_size (view->vadjustment));
-	gtk_adjustment_set_value (view->vadjustment, value);
+  value = gtk_adjustment_get_value (view->vadjustment);
+  value = CLAMP (value + speed, 0,
+                 gtk_adjustment_get_upper (view->vadjustment) -
+                 gtk_adjustment_get_page_size (view->vadjustment));
+  gtk_adjustment_set_value (view->vadjustment, value);
 
-	return TRUE;
+  return TRUE;
 
 }
 
 static void
-ev_view_autoscroll_resume (EvView *view)
-{
-	if (!view->scroll_info.autoscrolling)
-		return;
+ev_view_autoscroll_resume (EvView *view) {
+  if (!view->scroll_info.autoscrolling)
+    return;
 
-	if (view->scroll_info.timeout_id > 0)
-		return;
+  if (view->scroll_info.timeout_id > 0)
+    return;
 
-	view->scroll_info.timeout_id =
-		g_timeout_add (20, (GSourceFunc)ev_view_autoscroll_cb,
-			       view);
+  view->scroll_info.timeout_id =
+    g_timeout_add (20, (GSourceFunc)ev_view_autoscroll_cb,
+                   view);
 }
 
 static void
-ev_view_autoscroll_pause (EvView *view)
-{
-	if (!view->scroll_info.autoscrolling)
-		return;
+ev_view_autoscroll_pause (EvView *view) {
+  if (!view->scroll_info.autoscrolling)
+    return;
 
-	if (view->scroll_info.timeout_id == 0)
-		return;
+  if (view->scroll_info.timeout_id == 0)
+    return;
 
-	g_source_remove (view->scroll_info.timeout_id);
-	view->scroll_info.timeout_id = 0;
+  g_source_remove (view->scroll_info.timeout_id);
+  view->scroll_info.timeout_id = 0;
 }
 
 static gint
 ev_view_focus_in (GtkWidget     *widget,
-		  GdkEventFocus *event)
-{
-	EvView *view = EV_VIEW (widget);
+                  GdkEventFocus *event) {
+  EvView *view = EV_VIEW (widget);
 
-	if (view->pixbuf_cache)
-		ev_pixbuf_cache_style_changed (view->pixbuf_cache);
+  if (view->pixbuf_cache)
+    ev_pixbuf_cache_style_changed (view->pixbuf_cache);
 
-	ev_view_autoscroll_resume (view);
+  ev_view_autoscroll_resume (view);
 
-	ev_view_check_cursor_blink (view);
-	gtk_widget_queue_draw (widget);
+  ev_view_check_cursor_blink (view);
+  gtk_widget_queue_draw (widget);
 
-	return FALSE;
+  return FALSE;
 }
 
 static gint
 ev_view_focus_out (GtkWidget     *widget,
-		   GdkEventFocus *event)
-{
-	EvView *view = EV_VIEW (widget);
+                   GdkEventFocus *event) {
+  EvView *view = EV_VIEW (widget);
 
-	if (view->pixbuf_cache)
-		ev_pixbuf_cache_style_changed (view->pixbuf_cache);
+  if (view->pixbuf_cache)
+    ev_pixbuf_cache_style_changed (view->pixbuf_cache);
 
-	ev_view_autoscroll_pause (view);
+  ev_view_autoscroll_pause (view);
 
-	ev_view_check_cursor_blink (view);
-	gtk_widget_queue_draw (widget);
+  ev_view_check_cursor_blink (view);
+  gtk_widget_queue_draw (widget);
 
-	return FALSE;
+  return FALSE;
 }
 
 static gboolean
-ev_view_leave_notify_event (GtkWidget *widget, GdkEventCrossing   *event)
-{
-	EvView *view = EV_VIEW (widget);
+ev_view_leave_notify_event (GtkWidget *widget, GdkEventCrossing   *event) {
+  EvView *view = EV_VIEW (widget);
 
-	if (view->cursor != EV_VIEW_CURSOR_NORMAL)
-		ev_view_set_cursor (view, EV_VIEW_CURSOR_NORMAL);
+  if (view->cursor != EV_VIEW_CURSOR_NORMAL)
+    ev_view_set_cursor (view, EV_VIEW_CURSOR_NORMAL);
 
-	return FALSE;
+  return FALSE;
 }
 
 static gboolean
-ev_view_enter_notify_event (GtkWidget *widget, GdkEventCrossing   *event)
-{
-	EvView *view = EV_VIEW (widget);
+ev_view_enter_notify_event (GtkWidget *widget, GdkEventCrossing   *event) {
+  EvView *view = EV_VIEW (widget);
+
+  ev_view_handle_cursor_over_xy (view, event->x, event->y);
 
-	ev_view_handle_cursor_over_xy (view, event->x, event->y);
-    
-	return FALSE;
+  return FALSE;
 }
 
 static void
-ev_view_style_updated (GtkWidget *widget)
-{
-	if (EV_VIEW (widget)->pixbuf_cache)
-		ev_pixbuf_cache_style_changed (EV_VIEW (widget)->pixbuf_cache);
+ev_view_style_updated (GtkWidget *widget) {
+  if (EV_VIEW (widget)->pixbuf_cache)
+    ev_pixbuf_cache_style_changed (EV_VIEW (widget)->pixbuf_cache);
 
-	GTK_WIDGET_CLASS (ev_view_parent_class)->style_updated (widget);
+  GTK_WIDGET_CLASS (ev_view_parent_class)->style_updated (widget);
 }
 
 /*** Drawing ***/
 
 static void
 draw_rubberband (EvView             *view,
-		 cairo_t            *cr,
-		 const GdkRectangle *rect,
-		 gdouble             alpha)
-{
-	GtkStyleContext *context;
-	GdkRGBA          color;
+                 cairo_t            *cr,
+                 const GdkRectangle *rect,
+                 gdouble             alpha) {
+  GtkStyleContext *context;
+  GdkRGBA          color;
 
-	context = gtk_widget_get_style_context (GTK_WIDGET (view));
-	gtk_style_context_save (context);
-	gtk_style_context_get_background_color (context, GTK_STATE_FLAG_SELECTED, &color);
-	gtk_style_context_restore (context);
-        cairo_save (cr);
+  context = gtk_widget_get_style_context (GTK_WIDGET (view));
+  gtk_style_context_save (context);
+  gtk_style_context_get_background_color (context, GTK_STATE_FLAG_SELECTED, &color);
+  gtk_style_context_restore (context);
+  cairo_save (cr);
 
-	cairo_set_source_rgba (cr, color.red, color.green, color.blue, alpha);
-	cairo_rectangle (cr,
-			 rect->x - view->scroll_x,
-			 rect->y - view->scroll_y,
-			 rect->width, rect->height);
-	cairo_fill_preserve (cr);
+  cairo_set_source_rgba (cr, color.red, color.green, color.blue, alpha);
+  cairo_rectangle (cr,
+                   rect->x - view->scroll_x,
+                   rect->y - view->scroll_y,
+                   rect->width, rect->height);
+  cairo_fill_preserve (cr);
 
-	cairo_set_line_width (cr, 0.5);
-	cairo_set_source_rgb (cr, color.red, color.green, color.blue);
-	cairo_stroke (cr);
+  cairo_set_line_width (cr, 0.5);
+  cairo_set_source_rgb (cr, color.red, color.green, color.blue);
+  cairo_stroke (cr);
 
-	cairo_restore (cr);
+  cairo_restore (cr);
 }
 
 
 static void
 highlight_find_results (EvView *view,
                         cairo_t *cr,
-                        int page)
-{
-	gint i, n_results = 0;
-
-	n_results = ev_view_find_get_n_results (view, page);
-
-	for (i = 0; i < n_results; i++) {
-		EvRectangle *rectangle;
-		GdkRectangle view_rectangle;
-		gdouble      alpha;
-
-		if (i == view->find_result && page == view->find_page) {
-			alpha = 0.6;
-		} else {
-			alpha = 0.3;
-		}
-
-		rectangle = ev_view_find_get_result (view, page, i);
-		_ev_view_transform_doc_rect_to_view_rect (view, page, rectangle, &view_rectangle);
-		draw_rubberband (view, cr, &view_rectangle, alpha);
-        }
+                        int page) {
+  gint i, n_results = 0;
+
+  n_results = ev_view_find_get_n_results (view, page);
+
+  for (i = 0; i < n_results; i++) {
+    EvRectangle *rectangle;
+    GdkRectangle view_rectangle;
+    gdouble      alpha;
+
+    if (i == view->find_result && page == view->find_page) {
+      alpha = 0.6;
+    } else {
+      alpha = 0.3;
+    }
+
+    rectangle = ev_view_find_get_result (view, page, i);
+    _ev_view_transform_doc_rect_to_view_rect (view, page, rectangle, &view_rectangle);
+    draw_rubberband (view, cr, &view_rectangle, alpha);
+  }
 }
 
 static void
 highlight_forward_search_results (EvView *view,
                                   cairo_t *cr,
-                                  int page)
-{
-	GdkRectangle rect;
-	EvMapping   *mapping = view->synctex_result;
+                                  int page) {
+  GdkRectangle rect;
+  EvMapping   *mapping = view->synctex_result;
 
-	if (GPOINTER_TO_INT (mapping->data) != page)
-		return;
+  if (GPOINTER_TO_INT (mapping->data) != page)
+    return;
 
-	_ev_view_transform_doc_rect_to_view_rect (view, page, &mapping->area, &rect);
+  _ev_view_transform_doc_rect_to_view_rect (view, page, &mapping->area, &rect);
 
-        cairo_save (cr);
-	cairo_set_source_rgb (cr, 1., 0., 0.);
-	cairo_rectangle (cr,
-			 rect.x - view->scroll_x,
-			 rect.y - view->scroll_y,
-			 rect.width, rect.height);
-	cairo_stroke (cr);
-	cairo_restore (cr);
+  cairo_save (cr);
+  cairo_set_source_rgb (cr, 1., 0., 0.);
+  cairo_rectangle (cr,
+                   rect.x - view->scroll_x,
+                   rect.y - view->scroll_y,
+                   rect.width, rect.height);
+  cairo_stroke (cr);
+  cairo_restore (cr);
 }
 
 static void
 draw_surface (cairo_t 	      *cr,
-	      cairo_surface_t *surface,
-	      gint             x,
-	      gint             y,
-	      gint             offset_x,
-	      gint             offset_y,
-	      gint             target_width,
-	      gint             target_height)
-{
-	gdouble width, height;
-	gdouble device_scale_x = 1, device_scale_y = 1;
+              cairo_surface_t *surface,
+              gint             x,
+              gint             y,
+              gint             offset_x,
+              gint             offset_y,
+              gint             target_width,
+              gint             target_height) {
+  gdouble width, height;
+  gdouble device_scale_x = 1, device_scale_y = 1;
 
 #ifdef HAVE_HIDPI_SUPPORT
-	cairo_surface_get_device_scale (surface, &device_scale_x, &device_scale_y);
+  cairo_surface_get_device_scale (surface, &device_scale_x, &device_scale_y);
 #endif
-	width = cairo_image_surface_get_width (surface) / device_scale_x;
-	height = cairo_image_surface_get_height (surface) / device_scale_y;
+  width = cairo_image_surface_get_width (surface) / device_scale_x;
+  height = cairo_image_surface_get_height (surface) / device_scale_y;
 
-	cairo_save (cr);
-	cairo_translate (cr, x, y);
+  cairo_save (cr);
+  cairo_translate (cr, x, y);
 
-	if (width != target_width || height != target_height) {
-		gdouble scale_x, scale_y;
+  if (width != target_width || height != target_height) {
+    gdouble scale_x, scale_y;
 
-		scale_x = (gdouble)target_width / width;
-		scale_y = (gdouble)target_height / height;
-		cairo_pattern_set_filter (cairo_get_source (cr),
-					  CAIRO_FILTER_NEAREST);
-		cairo_scale (cr, scale_x, scale_y);
+    scale_x = (gdouble)target_width / width;
+    scale_y = (gdouble)target_height / height;
+    cairo_pattern_set_filter (cairo_get_source (cr),
+                              CAIRO_FILTER_NEAREST);
+    cairo_scale (cr, scale_x, scale_y);
 
-		offset_x /= scale_x;
-		offset_y /= scale_y;
-	}
+    offset_x /= scale_x;
+    offset_y /= scale_y;
+  }
 
-	cairo_surface_set_device_offset (surface,
-					 offset_x * device_scale_x,
-					 offset_y * device_scale_y);
-	cairo_set_source_surface (cr, surface, 0, 0);
-	cairo_paint (cr);
-	cairo_restore (cr);
+  cairo_surface_set_device_offset (surface,
+                                   offset_x * device_scale_x,
+                                   offset_y * device_scale_y);
+  cairo_set_source_surface (cr, surface, 0, 0);
+  cairo_paint (cr);
+  cairo_restore (cr);
 }
 
 void
 _ev_view_get_selection_colors (EvView  *view,
-			       GdkRGBA *bg_color,
-			       GdkRGBA *fg_color)
-{
-	GtkWidget       *widget = GTK_WIDGET (view);
-	GtkStateFlags    state;
-	GtkStyleContext *context;
+                               GdkRGBA *bg_color,
+                               GdkRGBA *fg_color) {
+  GtkWidget       *widget = GTK_WIDGET (view);
+  GtkStateFlags    state;
+  GtkStyleContext *context;
 
-	context = gtk_widget_get_style_context (widget);
-	gtk_style_context_save (context);
-	state = gtk_style_context_get_state (context) |
-		(gtk_widget_has_focus (widget) ? GTK_STATE_FLAG_SELECTED : GTK_STATE_FLAG_ACTIVE);
-	gtk_style_context_set_state (context, state);
+  context = gtk_widget_get_style_context (widget);
+  gtk_style_context_save (context);
+  state = gtk_style_context_get_state (context) |
+          (gtk_widget_has_focus (widget) ? GTK_STATE_FLAG_SELECTED : GTK_STATE_FLAG_ACTIVE);
+  gtk_style_context_set_state (context, state);
 
-	if (bg_color)
-		gtk_style_context_get_background_color (context, state, bg_color);
+  if (bg_color)
+    gtk_style_context_get_background_color (context, state, bg_color);
 
-	if (fg_color)
-		gtk_style_context_get_color (context, state, fg_color);
+  if (fg_color)
+    gtk_style_context_get_color (context, state, fg_color);
 
-	gtk_style_context_restore (context);
+  gtk_style_context_restore (context);
 }
 
 static void
 draw_selection_region (cairo_t        *cr,
-		       cairo_region_t *region,
-		       GdkRGBA        *color,
-		       gint            x,
-		       gint            y,
-		       gdouble         scale_x,
-		       gdouble         scale_y)
-{
-	cairo_save (cr);
-	cairo_translate (cr, x, y);
-	cairo_scale (cr, scale_x, scale_y);
-	gdk_cairo_region (cr, region);
-	cairo_set_source_rgb (cr, color->red, color->green, color->blue);
-	cairo_set_operator (cr, CAIRO_OPERATOR_MULTIPLY);
-	cairo_set_antialias (cr, CAIRO_ANTIALIAS_NONE);
-	cairo_fill (cr);
-	cairo_restore (cr);
+                       cairo_region_t *region,
+                       GdkRGBA        *color,
+                       gint            x,
+                       gint            y,
+                       gdouble         scale_x,
+                       gdouble         scale_y) {
+  cairo_save (cr);
+  cairo_translate (cr, x, y);
+  cairo_scale (cr, scale_x, scale_y);
+  gdk_cairo_region (cr, region);
+  cairo_set_source_rgb (cr, color->red, color->green, color->blue);
+  cairo_set_operator (cr, CAIRO_OPERATOR_MULTIPLY);
+  cairo_set_antialias (cr, CAIRO_ANTIALIAS_NONE);
+  cairo_fill (cr);
+  cairo_restore (cr);
 }
 
 static void
 draw_one_page (EvView       *view,
-	       gint          page,
-	       cairo_t      *cr,
-	       GdkRectangle *page_area,
-	       GtkBorder    *border,
-	       GdkRectangle *expose_area,
-	       gboolean     *page_ready)
-{
-	GtkStyleContext *context;
-	GdkRectangle     overlap;
-	GdkRectangle     real_page_area;
-	gint             current_page;
-
-	g_assert (view->document);
-
-	if (! gdk_rectangle_intersect (page_area, expose_area, &overlap))
-		return;
-
-	/* Render the document itself */
-	real_page_area = *page_area;
-
-	real_page_area.x += border->left;
-	real_page_area.y += border->top;
-	real_page_area.width -= (border->left + border->right);
-	real_page_area.height -= (border->top + border->bottom);
-	*page_ready = TRUE;
-
-	context = gtk_widget_get_style_context (GTK_WIDGET (view));
-	current_page = ev_document_model_get_page (view->model);
-
-	gtk_style_context_save (context);
-	gtk_style_context_add_class (context, EV_STYLE_CLASS_DOCUMENT_PAGE);
-	if (ev_document_model_get_inverted_colors (view->model))
-		gtk_style_context_add_class (context, EV_STYLE_CLASS_INVERTED);
-
-	if (view->continuous && page == current_page)
-		gtk_style_context_set_state (context, GTK_STATE_FLAG_ACTIVE);
-
-	gtk_render_background (context, cr, page_area->x, page_area->y, page_area->width, page_area->height);
-	gtk_render_frame (context, cr, page_area->x, page_area->y, page_area->width, page_area->height);
-	gtk_style_context_restore (context);
-
-	if (gdk_rectangle_intersect (&real_page_area, expose_area, &overlap)) {
-		gint             width, height;
-		cairo_surface_t *page_surface = NULL;
-		cairo_surface_t *selection_surface = NULL;
-		gint offset_x, offset_y;
-		cairo_region_t *region = NULL;
-
-		page_surface = ev_pixbuf_cache_get_surface (view->pixbuf_cache, page);
-
-		if (!page_surface) {
-			if (page == current_page)
-				ev_view_set_loading (view, TRUE);
-
-			*page_ready = FALSE;
-
-			return;
-		}
-
-		if (page == current_page)
-			ev_view_set_loading (view, FALSE);
-
-		ev_view_get_page_size (view, page, &width, &height);
-		offset_x = overlap.x - real_page_area.x;
-		offset_y = overlap.y - real_page_area.y;
-
-		draw_surface (cr, page_surface, overlap.x, overlap.y, offset_x, offset_y, width, height);
-
-		/* Get the selection pixbuf iff we have something to draw */
-		if (!find_selection_for_page (view, page))
-			return;
-
-		selection_surface = ev_pixbuf_cache_get_selection_surface (view->pixbuf_cache,
-									   page,
-									   view->scale);
-		if (selection_surface) {
-			draw_surface (cr, selection_surface, overlap.x, overlap.y, offset_x, offset_y,
-				      width, height);
-			return;
-		}
-
-		region = ev_pixbuf_cache_get_selection_region (view->pixbuf_cache,
-							       page,
-							       view->scale);
-		if (region) {
-			double scale_x, scale_y;
-			GdkRGBA color;
-			double device_scale_x = 1, device_scale_y = 1;
-
-			scale_x = (gdouble)width / cairo_image_surface_get_width (page_surface);
-			scale_y = (gdouble)height / cairo_image_surface_get_height (page_surface);
+               gint          page,
+               cairo_t      *cr,
+               GdkRectangle *page_area,
+               GtkBorder    *border,
+               GdkRectangle *expose_area,
+               gboolean     *page_ready) {
+  GtkStyleContext *context;
+  GdkRectangle     overlap;
+  GdkRectangle     real_page_area;
+  gint             current_page;
+
+  g_assert (view->document);
+
+  if (! gdk_rectangle_intersect (page_area, expose_area, &overlap))
+    return;
+
+  /* Render the document itself */
+  real_page_area = *page_area;
+
+  real_page_area.x += border->left;
+  real_page_area.y += border->top;
+  real_page_area.width -= (border->left + border->right);
+  real_page_area.height -= (border->top + border->bottom);
+  *page_ready = TRUE;
+
+  context = gtk_widget_get_style_context (GTK_WIDGET (view));
+  current_page = ev_document_model_get_page (view->model);
+
+  gtk_style_context_save (context);
+  gtk_style_context_add_class (context, EV_STYLE_CLASS_DOCUMENT_PAGE);
+  if (ev_document_model_get_inverted_colors (view->model))
+    gtk_style_context_add_class (context, EV_STYLE_CLASS_INVERTED);
+
+  if (view->continuous && page == current_page)
+    gtk_style_context_set_state (context, GTK_STATE_FLAG_ACTIVE);
+
+  gtk_render_background (context, cr, page_area->x, page_area->y, page_area->width, page_area->height);
+  gtk_render_frame (context, cr, page_area->x, page_area->y, page_area->width, page_area->height);
+  gtk_style_context_restore (context);
+
+  if (gdk_rectangle_intersect (&real_page_area, expose_area, &overlap)) {
+    gint             width, height;
+    cairo_surface_t *page_surface = NULL;
+    cairo_surface_t *selection_surface = NULL;
+    gint offset_x, offset_y;
+    cairo_region_t *region = NULL;
+
+    page_surface = ev_pixbuf_cache_get_surface (view->pixbuf_cache, page);
+
+    if (!page_surface) {
+      if (page == current_page)
+        ev_view_set_loading (view, TRUE);
+
+      *page_ready = FALSE;
+
+      return;
+    }
+
+    if (page == current_page)
+      ev_view_set_loading (view, FALSE);
+
+    ev_view_get_page_size (view, page, &width, &height);
+    offset_x = overlap.x - real_page_area.x;
+    offset_y = overlap.y - real_page_area.y;
+
+    draw_surface (cr, page_surface, overlap.x, overlap.y, offset_x, offset_y, width, height);
+
+    /* Get the selection pixbuf iff we have something to draw */
+    if (!find_selection_for_page (view, page))
+      return;
+
+    selection_surface = ev_pixbuf_cache_get_selection_surface (view->pixbuf_cache,
+                                                               page,
+                                                               view->scale);
+    if (selection_surface) {
+      draw_surface (cr, selection_surface, overlap.x, overlap.y, offset_x, offset_y,
+                    width, height);
+      return;
+    }
+
+    region = ev_pixbuf_cache_get_selection_region (view->pixbuf_cache,
+                                                   page,
+                                                   view->scale);
+    if (region) {
+      double scale_x, scale_y;
+      GdkRGBA color;
+      double device_scale_x = 1, device_scale_y = 1;
+
+      scale_x = (gdouble)width / cairo_image_surface_get_width (page_surface);
+      scale_y = (gdouble)height / cairo_image_surface_get_height (page_surface);
 
 #ifdef HAVE_HIDPI_SUPPORT
-			cairo_surface_get_device_scale (page_surface, &device_scale_x, &device_scale_y);
+      cairo_surface_get_device_scale (page_surface, &device_scale_x, &device_scale_y);
 #endif
 
-			scale_x *= device_scale_x;
-			scale_y *= device_scale_y;
+      scale_x *= device_scale_x;
+      scale_y *= device_scale_y;
 
-			_ev_view_get_selection_colors (view, &color, NULL);
-			draw_selection_region (cr, region, &color, real_page_area.x, real_page_area.y,
-					       scale_x, scale_y);
-		}
-	}
+      _ev_view_get_selection_colors (view, &color, NULL);
+      draw_selection_region (cr, region, &color, real_page_area.x, real_page_area.y,
+                             scale_x, scale_y);
+    }
+  }
 }
 
 /*** GObject functions ***/
 
 static void
-ev_view_finalize (GObject *object)
-{
-	EvView *view = EV_VIEW (object);
+ev_view_finalize (GObject *object) {
+  EvView *view = EV_VIEW (object);
 
-	if (view->selection_info.selections) {
-		g_list_free_full (view->selection_info.selections, (GDestroyNotify)selection_free);
-		view->selection_info.selections = NULL;
-	}
-	clear_link_selected (view);
+  if (view->selection_info.selections) {
+    g_list_free_full (view->selection_info.selections, (GDestroyNotify)selection_free);
+    view->selection_info.selections = NULL;
+  }
+  clear_link_selected (view);
 
-	if (view->synctex_result) {
-		g_free (view->synctex_result);
-		view->synctex_result = NULL;
-	}
+  if (view->synctex_result) {
+    g_free (view->synctex_result);
+    view->synctex_result = NULL;
+  }
 
-	if (view->image_dnd_info.image)
-		g_object_unref (view->image_dnd_info.image);
-	view->image_dnd_info.image = NULL;
-	if (view->annot_window_map)
-		g_hash_table_destroy (view->annot_window_map);
+  if (view->image_dnd_info.image)
+    g_object_unref (view->image_dnd_info.image);
+  view->image_dnd_info.image = NULL;
+  if (view->annot_window_map)
+    g_hash_table_destroy (view->annot_window_map);
 
-	g_object_unref (view->zoom_gesture);
+  g_object_unref (view->zoom_gesture);
 
-	G_OBJECT_CLASS (ev_view_parent_class)->finalize (object);
+  G_OBJECT_CLASS (ev_view_parent_class)->finalize (object);
 }
 
 static void
-ev_view_dispose (GObject *object)
-{
-	EvView *view = EV_VIEW (object);
+ev_view_dispose (GObject *object) {
+  EvView *view = EV_VIEW (object);
 
-	if (view->model) {
-		g_signal_handlers_disconnect_by_data (view->model, view);
-		g_object_unref (view->model);
-		view->model = NULL;
-	}
+  if (view->model) {
+    g_signal_handlers_disconnect_by_data (view->model, view);
+    g_object_unref (view->model);
+    view->model = NULL;
+  }
 
-	if (view->pixbuf_cache) {
-		g_object_unref (view->pixbuf_cache);
-		view->pixbuf_cache = NULL;
-	}
+  if (view->pixbuf_cache) {
+    g_object_unref (view->pixbuf_cache);
+    view->pixbuf_cache = NULL;
+  }
 
-	if (view->document) {
-		g_object_unref (view->document);
-		view->document = NULL;
-	}
+  if (view->document) {
+    g_object_unref (view->document);
+    view->document = NULL;
+  }
 
-	if (view->page_cache) {
-		g_object_unref (view->page_cache);
-		view->page_cache = NULL;
-	}
+  if (view->page_cache) {
+    g_object_unref (view->page_cache);
+    view->page_cache = NULL;
+  }
 
-	ev_view_find_cancel (view);
+  ev_view_find_cancel (view);
 
-	ev_view_window_children_free (view);
+  ev_view_window_children_free (view);
 
-	if (view->update_cursor_idle_id) {
-		g_source_remove (view->update_cursor_idle_id);
-		view->update_cursor_idle_id = 0;
-	}
+  if (view->update_cursor_idle_id) {
+    g_source_remove (view->update_cursor_idle_id);
+    view->update_cursor_idle_id = 0;
+  }
 
-	if (view->selection_scroll_id) {
-	    g_source_remove (view->selection_scroll_id);
-	    view->selection_scroll_id = 0;
-	}
+  if (view->selection_scroll_id) {
+    g_source_remove (view->selection_scroll_id);
+    view->selection_scroll_id = 0;
+  }
 
-	if (view->selection_update_id) {
-	    g_source_remove (view->selection_update_id);
-	    view->selection_update_id = 0;
-	}
+  if (view->selection_update_id) {
+    g_source_remove (view->selection_update_id);
+    view->selection_update_id = 0;
+  }
 
-	if (view->scroll_info.timeout_id) {
-	    g_source_remove (view->scroll_info.timeout_id);
-	    view->scroll_info.timeout_id = 0;
-	}
+  if (view->scroll_info.timeout_id) {
+    g_source_remove (view->scroll_info.timeout_id);
+    view->scroll_info.timeout_id = 0;
+  }
 
-	if (view->drag_info.drag_timeout_id) {
-		g_source_remove (view->drag_info.drag_timeout_id);
-		view->drag_info.drag_timeout_id = 0;
-	}
+  if (view->drag_info.drag_timeout_id) {
+    g_source_remove (view->drag_info.drag_timeout_id);
+    view->drag_info.drag_timeout_id = 0;
+  }
 
-	if (view->drag_info.release_timeout_id) {
-		g_source_remove (view->drag_info.release_timeout_id);
-		view->drag_info.release_timeout_id = 0;
-	}
+  if (view->drag_info.release_timeout_id) {
+    g_source_remove (view->drag_info.release_timeout_id);
+    view->drag_info.release_timeout_id = 0;
+  }
 
-	if (view->cursor_blink_timeout_id) {
-		g_source_remove (view->cursor_blink_timeout_id);
-		view->cursor_blink_timeout_id = 0;
-	}
+  if (view->cursor_blink_timeout_id) {
+    g_source_remove (view->cursor_blink_timeout_id);
+    view->cursor_blink_timeout_id = 0;
+  }
 
-	if (view->child_focus_idle_id) {
-		g_source_remove (view->child_focus_idle_id);
-		view->child_focus_idle_id = 0;
-	}
+  if (view->child_focus_idle_id) {
+    g_source_remove (view->child_focus_idle_id);
+    view->child_focus_idle_id = 0;
+  }
 
-        gtk_scrollable_set_hadjustment (GTK_SCROLLABLE (view), NULL);
-        gtk_scrollable_set_vadjustment (GTK_SCROLLABLE (view), NULL);
+  gtk_scrollable_set_hadjustment (GTK_SCROLLABLE (view), NULL);
+  gtk_scrollable_set_vadjustment (GTK_SCROLLABLE (view), NULL);
 
-	g_clear_object(&view->accessible);
+  g_clear_object(&view->accessible);
 
-	G_OBJECT_CLASS (ev_view_parent_class)->dispose (object);
+  G_OBJECT_CLASS (ev_view_parent_class)->dispose (object);
 }
 
 static void
 ev_view_get_property (GObject     *object,
-		      guint        prop_id,
-		      GValue      *value,
-		      GParamSpec  *pspec)
-{
-	EvView *view = EV_VIEW (object);
-
-	switch (prop_id) {
-	case PROP_IS_LOADING:
-		g_value_set_boolean (value, view->loading);
-		break;
-	case PROP_CAN_ZOOM_IN:
-		g_value_set_boolean (value, view->can_zoom_in);
-		break;
-	case PROP_CAN_ZOOM_OUT:
-		g_value_set_boolean (value, view->can_zoom_out);
-		break;
-	case PROP_HADJUSTMENT:
-		g_value_set_object (value, view->hadjustment);
-		break;
-	case PROP_VADJUSTMENT:
-		g_value_set_object (value, view->vadjustment);
-		break;
-	case PROP_HSCROLL_POLICY:
-		g_value_set_enum (value, view->hscroll_policy);
-		break;
-	case PROP_VSCROLL_POLICY:
-		g_value_set_enum (value, view->vscroll_policy);
-		break;
-	default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-		break;
-	}
+                      guint        prop_id,
+                      GValue      *value,
+                      GParamSpec  *pspec) {
+  EvView *view = EV_VIEW (object);
+
+  switch (prop_id) {
+    case PROP_IS_LOADING:
+      g_value_set_boolean (value, view->loading);
+      break;
+    case PROP_CAN_ZOOM_IN:
+      g_value_set_boolean (value, view->can_zoom_in);
+      break;
+    case PROP_CAN_ZOOM_OUT:
+      g_value_set_boolean (value, view->can_zoom_out);
+      break;
+    case PROP_HADJUSTMENT:
+      g_value_set_object (value, view->hadjustment);
+      break;
+    case PROP_VADJUSTMENT:
+      g_value_set_object (value, view->vadjustment);
+      break;
+    case PROP_HSCROLL_POLICY:
+      g_value_set_enum (value, view->hscroll_policy);
+      break;
+    case PROP_VSCROLL_POLICY:
+      g_value_set_enum (value, view->vscroll_policy);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
 }
 
 static void
 ev_view_set_property (GObject      *object,
-		      guint         prop_id,
-		      const GValue *value,
-		      GParamSpec   *pspec)
-{
-	EvView *view = EV_VIEW (object);
-
-	switch (prop_id) {
-	case PROP_IS_LOADING:
-		ev_view_set_loading (view, g_value_get_boolean (value));
-		break;
-	case PROP_HADJUSTMENT:
-		ev_view_set_scroll_adjustment (view, GTK_ORIENTATION_HORIZONTAL,
-					       (GtkAdjustment *) g_value_get_object (value));
-		break;
-	case PROP_VADJUSTMENT:
-		ev_view_set_scroll_adjustment (view, GTK_ORIENTATION_VERTICAL,
-					       (GtkAdjustment *) g_value_get_object (value));
-		break;
-	case PROP_HSCROLL_POLICY:
-		view->hscroll_policy = g_value_get_enum (value);
-		gtk_widget_queue_resize (GTK_WIDGET (view));
-		break;
-	case PROP_VSCROLL_POLICY:
-		view->vscroll_policy = g_value_get_enum (value);
-		gtk_widget_queue_resize (GTK_WIDGET (view));
-		break;
-	default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-		break;
-	}
+                      guint         prop_id,
+                      const GValue *value,
+                      GParamSpec   *pspec) {
+  EvView *view = EV_VIEW (object);
+
+  switch (prop_id) {
+    case PROP_IS_LOADING:
+      ev_view_set_loading (view, g_value_get_boolean (value));
+      break;
+    case PROP_HADJUSTMENT:
+      ev_view_set_scroll_adjustment (view, GTK_ORIENTATION_HORIZONTAL,
+                                     (GtkAdjustment *) g_value_get_object (value));
+      break;
+    case PROP_VADJUSTMENT:
+      ev_view_set_scroll_adjustment (view, GTK_ORIENTATION_VERTICAL,
+                                     (GtkAdjustment *) g_value_get_object (value));
+      break;
+    case PROP_HSCROLL_POLICY:
+      view->hscroll_policy = g_value_get_enum (value);
+      gtk_widget_queue_resize (GTK_WIDGET (view));
+      break;
+    case PROP_VSCROLL_POLICY:
+      view->vscroll_policy = g_value_get_enum (value);
+      gtk_widget_queue_resize (GTK_WIDGET (view));
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
 }
 
 /* Accessibility */
 static AtkObject *
-ev_view_get_accessible (GtkWidget *widget)
-{
-	EvView *view = EV_VIEW (widget);
+ev_view_get_accessible (GtkWidget *widget) {
+  EvView *view = EV_VIEW (widget);
 
-	if (!view->accessible)
-		view->accessible = ev_view_accessible_new (widget);
-	return view->accessible;
+  if (!view->accessible)
+    view->accessible = ev_view_accessible_new (widget);
+  return view->accessible;
 }
 
 /* GtkContainer */
 static void
 ev_view_remove (GtkContainer *container,
-		GtkWidget    *widget)
-{
-	EvView *view = EV_VIEW (container);
-	GList *tmp_list = view->children;
-	EvViewChild *child;
+                GtkWidget    *widget) {
+  EvView *view = EV_VIEW (container);
+  GList *tmp_list = view->children;
+  EvViewChild *child;
 
-	while (tmp_list) {
-		child = tmp_list->data;
+  while (tmp_list) {
+    child = tmp_list->data;
 
-		if (child->widget == widget) {
-			gtk_widget_unparent (widget);
+    if (child->widget == widget) {
+      gtk_widget_unparent (widget);
 
-			view->children = g_list_remove_link (view->children, tmp_list);
-			g_list_free_1 (tmp_list);
-			g_slice_free (EvViewChild, child);
+      view->children = g_list_remove_link (view->children, tmp_list);
+      g_list_free_1 (tmp_list);
+      g_slice_free (EvViewChild, child);
 
-			return;
-		}
+      return;
+    }
 
-		tmp_list = tmp_list->next;
-	}
+    tmp_list = tmp_list->next;
+  }
 }
 
 static void
 ev_view_forall (GtkContainer *container,
-		gboolean      include_internals,
-		GtkCallback   callback,
-		gpointer      callback_data)
-{
-	EvView *view = EV_VIEW (container);
-	GList *tmp_list = view->children;
-	EvViewChild *child;
+                gboolean      include_internals,
+                GtkCallback   callback,
+                gpointer      callback_data) {
+  EvView *view = EV_VIEW (container);
+  GList *tmp_list = view->children;
+  EvViewChild *child;
 
-	while (tmp_list) {
-		child = tmp_list->data;
-		tmp_list = tmp_list->next;
+  while (tmp_list) {
+    child = tmp_list->data;
+    tmp_list = tmp_list->next;
 
-		(* callback) (child->widget, callback_data);
-	}
+    (* callback) (child->widget, callback_data);
+  }
 }
 
 static void
-view_update_scale_limits (EvView *view)
-{
-	gdouble    min_width, min_height;
-	gdouble    width, height;
-	gdouble    max_scale;
-	gdouble    dpi;
-	gint       rotation;
+view_update_scale_limits (EvView *view) {
+  gdouble    min_width, min_height;
+  gdouble    width, height;
+  gdouble    max_scale;
+  gdouble    dpi;
+  gint       rotation;
 
-	if (!view->document)
-		return;
+  if (!view->document)
+    return;
 
-	rotation = ev_document_model_get_rotation (view->model);
+  rotation = ev_document_model_get_rotation (view->model);
 
-	dpi = ev_document_misc_get_widget_dpi (GTK_WIDGET (view)) / 72.0;
+  dpi = ev_document_misc_get_widget_dpi (GTK_WIDGET (view)) / 72.0;
 
-	ev_document_get_min_page_size (view->document, &min_width, &min_height);
-	width = (rotation == 0 || rotation == 180) ? min_width : min_height;
-	height = (rotation == 0 || rotation == 180) ? min_height : min_width;
-	max_scale = sqrt (view->pixbuf_cache_size / (width * dpi * 4 * height * dpi));
+  ev_document_get_min_page_size (view->document, &min_width, &min_height);
+  width = (rotation == 0 || rotation == 180) ? min_width : min_height;
+  height = (rotation == 0 || rotation == 180) ? min_height : min_width;
+  max_scale = sqrt (view->pixbuf_cache_size / (width * dpi * 4 * height * dpi));
 
-	ev_document_model_set_min_scale (view->model, MIN_SCALE * dpi);
-	ev_document_model_set_max_scale (view->model, max_scale * dpi);
+  ev_document_model_set_min_scale (view->model, MIN_SCALE * dpi);
+  ev_document_model_set_max_scale (view->model, max_scale * dpi);
 }
 
 static void
 ev_view_screen_changed (GtkWidget *widget,
-			GdkScreen *old_screen)
-{
-	EvView *view = EV_VIEW (widget);
-	GdkScreen *screen;
+                        GdkScreen *old_screen) {
+  EvView *view = EV_VIEW (widget);
+  GdkScreen *screen;
 
-	screen = gtk_widget_get_screen (widget);
-	if (screen == old_screen)
-		return;
+  screen = gtk_widget_get_screen (widget);
+  if (screen == old_screen)
+    return;
 
-	view_update_scale_limits (view);
+  view_update_scale_limits (view);
 
-	if (GTK_WIDGET_CLASS (ev_view_parent_class)->screen_changed) {
-		GTK_WIDGET_CLASS (ev_view_parent_class)->screen_changed (widget, old_screen);
-	}
+  if (GTK_WIDGET_CLASS (ev_view_parent_class)->screen_changed) {
+    GTK_WIDGET_CLASS (ev_view_parent_class)->screen_changed (widget, old_screen);
+  }
 }
 
 static void
 pan_gesture_pan_cb (GtkGesturePan   *gesture,
-		    GtkPanDirection  direction,
-		    gdouble          offset,
-		    EvView          *view)
-{
-	GtkAllocation allocation;
+                    GtkPanDirection  direction,
+                    gdouble          offset,
+                    EvView          *view) {
+  GtkAllocation allocation;
 
-	gtk_widget_get_allocation (GTK_WIDGET (view), &allocation);
+  gtk_widget_get_allocation (GTK_WIDGET (view), &allocation);
 
-	if (view->continuous ||
-	    allocation.width < view->requisition.width) {
-		gtk_gesture_set_state (GTK_GESTURE (gesture),
-				       GTK_EVENT_SEQUENCE_DENIED);
-		return;
-	}
+  if (view->continuous ||
+      allocation.width < view->requisition.width) {
+    gtk_gesture_set_state (GTK_GESTURE (gesture),
+                           GTK_EVENT_SEQUENCE_DENIED);
+    return;
+  }
 
 #define PAN_ACTION_DISTANCE 200
 
-	view->pan_action = EV_PAN_ACTION_NONE;
-	gtk_gesture_set_state (GTK_GESTURE (gesture), GTK_EVENT_SEQUENCE_CLAIMED);
+  view->pan_action = EV_PAN_ACTION_NONE;
+  gtk_gesture_set_state (GTK_GESTURE (gesture), GTK_EVENT_SEQUENCE_CLAIMED);
 
-	if (offset > PAN_ACTION_DISTANCE) {
-		if (direction == GTK_PAN_DIRECTION_LEFT ||
-		    gtk_widget_get_direction (GTK_WIDGET (view)) == GTK_TEXT_DIR_RTL)
-			view->pan_action = EV_PAN_ACTION_NEXT;
-		else
-			view->pan_action = EV_PAN_ACTION_PREV;
-	}
+  if (offset > PAN_ACTION_DISTANCE) {
+    if (direction == GTK_PAN_DIRECTION_LEFT ||
+        gtk_widget_get_direction (GTK_WIDGET (view)) == GTK_TEXT_DIR_RTL)
+      view->pan_action = EV_PAN_ACTION_NEXT;
+    else
+      view->pan_action = EV_PAN_ACTION_PREV;
+  }
 #undef PAN_ACTION_DISTANCE
 }
 
 static void
 pan_gesture_end_cb (GtkGesture       *gesture,
-		    GdkEventSequence *sequence,
-		    EvView           *view)
-{
-	if (!gtk_gesture_handles_sequence (gesture, sequence))
-		return;
+                    GdkEventSequence *sequence,
+                    EvView           *view) {
+  if (!gtk_gesture_handles_sequence (gesture, sequence))
+    return;
 
-	if (view->pan_action == EV_PAN_ACTION_PREV)
-		ev_view_previous_page (view);
-	else if (view->pan_action == EV_PAN_ACTION_NEXT)
-		ev_view_next_page (view);
+  if (view->pan_action == EV_PAN_ACTION_PREV)
+    ev_view_previous_page (view);
+  else if (view->pan_action == EV_PAN_ACTION_NEXT)
+    ev_view_next_page (view);
 
-	view->pan_action = EV_PAN_ACTION_NONE;
+  view->pan_action = EV_PAN_ACTION_NONE;
 }
 
 static void
 ev_view_hierarchy_changed (GtkWidget *widget,
-			   GtkWidget *previous_toplevel)
-{
-	GtkWidget *parent = gtk_widget_get_parent (widget);
-	EvView *view = EV_VIEW (widget);
+                           GtkWidget *previous_toplevel) {
+  GtkWidget *parent = gtk_widget_get_parent (widget);
+  EvView *view = EV_VIEW (widget);
 
-	if (parent && !view->pan_gesture) {
-		view->pan_gesture =
-			gtk_gesture_pan_new (parent, GTK_ORIENTATION_HORIZONTAL);
-		g_signal_connect (view->pan_gesture, "pan",
-				  G_CALLBACK (pan_gesture_pan_cb), widget);
-		g_signal_connect (view->pan_gesture, "end",
-				  G_CALLBACK (pan_gesture_end_cb), widget);
+  if (parent && !view->pan_gesture) {
+    view->pan_gesture =
+      gtk_gesture_pan_new (parent, GTK_ORIENTATION_HORIZONTAL);
+    g_signal_connect (view->pan_gesture, "pan",
+                      G_CALLBACK (pan_gesture_pan_cb), widget);
+    g_signal_connect (view->pan_gesture, "end",
+                      G_CALLBACK (pan_gesture_end_cb), widget);
 
-		gtk_gesture_single_set_touch_only (GTK_GESTURE_SINGLE (view->pan_gesture), TRUE);
-		gtk_event_controller_set_propagation_phase (GTK_EVENT_CONTROLLER (view->pan_gesture),
-							    GTK_PHASE_CAPTURE);
-	} else if (!parent && view->pan_gesture) {
-		g_clear_object (&view->pan_gesture);
-	}
+    gtk_gesture_single_set_touch_only (GTK_GESTURE_SINGLE (view->pan_gesture), TRUE);
+    gtk_event_controller_set_propagation_phase (GTK_EVENT_CONTROLLER (view->pan_gesture),
+                                                GTK_PHASE_CAPTURE);
+  } else if (!parent && view->pan_gesture) {
+    g_clear_object (&view->pan_gesture);
+  }
 }
 
 static void
 add_move_binding_keypad (GtkBindingSet  *binding_set,
-			 guint           keyval,
-			 GdkModifierType modifiers,
-			 GtkMovementStep step,
-			 gint            count)
-{
-	guint keypad_keyval = keyval - GDK_KEY_Left + GDK_KEY_KP_Left;
-
-	gtk_binding_entry_add_signal (binding_set, keyval, modifiers,
-				      "move-cursor", 3,
-				      GTK_TYPE_MOVEMENT_STEP, step,
-				      G_TYPE_INT, count,
-				      G_TYPE_BOOLEAN, FALSE);
-	gtk_binding_entry_add_signal (binding_set, keypad_keyval, modifiers,
-				      "move-cursor", 3,
-				      GTK_TYPE_MOVEMENT_STEP, step,
-				      G_TYPE_INT, count,
-				      G_TYPE_BOOLEAN, FALSE);
-
-	/* Selection-extending version */
-	gtk_binding_entry_add_signal (binding_set, keyval, modifiers | GDK_SHIFT_MASK,
-				      "move-cursor", 3,
-				      GTK_TYPE_MOVEMENT_STEP, step,
-				      G_TYPE_INT, count,
-				      G_TYPE_BOOLEAN, TRUE);
-	gtk_binding_entry_add_signal (binding_set, keypad_keyval, modifiers | GDK_SHIFT_MASK,
-				      "move-cursor", 3,
-				      GTK_TYPE_MOVEMENT_STEP, step,
-				      G_TYPE_INT, count,
-				      G_TYPE_BOOLEAN, TRUE);
+                         guint           keyval,
+                         GdkModifierType modifiers,
+                         GtkMovementStep step,
+                         gint            count) {
+  guint keypad_keyval = keyval - GDK_KEY_Left + GDK_KEY_KP_Left;
+
+  gtk_binding_entry_add_signal (binding_set, keyval, modifiers,
+                                "move-cursor", 3,
+                                GTK_TYPE_MOVEMENT_STEP, step,
+                                G_TYPE_INT, count,
+                                G_TYPE_BOOLEAN, FALSE);
+  gtk_binding_entry_add_signal (binding_set, keypad_keyval, modifiers,
+                                "move-cursor", 3,
+                                GTK_TYPE_MOVEMENT_STEP, step,
+                                G_TYPE_INT, count,
+                                G_TYPE_BOOLEAN, FALSE);
+
+  /* Selection-extending version */
+  gtk_binding_entry_add_signal (binding_set, keyval, modifiers | GDK_SHIFT_MASK,
+                                "move-cursor", 3,
+                                GTK_TYPE_MOVEMENT_STEP, step,
+                                G_TYPE_INT, count,
+                                G_TYPE_BOOLEAN, TRUE);
+  gtk_binding_entry_add_signal (binding_set, keypad_keyval, modifiers | GDK_SHIFT_MASK,
+                                "move-cursor", 3,
+                                GTK_TYPE_MOVEMENT_STEP, step,
+                                G_TYPE_INT, count,
+                                G_TYPE_BOOLEAN, TRUE);
 }
 
 static gint
 ev_view_mapping_compare (const EvMapping *a,
-			 const EvMapping *b,
-			 gpointer         user_data)
-{
-	GtkTextDirection text_direction = GPOINTER_TO_INT (user_data);
-	gint y1 = a->area.y1 + (a->area.y2 - a->area.y1) / 2;
-	gint y2 = b->area.y1 + (b->area.y2 - b->area.y1) / 2;
+                         const EvMapping *b,
+                         gpointer         user_data) {
+  GtkTextDirection text_direction = GPOINTER_TO_INT (user_data);
+  gint y1 = a->area.y1 + (a->area.y2 - a->area.y1) / 2;
+  gint y2 = b->area.y1 + (b->area.y2 - b->area.y1) / 2;
 
-	if (y1 == y2) {
-		gint x1 = a->area.x1 + (a->area.x2 - a->area.x1) / 2;
-		gint x2 = b->area.x1 + (b->area.x2 - b->area.x1) / 2;
+  if (y1 == y2) {
+    gint x1 = a->area.x1 + (a->area.x2 - a->area.x1) / 2;
+    gint x2 = b->area.x1 + (b->area.x2 - b->area.x1) / 2;
 
-		if (text_direction == GTK_TEXT_DIR_RTL)
-			return (x1 < x2) ? 1 : ((x1 == x2) ? 0 : -1);
+    if (text_direction == GTK_TEXT_DIR_RTL)
+      return (x1 < x2) ? 1 : ((x1 == x2) ? 0 : -1);
 
-		return (x1 < x2) ? -1 : ((x1 == x2) ? 0 : 1);
-	}
+    return (x1 < x2) ? -1 : ((x1 == x2) ? 0 : 1);
+  }
 
-	return (y1 < y2) ? -1 : 1;
+  return (y1 < y2) ? -1 : 1;
 }
 
 static GList *
 ev_view_get_sorted_mapping_list (EvView          *view,
-				 GtkDirectionType direction,
-				 gint             page)
-{
-	GList         *mapping_list = NULL, *l;
-	EvMappingList *forms_mapping;
+                                 GtkDirectionType direction,
+                                 gint             page) {
+  GList         *mapping_list = NULL, *l;
+  EvMappingList *forms_mapping;
 
-	forms_mapping = ev_page_cache_get_form_field_mapping (view->page_cache, page);
+  forms_mapping = ev_page_cache_get_form_field_mapping (view->page_cache, page);
 
-	for (l = ev_mapping_list_get_list (forms_mapping); l; l = g_list_next (l)) {
-		EvMapping   *mapping = (EvMapping *)l->data;
-		EvFormField *field = (EvFormField *)mapping->data;
+  for (l = ev_mapping_list_get_list (forms_mapping); l; l = g_list_next (l)) {
+    EvMapping   *mapping = (EvMapping *)l->data;
+    EvFormField *field = (EvFormField *)mapping->data;
 
-		if (field->is_read_only || EV_IS_FORM_FIELD_SIGNATURE (field))
-			continue;
+    if (field->is_read_only || EV_IS_FORM_FIELD_SIGNATURE (field))
+      continue;
 
-		mapping_list = g_list_prepend (mapping_list, mapping);
-	}
+    mapping_list = g_list_prepend (mapping_list, mapping);
+  }
 
-	if (!mapping_list)
-		return NULL;
+  if (!mapping_list)
+    return NULL;
 
-	mapping_list = g_list_sort_with_data (g_list_reverse (mapping_list),
-					      (GCompareDataFunc)ev_view_mapping_compare,
-					      GINT_TO_POINTER (gtk_widget_get_direction (GTK_WIDGET (view))));
+  mapping_list = g_list_sort_with_data (g_list_reverse (mapping_list),
+                                        (GCompareDataFunc)ev_view_mapping_compare,
+                                        GINT_TO_POINTER (gtk_widget_get_direction (GTK_WIDGET (view))));
 
-	if (direction == GTK_DIR_TAB_BACKWARD)
-		mapping_list = g_list_reverse (mapping_list);
-	return mapping_list;
+  if (direction == GTK_DIR_TAB_BACKWARD)
+    mapping_list = g_list_reverse (mapping_list);
+  return mapping_list;
 }
 
 static gboolean
-child_focus_forward_idle_cb (gpointer user_data)
-{
-	EvView *view = EV_VIEW (user_data);
+child_focus_forward_idle_cb (gpointer user_data) {
+  EvView *view = EV_VIEW (user_data);
 
-	view->child_focus_idle_id = 0;
-	gtk_widget_child_focus (GTK_WIDGET (view), GTK_DIR_TAB_FORWARD);
+  view->child_focus_idle_id = 0;
+  gtk_widget_child_focus (GTK_WIDGET (view), GTK_DIR_TAB_FORWARD);
 
-	return G_SOURCE_REMOVE;
+  return G_SOURCE_REMOVE;
 }
 
 static gboolean
-child_focus_backward_idle_cb (gpointer user_data)
-{
-	EvView *view = EV_VIEW (user_data);
+child_focus_backward_idle_cb (gpointer user_data) {
+  EvView *view = EV_VIEW (user_data);
 
-	view->child_focus_idle_id = 0;
-	gtk_widget_child_focus (GTK_WIDGET (view), GTK_DIR_TAB_BACKWARD);
+  view->child_focus_idle_id = 0;
+  gtk_widget_child_focus (GTK_WIDGET (view), GTK_DIR_TAB_BACKWARD);
 
-	return G_SOURCE_REMOVE;
+  return G_SOURCE_REMOVE;
 }
 
 static void
 schedule_child_focus_in_idle (EvView           *view,
-			      GtkDirectionType  direction)
-{
-	if (view->child_focus_idle_id)
-		g_source_remove (view->child_focus_idle_id);
-	view->child_focus_idle_id =
-		g_idle_add (direction == GTK_DIR_TAB_FORWARD ? child_focus_forward_idle_cb : child_focus_backward_idle_cb,
-			    view);
+                              GtkDirectionType  direction) {
+  if (view->child_focus_idle_id)
+    g_source_remove (view->child_focus_idle_id);
+  view->child_focus_idle_id =
+    g_idle_add (direction == GTK_DIR_TAB_FORWARD ? child_focus_forward_idle_cb : child_focus_backward_idle_cb,
+                view);
 }
 
 static gboolean
 ev_view_focus_next (EvView           *view,
-		    GtkDirectionType  direction)
-{
-	EvMapping *focus_element;
-	GList     *elements;
-	gboolean   had_focused_element;
-
-	if (view->focused_element) {
-		GList *l;
-
-		elements = ev_view_get_sorted_mapping_list (view, direction, view->focused_element_page);
-		l = g_list_find (elements, view->focused_element);
-		l = g_list_next (l);
-		focus_element = l ? l->data : NULL;
-		had_focused_element = TRUE;
-	} else {
-		elements = ev_view_get_sorted_mapping_list (view, direction, view->current_page);
-		focus_element = elements ? elements->data : NULL;
-		had_focused_element = FALSE;
-	}
-
-	g_list_free (elements);
-
-	if (focus_element) {
-		ev_view_remove_all_form_fields (view);
-		_ev_view_focus_form_field (view, EV_FORM_FIELD (focus_element->data));
-
-		return TRUE;
-	}
-
-	ev_view_remove_all_form_fields (view);
-	_ev_view_set_focused_element (view, NULL, -1);
-
-	/* Only try to move the focus to next/previous pages when the current page had
-	 * a focused element. This prevents the view from jumping to the first/last page
-	 * when there are not focusable elements.
-	 */
-	if (!had_focused_element)
-		return FALSE;
-
-	/* FIXME: this doesn't work if the next/previous page doesn't have form fields */
-	if (direction == GTK_DIR_TAB_FORWARD) {
-		if (ev_view_next_page (view)) {
-			schedule_child_focus_in_idle (view, direction);
-			return TRUE;
-		}
-	} else if (direction == GTK_DIR_TAB_BACKWARD) {
-		if (ev_view_previous_page (view)) {
-			schedule_child_focus_in_idle (view, direction);
-			return TRUE;
-		}
-	}
-
-	return FALSE;
+                    GtkDirectionType  direction) {
+  EvMapping *focus_element;
+  GList     *elements;
+  gboolean   had_focused_element;
+
+  if (view->focused_element) {
+    GList *l;
+
+    elements = ev_view_get_sorted_mapping_list (view, direction, view->focused_element_page);
+    l = g_list_find (elements, view->focused_element);
+    l = g_list_next (l);
+    focus_element = l ? l->data : NULL;
+    had_focused_element = TRUE;
+  } else {
+    elements = ev_view_get_sorted_mapping_list (view, direction, view->current_page);
+    focus_element = elements ? elements->data : NULL;
+    had_focused_element = FALSE;
+  }
+
+  g_list_free (elements);
+
+  if (focus_element) {
+    ev_view_remove_all_form_fields (view);
+    _ev_view_focus_form_field (view, EV_FORM_FIELD (focus_element->data));
+
+    return TRUE;
+  }
+
+  ev_view_remove_all_form_fields (view);
+  _ev_view_set_focused_element (view, NULL, -1);
+
+  /* Only try to move the focus to next/previous pages when the current page had
+   * a focused element. This prevents the view from jumping to the first/last page
+   * when there are not focusable elements.
+   */
+  if (!had_focused_element)
+    return FALSE;
+
+  /* FIXME: this doesn't work if the next/previous page doesn't have form fields */
+  if (direction == GTK_DIR_TAB_FORWARD) {
+    if (ev_view_next_page (view)) {
+      schedule_child_focus_in_idle (view, direction);
+      return TRUE;
+    }
+  } else if (direction == GTK_DIR_TAB_BACKWARD) {
+    if (ev_view_previous_page (view)) {
+      schedule_child_focus_in_idle (view, direction);
+      return TRUE;
+    }
+  }
+
+  return FALSE;
 }
 
 static gboolean
 ev_view_focus (GtkWidget        *widget,
-	       GtkDirectionType  direction)
-{
-	EvView *view = EV_VIEW (widget);
+               GtkDirectionType  direction) {
+  EvView *view = EV_VIEW (widget);
 
-	if (view->document) {
-		if (direction == GTK_DIR_TAB_FORWARD || direction == GTK_DIR_TAB_BACKWARD)
-			return ev_view_focus_next (view, direction);
-	}
+  if (view->document) {
+    if (direction == GTK_DIR_TAB_FORWARD || direction == GTK_DIR_TAB_BACKWARD)
+      return ev_view_focus_next (view, direction);
+  }
 
-	return GTK_WIDGET_CLASS (ev_view_parent_class)->focus (widget, direction);
+  return GTK_WIDGET_CLASS (ev_view_parent_class)->focus (widget, direction);
 }
 
 static void
 ev_view_parent_set (GtkWidget *widget,
-		    GtkWidget *previous_parent)
-{
-	GtkWidget *parent;
-
-	parent = gtk_widget_get_parent (widget);
-	g_assert (!parent || GTK_IS_SCROLLED_WINDOW (parent));
-}
-
-static void
-ev_view_class_init (EvViewClass *class)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (class);
-	GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (class);
-	GtkContainerClass *container_class = GTK_CONTAINER_CLASS (class);
-	GtkBindingSet *binding_set;
-
-	object_class->get_property = ev_view_get_property;
-	object_class->set_property = ev_view_set_property;
-        object_class->dispose = ev_view_dispose;
-	object_class->finalize = ev_view_finalize;
-
-	widget_class->realize = ev_view_realize;
-        widget_class->draw = ev_view_draw;
-	widget_class->button_press_event = ev_view_button_press_event;
-	widget_class->motion_notify_event = ev_view_motion_notify_event;
-	widget_class->button_release_event = ev_view_button_release_event;
-	widget_class->key_press_event = ev_view_key_press_event;
-	widget_class->focus_in_event = ev_view_focus_in;
-	widget_class->focus_out_event = ev_view_focus_out;
- 	widget_class->get_accessible = ev_view_get_accessible;
-	widget_class->get_preferred_width = ev_view_get_preferred_width;
-	widget_class->get_preferred_height = ev_view_get_preferred_height;
-	widget_class->size_allocate = ev_view_size_allocate;
-	widget_class->scroll_event = ev_view_scroll_event;
-	widget_class->enter_notify_event = ev_view_enter_notify_event;
-	widget_class->leave_notify_event = ev_view_leave_notify_event;
-	widget_class->style_updated = ev_view_style_updated;
-	widget_class->drag_data_get = ev_view_drag_data_get;
-	widget_class->drag_motion = ev_view_drag_motion;
-	widget_class->popup_menu = ev_view_popup_menu;
-	widget_class->query_tooltip = ev_view_query_tooltip;
-	widget_class->screen_changed = ev_view_screen_changed;
-	widget_class->focus = ev_view_focus;
-	widget_class->parent_set = ev_view_parent_set;
-	widget_class->hierarchy_changed = ev_view_hierarchy_changed;
+                    GtkWidget *previous_parent) {
+  GtkWidget *parent;
+
+  parent = gtk_widget_get_parent (widget);
+  g_assert (!parent || GTK_IS_SCROLLED_WINDOW (parent));
+}
+
+static void
+ev_view_class_init (EvViewClass *class) {
+  GObjectClass *object_class = G_OBJECT_CLASS (class);
+  GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (class);
+  GtkContainerClass *container_class = GTK_CONTAINER_CLASS (class);
+  GtkBindingSet *binding_set;
+
+  object_class->get_property = ev_view_get_property;
+  object_class->set_property = ev_view_set_property;
+  object_class->dispose = ev_view_dispose;
+  object_class->finalize = ev_view_finalize;
+
+  widget_class->realize = ev_view_realize;
+  widget_class->draw = ev_view_draw;
+  widget_class->button_press_event = ev_view_button_press_event;
+  widget_class->motion_notify_event = ev_view_motion_notify_event;
+  widget_class->button_release_event = ev_view_button_release_event;
+  widget_class->key_press_event = ev_view_key_press_event;
+  widget_class->focus_in_event = ev_view_focus_in;
+  widget_class->focus_out_event = ev_view_focus_out;
+  widget_class->get_accessible = ev_view_get_accessible;
+  widget_class->get_preferred_width = ev_view_get_preferred_width;
+  widget_class->get_preferred_height = ev_view_get_preferred_height;
+  widget_class->size_allocate = ev_view_size_allocate;
+  widget_class->scroll_event = ev_view_scroll_event;
+  widget_class->enter_notify_event = ev_view_enter_notify_event;
+  widget_class->leave_notify_event = ev_view_leave_notify_event;
+  widget_class->style_updated = ev_view_style_updated;
+  widget_class->drag_data_get = ev_view_drag_data_get;
+  widget_class->drag_motion = ev_view_drag_motion;
+  widget_class->popup_menu = ev_view_popup_menu;
+  widget_class->query_tooltip = ev_view_query_tooltip;
+  widget_class->screen_changed = ev_view_screen_changed;
+  widget_class->focus = ev_view_focus;
+  widget_class->parent_set = ev_view_parent_set;
+  widget_class->hierarchy_changed = ev_view_hierarchy_changed;
 
 #if GTK_CHECK_VERSION(3, 20, 0)
-	gtk_widget_class_set_css_name (widget_class, "evview");
+  gtk_widget_class_set_css_name (widget_class, "evview");
 #endif
 
-	container_class->remove = ev_view_remove;
-	container_class->forall = ev_view_forall;
-
-	class->scroll = ev_view_scroll_internal;
-	class->move_cursor = ev_view_move_cursor;
-	class->activate = ev_view_activate;
-
-	/**
-	 * EvView:is-loading:
-	 *
-	 * Allows to implement a custom notification system.
-	 *
-	 * Since: 3.8
-	 */
-	g_object_class_install_property (object_class,
-					 PROP_IS_LOADING,
-					 g_param_spec_boolean ("is-loading",
-							       "Is Loading",
-							       "Whether the view is loading",
-							       FALSE,
-							       G_PARAM_READABLE |
-							       G_PARAM_STATIC_STRINGS));
-	/**
-	 * EvView:can-zoom-in:
-	 *
-	 * Since: 3.8
-	 */
-	g_object_class_install_property (object_class,
-					 PROP_CAN_ZOOM_IN,
-					 g_param_spec_boolean ("can-zoom-in",
-							       "Can Zoom In",
-							       "Whether the view can be zoomed in further",
-							       TRUE,
-							       G_PARAM_READABLE |
-							       G_PARAM_STATIC_STRINGS));
-	/**
-	 * EvView:can-zoom-out:
-	 *
-	 * Since: 3.8
-	 */
-	g_object_class_install_property (object_class,
-					 PROP_CAN_ZOOM_OUT,
-					 g_param_spec_boolean ("can-zoom-out",
-							       "Can Zoom Out",
-							       "Whether the view can be zoomed out further",
-							       TRUE,
-							       G_PARAM_READABLE |
-							       G_PARAM_STATIC_STRINGS));
-
-	/* Scrollable interface */
-	g_object_class_override_property (object_class, PROP_HADJUSTMENT, "hadjustment");
-	g_object_class_override_property (object_class, PROP_VADJUSTMENT, "vadjustment");
-	g_object_class_override_property (object_class, PROP_HSCROLL_POLICY, "hscroll-policy");
-	g_object_class_override_property (object_class, PROP_VSCROLL_POLICY, "vscroll-policy");
-
-	signals[SIGNAL_SCROLL] = g_signal_new ("scroll",
-	  	         G_TYPE_FROM_CLASS (object_class),
-		         G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
-		         G_STRUCT_OFFSET (EvViewClass, scroll),
-		         NULL, NULL,
-		         ev_view_marshal_VOID__ENUM_ENUM,
-		         G_TYPE_NONE, 2,
-		         GTK_TYPE_SCROLL_TYPE,
-		         GTK_TYPE_ORIENTATION);
-	signals[SIGNAL_HANDLE_LINK] = g_signal_new ("handle-link",
-	  	         G_TYPE_FROM_CLASS (object_class),
-		         G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
-		         G_STRUCT_OFFSET (EvViewClass, handle_link),
-		         NULL, NULL,
-		         g_cclosure_marshal_VOID__OBJECT,
-		         G_TYPE_NONE, 1,
-			 G_TYPE_OBJECT);
-	signals[SIGNAL_EXTERNAL_LINK] = g_signal_new ("external-link",
-	  	         G_TYPE_FROM_CLASS (object_class),
-		         G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
-		         G_STRUCT_OFFSET (EvViewClass, external_link),
-		         NULL, NULL,
-		         g_cclosure_marshal_VOID__OBJECT,
-		         G_TYPE_NONE, 1,
-			 G_TYPE_OBJECT);
-	signals[SIGNAL_POPUP_MENU] = g_signal_new ("popup",
-	  	         G_TYPE_FROM_CLASS (object_class),
-		         G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
-		         G_STRUCT_OFFSET (EvViewClass, popup_menu),
-		         NULL, NULL,
-		         g_cclosure_marshal_VOID__POINTER,
-		         G_TYPE_NONE, 1,
-			 G_TYPE_POINTER);
-	signals[SIGNAL_SELECTION_CHANGED] = g_signal_new ("selection-changed",
-                         G_TYPE_FROM_CLASS (object_class),
-                         G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
-                         G_STRUCT_OFFSET (EvViewClass, selection_changed),
-                         NULL, NULL,
-			 g_cclosure_marshal_VOID__VOID,
-                         G_TYPE_NONE, 0,
-                         G_TYPE_NONE);
-	signals[SIGNAL_SYNC_SOURCE] = g_signal_new ("sync-source",
-	  	         G_TYPE_FROM_CLASS (object_class),
-		         G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
-		         G_STRUCT_OFFSET (EvViewClass, sync_source),
-		         NULL, NULL,
-		         g_cclosure_marshal_VOID__BOXED,
-		         G_TYPE_NONE, 1,
-			 EV_TYPE_SOURCE_LINK | G_SIGNAL_TYPE_STATIC_SCOPE);
-	signals[SIGNAL_ANNOT_ADDED] = g_signal_new ("annot-added",
-	  	         G_TYPE_FROM_CLASS (object_class),
-		         G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
-		         G_STRUCT_OFFSET (EvViewClass, annot_added),
-		         NULL, NULL,
-		         g_cclosure_marshal_VOID__OBJECT,
-		         G_TYPE_NONE, 1,
-			 EV_TYPE_ANNOTATION);
-	signals[SIGNAL_ANNOT_REMOVED] = g_signal_new ("annot-removed",
-	  	         G_TYPE_FROM_CLASS (object_class),
-		         G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
-		         G_STRUCT_OFFSET (EvViewClass, annot_removed),
-		         NULL, NULL,
-		         g_cclosure_marshal_VOID__OBJECT,
-		         G_TYPE_NONE, 1,
- 		         EV_TYPE_ANNOTATION);
-	signals[SIGNAL_LAYERS_CHANGED] = g_signal_new ("layers-changed",
-	  	         G_TYPE_FROM_CLASS (object_class),
-		         G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
-		         G_STRUCT_OFFSET (EvViewClass, layers_changed),
-		         NULL, NULL,
-		         g_cclosure_marshal_VOID__VOID,
-		         G_TYPE_NONE, 0,
-			 G_TYPE_NONE);
-	signals[SIGNAL_MOVE_CURSOR] = g_signal_new ("move-cursor",
-		         G_TYPE_FROM_CLASS (object_class),
-		         G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
-		         G_STRUCT_OFFSET (EvViewClass, move_cursor),
-		         NULL, NULL,
-		         ev_view_marshal_BOOLEAN__ENUM_INT_BOOLEAN,
-		         G_TYPE_BOOLEAN, 3,
-		         GTK_TYPE_MOVEMENT_STEP,
-			 G_TYPE_INT,
-			 G_TYPE_BOOLEAN);
-	signals[SIGNAL_CURSOR_MOVED] = g_signal_new ("cursor-moved",
-			 G_TYPE_FROM_CLASS (object_class),
-			 G_SIGNAL_RUN_LAST,
-		         0,
-		         NULL, NULL,
-		         ev_view_marshal_VOID__INT_INT,
-		         G_TYPE_NONE, 2,
-		         G_TYPE_INT,
-			 G_TYPE_INT);
-	signals[SIGNAL_ACTIVATE] = g_signal_new ("activate",
-			 G_OBJECT_CLASS_TYPE (object_class),
-			 G_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION,
-			 G_STRUCT_OFFSET (EvViewClass, activate),
-			 NULL, NULL,
-			 g_cclosure_marshal_VOID__VOID,
-			 G_TYPE_NONE, 0,
-			 G_TYPE_NONE);
-	widget_class->activate_signal = signals[SIGNAL_ACTIVATE];
-
-	binding_set = gtk_binding_set_by_class (class);
-
-	add_move_binding_keypad (binding_set, GDK_KEY_Left,  0, GTK_MOVEMENT_VISUAL_POSITIONS, -1);
-	add_move_binding_keypad (binding_set, GDK_KEY_Right, 0, GTK_MOVEMENT_VISUAL_POSITIONS, 1);
-	add_move_binding_keypad (binding_set, GDK_KEY_Left,  GDK_CONTROL_MASK, GTK_MOVEMENT_WORDS, -1);
-	add_move_binding_keypad (binding_set, GDK_KEY_Right, GDK_CONTROL_MASK, GTK_MOVEMENT_WORDS, 1);
-	add_move_binding_keypad (binding_set, GDK_KEY_Up,    0, GTK_MOVEMENT_DISPLAY_LINES, -1);
-	add_move_binding_keypad (binding_set, GDK_KEY_Down,  0, GTK_MOVEMENT_DISPLAY_LINES, 1);
-	add_move_binding_keypad (binding_set, GDK_KEY_Home,  0, GTK_MOVEMENT_DISPLAY_LINE_ENDS, -1);
-	add_move_binding_keypad (binding_set, GDK_KEY_End,   0, GTK_MOVEMENT_DISPLAY_LINE_ENDS, 1);
-	add_move_binding_keypad (binding_set, GDK_KEY_Home,  GDK_CONTROL_MASK, GTK_MOVEMENT_BUFFER_ENDS, -1);
-	add_move_binding_keypad (binding_set, GDK_KEY_End,   GDK_CONTROL_MASK, GTK_MOVEMENT_BUFFER_ENDS, 1);
-
-        add_scroll_binding_keypad (binding_set, GDK_KEY_Left,  0, GTK_SCROLL_STEP_BACKWARD, GTK_ORIENTATION_HORIZONTAL);
-        add_scroll_binding_keypad (binding_set, GDK_KEY_Right, 0, GTK_SCROLL_STEP_FORWARD, GTK_ORIENTATION_HORIZONTAL);
-        add_scroll_binding_keypad (binding_set, GDK_KEY_Left,  GDK_MOD1_MASK, GTK_SCROLL_STEP_DOWN, GTK_ORIENTATION_HORIZONTAL);
-        add_scroll_binding_keypad (binding_set, GDK_KEY_Right, GDK_MOD1_MASK, GTK_SCROLL_STEP_UP, GTK_ORIENTATION_HORIZONTAL);
-        add_scroll_binding_keypad (binding_set, GDK_KEY_Up,    0, GTK_SCROLL_STEP_BACKWARD, GTK_ORIENTATION_VERTICAL);
-        add_scroll_binding_keypad (binding_set, GDK_KEY_Down,  0, GTK_SCROLL_STEP_FORWARD, GTK_ORIENTATION_VERTICAL);
-        add_scroll_binding_keypad (binding_set, GDK_KEY_Up,    GDK_MOD1_MASK, GTK_SCROLL_STEP_DOWN, GTK_ORIENTATION_VERTICAL);
-        add_scroll_binding_keypad (binding_set, GDK_KEY_Down,  GDK_MOD1_MASK, GTK_SCROLL_STEP_UP, GTK_ORIENTATION_VERTICAL);
-	add_scroll_binding_keypad (binding_set, GDK_KEY_Page_Up, 0, GTK_SCROLL_PAGE_BACKWARD, GTK_ORIENTATION_VERTICAL);
-	add_scroll_binding_keypad (binding_set, GDK_KEY_Page_Down, 0, GTK_SCROLL_PAGE_FORWARD, GTK_ORIENTATION_VERTICAL);
-	add_scroll_binding_keypad (binding_set, GDK_KEY_Home, GDK_CONTROL_MASK, GTK_SCROLL_START, GTK_ORIENTATION_VERTICAL);
-	add_scroll_binding_keypad (binding_set, GDK_KEY_End, GDK_CONTROL_MASK, GTK_SCROLL_END, GTK_ORIENTATION_VERTICAL);
-
-	/* We can't use the bindings defined in GtkWindow for Space and Return,
-	 * because we also have those bindings for scrolling.
-	 */
-	gtk_binding_entry_add_signal (binding_set, GDK_KEY_space, 0,
-				      "activate", 0);
-	gtk_binding_entry_add_signal (binding_set, GDK_KEY_KP_Space, 0,
-				      "activate", 0);
-	gtk_binding_entry_add_signal (binding_set, GDK_KEY_Return, 0,
-				      "activate", 0);
-	gtk_binding_entry_add_signal (binding_set, GDK_KEY_ISO_Enter, 0,
-				      "activate", 0);
-	gtk_binding_entry_add_signal (binding_set, GDK_KEY_KP_Enter, 0,
-				      "activate", 0);
-
-	gtk_binding_entry_add_signal (binding_set, GDK_KEY_Return, 0, "scroll", 2,
-				      GTK_TYPE_SCROLL_TYPE, GTK_SCROLL_PAGE_FORWARD,
-				      GTK_TYPE_ORIENTATION, GTK_ORIENTATION_VERTICAL);
-	gtk_binding_entry_add_signal (binding_set, GDK_KEY_Return, GDK_SHIFT_MASK, "scroll", 2,
-				      GTK_TYPE_SCROLL_TYPE, GTK_SCROLL_PAGE_BACKWARD,
-				      GTK_TYPE_ORIENTATION, GTK_ORIENTATION_VERTICAL);
-        gtk_binding_entry_add_signal (binding_set, GDK_KEY_H, 0, "scroll", 2,
-				      GTK_TYPE_SCROLL_TYPE, GTK_SCROLL_STEP_BACKWARD,
-				      GTK_TYPE_ORIENTATION, GTK_ORIENTATION_HORIZONTAL);
-	gtk_binding_entry_add_signal (binding_set, GDK_KEY_J, 0, "scroll", 2,
-				      GTK_TYPE_SCROLL_TYPE, GTK_SCROLL_STEP_FORWARD,
-				      GTK_TYPE_ORIENTATION, GTK_ORIENTATION_VERTICAL);
-	gtk_binding_entry_add_signal (binding_set, GDK_KEY_K, 0, "scroll", 2,
-				      GTK_TYPE_SCROLL_TYPE, GTK_SCROLL_STEP_BACKWARD,
-				      GTK_TYPE_ORIENTATION, GTK_ORIENTATION_VERTICAL);
-	gtk_binding_entry_add_signal (binding_set, GDK_KEY_L, 0, "scroll", 2,
-				      GTK_TYPE_SCROLL_TYPE, GTK_SCROLL_STEP_FORWARD,
-				      GTK_TYPE_ORIENTATION, GTK_ORIENTATION_HORIZONTAL);
-	gtk_binding_entry_add_signal (binding_set, GDK_KEY_space, 0, "scroll", 2,
-				      GTK_TYPE_SCROLL_TYPE, GTK_SCROLL_PAGE_FORWARD,
-				      GTK_TYPE_ORIENTATION, GTK_ORIENTATION_VERTICAL);
-	gtk_binding_entry_add_signal (binding_set, GDK_KEY_space, GDK_SHIFT_MASK, "scroll", 2,
-				      GTK_TYPE_SCROLL_TYPE, GTK_SCROLL_PAGE_BACKWARD,
-				      GTK_TYPE_ORIENTATION, GTK_ORIENTATION_VERTICAL);
-	gtk_binding_entry_add_signal (binding_set, GDK_KEY_BackSpace, 0, "scroll", 2,
-				      GTK_TYPE_SCROLL_TYPE, GTK_SCROLL_PAGE_BACKWARD,
-				      GTK_TYPE_ORIENTATION, GTK_ORIENTATION_VERTICAL);
-	gtk_binding_entry_add_signal (binding_set, GDK_KEY_BackSpace, GDK_SHIFT_MASK, "scroll", 2,
-				      GTK_TYPE_SCROLL_TYPE, GTK_SCROLL_PAGE_FORWARD,
-				      GTK_TYPE_ORIENTATION, GTK_ORIENTATION_VERTICAL);
+  container_class->remove = ev_view_remove;
+  container_class->forall = ev_view_forall;
+
+  class->scroll = ev_view_scroll_internal;
+  class->move_cursor = ev_view_move_cursor;
+  class->activate = ev_view_activate;
+
+  /**
+   * EvView:is-loading:
+   *
+   * Allows to implement a custom notification system.
+   *
+   * Since: 3.8
+   */
+  g_object_class_install_property (object_class,
+                                   PROP_IS_LOADING,
+                                   g_param_spec_boolean ("is-loading",
+                                                         "Is Loading",
+                                                         "Whether the view is loading",
+                                                         FALSE,
+                                                         G_PARAM_READABLE |
+                                                         G_PARAM_STATIC_STRINGS));
+  /**
+   * EvView:can-zoom-in:
+   *
+   * Since: 3.8
+   */
+  g_object_class_install_property (object_class,
+                                   PROP_CAN_ZOOM_IN,
+                                   g_param_spec_boolean ("can-zoom-in",
+                                                         "Can Zoom In",
+                                                         "Whether the view can be zoomed in further",
+                                                         TRUE,
+                                                         G_PARAM_READABLE |
+                                                         G_PARAM_STATIC_STRINGS));
+  /**
+   * EvView:can-zoom-out:
+   *
+   * Since: 3.8
+   */
+  g_object_class_install_property (object_class,
+                                   PROP_CAN_ZOOM_OUT,
+                                   g_param_spec_boolean ("can-zoom-out",
+                                                         "Can Zoom Out",
+                                                         "Whether the view can be zoomed out further",
+                                                         TRUE,
+                                                         G_PARAM_READABLE |
+                                                         G_PARAM_STATIC_STRINGS));
+
+  /* Scrollable interface */
+  g_object_class_override_property (object_class, PROP_HADJUSTMENT, "hadjustment");
+  g_object_class_override_property (object_class, PROP_VADJUSTMENT, "vadjustment");
+  g_object_class_override_property (object_class, PROP_HSCROLL_POLICY, "hscroll-policy");
+  g_object_class_override_property (object_class, PROP_VSCROLL_POLICY, "vscroll-policy");
+
+  signals[SIGNAL_SCROLL] = g_signal_new ("scroll",
+                                         G_TYPE_FROM_CLASS (object_class),
+                                         G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+                                         G_STRUCT_OFFSET (EvViewClass, scroll),
+                                         NULL, NULL,
+                                         ev_view_marshal_VOID__ENUM_ENUM,
+                                         G_TYPE_NONE, 2,
+                                         GTK_TYPE_SCROLL_TYPE,
+                                         GTK_TYPE_ORIENTATION);
+  signals[SIGNAL_HANDLE_LINK] = g_signal_new ("handle-link",
+                                              G_TYPE_FROM_CLASS (object_class),
+                                              G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+                                              G_STRUCT_OFFSET (EvViewClass, handle_link),
+                                              NULL, NULL,
+                                              g_cclosure_marshal_VOID__OBJECT,
+                                              G_TYPE_NONE, 1,
+                                              G_TYPE_OBJECT);
+  signals[SIGNAL_EXTERNAL_LINK] = g_signal_new ("external-link",
+                                                G_TYPE_FROM_CLASS (object_class),
+                                                G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+                                                G_STRUCT_OFFSET (EvViewClass, external_link),
+                                                NULL, NULL,
+                                                g_cclosure_marshal_VOID__OBJECT,
+                                                G_TYPE_NONE, 1,
+                                                G_TYPE_OBJECT);
+  signals[SIGNAL_POPUP_MENU] = g_signal_new ("popup",
+                                             G_TYPE_FROM_CLASS (object_class),
+                                             G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+                                             G_STRUCT_OFFSET (EvViewClass, popup_menu),
+                                             NULL, NULL,
+                                             g_cclosure_marshal_VOID__POINTER,
+                                             G_TYPE_NONE, 1,
+                                             G_TYPE_POINTER);
+  signals[SIGNAL_SELECTION_CHANGED] = g_signal_new ("selection-changed",
+                                                    G_TYPE_FROM_CLASS (object_class),
+                                                    G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+                                                    G_STRUCT_OFFSET (EvViewClass, selection_changed),
+                                                    NULL, NULL,
+                                                    g_cclosure_marshal_VOID__VOID,
+                                                    G_TYPE_NONE, 0,
+                                                    G_TYPE_NONE);
+  signals[SIGNAL_SYNC_SOURCE] = g_signal_new ("sync-source",
+                                              G_TYPE_FROM_CLASS (object_class),
+                                              G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+                                              G_STRUCT_OFFSET (EvViewClass, sync_source),
+                                              NULL, NULL,
+                                              g_cclosure_marshal_VOID__BOXED,
+                                              G_TYPE_NONE, 1,
+                                              EV_TYPE_SOURCE_LINK | G_SIGNAL_TYPE_STATIC_SCOPE);
+  signals[SIGNAL_ANNOT_ADDED] = g_signal_new ("annot-added",
+                                              G_TYPE_FROM_CLASS (object_class),
+                                              G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+                                              G_STRUCT_OFFSET (EvViewClass, annot_added),
+                                              NULL, NULL,
+                                              g_cclosure_marshal_VOID__OBJECT,
+                                              G_TYPE_NONE, 1,
+                                              EV_TYPE_ANNOTATION);
+  signals[SIGNAL_ANNOT_REMOVED] = g_signal_new ("annot-removed",
+                                                G_TYPE_FROM_CLASS (object_class),
+                                                G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+                                                G_STRUCT_OFFSET (EvViewClass, annot_removed),
+                                                NULL, NULL,
+                                                g_cclosure_marshal_VOID__OBJECT,
+                                                G_TYPE_NONE, 1,
+                                                EV_TYPE_ANNOTATION);
+  signals[SIGNAL_LAYERS_CHANGED] = g_signal_new ("layers-changed",
+                                                 G_TYPE_FROM_CLASS (object_class),
+                                                 G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+                                                 G_STRUCT_OFFSET (EvViewClass, layers_changed),
+                                                 NULL, NULL,
+                                                 g_cclosure_marshal_VOID__VOID,
+                                                 G_TYPE_NONE, 0,
+                                                 G_TYPE_NONE);
+  signals[SIGNAL_MOVE_CURSOR] = g_signal_new ("move-cursor",
+                                              G_TYPE_FROM_CLASS (object_class),
+                                              G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+                                              G_STRUCT_OFFSET (EvViewClass, move_cursor),
+                                              NULL, NULL,
+                                              ev_view_marshal_BOOLEAN__ENUM_INT_BOOLEAN,
+                                              G_TYPE_BOOLEAN, 3,
+                                              GTK_TYPE_MOVEMENT_STEP,
+                                              G_TYPE_INT,
+                                              G_TYPE_BOOLEAN);
+  signals[SIGNAL_CURSOR_MOVED] = g_signal_new ("cursor-moved",
+                                               G_TYPE_FROM_CLASS (object_class),
+                                               G_SIGNAL_RUN_LAST,
+                                               0,
+                                               NULL, NULL,
+                                               ev_view_marshal_VOID__INT_INT,
+                                               G_TYPE_NONE, 2,
+                                               G_TYPE_INT,
+                                               G_TYPE_INT);
+  signals[SIGNAL_ACTIVATE] = g_signal_new ("activate",
+                                           G_OBJECT_CLASS_TYPE (object_class),
+                                           G_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION,
+                                           G_STRUCT_OFFSET (EvViewClass, activate),
+                                           NULL, NULL,
+                                           g_cclosure_marshal_VOID__VOID,
+                                           G_TYPE_NONE, 0,
+                                           G_TYPE_NONE);
+  widget_class->activate_signal = signals[SIGNAL_ACTIVATE];
+
+  binding_set = gtk_binding_set_by_class (class);
+
+  add_move_binding_keypad (binding_set, GDK_KEY_Left,  0, GTK_MOVEMENT_VISUAL_POSITIONS, -1);
+  add_move_binding_keypad (binding_set, GDK_KEY_Right, 0, GTK_MOVEMENT_VISUAL_POSITIONS, 1);
+  add_move_binding_keypad (binding_set, GDK_KEY_Left,  GDK_CONTROL_MASK, GTK_MOVEMENT_WORDS, -1);
+  add_move_binding_keypad (binding_set, GDK_KEY_Right, GDK_CONTROL_MASK, GTK_MOVEMENT_WORDS, 1);
+  add_move_binding_keypad (binding_set, GDK_KEY_Up,    0, GTK_MOVEMENT_DISPLAY_LINES, -1);
+  add_move_binding_keypad (binding_set, GDK_KEY_Down,  0, GTK_MOVEMENT_DISPLAY_LINES, 1);
+  add_move_binding_keypad (binding_set, GDK_KEY_Home,  0, GTK_MOVEMENT_DISPLAY_LINE_ENDS, -1);
+  add_move_binding_keypad (binding_set, GDK_KEY_End,   0, GTK_MOVEMENT_DISPLAY_LINE_ENDS, 1);
+  add_move_binding_keypad (binding_set, GDK_KEY_Home,  GDK_CONTROL_MASK, GTK_MOVEMENT_BUFFER_ENDS, -1);
+  add_move_binding_keypad (binding_set, GDK_KEY_End,   GDK_CONTROL_MASK, GTK_MOVEMENT_BUFFER_ENDS, 1);
+
+  add_scroll_binding_keypad (binding_set, GDK_KEY_Left,  0, GTK_SCROLL_STEP_BACKWARD, GTK_ORIENTATION_HORIZONTAL);
+  add_scroll_binding_keypad (binding_set, GDK_KEY_Right, 0, GTK_SCROLL_STEP_FORWARD, GTK_ORIENTATION_HORIZONTAL);
+  add_scroll_binding_keypad (binding_set, GDK_KEY_Left,  GDK_MOD1_MASK, GTK_SCROLL_STEP_DOWN, GTK_ORIENTATION_HORIZONTAL);
+  add_scroll_binding_keypad (binding_set, GDK_KEY_Right, GDK_MOD1_MASK, GTK_SCROLL_STEP_UP, GTK_ORIENTATION_HORIZONTAL);
+  add_scroll_binding_keypad (binding_set, GDK_KEY_Up,    0, GTK_SCROLL_STEP_BACKWARD, GTK_ORIENTATION_VERTICAL);
+  add_scroll_binding_keypad (binding_set, GDK_KEY_Down,  0, GTK_SCROLL_STEP_FORWARD, GTK_ORIENTATION_VERTICAL);
+  add_scroll_binding_keypad (binding_set, GDK_KEY_Up,    GDK_MOD1_MASK, GTK_SCROLL_STEP_DOWN, GTK_ORIENTATION_VERTICAL);
+  add_scroll_binding_keypad (binding_set, GDK_KEY_Down,  GDK_MOD1_MASK, GTK_SCROLL_STEP_UP, GTK_ORIENTATION_VERTICAL);
+  add_scroll_binding_keypad (binding_set, GDK_KEY_Page_Up, 0, GTK_SCROLL_PAGE_BACKWARD, GTK_ORIENTATION_VERTICAL);
+  add_scroll_binding_keypad (binding_set, GDK_KEY_Page_Down, 0, GTK_SCROLL_PAGE_FORWARD, GTK_ORIENTATION_VERTICAL);
+  add_scroll_binding_keypad (binding_set, GDK_KEY_Home, GDK_CONTROL_MASK, GTK_SCROLL_START, GTK_ORIENTATION_VERTICAL);
+  add_scroll_binding_keypad (binding_set, GDK_KEY_End, GDK_CONTROL_MASK, GTK_SCROLL_END, GTK_ORIENTATION_VERTICAL);
+
+  /* We can't use the bindings defined in GtkWindow for Space and Return,
+   * because we also have those bindings for scrolling.
+   */
+  gtk_binding_entry_add_signal (binding_set, GDK_KEY_space, 0,
+                                "activate", 0);
+  gtk_binding_entry_add_signal (binding_set, GDK_KEY_KP_Space, 0,
+                                "activate", 0);
+  gtk_binding_entry_add_signal (binding_set, GDK_KEY_Return, 0,
+                                "activate", 0);
+  gtk_binding_entry_add_signal (binding_set, GDK_KEY_ISO_Enter, 0,
+                                "activate", 0);
+  gtk_binding_entry_add_signal (binding_set, GDK_KEY_KP_Enter, 0,
+                                "activate", 0);
+
+  gtk_binding_entry_add_signal (binding_set, GDK_KEY_Return, 0, "scroll", 2,
+                                GTK_TYPE_SCROLL_TYPE, GTK_SCROLL_PAGE_FORWARD,
+                                GTK_TYPE_ORIENTATION, GTK_ORIENTATION_VERTICAL);
+  gtk_binding_entry_add_signal (binding_set, GDK_KEY_Return, GDK_SHIFT_MASK, "scroll", 2,
+                                GTK_TYPE_SCROLL_TYPE, GTK_SCROLL_PAGE_BACKWARD,
+                                GTK_TYPE_ORIENTATION, GTK_ORIENTATION_VERTICAL);
+  gtk_binding_entry_add_signal (binding_set, GDK_KEY_H, 0, "scroll", 2,
+                                GTK_TYPE_SCROLL_TYPE, GTK_SCROLL_STEP_BACKWARD,
+                                GTK_TYPE_ORIENTATION, GTK_ORIENTATION_HORIZONTAL);
+  gtk_binding_entry_add_signal (binding_set, GDK_KEY_J, 0, "scroll", 2,
+                                GTK_TYPE_SCROLL_TYPE, GTK_SCROLL_STEP_FORWARD,
+                                GTK_TYPE_ORIENTATION, GTK_ORIENTATION_VERTICAL);
+  gtk_binding_entry_add_signal (binding_set, GDK_KEY_K, 0, "scroll", 2,
+                                GTK_TYPE_SCROLL_TYPE, GTK_SCROLL_STEP_BACKWARD,
+                                GTK_TYPE_ORIENTATION, GTK_ORIENTATION_VERTICAL);
+  gtk_binding_entry_add_signal (binding_set, GDK_KEY_L, 0, "scroll", 2,
+                                GTK_TYPE_SCROLL_TYPE, GTK_SCROLL_STEP_FORWARD,
+                                GTK_TYPE_ORIENTATION, GTK_ORIENTATION_HORIZONTAL);
+  gtk_binding_entry_add_signal (binding_set, GDK_KEY_space, 0, "scroll", 2,
+                                GTK_TYPE_SCROLL_TYPE, GTK_SCROLL_PAGE_FORWARD,
+                                GTK_TYPE_ORIENTATION, GTK_ORIENTATION_VERTICAL);
+  gtk_binding_entry_add_signal (binding_set, GDK_KEY_space, GDK_SHIFT_MASK, "scroll", 2,
+                                GTK_TYPE_SCROLL_TYPE, GTK_SCROLL_PAGE_BACKWARD,
+                                GTK_TYPE_ORIENTATION, GTK_ORIENTATION_VERTICAL);
+  gtk_binding_entry_add_signal (binding_set, GDK_KEY_BackSpace, 0, "scroll", 2,
+                                GTK_TYPE_SCROLL_TYPE, GTK_SCROLL_PAGE_BACKWARD,
+                                GTK_TYPE_ORIENTATION, GTK_ORIENTATION_VERTICAL);
+  gtk_binding_entry_add_signal (binding_set, GDK_KEY_BackSpace, GDK_SHIFT_MASK, "scroll", 2,
+                                GTK_TYPE_SCROLL_TYPE, GTK_SCROLL_PAGE_FORWARD,
+                                GTK_TYPE_ORIENTATION, GTK_ORIENTATION_VERTICAL);
 }
 
 static void
 on_notify_scale_factor (EvView     *view,
-			GParamSpec *pspec)
-{
-	if (view->document)
-		view_update_range_and_current_page (view);
+                        GParamSpec *pspec) {
+  if (view->document)
+    view_update_range_and_current_page (view);
 }
 
 static void
 zoom_gesture_begin_cb (GtkGesture       *gesture,
-		       GdkEventSequence *sequence,
-		       EvView           *view)
-{
-	view->prev_zoom_gesture_scale = 1;
+                       GdkEventSequence *sequence,
+                       EvView           *view) {
+  view->prev_zoom_gesture_scale = 1;
 }
 
 static void
 zoom_gesture_scale_changed_cb (GtkGestureZoom *gesture,
-			       gdouble         scale,
-			       EvView         *view)
-{
-	gdouble factor;
+                               gdouble         scale,
+                               EvView         *view) {
+  gdouble factor;
 
-	view->drag_info.in_drag = FALSE;
-	view->image_dnd_info.in_drag = FALSE;
+  view->drag_info.in_drag = FALSE;
+  view->image_dnd_info.in_drag = FALSE;
 
-	factor = scale - view->prev_zoom_gesture_scale + 1;
-	view->prev_zoom_gesture_scale = scale;
-	ev_document_model_set_sizing_mode (view->model, EV_SIZING_FREE);
+  factor = scale - view->prev_zoom_gesture_scale + 1;
+  view->prev_zoom_gesture_scale = scale;
+  ev_document_model_set_sizing_mode (view->model, EV_SIZING_FREE);
 
-	gtk_gesture_get_bounding_box_center (GTK_GESTURE (gesture), &view->zoom_center_x, &view->zoom_center_y);
+  gtk_gesture_get_bounding_box_center (GTK_GESTURE (gesture), &view->zoom_center_x, &view->zoom_center_y);
 
-	if ((factor < 1.0 && ev_view_can_zoom_out (view)) ||
-	    (factor >= 1.0 && ev_view_can_zoom_in (view)))
-		ev_view_zoom (view, factor);
+  if ((factor < 1.0 && ev_view_can_zoom_out (view)) ||
+      (factor >= 1.0 && ev_view_can_zoom_in (view)))
+    ev_view_zoom (view, factor);
 }
 
 static void
-ev_view_init (EvView *view)
-{
-	GtkStyleContext *context;
+ev_view_init (EvView *view) {
+  GtkStyleContext *context;
 #if defined (ENABLE_MULTIMEDIA) && defined (GDK_WINDOWING_X11)
-	GdkVisual       *visual;
+  GdkVisual       *visual;
 #endif
 
-	gtk_widget_set_has_window (GTK_WIDGET (view), TRUE);
-	gtk_widget_set_can_focus (GTK_WIDGET (view), TRUE);
-	gtk_widget_set_redraw_on_allocate (GTK_WIDGET (view), FALSE);
+  gtk_widget_set_has_window (GTK_WIDGET (view), TRUE);
+  gtk_widget_set_can_focus (GTK_WIDGET (view), TRUE);
+  gtk_widget_set_redraw_on_allocate (GTK_WIDGET (view), FALSE);
 
-	context = gtk_widget_get_style_context (GTK_WIDGET (view));
-	gtk_style_context_add_class (context, "content-view");
-	gtk_style_context_add_class (context, "view");
+  context = gtk_widget_get_style_context (GTK_WIDGET (view));
+  gtk_style_context_add_class (context, "content-view");
+  gtk_style_context_add_class (context, "view");
 
 #if defined (ENABLE_MULTIMEDIA) && defined (GDK_WINDOWING_X11)
-	/* Use always the system visual, instead of the one inherited from the
-	 * window, because gst xvimagesink doesn't work with RGBA visuals.
-	 * See https://bugzilla.gnome.org/show_bug.cgi?id=721148
-	 */
-	visual = gdk_screen_get_system_visual (gdk_screen_get_default ());
-	gtk_widget_set_visual (GTK_WIDGET (view), visual);
+  /* Use always the system visual, instead of the one inherited from the
+   * window, because gst xvimagesink doesn't work with RGBA visuals.
+   * See https://bugzilla.gnome.org/show_bug.cgi?id=721148
+   */
+  visual = gdk_screen_get_system_visual (gdk_screen_get_default ());
+  gtk_widget_set_visual (GTK_WIDGET (view), visual);
 #endif
 
-	gtk_widget_set_events (GTK_WIDGET (view),
-			       GDK_TOUCH_MASK |
-			       GDK_EXPOSURE_MASK |
-			       GDK_BUTTON_PRESS_MASK |
-			       GDK_BUTTON_RELEASE_MASK |
-			       GDK_SCROLL_MASK |
-			       GDK_SMOOTH_SCROLL_MASK |
-			       GDK_KEY_PRESS_MASK |
-			       GDK_POINTER_MOTION_MASK |
-			       GDK_POINTER_MOTION_HINT_MASK |
-			       GDK_ENTER_NOTIFY_MASK |
-			       GDK_LEAVE_NOTIFY_MASK);
-
-	view->start_page = -1;
-	view->end_page = -1;
-	view->spacing = 5;
-	view->scale = 1.0;
-	view->current_page = 0;
-	view->pressed_button = -1;
-	view->cursor = EV_VIEW_CURSOR_NORMAL;
-	view->drag_info.in_drag = FALSE;
-	view->scroll_info.autoscrolling = FALSE;
-	view->selection_info.selections = NULL;
-	view->selection_info.in_drag = FALSE;
-	view->continuous = TRUE;
-	view->dual_even_left = TRUE;
-	view->fullscreen = FALSE;
-	view->sizing_mode = EV_SIZING_FIT_WIDTH;
-	view->page_layout = EV_PAGE_LAYOUT_SINGLE;
-	view->pending_scroll = SCROLL_TO_KEEP_POSITION;
-	view->find_page = -1;
-	view->jump_to_find_result = TRUE;
-	view->highlight_find_results = FALSE;
-	view->pixbuf_cache_size = DEFAULT_PIXBUF_CACHE_SIZE;
-	view->caret_enabled = FALSE;
-	view->cursor_page = 0;
-	view->allow_links_change_zoom = TRUE;
-	view->zoom_center_x = -1;
-	view->zoom_center_y = -1;
-
-	g_signal_connect (view, "notify::scale-factor",
-			  G_CALLBACK (on_notify_scale_factor), NULL);
-
-	view->zoom_gesture = gtk_gesture_zoom_new (GTK_WIDGET (view));
-	gtk_event_controller_set_propagation_phase (GTK_EVENT_CONTROLLER (view->zoom_gesture),
-						    GTK_PHASE_CAPTURE);
-
-	g_signal_connect (view->zoom_gesture, "begin",
-			  G_CALLBACK (zoom_gesture_begin_cb), view);
-	g_signal_connect (view->zoom_gesture, "scale-changed",
-			  G_CALLBACK (zoom_gesture_scale_changed_cb), view);
+  gtk_widget_set_events (GTK_WIDGET (view),
+                         GDK_TOUCH_MASK |
+                         GDK_EXPOSURE_MASK |
+                         GDK_BUTTON_PRESS_MASK |
+                         GDK_BUTTON_RELEASE_MASK |
+                         GDK_SCROLL_MASK |
+                         GDK_SMOOTH_SCROLL_MASK |
+                         GDK_KEY_PRESS_MASK |
+                         GDK_POINTER_MOTION_MASK |
+                         GDK_POINTER_MOTION_HINT_MASK |
+                         GDK_ENTER_NOTIFY_MASK |
+                         GDK_LEAVE_NOTIFY_MASK);
+
+  view->start_page = -1;
+  view->end_page = -1;
+  view->spacing = 5;
+  view->scale = 1.0;
+  view->current_page = 0;
+  view->pressed_button = -1;
+  view->cursor = EV_VIEW_CURSOR_NORMAL;
+  view->drag_info.in_drag = FALSE;
+  view->scroll_info.autoscrolling = FALSE;
+  view->selection_info.selections = NULL;
+  view->selection_info.in_drag = FALSE;
+  view->continuous = TRUE;
+  view->dual_even_left = TRUE;
+  view->fullscreen = FALSE;
+  view->sizing_mode = EV_SIZING_FIT_WIDTH;
+  view->page_layout = EV_PAGE_LAYOUT_SINGLE;
+  view->pending_scroll = SCROLL_TO_KEEP_POSITION;
+  view->find_page = -1;
+  view->jump_to_find_result = TRUE;
+  view->highlight_find_results = FALSE;
+  view->pixbuf_cache_size = DEFAULT_PIXBUF_CACHE_SIZE;
+  view->caret_enabled = FALSE;
+  view->cursor_page = 0;
+  view->allow_links_change_zoom = TRUE;
+  view->zoom_center_x = -1;
+  view->zoom_center_y = -1;
+
+  g_signal_connect (view, "notify::scale-factor",
+                    G_CALLBACK (on_notify_scale_factor), NULL);
+
+  view->zoom_gesture = gtk_gesture_zoom_new (GTK_WIDGET (view));
+  gtk_event_controller_set_propagation_phase (GTK_EVENT_CONTROLLER (view->zoom_gesture),
+                                              GTK_PHASE_CAPTURE);
+
+  g_signal_connect (view->zoom_gesture, "begin",
+                    G_CALLBACK (zoom_gesture_begin_cb), view);
+  g_signal_connect (view->zoom_gesture, "scale-changed",
+                    G_CALLBACK (zoom_gesture_scale_changed_cb), view);
 }
 
 /*** Callbacks ***/
 
 static void
 ev_view_change_page (EvView *view,
-		     gint    new_page)
-{
-	gint x, y;
+                     gint    new_page) {
+  gint x, y;
 
-	view->current_page = new_page;
-	view->pending_scroll = SCROLL_TO_PAGE_POSITION;
+  view->current_page = new_page;
+  view->pending_scroll = SCROLL_TO_PAGE_POSITION;
 
-	ev_view_set_loading (view, FALSE);
+  ev_view_set_loading (view, FALSE);
 
-	ev_document_misc_get_pointer_position (GTK_WIDGET (view), &x, &y);
-	ev_view_handle_cursor_over_xy (view, x, y);
+  ev_document_misc_get_pointer_position (GTK_WIDGET (view), &x, &y);
+  ev_view_handle_cursor_over_xy (view, x, y);
 
-	gtk_widget_queue_resize (GTK_WIDGET (view));
+  gtk_widget_queue_resize (GTK_WIDGET (view));
 }
 
 static void
 job_finished_cb (EvPixbufCache  *pixbuf_cache,
-		 cairo_region_t *region,
-		 EvView         *view)
-{
-	if (region) {
-		gdk_window_invalidate_region (gtk_widget_get_window (GTK_WIDGET (view)), region, TRUE);
-	} else {
-		gtk_widget_queue_draw (GTK_WIDGET (view));
-	}
+                 cairo_region_t *region,
+                 EvView         *view) {
+  if (region) {
+    gdk_window_invalidate_region (gtk_widget_get_window (GTK_WIDGET (view)), region, TRUE);
+  } else {
+    gtk_widget_queue_draw (GTK_WIDGET (view));
+  }
 }
 
 static void
 ev_view_page_changed_cb (EvDocumentModel *model,
-			 gint             old_page,
-			 gint             new_page,
-			 EvView          *view)
-{
-	if (!view->document)
-		return;
+                         gint             old_page,
+                         gint             new_page,
+                         EvView          *view) {
+  if (!view->document)
+    return;
 
-	if (view->current_page != new_page) {
-		ev_view_change_page (view, new_page);
-	} else {
-		gtk_widget_queue_draw (GTK_WIDGET (view));
-	}
+  if (view->current_page != new_page) {
+    ev_view_change_page (view, new_page);
+  } else {
+    gtk_widget_queue_draw (GTK_WIDGET (view));
+  }
 }
 
 static gboolean
-cursor_scroll_update (gpointer data)
-{
-	EvView *view = data;
-	gint x, y;
+cursor_scroll_update (gpointer data) {
+  EvView *view = data;
+  gint x, y;
 
-	view->update_cursor_idle_id = 0;
-	ev_document_misc_get_pointer_position (GTK_WIDGET (view), &x, &y);
-	ev_view_handle_cursor_over_xy (view, x, y);
+  view->update_cursor_idle_id = 0;
+  ev_document_misc_get_pointer_position (GTK_WIDGET (view), &x, &y);
+  ev_view_handle_cursor_over_xy (view, x, y);
 
-	return FALSE;
+  return FALSE;
 }
 
 static void
-schedule_scroll_cursor_update (EvView *view)
-{
-	if (view->update_cursor_idle_id)
-		return;
+schedule_scroll_cursor_update (EvView *view) {
+  if (view->update_cursor_idle_id)
+    return;
 
-	view->update_cursor_idle_id =
-		g_idle_add (cursor_scroll_update, view);
+  view->update_cursor_idle_id =
+    g_idle_add (cursor_scroll_update, view);
 }
 
 static void
 on_adjustment_value_changed (GtkAdjustment *adjustment,
-			     EvView        *view)
-{
-	GtkWidget *widget = GTK_WIDGET (view);
-	int dx = 0, dy = 0;
-	gdouble x, y;
-	gint value;
-	GList *l;
-	GdkEvent *event;
-	gboolean cursor_updated;
-
-	if (!gtk_widget_get_realized (widget))
-		return;
-
-	/* If the adjustment value is set during a drag event, update the drag
-	 * start position so it can continue from the new location. */
-	if (view->drag_info.in_drag && !view->drag_info.in_notify) {
-		view->drag_info.hadj += gtk_adjustment_get_value (view->hadjustment) - view->scroll_x;
-		view->drag_info.vadj += gtk_adjustment_get_value (view->vadjustment) - view->scroll_y;
-	}
-
-	if (view->hadjustment) {
-		value = (gint) gtk_adjustment_get_value (view->hadjustment);
-		dx = view->scroll_x - value;
-		view->scroll_x = value;
-	} else {
-		view->scroll_x = 0;
-	}
-
-	if (view->vadjustment) {
-		value = (gint) gtk_adjustment_get_value (view->vadjustment);
-		dy = view->scroll_y - value;
-		view->scroll_y = value;
-	} else {
-		view->scroll_y = 0;
-	}
-
-	for (l = view->children; l && l->data; l = g_list_next (l)) {
-		EvViewChild *child = (EvViewChild *)l->data;
-
-		child->x += dx;
-		child->y += dy;
-		if (gtk_widget_get_visible (child->widget) && gtk_widget_get_visible (widget))
-			gtk_widget_queue_resize (widget);
-	}
-
-	for (l = view->window_children; l && l->data; l = g_list_next (l)) {
-		EvViewWindowChild *child;
-
-		child = (EvViewWindowChild *)l->data;
-
-		ev_view_window_child_move (view, child, child->x + dx, child->y + dy);
-	}
-
-	if (view->pending_resize) {
-		gtk_widget_queue_draw (widget);
-	} else {
-		gdk_window_scroll (gtk_widget_get_window (widget), dx, dy);
-	}
-
-	cursor_updated = FALSE;
-	event = gtk_get_current_event ();
-	if (event) {
-		if (event->type == GDK_SCROLL &&
-		    gdk_event_get_window (event) == gtk_widget_get_window (widget)) {
-			gdk_event_get_coords (event, &x, &y);
-			ev_view_handle_cursor_over_xy (view, (gint) x, (gint) y);
-			cursor_updated = TRUE;
-		}
-		gdk_event_free (event);
-	}
-
-	if (!cursor_updated)
-		schedule_scroll_cursor_update (view);
-
-	if (view->document)
-		view_update_range_and_current_page (view);
-}
-
-GtkWidget*
-ev_view_new (void)
-{
-	GtkWidget *view;
-
-	view = g_object_new (EV_TYPE_VIEW, NULL);
-
-	return view;
-}
-
-static void
-setup_caches (EvView *view)
-{
-	gboolean inverted_colors;
-
-	view->height_to_page_cache = ev_view_get_height_to_page_cache (view);
-	view->pixbuf_cache = ev_pixbuf_cache_new (GTK_WIDGET (view), view->model, view->pixbuf_cache_size);
-	view->page_cache = ev_page_cache_new (view->document);
-
-	ev_page_cache_set_flags (view->page_cache,
-				 ev_page_cache_get_flags (view->page_cache) |
-				 EV_PAGE_DATA_INCLUDE_TEXT_LAYOUT |
-				 EV_PAGE_DATA_INCLUDE_TEXT |
-				 EV_PAGE_DATA_INCLUDE_TEXT_ATTRS |
-		                 EV_PAGE_DATA_INCLUDE_TEXT_LOG_ATTRS);
-
-	inverted_colors = ev_document_model_get_inverted_colors (view->model);
-	ev_pixbuf_cache_set_inverted_colors (view->pixbuf_cache, inverted_colors);
-	g_signal_connect (view->pixbuf_cache, "job-finished", G_CALLBACK (job_finished_cb), view);
+                             EvView        *view) {
+  GtkWidget *widget = GTK_WIDGET (view);
+  int dx = 0, dy = 0;
+  gdouble x, y;
+  gint value;
+  GList *l;
+  GdkEvent *event;
+  gboolean cursor_updated;
+
+  if (!gtk_widget_get_realized (widget))
+    return;
+
+  /* If the adjustment value is set during a drag event, update the drag
+   * start position so it can continue from the new location. */
+  if (view->drag_info.in_drag && !view->drag_info.in_notify) {
+    view->drag_info.hadj += gtk_adjustment_get_value (view->hadjustment) - view->scroll_x;
+    view->drag_info.vadj += gtk_adjustment_get_value (view->vadjustment) - view->scroll_y;
+  }
+
+  if (view->hadjustment) {
+    value = (gint) gtk_adjustment_get_value (view->hadjustment);
+    dx = view->scroll_x - value;
+    view->scroll_x = value;
+  } else {
+    view->scroll_x = 0;
+  }
+
+  if (view->vadjustment) {
+    value = (gint) gtk_adjustment_get_value (view->vadjustment);
+    dy = view->scroll_y - value;
+    view->scroll_y = value;
+  } else {
+    view->scroll_y = 0;
+  }
+
+  for (l = view->children; l && l->data; l = g_list_next (l)) {
+    EvViewChild *child = (EvViewChild *)l->data;
+
+    child->x += dx;
+    child->y += dy;
+    if (gtk_widget_get_visible (child->widget) && gtk_widget_get_visible (widget))
+      gtk_widget_queue_resize (widget);
+  }
+
+  for (l = view->window_children; l && l->data; l = g_list_next (l)) {
+    EvViewWindowChild *child;
+
+    child = (EvViewWindowChild *)l->data;
+
+    ev_view_window_child_move (view, child, child->x + dx, child->y + dy);
+  }
+
+  if (view->pending_resize) {
+    gtk_widget_queue_draw (widget);
+  } else {
+    gdk_window_scroll (gtk_widget_get_window (widget), dx, dy);
+  }
+
+  cursor_updated = FALSE;
+  event = gtk_get_current_event ();
+  if (event) {
+    if (event->type == GDK_SCROLL &&
+        gdk_event_get_window (event) == gtk_widget_get_window (widget)) {
+      gdk_event_get_coords (event, &x, &y);
+      ev_view_handle_cursor_over_xy (view, (gint) x, (gint) y);
+      cursor_updated = TRUE;
+    }
+    gdk_event_free (event);
+  }
+
+  if (!cursor_updated)
+    schedule_scroll_cursor_update (view);
+
+  if (view->document)
+    view_update_range_and_current_page (view);
+}
+
+GtkWidget *
+ev_view_new (void) {
+  GtkWidget *view;
+
+  view = g_object_new (EV_TYPE_VIEW, NULL);
+
+  return view;
 }
 
 static void
-clear_caches (EvView *view)
-{
-	if (view->pixbuf_cache) {
-		g_object_unref (view->pixbuf_cache);
-		view->pixbuf_cache = NULL;
-	}
+setup_caches (EvView *view) {
+  gboolean inverted_colors;
 
-	if (view->page_cache) {
-		g_object_unref (view->page_cache);
-		view->page_cache = NULL;
-	}
+  view->height_to_page_cache = ev_view_get_height_to_page_cache (view);
+  view->pixbuf_cache = ev_pixbuf_cache_new (GTK_WIDGET (view), view->model, view->pixbuf_cache_size);
+  view->page_cache = ev_page_cache_new (view->document);
+
+  ev_page_cache_set_flags (view->page_cache,
+                           ev_page_cache_get_flags (view->page_cache) |
+                           EV_PAGE_DATA_INCLUDE_TEXT_LAYOUT |
+                           EV_PAGE_DATA_INCLUDE_TEXT |
+                           EV_PAGE_DATA_INCLUDE_TEXT_ATTRS |
+                           EV_PAGE_DATA_INCLUDE_TEXT_LOG_ATTRS);
+
+  inverted_colors = ev_document_model_get_inverted_colors (view->model);
+  ev_pixbuf_cache_set_inverted_colors (view->pixbuf_cache, inverted_colors);
+  g_signal_connect (view->pixbuf_cache, "job-finished", G_CALLBACK (job_finished_cb), view);
+}
+
+static void
+clear_caches (EvView *view) {
+  if (view->pixbuf_cache) {
+    g_object_unref (view->pixbuf_cache);
+    view->pixbuf_cache = NULL;
+  }
+
+  if (view->page_cache) {
+    g_object_unref (view->page_cache);
+    view->page_cache = NULL;
+  }
 }
 
 /**
@@ -8298,16 +8049,15 @@ clear_caches (EvView *view)
  */
 void
 ev_view_set_page_cache_size (EvView *view,
-			     gsize   cache_size)
-{
-	if (view->pixbuf_cache_size == cache_size)
-		return;
+                             gsize   cache_size) {
+  if (view->pixbuf_cache_size == cache_size)
+    return;
 
-	view->pixbuf_cache_size = cache_size;
-	if (view->pixbuf_cache)
-		ev_pixbuf_cache_set_max_size (view->pixbuf_cache, cache_size);
+  view->pixbuf_cache_size = cache_size;
+  if (view->pixbuf_cache)
+    ev_pixbuf_cache_set_max_size (view->pixbuf_cache, cache_size);
 
-	view_update_scale_limits (view);
+  view_update_scale_limits (view);
 }
 
 /**
@@ -8319,13 +8069,12 @@ ev_view_set_page_cache_size (EvView *view,
  */
 void
 ev_view_set_loading (EvView 	  *view,
-		     gboolean      loading)
-{
-	if (view->loading == loading)
-		return;
+                     gboolean      loading) {
+  if (view->loading == loading)
+    return;
 
-	view->loading = loading;
-	g_object_notify (G_OBJECT (view), "is-loading");
+  view->loading = loading;
+  g_object_notify (G_OBJECT (view), "is-loading");
 }
 
 /**
@@ -8337,757 +8086,719 @@ ev_view_set_loading (EvView 	  *view,
  * Since: 3.8
  */
 gboolean
-ev_view_is_loading (EvView *view)
-{
-	return view->loading;
+ev_view_is_loading (EvView *view) {
+  return view->loading;
 }
 
 void
-ev_view_autoscroll_start (EvView *view)
-{
-	gint x, y;
-	
-	g_return_if_fail (EV_IS_VIEW (view));
+ev_view_autoscroll_start (EvView *view) {
+  gint x, y;
+
+  g_return_if_fail (EV_IS_VIEW (view));
 
-	if (view->scroll_info.autoscrolling)
-		return;
-	
-	view->scroll_info.autoscrolling = TRUE;
-	ev_view_autoscroll_resume (view);
+  if (view->scroll_info.autoscrolling)
+    return;
 
-	ev_document_misc_get_pointer_position (GTK_WIDGET (view), &x, &y);
-	ev_view_handle_cursor_over_xy (view, x, y);
+  view->scroll_info.autoscrolling = TRUE;
+  ev_view_autoscroll_resume (view);
+
+  ev_document_misc_get_pointer_position (GTK_WIDGET (view), &x, &y);
+  ev_view_handle_cursor_over_xy (view, x, y);
 }
 
 void
-ev_view_autoscroll_stop (EvView *view)
-{
-	gint x, y;
-	
-	g_return_if_fail (EV_IS_VIEW (view));
+ev_view_autoscroll_stop (EvView *view) {
+  gint x, y;
+
+  g_return_if_fail (EV_IS_VIEW (view));
 
-	if (!view->scroll_info.autoscrolling)
-		return;
+  if (!view->scroll_info.autoscrolling)
+    return;
 
-	view->scroll_info.autoscrolling = FALSE;
-	ev_view_autoscroll_pause (view);
+  view->scroll_info.autoscrolling = FALSE;
+  ev_view_autoscroll_pause (view);
 
-	ev_document_misc_get_pointer_position (GTK_WIDGET (view), &x, &y);
-	ev_view_handle_cursor_over_xy (view, x, y);
+  ev_document_misc_get_pointer_position (GTK_WIDGET (view), &x, &y);
+  ev_view_handle_cursor_over_xy (view, x, y);
 }
 
 static void
 ev_view_document_changed_cb (EvDocumentModel *model,
-			     GParamSpec      *pspec,
-			     EvView          *view)
-{
-	EvDocument *document = ev_document_model_get_document (model);
+                             GParamSpec      *pspec,
+                             EvView          *view) {
+  EvDocument *document = ev_document_model_get_document (model);
 
-	if (document != view->document) {
-		gint current_page;
+  if (document != view->document) {
+    gint current_page;
 
-		ev_view_remove_all (view);
-		clear_caches (view);
+    ev_view_remove_all (view);
+    clear_caches (view);
 
-		if (view->document) {
-			g_object_unref (view->document);
-                }
+    if (view->document) {
+      g_object_unref (view->document);
+    }
 
-		view->document = document ? g_object_ref (document) : NULL;
-		view->find_page = -1;
-		view->find_result = 0;
+    view->document = document ? g_object_ref (document) : NULL;
+    view->find_page = -1;
+    view->find_result = 0;
 
-		if (view->document) {
-			if (ev_document_get_n_pages (view->document) <= 0 ||
-			    !ev_document_check_dimensions (view->document))
-				return;
+    if (view->document) {
+      if (ev_document_get_n_pages (view->document) <= 0 ||
+          !ev_document_check_dimensions (view->document))
+        return;
 
-			ev_view_set_loading (view, FALSE);
-			setup_caches (view);
+      ev_view_set_loading (view, FALSE);
+      setup_caches (view);
 
-			if (view->caret_enabled)
-				preload_pages_for_caret_navigation (view);
-		}
+      if (view->caret_enabled)
+        preload_pages_for_caret_navigation (view);
+    }
 
-		current_page = ev_document_model_get_page (model);
-		if (view->current_page != current_page) {
-			ev_view_change_page (view, current_page);
-		} else {
-			view->pending_scroll = SCROLL_TO_KEEP_POSITION;
-			gtk_widget_queue_resize (GTK_WIDGET (view));
-		}
-		view_update_scale_limits (view);
-	}
+    current_page = ev_document_model_get_page (model);
+    if (view->current_page != current_page) {
+      ev_view_change_page (view, current_page);
+    } else {
+      view->pending_scroll = SCROLL_TO_KEEP_POSITION;
+      gtk_widget_queue_resize (GTK_WIDGET (view));
+    }
+    view_update_scale_limits (view);
+  }
 }
 
 static void
 ev_view_rotation_changed_cb (EvDocumentModel *model,
-			     GParamSpec      *pspec,
-			     EvView          *view)
-{
-	gint rotation = ev_document_model_get_rotation (model);
+                             GParamSpec      *pspec,
+                             EvView          *view) {
+  gint rotation = ev_document_model_get_rotation (model);
 
-	view->rotation = rotation;
+  view->rotation = rotation;
 
-	if (view->pixbuf_cache) {
-		ev_pixbuf_cache_clear (view->pixbuf_cache);
-		if (!ev_document_is_page_size_uniform (view->document))
-			view->pending_scroll = SCROLL_TO_PAGE_POSITION;
-		gtk_widget_queue_resize (GTK_WIDGET (view));
-	}
+  if (view->pixbuf_cache) {
+    ev_pixbuf_cache_clear (view->pixbuf_cache);
+    if (!ev_document_is_page_size_uniform (view->document))
+      view->pending_scroll = SCROLL_TO_PAGE_POSITION;
+    gtk_widget_queue_resize (GTK_WIDGET (view));
+  }
 
-	ev_view_remove_all (view);
-	view_update_scale_limits (view);
+  ev_view_remove_all (view);
+  view_update_scale_limits (view);
 
-	if (rotation != 0)
-		clear_selection (view);
+  if (rotation != 0)
+    clear_selection (view);
 }
 
 static void
 ev_view_inverted_colors_changed_cb (EvDocumentModel *model,
-				    GParamSpec      *pspec,
-				    EvView          *view)
-{
-	if (view->pixbuf_cache) {
-		gboolean inverted_colors;
+                                    GParamSpec      *pspec,
+                                    EvView          *view) {
+  if (view->pixbuf_cache) {
+    gboolean inverted_colors;
 
-		inverted_colors = ev_document_model_get_inverted_colors (model);
-		ev_pixbuf_cache_set_inverted_colors (view->pixbuf_cache, inverted_colors);
-		gtk_widget_queue_draw (GTK_WIDGET (view));
-	}
+    inverted_colors = ev_document_model_get_inverted_colors (model);
+    ev_pixbuf_cache_set_inverted_colors (view->pixbuf_cache, inverted_colors);
+    gtk_widget_queue_draw (GTK_WIDGET (view));
+  }
 }
 
 static void
 ev_view_sizing_mode_changed_cb (EvDocumentModel *model,
-				GParamSpec      *pspec,
-				EvView          *view)
-{
-	EvSizingMode mode = ev_document_model_get_sizing_mode (model);
+                                GParamSpec      *pspec,
+                                EvView          *view) {
+  EvSizingMode mode = ev_document_model_get_sizing_mode (model);
 
-	view->sizing_mode = mode;
-	if (mode != EV_SIZING_FREE)
-		gtk_widget_queue_resize (GTK_WIDGET (view));
+  view->sizing_mode = mode;
+  if (mode != EV_SIZING_FREE)
+    gtk_widget_queue_resize (GTK_WIDGET (view));
 }
 
 static void
-update_can_zoom (EvView *view)
-{
-	gdouble min_scale;
-	gdouble max_scale;
-	gboolean can_zoom_in;
-	gboolean can_zoom_out;
+update_can_zoom (EvView *view) {
+  gdouble min_scale;
+  gdouble max_scale;
+  gboolean can_zoom_in;
+  gboolean can_zoom_out;
 
-	min_scale = ev_document_model_get_min_scale (view->model);
-	max_scale = ev_document_model_get_max_scale (view->model);
+  min_scale = ev_document_model_get_min_scale (view->model);
+  max_scale = ev_document_model_get_max_scale (view->model);
 
-	can_zoom_in = view->scale <= max_scale;
-	can_zoom_out = view->scale > min_scale;
+  can_zoom_in = view->scale <= max_scale;
+  can_zoom_out = view->scale > min_scale;
 
-	if (can_zoom_in != view->can_zoom_in) {
-		view->can_zoom_in = can_zoom_in;
-		g_object_notify (G_OBJECT (view), "can-zoom-in");
-	}
+  if (can_zoom_in != view->can_zoom_in) {
+    view->can_zoom_in = can_zoom_in;
+    g_object_notify (G_OBJECT (view), "can-zoom-in");
+  }
 
-	if (can_zoom_out != view->can_zoom_out) {
-		view->can_zoom_out = can_zoom_out;
-		g_object_notify (G_OBJECT (view), "can-zoom-out");
-	}
+  if (can_zoom_out != view->can_zoom_out) {
+    view->can_zoom_out = can_zoom_out;
+    g_object_notify (G_OBJECT (view), "can-zoom-out");
+  }
 }
 
 static void
 ev_view_page_layout_changed_cb (EvDocumentModel *model,
-				GParamSpec      *pspec,
-				EvView          *view)
-{
-	EvPageLayout layout = ev_document_model_get_page_layout (model);
+                                GParamSpec      *pspec,
+                                EvView          *view) {
+  EvPageLayout layout = ev_document_model_get_page_layout (model);
 
-	view->page_layout = layout;
+  view->page_layout = layout;
 
-	view->pending_scroll = SCROLL_TO_PAGE_POSITION;
-	gtk_widget_queue_resize (GTK_WIDGET (view));
+  view->pending_scroll = SCROLL_TO_PAGE_POSITION;
+  gtk_widget_queue_resize (GTK_WIDGET (view));
 
-	/* FIXME: if we're keeping the pixbuf cache around, we should extend the
-	 * preload_cache_size to be 2 if dual_page is set.
-	 */
+  /* FIXME: if we're keeping the pixbuf cache around, we should extend the
+   * preload_cache_size to be 2 if dual_page is set.
+   */
 }
 
 #define EPSILON 0.0000001
 static void
 ev_view_scale_changed_cb (EvDocumentModel *model,
-			  GParamSpec      *pspec,
-			  EvView          *view)
-{
-	gdouble scale = ev_document_model_get_scale (model);
+                          GParamSpec      *pspec,
+                          EvView          *view) {
+  gdouble scale = ev_document_model_get_scale (model);
 
-	if (ABS (view->scale - scale) < EPSILON)
-		return;
+  if (ABS (view->scale - scale) < EPSILON)
+    return;
 
-	view->scale = scale;
+  view->scale = scale;
 
-	view->pending_resize = TRUE;
-	if (view->sizing_mode == EV_SIZING_FREE)
-		gtk_widget_queue_resize (GTK_WIDGET (view));
+  view->pending_resize = TRUE;
+  if (view->sizing_mode == EV_SIZING_FREE)
+    gtk_widget_queue_resize (GTK_WIDGET (view));
 
-	update_can_zoom (view);
+  update_can_zoom (view);
 }
 
 static void
 ev_view_min_scale_changed_cb (EvDocumentModel *model,
-			      GParamSpec      *pspec,
-			      EvView          *view)
-{
-	update_can_zoom (view);
+                              GParamSpec      *pspec,
+                              EvView          *view) {
+  update_can_zoom (view);
 }
 
 static void
 ev_view_max_scale_changed_cb (EvDocumentModel *model,
-			      GParamSpec      *pspec,
-			      EvView          *view)
-{
-	update_can_zoom (view);
+                              GParamSpec      *pspec,
+                              EvView          *view) {
+  update_can_zoom (view);
 }
 
 static void
 ev_view_continuous_changed_cb (EvDocumentModel *model,
-			       GParamSpec      *pspec,
-			       EvView          *view)
-{
-	gboolean continuous = ev_document_model_get_continuous (model);
-
-	if (view->document) {
-		GdkPoint     view_point;
-		GdkRectangle page_area;
-		GtkBorder    border;
-
-		view_point.x = view->scroll_x;
-		view_point.y = view->scroll_y;
-		ev_view_get_page_extents (view, view->start_page, &page_area, &border);
-		_ev_view_transform_view_point_to_doc_point (view, &view_point,
-							    &page_area, &border,
-							    &view->pending_point.x,
-							    &view->pending_point.y);
-	}
-	view->continuous = continuous;
-	view->pending_scroll = SCROLL_TO_PAGE_POSITION;
-	gtk_widget_queue_resize (GTK_WIDGET (view));
+                               GParamSpec      *pspec,
+                               EvView          *view) {
+  gboolean continuous = ev_document_model_get_continuous (model);
+
+  if (view->document) {
+    GdkPoint     view_point;
+    GdkRectangle page_area;
+    GtkBorder    border;
+
+    view_point.x = view->scroll_x;
+    view_point.y = view->scroll_y;
+    ev_view_get_page_extents (view, view->start_page, &page_area, &border);
+    _ev_view_transform_view_point_to_doc_point (view, &view_point,
+                                                &page_area, &border,
+                                                &view->pending_point.x,
+                                                &view->pending_point.y);
+  }
+  view->continuous = continuous;
+  view->pending_scroll = SCROLL_TO_PAGE_POSITION;
+  gtk_widget_queue_resize (GTK_WIDGET (view));
 }
 
 static void
 ev_view_dual_odd_left_changed_cb (EvDocumentModel *model,
-				  GParamSpec      *pspec,
-				  EvView          *view)
-{
-	view->dual_even_left = !ev_document_model_get_dual_page_odd_pages_left (model);
-	view->pending_scroll = SCROLL_TO_PAGE_POSITION;
-	if (ev_document_model_get_dual_page (model))
-		/* odd_left may be set when not in dual mode,
-		   queue_resize is not needed in that case */
-		gtk_widget_queue_resize (GTK_WIDGET (view));
+                                  GParamSpec      *pspec,
+                                  EvView          *view) {
+  view->dual_even_left = !ev_document_model_get_dual_page_odd_pages_left (model);
+  view->pending_scroll = SCROLL_TO_PAGE_POSITION;
+  if (ev_document_model_get_dual_page (model))
+    /* odd_left may be set when not in dual mode,
+       queue_resize is not needed in that case */
+    gtk_widget_queue_resize (GTK_WIDGET (view));
 }
 
 static void
 ev_view_direction_changed_cb (EvDocumentModel *model,
                               GParamSpec      *pspec,
-                              EvView          *view)
-{
-	gboolean rtl = ev_document_model_get_rtl (model);
-	gtk_widget_set_direction (GTK_WIDGET (view), rtl ? GTK_TEXT_DIR_RTL : GTK_TEXT_DIR_LTR);
-	view->pending_scroll = SCROLL_TO_PAGE_POSITION;
-	gtk_widget_queue_resize (GTK_WIDGET (view));
+                              EvView          *view) {
+  gboolean rtl = ev_document_model_get_rtl (model);
+  gtk_widget_set_direction (GTK_WIDGET (view), rtl ? GTK_TEXT_DIR_RTL : GTK_TEXT_DIR_LTR);
+  view->pending_scroll = SCROLL_TO_PAGE_POSITION;
+  gtk_widget_queue_resize (GTK_WIDGET (view));
 }
 
 static void
 ev_view_fullscreen_changed_cb (EvDocumentModel *model,
-			       GParamSpec      *pspec,
-			       EvView          *view)
-{
-	gboolean fullscreen = ev_document_model_get_fullscreen (model);
+                               GParamSpec      *pspec,
+                               EvView          *view) {
+  gboolean fullscreen = ev_document_model_get_fullscreen (model);
 
-	view->fullscreen = fullscreen;
-	gtk_widget_queue_resize (GTK_WIDGET (view));
+  view->fullscreen = fullscreen;
+  gtk_widget_queue_resize (GTK_WIDGET (view));
 }
 
 void
 ev_view_set_model (EvView          *view,
-		   EvDocumentModel *model)
-{
-	g_return_if_fail (EV_IS_VIEW (view));
-	g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
-
-	if (model == view->model)
-		return;
-
-	if (view->model) {
-		g_signal_handlers_disconnect_by_data (view->model, view);
-		g_object_unref (view->model);
-	}
-	view->model = g_object_ref (model);
-
-	/* Initialize view from model */
-	view->rotation = ev_document_model_get_rotation (view->model);
-	view->sizing_mode = ev_document_model_get_sizing_mode (view->model);
-	view->scale = ev_document_model_get_scale (view->model);
-	view->continuous = ev_document_model_get_continuous (view->model);
-	view->page_layout = ev_document_model_get_page_layout (view->model);
-	gtk_widget_set_direction (GTK_WIDGET(view), ev_document_model_get_rtl (view->model));
-	view->fullscreen = ev_document_model_get_fullscreen (view->model);
-	ev_view_document_changed_cb (view->model, NULL, view);
-
-	g_signal_connect (view->model, "notify::document",
-			  G_CALLBACK (ev_view_document_changed_cb),
-			  view);
-	g_signal_connect (view->model, "notify::rotation",
-			  G_CALLBACK (ev_view_rotation_changed_cb),
-			  view);
-	g_signal_connect (view->model, "notify::inverted-colors",
-			  G_CALLBACK (ev_view_inverted_colors_changed_cb),
-			  view);
-	g_signal_connect (view->model, "notify::sizing-mode",
-			  G_CALLBACK (ev_view_sizing_mode_changed_cb),
-			  view);
-	g_signal_connect (view->model, "notify::page-layout",
-			  G_CALLBACK (ev_view_page_layout_changed_cb),
-			  view);
-	g_signal_connect (view->model, "notify::scale",
-			  G_CALLBACK (ev_view_scale_changed_cb),
-			  view);
-	g_signal_connect (view->model, "notify::min-scale",
-			  G_CALLBACK (ev_view_min_scale_changed_cb),
-			  view);
-	g_signal_connect (view->model, "notify::max-scale",
-			  G_CALLBACK (ev_view_max_scale_changed_cb),
-			  view);
-	g_signal_connect (view->model, "notify::continuous",
-			  G_CALLBACK (ev_view_continuous_changed_cb),
-			  view);
-	g_signal_connect (view->model, "notify::dual-odd-left",
-			  G_CALLBACK (ev_view_dual_odd_left_changed_cb),
-			  view);
-	g_signal_connect (view->model, "notify::rtl",
-			  G_CALLBACK (ev_view_direction_changed_cb),
-			  view);
-	g_signal_connect (view->model, "notify::fullscreen",
-			  G_CALLBACK (ev_view_fullscreen_changed_cb),
-			  view);
-	g_signal_connect (view->model, "page-changed",
-			  G_CALLBACK (ev_view_page_changed_cb),
-			  view);
-
-	if (view->accessible)
-		ev_view_accessible_set_model (EV_VIEW_ACCESSIBLE (view->accessible),
-					      view->model);
+                   EvDocumentModel *model) {
+  g_return_if_fail (EV_IS_VIEW (view));
+  g_return_if_fail (EV_IS_DOCUMENT_MODEL (model));
+
+  if (model == view->model)
+    return;
+
+  if (view->model) {
+    g_signal_handlers_disconnect_by_data (view->model, view);
+    g_object_unref (view->model);
+  }
+  view->model = g_object_ref (model);
+
+  /* Initialize view from model */
+  view->rotation = ev_document_model_get_rotation (view->model);
+  view->sizing_mode = ev_document_model_get_sizing_mode (view->model);
+  view->scale = ev_document_model_get_scale (view->model);
+  view->continuous = ev_document_model_get_continuous (view->model);
+  view->page_layout = ev_document_model_get_page_layout (view->model);
+  gtk_widget_set_direction (GTK_WIDGET(view), ev_document_model_get_rtl (view->model));
+  view->fullscreen = ev_document_model_get_fullscreen (view->model);
+  ev_view_document_changed_cb (view->model, NULL, view);
+
+  g_signal_connect (view->model, "notify::document",
+                    G_CALLBACK (ev_view_document_changed_cb),
+                    view);
+  g_signal_connect (view->model, "notify::rotation",
+                    G_CALLBACK (ev_view_rotation_changed_cb),
+                    view);
+  g_signal_connect (view->model, "notify::inverted-colors",
+                    G_CALLBACK (ev_view_inverted_colors_changed_cb),
+                    view);
+  g_signal_connect (view->model, "notify::sizing-mode",
+                    G_CALLBACK (ev_view_sizing_mode_changed_cb),
+                    view);
+  g_signal_connect (view->model, "notify::page-layout",
+                    G_CALLBACK (ev_view_page_layout_changed_cb),
+                    view);
+  g_signal_connect (view->model, "notify::scale",
+                    G_CALLBACK (ev_view_scale_changed_cb),
+                    view);
+  g_signal_connect (view->model, "notify::min-scale",
+                    G_CALLBACK (ev_view_min_scale_changed_cb),
+                    view);
+  g_signal_connect (view->model, "notify::max-scale",
+                    G_CALLBACK (ev_view_max_scale_changed_cb),
+                    view);
+  g_signal_connect (view->model, "notify::continuous",
+                    G_CALLBACK (ev_view_continuous_changed_cb),
+                    view);
+  g_signal_connect (view->model, "notify::dual-odd-left",
+                    G_CALLBACK (ev_view_dual_odd_left_changed_cb),
+                    view);
+  g_signal_connect (view->model, "notify::rtl",
+                    G_CALLBACK (ev_view_direction_changed_cb),
+                    view);
+  g_signal_connect (view->model, "notify::fullscreen",
+                    G_CALLBACK (ev_view_fullscreen_changed_cb),
+                    view);
+  g_signal_connect (view->model, "page-changed",
+                    G_CALLBACK (ev_view_page_changed_cb),
+                    view);
+
+  if (view->accessible)
+    ev_view_accessible_set_model (EV_VIEW_ACCESSIBLE (view->accessible),
+                                  view->model);
 }
 
 static void
 ev_view_reload_page (EvView         *view,
-		     gint            page,
-		     cairo_region_t *region)
-{
-	ev_pixbuf_cache_reload_page (view->pixbuf_cache,
-				     region,
-				     page,
-				     view->rotation,
-				     view->scale);
+                     gint            page,
+                     cairo_region_t *region) {
+  ev_pixbuf_cache_reload_page (view->pixbuf_cache,
+                               region,
+                               page,
+                               view->rotation,
+                               view->scale);
 }
 
 void
-ev_view_reload (EvView *view)
-{
-	ev_pixbuf_cache_clear (view->pixbuf_cache);
-	view_update_range_and_current_page (view);
+ev_view_reload (EvView *view) {
+  ev_pixbuf_cache_clear (view->pixbuf_cache);
+  view_update_range_and_current_page (view);
 }
 
 /*** Zoom and sizing mode ***/
 
 static gboolean
-ev_view_can_zoom (EvView *view, gdouble factor)
-{
-	if (factor == 1.0)
-		return TRUE;
+ev_view_can_zoom (EvView *view, gdouble factor) {
+  if (factor == 1.0)
+    return TRUE;
 
-	else if (factor < 1.0) {
-		return ev_view_can_zoom_out (view);
-	} else {
-		return ev_view_can_zoom_in (view);
-	}
+  else if (factor < 1.0) {
+    return ev_view_can_zoom_out (view);
+  } else {
+    return ev_view_can_zoom_in (view);
+  }
 }
 
 gboolean
-ev_view_can_zoom_in (EvView *view)
-{
-	return view->can_zoom_in;
+ev_view_can_zoom_in (EvView *view) {
+  return view->can_zoom_in;
 }
 
 gboolean
-ev_view_can_zoom_out (EvView *view)
-{
-	return view->can_zoom_out;
+ev_view_can_zoom_out (EvView *view) {
+  return view->can_zoom_out;
 }
 
 static void
-ev_view_zoom (EvView *view, gdouble factor)
-{
-	gdouble scale;
+ev_view_zoom (EvView *view, gdouble factor) {
+  gdouble scale;
 
-	g_return_if_fail (view->sizing_mode == EV_SIZING_FREE);
+  g_return_if_fail (view->sizing_mode == EV_SIZING_FREE);
 
-	view->pending_scroll = SCROLL_TO_CENTER;
-	scale = ev_document_model_get_scale (view->model) * factor;
-	ev_document_model_set_scale (view->model, scale);
+  view->pending_scroll = SCROLL_TO_CENTER;
+  scale = ev_document_model_get_scale (view->model) * factor;
+  ev_document_model_set_scale (view->model, scale);
 }
 
 void
-ev_view_zoom_in (EvView *view)
-{
-	ev_view_zoom (view, ZOOM_IN_FACTOR);
+ev_view_zoom_in (EvView *view) {
+  ev_view_zoom (view, ZOOM_IN_FACTOR);
 }
 
 void
-ev_view_zoom_out (EvView *view)
-{
-	ev_view_zoom (view, ZOOM_OUT_FACTOR);
+ev_view_zoom_out (EvView *view) {
+  ev_view_zoom (view, ZOOM_OUT_FACTOR);
 }
 
 static double
 zoom_for_size_fit_width (gdouble doc_width,
-			 gdouble doc_height,
-			 int     target_width,
-			 int     target_height)
-{
-	return (double)target_width / doc_width;
+                         gdouble doc_height,
+                         int     target_width,
+                         int     target_height) {
+  return (double)target_width / doc_width;
 }
 
 static double
 zoom_for_size_fit_height (gdouble doc_width,
-			  gdouble doc_height,
-			  int     target_width,
-			  int     target_height)
-{
-	return (double)target_height / doc_height;
+                          gdouble doc_height,
+                          int     target_width,
+                          int     target_height) {
+  return (double)target_height / doc_height;
 }
 
 static double
 zoom_for_size_fit_page (gdouble doc_width,
-			gdouble doc_height,
-			int     target_width,
-			int     target_height)
-{
-	double w_scale;
-	double h_scale;
+                        gdouble doc_height,
+                        int     target_width,
+                        int     target_height) {
+  double w_scale;
+  double h_scale;
 
-	w_scale = (double)target_width / doc_width;
-	h_scale = (double)target_height / doc_height;
+  w_scale = (double)target_width / doc_width;
+  h_scale = (double)target_height / doc_height;
 
-	return MIN (w_scale, h_scale);
+  return MIN (w_scale, h_scale);
 }
 
 static double
 zoom_for_size_automatic (GtkWidget *widget,
-			 gdouble    doc_width,
-			 gdouble    doc_height,
-			 int        target_width,
-			 int        target_height)
-{
-	double fit_width_scale;
-	double scale;
+                         gdouble    doc_width,
+                         gdouble    doc_height,
+                         int        target_width,
+                         int        target_height) {
+  double fit_width_scale;
+  double scale;
 
-	fit_width_scale = zoom_for_size_fit_width (doc_width, doc_height, target_width, target_height);
+  fit_width_scale = zoom_for_size_fit_width (doc_width, doc_height, target_width, target_height);
 
-	if (doc_height < doc_width) {
-		double fit_height_scale;
+  if (doc_height < doc_width) {
+    double fit_height_scale;
 
-		fit_height_scale = zoom_for_size_fit_height (doc_width, doc_height, target_width, target_height);
-		scale = MIN (fit_width_scale, fit_height_scale);
-	} else {
-		double actual_scale;
+    fit_height_scale = zoom_for_size_fit_height (doc_width, doc_height, target_width, target_height);
+    scale = MIN (fit_width_scale, fit_height_scale);
+  } else {
+    double actual_scale;
 
-		actual_scale = ev_document_misc_get_widget_dpi (widget) / 72.0;
-		scale = MIN (fit_width_scale, actual_scale);
-	}
+    actual_scale = ev_document_misc_get_widget_dpi (widget) / 72.0;
+    scale = MIN (fit_width_scale, actual_scale);
+  }
 
-	return scale;
+  return scale;
 }
 
 static void
 ev_view_zoom_for_size_continuous_and_dual_page (EvView *view,
-						int     width,
-						int     height)
-{
-	gdouble doc_width, doc_height;
-	GtkBorder border;
-	gdouble scale;
-	gint sb_size;
-
-	ev_document_get_max_page_size (view->document, &doc_width, &doc_height);
-	if (view->rotation == 90 || view->rotation == 270) {
-		gdouble tmp;
-
-		tmp = doc_width;
-		doc_width = doc_height;
-		doc_height = tmp;
-	}
-
-	compute_border (view, &border);
-
-	doc_width *= 2;
-	width -= (2 * (border.left + border.right) + 3 * view->spacing);
-	height -= (border.top + border.bottom + 2 * view->spacing);
-
-	sb_size = ev_view_get_scrollbar_size (view, GTK_ORIENTATION_VERTICAL);
-
-	switch (view->sizing_mode) {
-	case EV_SIZING_FIT_WIDTH:
-		scale = zoom_for_size_fit_width (doc_width, doc_height, width - sb_size, height);
-		break;
-	case EV_SIZING_FIT_PAGE:
-		scale = zoom_for_size_fit_page (doc_width, doc_height, width - sb_size, height);
-		break;
-	case EV_SIZING_AUTOMATIC:
-		scale = zoom_for_size_automatic (GTK_WIDGET (view),
-						 doc_width, doc_height, width - sb_size, height);
-		break;
-	default:
-		g_assert_not_reached ();
-	}
-
-	ev_document_model_set_scale (view->model, scale);
+                                                int     width,
+                                                int     height) {
+  gdouble doc_width, doc_height;
+  GtkBorder border;
+  gdouble scale;
+  gint sb_size;
+
+  ev_document_get_max_page_size (view->document, &doc_width, &doc_height);
+  if (view->rotation == 90 || view->rotation == 270) {
+    gdouble tmp;
+
+    tmp = doc_width;
+    doc_width = doc_height;
+    doc_height = tmp;
+  }
+
+  compute_border (view, &border);
+
+  doc_width *= 2;
+  width -= (2 * (border.left + border.right) + 3 * view->spacing);
+  height -= (border.top + border.bottom + 2 * view->spacing);
+
+  sb_size = ev_view_get_scrollbar_size (view, GTK_ORIENTATION_VERTICAL);
+
+  switch (view->sizing_mode) {
+    case EV_SIZING_FIT_WIDTH:
+      scale = zoom_for_size_fit_width (doc_width, doc_height, width - sb_size, height);
+      break;
+    case EV_SIZING_FIT_PAGE:
+      scale = zoom_for_size_fit_page (doc_width, doc_height, width - sb_size, height);
+      break;
+    case EV_SIZING_AUTOMATIC:
+      scale = zoom_for_size_automatic (GTK_WIDGET (view),
+                                       doc_width, doc_height, width - sb_size, height);
+      break;
+    default:
+      g_assert_not_reached ();
+  }
+
+  ev_document_model_set_scale (view->model, scale);
 }
 
 static void
 ev_view_zoom_for_size_continuous (EvView *view,
-				  int     width,
-				  int     height)
-{
-	gdouble doc_width, doc_height;
-	GtkBorder border;
-	gdouble scale;
-	gint sb_size;
+                                  int     width,
+                                  int     height) {
+  gdouble doc_width, doc_height;
+  GtkBorder border;
+  gdouble scale;
+  gint sb_size;
 
-	ev_document_get_max_page_size (view->document, &doc_width, &doc_height);
-	if (view->rotation == 90 || view->rotation == 270) {
-		gdouble tmp;
+  ev_document_get_max_page_size (view->document, &doc_width, &doc_height);
+  if (view->rotation == 90 || view->rotation == 270) {
+    gdouble tmp;
 
-		tmp = doc_width;
-		doc_width = doc_height;
-		doc_height = tmp;
-	}
+    tmp = doc_width;
+    doc_width = doc_height;
+    doc_height = tmp;
+  }
 
-	compute_border (view, &border);
+  compute_border (view, &border);
 
-	width -= (border.left + border.right + 2 * view->spacing);
-	height -= (border.top + border.bottom + 2 * view->spacing);
+  width -= (border.left + border.right + 2 * view->spacing);
+  height -= (border.top + border.bottom + 2 * view->spacing);
 
-	sb_size = ev_view_get_scrollbar_size (view, GTK_ORIENTATION_VERTICAL);
+  sb_size = ev_view_get_scrollbar_size (view, GTK_ORIENTATION_VERTICAL);
 
-	switch (view->sizing_mode) {
-	case EV_SIZING_FIT_WIDTH:
-		scale = zoom_for_size_fit_width (doc_width, doc_height, width - sb_size, height);
-		break;
-	case EV_SIZING_FIT_PAGE:
-		scale = zoom_for_size_fit_page (doc_width, doc_height, width - sb_size, height);
-		break;
-	case EV_SIZING_AUTOMATIC:
-		scale = zoom_for_size_automatic (GTK_WIDGET (view),
-						 doc_width, doc_height, width - sb_size, height);
-		break;
-	default:
-		g_assert_not_reached ();
-	}
+  switch (view->sizing_mode) {
+    case EV_SIZING_FIT_WIDTH:
+      scale = zoom_for_size_fit_width (doc_width, doc_height, width - sb_size, height);
+      break;
+    case EV_SIZING_FIT_PAGE:
+      scale = zoom_for_size_fit_page (doc_width, doc_height, width - sb_size, height);
+      break;
+    case EV_SIZING_AUTOMATIC:
+      scale = zoom_for_size_automatic (GTK_WIDGET (view),
+                                       doc_width, doc_height, width - sb_size, height);
+      break;
+    default:
+      g_assert_not_reached ();
+  }
 
-	ev_document_model_set_scale (view->model, scale);
+  ev_document_model_set_scale (view->model, scale);
 }
 
 static void
 ev_view_zoom_for_size_dual_page (EvView *view,
-				 int     width,
-				 int     height)
-{
-	GtkBorder border;
-	gdouble doc_width, doc_height;
-	gdouble scale;
-	gint other_page;
-	gint sb_size;
-
-	other_page = view->current_page ^ 1;
-
-	/* Find the largest of the two. */
-	get_doc_page_size (view, view->current_page, &doc_width, &doc_height);
-	if (other_page < ev_document_get_n_pages (view->document)) {
-		gdouble width_2, height_2;
-
-		get_doc_page_size (view, other_page, &width_2, &height_2);
-		if (width_2 > doc_width)
-			doc_width = width_2;
-		if (height_2 > doc_height)
-			doc_height = height_2;
-	}
-	compute_border (view, &border);
-
-	doc_width = doc_width * 2;
-	width -= ((border.left + border.right)* 2 + 3 * view->spacing);
-	height -= (border.top + border.bottom + 2 * view->spacing);
-
-	switch (view->sizing_mode) {
-	case EV_SIZING_FIT_WIDTH:
-		sb_size = ev_view_get_scrollbar_size (view, GTK_ORIENTATION_VERTICAL);
-		scale = zoom_for_size_fit_width (doc_width, doc_height, width - sb_size, height);
-		break;
-	case EV_SIZING_FIT_PAGE:
-		scale = zoom_for_size_fit_page (doc_width, doc_height, width, height);
-		break;
-	case EV_SIZING_AUTOMATIC:
-		sb_size = ev_view_get_scrollbar_size (view, GTK_ORIENTATION_VERTICAL);
-		scale = zoom_for_size_automatic (GTK_WIDGET (view),
-						 doc_width, doc_height, width - sb_size, height);
-		break;
-	default:
-		g_assert_not_reached ();
-	}
-
-	ev_document_model_set_scale (view->model, scale);
+                                 int     width,
+                                 int     height) {
+  GtkBorder border;
+  gdouble doc_width, doc_height;
+  gdouble scale;
+  gint other_page;
+  gint sb_size;
+
+  other_page = view->current_page ^ 1;
+
+  /* Find the largest of the two. */
+  get_doc_page_size (view, view->current_page, &doc_width, &doc_height);
+  if (other_page < ev_document_get_n_pages (view->document)) {
+    gdouble width_2, height_2;
+
+    get_doc_page_size (view, other_page, &width_2, &height_2);
+    if (width_2 > doc_width)
+      doc_width = width_2;
+    if (height_2 > doc_height)
+      doc_height = height_2;
+  }
+  compute_border (view, &border);
+
+  doc_width = doc_width * 2;
+  width -= ((border.left + border.right) * 2 + 3 * view->spacing);
+  height -= (border.top + border.bottom + 2 * view->spacing);
+
+  switch (view->sizing_mode) {
+    case EV_SIZING_FIT_WIDTH:
+      sb_size = ev_view_get_scrollbar_size (view, GTK_ORIENTATION_VERTICAL);
+      scale = zoom_for_size_fit_width (doc_width, doc_height, width - sb_size, height);
+      break;
+    case EV_SIZING_FIT_PAGE:
+      scale = zoom_for_size_fit_page (doc_width, doc_height, width, height);
+      break;
+    case EV_SIZING_AUTOMATIC:
+      sb_size = ev_view_get_scrollbar_size (view, GTK_ORIENTATION_VERTICAL);
+      scale = zoom_for_size_automatic (GTK_WIDGET (view),
+                                       doc_width, doc_height, width - sb_size, height);
+      break;
+    default:
+      g_assert_not_reached ();
+  }
+
+  ev_document_model_set_scale (view->model, scale);
 }
 
 static void
 ev_view_zoom_for_size_single_page (EvView *view,
-				   int     width,
-				   int     height)
-{
-	gdouble doc_width, doc_height;
-	GtkBorder border;
-	gdouble scale;
-	gint sb_size;
-
-	get_doc_page_size (view, view->current_page, &doc_width, &doc_height);
-
-	/* Get an approximate border */
-	compute_border (view, &border);
-
-	width -= (border.left + border.right + 2 * view->spacing);
-	height -= (border.top + border.bottom + 2 * view->spacing);
-
-	switch (view->sizing_mode) {
-	case EV_SIZING_FIT_WIDTH:
-		sb_size = ev_view_get_scrollbar_size (view, GTK_ORIENTATION_VERTICAL);
-		scale = zoom_for_size_fit_width (doc_width, doc_height, width - sb_size, height);
-		break;
-	case EV_SIZING_FIT_PAGE:
-		scale = zoom_for_size_fit_page (doc_width, doc_height, width, height);
-		break;
-	case EV_SIZING_AUTOMATIC:
-		sb_size = ev_view_get_scrollbar_size (view, GTK_ORIENTATION_VERTICAL);
-		scale = zoom_for_size_automatic (GTK_WIDGET (view),
-						 doc_width, doc_height, width - sb_size, height);
-		break;
-	default:
-		g_assert_not_reached ();
-	}
-
-	ev_document_model_set_scale (view->model, scale);
+                                   int     width,
+                                   int     height) {
+  gdouble doc_width, doc_height;
+  GtkBorder border;
+  gdouble scale;
+  gint sb_size;
+
+  get_doc_page_size (view, view->current_page, &doc_width, &doc_height);
+
+  /* Get an approximate border */
+  compute_border (view, &border);
+
+  width -= (border.left + border.right + 2 * view->spacing);
+  height -= (border.top + border.bottom + 2 * view->spacing);
+
+  switch (view->sizing_mode) {
+    case EV_SIZING_FIT_WIDTH:
+      sb_size = ev_view_get_scrollbar_size (view, GTK_ORIENTATION_VERTICAL);
+      scale = zoom_for_size_fit_width (doc_width, doc_height, width - sb_size, height);
+      break;
+    case EV_SIZING_FIT_PAGE:
+      scale = zoom_for_size_fit_page (doc_width, doc_height, width, height);
+      break;
+    case EV_SIZING_AUTOMATIC:
+      sb_size = ev_view_get_scrollbar_size (view, GTK_ORIENTATION_VERTICAL);
+      scale = zoom_for_size_automatic (GTK_WIDGET (view),
+                                       doc_width, doc_height, width - sb_size, height);
+      break;
+    default:
+      g_assert_not_reached ();
+  }
+
+  ev_document_model_set_scale (view->model, scale);
 }
 
 static void
 ev_view_zoom_for_size (EvView *view,
-		       int     width,
-		       int     height)
-{
-	gboolean dual_page;
-
-	g_return_if_fail (EV_IS_VIEW (view));
-	g_return_if_fail (view->sizing_mode == EV_SIZING_FIT_WIDTH ||
-			  view->sizing_mode == EV_SIZING_FIT_PAGE ||
-			  view->sizing_mode == EV_SIZING_AUTOMATIC);
-	g_return_if_fail (width >= 0);
-	g_return_if_fail (height >= 0);
-
-	if (view->document == NULL)
-		return;
-
-	dual_page = is_dual_page (view, NULL);
-	if (view->continuous && dual_page)
-		ev_view_zoom_for_size_continuous_and_dual_page (view, width, height);
-	else if (view->continuous)
-		ev_view_zoom_for_size_continuous (view, width, height);
-	else if (dual_page)
-		ev_view_zoom_for_size_dual_page (view, width, height);
-	else
-		ev_view_zoom_for_size_single_page (view, width, height);
+                       int     width,
+                       int     height) {
+  gboolean dual_page;
+
+  g_return_if_fail (EV_IS_VIEW (view));
+  g_return_if_fail (view->sizing_mode == EV_SIZING_FIT_WIDTH ||
+                    view->sizing_mode == EV_SIZING_FIT_PAGE ||
+                    view->sizing_mode == EV_SIZING_AUTOMATIC);
+  g_return_if_fail (width >= 0);
+  g_return_if_fail (height >= 0);
+
+  if (view->document == NULL)
+    return;
+
+  dual_page = is_dual_page (view, NULL);
+  if (view->continuous && dual_page)
+    ev_view_zoom_for_size_continuous_and_dual_page (view, width, height);
+  else if (view->continuous)
+    ev_view_zoom_for_size_continuous (view, width, height);
+  else if (dual_page)
+    ev_view_zoom_for_size_dual_page (view, width, height);
+  else
+    ev_view_zoom_for_size_single_page (view, width, height);
 }
 
 static gboolean
 ev_view_page_fits (EvView         *view,
-		   GtkOrientation  orientation)
-{
-	GtkRequisition requisition;
-	GtkAllocation  allocation;
-	double         size;
-
-	if (view->sizing_mode == EV_SIZING_FIT_PAGE)
-		return TRUE;
-
-	if (orientation == GTK_ORIENTATION_HORIZONTAL &&
-	    (view->sizing_mode == EV_SIZING_FIT_WIDTH ||
-	     view->sizing_mode == EV_SIZING_AUTOMATIC))
-		return TRUE;
-
-	gtk_widget_get_allocation (GTK_WIDGET (view), &allocation);
-	ev_view_size_request (GTK_WIDGET (view), &requisition);
-
-	if (orientation == GTK_ORIENTATION_HORIZONTAL) {
-		if (requisition.width == 1) {
-			size = 1.0;
-		} else {
-			if (allocation.width > 0.0)
-				size = (double) requisition.width / allocation.width;
-			else
-				size = 1.0;
-		}
-	} else {
-		if (requisition.height == 1) {
-			size = 1.0;
-		} else {
-			if (allocation.height > 0.0)
-				size = (double) requisition.height / allocation.height;
-			else
-				size = 1.0;
-		}
-	}
-
-	return size <= 1.0;
+                   GtkOrientation  orientation) {
+  GtkRequisition requisition;
+  GtkAllocation  allocation;
+  double         size;
+
+  if (view->sizing_mode == EV_SIZING_FIT_PAGE)
+    return TRUE;
+
+  if (orientation == GTK_ORIENTATION_HORIZONTAL &&
+      (view->sizing_mode == EV_SIZING_FIT_WIDTH ||
+       view->sizing_mode == EV_SIZING_AUTOMATIC))
+    return TRUE;
+
+  gtk_widget_get_allocation (GTK_WIDGET (view), &allocation);
+  ev_view_size_request (GTK_WIDGET (view), &requisition);
+
+  if (orientation == GTK_ORIENTATION_HORIZONTAL) {
+    if (requisition.width == 1) {
+      size = 1.0;
+    } else {
+      if (allocation.width > 0.0)
+        size = (double) requisition.width / allocation.width;
+      else
+        size = 1.0;
+    }
+  } else {
+    if (requisition.height == 1) {
+      size = 1.0;
+    } else {
+      if (allocation.height > 0.0)
+        size = (double) requisition.height / allocation.height;
+      else
+        size = 1.0;
+    }
+  }
+
+  return size <= 1.0;
 }
 
 /*** Find ***/
 static gint
-ev_view_find_get_n_results (EvView *view, gint page)
-{
-	return view->find_pages ? g_list_length (view->find_pages[page]) : 0;
+ev_view_find_get_n_results (EvView *view, gint page) {
+  return view->find_pages ? g_list_length (view->find_pages[page]) : 0;
 }
 
 static EvRectangle *
-ev_view_find_get_result (EvView *view, gint page, gint result)
-{
-	return view->find_pages ? (EvRectangle *) g_list_nth_data (view->find_pages[page], result) : NULL;
+ev_view_find_get_result (EvView *view, gint page, gint result) {
+  return view->find_pages ? (EvRectangle *) g_list_nth_data (view->find_pages[page], result) : NULL;
 }
 
 static void
-jump_to_find_result (EvView *view)
-{
-	gint n_results;
-	gint page = view->find_page;
+jump_to_find_result (EvView *view) {
+  gint n_results;
+  gint page = view->find_page;
 
-	n_results = ev_view_find_get_n_results (view, page);
+  n_results = ev_view_find_get_n_results (view, page);
 
-	if (n_results > 0 && view->find_result < n_results) {
-		EvRectangle *rect;
-		GdkRectangle view_rect;
+  if (n_results > 0 && view->find_result < n_results) {
+    EvRectangle *rect;
+    GdkRectangle view_rect;
 
-		rect = ev_view_find_get_result (view, page, view->find_result);
-		_ev_view_transform_doc_rect_to_view_rect (view, page, rect, &view_rect);
-		_ev_view_ensure_rectangle_is_visible (view, &view_rect);
-		if (view->caret_enabled && view->rotation == 0)
-			position_caret_cursor_at_doc_point (view, page, rect->x1, rect->y1);
+    rect = ev_view_find_get_result (view, page, view->find_result);
+    _ev_view_transform_doc_rect_to_view_rect (view, page, rect, &view_rect);
+    _ev_view_ensure_rectangle_is_visible (view, &view_rect);
+    if (view->caret_enabled && view->rotation == 0)
+      position_caret_cursor_at_doc_point (view, page, rect->x1, rect->y1);
 
-		view->jump_to_find_result = FALSE;
-	}
+    view->jump_to_find_result = FALSE;
+  }
 }
 
 /**
@@ -9097,44 +8808,42 @@ jump_to_find_result (EvView *view)
  * @shift: Shift from current page
  *
  * Jumps to the first page that has occurences of searched word.
- * Uses a direction where to look and a shift from current page. 
+ * Uses a direction where to look and a shift from current page.
  *
  */
 static void
-jump_to_find_page (EvView *view, EvViewFindDirection direction, gint shift)
-{
-	int n_pages, i;
+jump_to_find_page (EvView *view, EvViewFindDirection direction, gint shift) {
+  int n_pages, i;
 
-	n_pages = ev_document_get_n_pages (view->document);
+  n_pages = ev_document_get_n_pages (view->document);
 
-	for (i = 0; i < n_pages; i++) {
-		int page;
+  for (i = 0; i < n_pages; i++) {
+    int page;
 
-		if (direction == EV_VIEW_FIND_NEXT)
-			page = view->find_page + i;
-		else
-			page = view->find_page - i;
-		page += shift;
+    if (direction == EV_VIEW_FIND_NEXT)
+      page = view->find_page + i;
+    else
+      page = view->find_page - i;
+    page += shift;
 
-		if (page >= n_pages)
-			page = page - n_pages;
-		else if (page < 0)
-			page = page + n_pages;
+    if (page >= n_pages)
+      page = page - n_pages;
+    else if (page < 0)
+      page = page + n_pages;
 
-		if (view->find_pages && view->find_pages[page]) {
-			view->find_page = page;
-			break;
-		}
-	}
+    if (view->find_pages && view->find_pages[page]) {
+      view->find_page = page;
+      break;
+    }
+  }
 
-	if (!view->continuous)
-		ev_document_model_set_page (view->model, view->find_page);
+  if (!view->continuous)
+    ev_document_model_set_page (view->model, view->find_page);
 }
 
 static void
-find_job_updated_cb (EvJobFind *job, gint page, EvView *view)
-{
-	ev_view_find_changed (view, ev_job_find_get_results (job), page);
+find_job_updated_cb (EvJobFind *job, gint page, EvView *view) {
+  ev_view_find_changed (view, ev_job_find_get_results (job), page);
 }
 
 /**
@@ -9145,17 +8854,16 @@ find_job_updated_cb (EvJobFind *job, gint page, EvView *view)
  * Since: 3.6
  */
 void
-ev_view_find_started (EvView *view, EvJobFind *job)
-{
-	if (view->find_job == job)
-		return;
+ev_view_find_started (EvView *view, EvJobFind *job) {
+  if (view->find_job == job)
+    return;
 
-	ev_view_find_cancel (view);
-	view->find_job = g_object_ref (job);
-	view->find_page = view->current_page;
-	view->find_result = 0;
+  ev_view_find_cancel (view);
+  view->find_job = g_object_ref (job);
+  view->find_page = view->current_page;
+  view->find_result = 0;
 
-	g_signal_connect (job, "updated", G_CALLBACK (find_job_updated_cb), view);
+  g_signal_connect (job, "updated", G_CALLBACK (find_job_updated_cb), view);
 }
 
 /**
@@ -9167,21 +8875,20 @@ ev_view_find_started (EvView *view, EvJobFind *job)
  * Deprecated: 3.6: Use ev_view_find_started() instead
  */
 void
-ev_view_find_changed (EvView *view, GList **results, gint page)
-{
-	g_return_if_fail (view->current_page >= 0);
+ev_view_find_changed (EvView *view, GList **results, gint page) {
+  g_return_if_fail (view->current_page >= 0);
 
-	view->find_pages = results;
-	if (view->find_page == -1)
-		view->find_page = view->current_page;
+  view->find_pages = results;
+  if (view->find_page == -1)
+    view->find_page = view->current_page;
 
-	if (view->jump_to_find_result == TRUE) {
-		jump_to_find_page (view, EV_VIEW_FIND_NEXT, 0);
-		jump_to_find_result (view);
-	}
+  if (view->jump_to_find_result == TRUE) {
+    jump_to_find_page (view, EV_VIEW_FIND_NEXT, 0);
+    jump_to_find_result (view);
+  }
 
-	if (view->find_page == page)
-		gtk_widget_queue_draw (GTK_WIDGET (view));
+  if (view->find_page == page)
+    gtk_widget_queue_draw (GTK_WIDGET (view));
 }
 
 /**
@@ -9195,51 +8902,48 @@ ev_view_find_changed (EvView *view, GList **results, gint page)
  */
 void
 ev_view_find_restart (EvView *view,
-		      gint    page)
-{
-	if (!view->find_job)
-		return;
+                      gint    page) {
+  if (!view->find_job)
+    return;
 
-	view->find_page = page;
-	view->find_result = 0;
-	jump_to_find_page (view, EV_VIEW_FIND_NEXT, 0);
-	jump_to_find_result (view);
-	gtk_widget_queue_draw (GTK_WIDGET (view));
+  view->find_page = page;
+  view->find_result = 0;
+  jump_to_find_page (view, EV_VIEW_FIND_NEXT, 0);
+  jump_to_find_result (view);
+  gtk_widget_queue_draw (GTK_WIDGET (view));
 }
 
 void
-ev_view_find_next (EvView *view)
-{
-	gint n_results;
+ev_view_find_next (EvView *view) {
+  gint n_results;
 
-	n_results = ev_view_find_get_n_results (view, view->find_page);
-	view->find_result++;
+  n_results = ev_view_find_get_n_results (view, view->find_page);
+  view->find_result++;
 
-	if (view->find_result >= n_results) {
-		view->find_result = 0;
-		jump_to_find_page (view, EV_VIEW_FIND_NEXT, 1);
-	} else if (view->find_page != view->current_page) {
-		jump_to_find_page (view, EV_VIEW_FIND_NEXT, 0);
-	}
+  if (view->find_result >= n_results) {
+    view->find_result = 0;
+    jump_to_find_page (view, EV_VIEW_FIND_NEXT, 1);
+  } else if (view->find_page != view->current_page) {
+    jump_to_find_page (view, EV_VIEW_FIND_NEXT, 0);
+  }
 
-	jump_to_find_result (view);
-	gtk_widget_queue_draw (GTK_WIDGET (view));
+  jump_to_find_result (view);
+  gtk_widget_queue_draw (GTK_WIDGET (view));
 }
 
 void
-ev_view_find_previous (EvView *view)
-{
-	view->find_result--;
+ev_view_find_previous (EvView *view) {
+  view->find_result--;
 
-	if (view->find_result < 0) {
-		jump_to_find_page (view, EV_VIEW_FIND_PREV, -1);
-		view->find_result = MAX (0, ev_view_find_get_n_results (view, view->find_page) - 1);
-	} else if (view->find_page != view->current_page) {
-		jump_to_find_page (view, EV_VIEW_FIND_PREV, 0);
-	}
+  if (view->find_result < 0) {
+    jump_to_find_page (view, EV_VIEW_FIND_PREV, -1);
+    view->find_result = MAX (0, ev_view_find_get_n_results (view, view->find_page) - 1);
+  } else if (view->find_page != view->current_page) {
+    jump_to_find_page (view, EV_VIEW_FIND_PREV, 0);
+  }
 
-	jump_to_find_result (view);
-	gtk_widget_queue_draw (GTK_WIDGET (view));
+  jump_to_find_result (view);
+  gtk_widget_queue_draw (GTK_WIDGET (view));
 }
 
 /**
@@ -9253,212 +8957,203 @@ ev_view_find_previous (EvView *view)
  * Since: 3.10
  */
 void
-ev_view_find_set_result (EvView *view, gint page, gint result)
-{
-	view->find_page = page;
-	view->find_result = result;
-	jump_to_find_page (view, EV_VIEW_FIND_NEXT, 0);
-	jump_to_find_result (view);
-	gtk_widget_queue_draw (GTK_WIDGET (view));
+ev_view_find_set_result (EvView *view, gint page, gint result) {
+  view->find_page = page;
+  view->find_result = result;
+  jump_to_find_page (view, EV_VIEW_FIND_NEXT, 0);
+  jump_to_find_result (view);
+  gtk_widget_queue_draw (GTK_WIDGET (view));
 }
 
 void
-ev_view_find_search_changed (EvView *view)
-{
-	/* search string has changed, focus on new search result */
-	view->jump_to_find_result = TRUE;
-	ev_view_find_cancel (view);
+ev_view_find_search_changed (EvView *view) {
+  /* search string has changed, focus on new search result */
+  view->jump_to_find_result = TRUE;
+  ev_view_find_cancel (view);
 }
 
 void
-ev_view_find_set_highlight_search (EvView *view, gboolean value)
-{
-	view->highlight_find_results = value;
-	gtk_widget_queue_draw (GTK_WIDGET (view));
+ev_view_find_set_highlight_search (EvView *view, gboolean value) {
+  view->highlight_find_results = value;
+  gtk_widget_queue_draw (GTK_WIDGET (view));
 }
 
 void
-ev_view_find_cancel (EvView *view)
-{
-	view->find_pages = NULL;
-	view->find_page = -1;
-	view->find_result = 0;
+ev_view_find_cancel (EvView *view) {
+  view->find_pages = NULL;
+  view->find_page = -1;
+  view->find_result = 0;
 
-	if (!view->find_job)
-		return;
+  if (!view->find_job)
+    return;
 
-	g_signal_handlers_disconnect_by_func (view->find_job, find_job_updated_cb, view);
-	g_object_unref (view->find_job);
-	view->find_job = NULL;
+  g_signal_handlers_disconnect_by_func (view->find_job, find_job_updated_cb, view);
+  g_object_unref (view->find_job);
+  view->find_job = NULL;
 }
 
 /*** Synctex ***/
 void
 ev_view_highlight_forward_search (EvView       *view,
-				  EvSourceLink *link)
-{
-	EvMapping   *mapping;
-	gint         page;
-	GdkRectangle view_rect;
+                                  EvSourceLink *link) {
+  EvMapping   *mapping;
+  gint         page;
+  GdkRectangle view_rect;
 
-	if (!ev_document_has_synctex (view->document))
-		return;
+  if (!ev_document_has_synctex (view->document))
+    return;
 
-	mapping = ev_document_synctex_forward_search (view->document, link);
-	if (!mapping)
-		return;
+  mapping = ev_document_synctex_forward_search (view->document, link);
+  if (!mapping)
+    return;
 
-	if (view->synctex_result)
-		g_free (view->synctex_result);
-	view->synctex_result = mapping;
+  if (view->synctex_result)
+    g_free (view->synctex_result);
+  view->synctex_result = mapping;
 
-	page = GPOINTER_TO_INT (mapping->data);
-	ev_document_model_set_page (view->model, page);
+  page = GPOINTER_TO_INT (mapping->data);
+  ev_document_model_set_page (view->model, page);
 
-	_ev_view_transform_doc_rect_to_view_rect (view, page, &mapping->area, &view_rect);
-	_ev_view_ensure_rectangle_is_visible (view, &view_rect);
-	gtk_widget_queue_draw (GTK_WIDGET (view));
+  _ev_view_transform_doc_rect_to_view_rect (view, page, &mapping->area, &view_rect);
+  _ev_view_ensure_rectangle_is_visible (view, &view_rect);
+  gtk_widget_queue_draw (GTK_WIDGET (view));
 }
 
 /*** Selections ***/
 static gboolean
 gdk_rectangle_point_in (GdkRectangle *rectangle,
-			GdkPoint     *point)
-{
-	return rectangle->x <= point->x &&
-		rectangle->y <= point->y &&
-		point->x < rectangle->x + rectangle->width &&
-		point->y < rectangle->y + rectangle->height;
+                        GdkPoint     *point) {
+  return rectangle->x <= point->x &&
+         rectangle->y <= point->y &&
+         point->x < rectangle->x + rectangle->width &&
+         point->y < rectangle->y + rectangle->height;
 }
 
 static inline gboolean
 gdk_point_equal (GdkPoint *a,
-		 GdkPoint *b)
-{
-	return a->x == b->x && a->y == b->y;
+                 GdkPoint *b) {
+  return a->x == b->x && a->y == b->y;
 }
 
 static gboolean
 get_selection_page_range (EvView          *view,
-			  EvSelectionStyle style,
-			  GdkPoint        *start,
-			  GdkPoint        *stop,
-			  gint            *first_page,
-			  gint            *last_page)
-{
-	gint start_page, end_page;
-	gint first, last;
-	gint i, n_pages;
-	GtkBorder border;
-
-	n_pages = ev_document_get_n_pages (view->document);
-
-	if (gdk_point_equal (start, stop)) {
-		start_page = view->start_page;
-		end_page = view->end_page;
-	} else if (view->continuous) {
-		start_page = 0;
-		end_page = n_pages - 1;
-	} else if (is_dual_page (view, NULL)) {
-		start_page = view->start_page;
-		end_page = view->end_page;
-	} else {
-		start_page = view->current_page;
-		end_page = view->current_page;
-	}
-
-	first = -1;
-	last = -1;
-	compute_border (view, &border);
-	for (i = start_page; i <= end_page; i++) {
-		GdkRectangle page_area;
-
-		ev_view_get_page_extents_for_border (view, i, &border, &page_area);
-		page_area.x -= border.left;
-		page_area.y -= border.top;
-		page_area.width += border.left + border.right;
-		page_area.height += border.top + border.bottom;
-		if (gdk_rectangle_point_in (&page_area, start) ||
-		    gdk_rectangle_point_in (&page_area, stop)) {
-			if (first == -1)
-				first = i;
-			last = i;
-		}
-	}
-
-	if (first != -1 && last != -1) {
-		*first_page = first;
-		*last_page = last;
-
-		return TRUE;
-	}
-
-	return FALSE;
+                          EvSelectionStyle style,
+                          GdkPoint        *start,
+                          GdkPoint        *stop,
+                          gint            *first_page,
+                          gint            *last_page) {
+  gint start_page, end_page;
+  gint first, last;
+  gint i, n_pages;
+  GtkBorder border;
+
+  n_pages = ev_document_get_n_pages (view->document);
+
+  if (gdk_point_equal (start, stop)) {
+    start_page = view->start_page;
+    end_page = view->end_page;
+  } else if (view->continuous) {
+    start_page = 0;
+    end_page = n_pages - 1;
+  } else if (is_dual_page (view, NULL)) {
+    start_page = view->start_page;
+    end_page = view->end_page;
+  } else {
+    start_page = view->current_page;
+    end_page = view->current_page;
+  }
+
+  first = -1;
+  last = -1;
+  compute_border (view, &border);
+  for (i = start_page; i <= end_page; i++) {
+    GdkRectangle page_area;
+
+    ev_view_get_page_extents_for_border (view, i, &border, &page_area);
+    page_area.x -= border.left;
+    page_area.y -= border.top;
+    page_area.width += border.left + border.right;
+    page_area.height += border.top + border.bottom;
+    if (gdk_rectangle_point_in (&page_area, start) ||
+        gdk_rectangle_point_in (&page_area, stop)) {
+      if (first == -1)
+        first = i;
+      last = i;
+    }
+  }
+
+  if (first != -1 && last != -1) {
+    *first_page = first;
+    *last_page = last;
+
+    return TRUE;
+  }
+
+  return FALSE;
 }
 
 static GList *
 compute_new_selection (EvView          *view,
-		       EvSelectionStyle style,
-		       GdkPoint        *start,
-		       GdkPoint        *stop)
-{
-	int i, first, last;
-	GtkBorder border;
-	GList *list = NULL;
-
-	/* First figure out the range of pages the selection affects. */
-	if (!get_selection_page_range (view, style, start, stop, &first, &last))
-		return list;
-
-	/* Now create a list of EvViewSelection's for the affected
-	 * pages. This could be an empty list, a list of just one
-	 * page or a number of pages.*/
-	compute_border (view, &border);
-	for (i = first; i <= last; i++) {
-		EvViewSelection *selection;
-		GdkRectangle     page_area;
-		GdkPoint        *point;
-		gdouble          width, height;
-
-		get_doc_page_size (view, i, &width, &height);
-
-		selection = g_slice_new0 (EvViewSelection);
-		selection->page = i;
-		selection->style = style;
-		selection->rect.x1 = selection->rect.y1 = 0;
-		selection->rect.x2 = width;
-		selection->rect.y2 = height;
-
-		ev_view_get_page_extents_for_border (view, i, &border, &page_area);
-		if (gdk_rectangle_point_in (&page_area, start))
-			point = start;
-		else
-			point = stop;
-
-		if (i == first) {
-			_ev_view_transform_view_point_to_doc_point (view, point,
-								    &page_area, &border,
-								    &selection->rect.x1,
-								    &selection->rect.y1);
-		}
-
-		/* If the selection is contained within just one page,
-		 * make sure we don't write 'start' into both points
-		 * in selection->rect. */
-		if (first == last)
-			point = stop;
-
-		if (i == last) {
-			_ev_view_transform_view_point_to_doc_point (view, point,
-								    &page_area, &border,
-								    &selection->rect.x2,
-								    &selection->rect.y2);
-		}
-
-		list = g_list_prepend (list, selection);
-	}
-
-	return g_list_reverse (list);
+                       EvSelectionStyle style,
+                       GdkPoint        *start,
+                       GdkPoint        *stop) {
+  int i, first, last;
+  GtkBorder border;
+  GList *list = NULL;
+
+  /* First figure out the range of pages the selection affects. */
+  if (!get_selection_page_range (view, style, start, stop, &first, &last))
+    return list;
+
+  /* Now create a list of EvViewSelection's for the affected
+   * pages. This could be an empty list, a list of just one
+   * page or a number of pages.*/
+  compute_border (view, &border);
+  for (i = first; i <= last; i++) {
+    EvViewSelection *selection;
+    GdkRectangle     page_area;
+    GdkPoint        *point;
+    gdouble          width, height;
+
+    get_doc_page_size (view, i, &width, &height);
+
+    selection = g_slice_new0 (EvViewSelection);
+    selection->page = i;
+    selection->style = style;
+    selection->rect.x1 = selection->rect.y1 = 0;
+    selection->rect.x2 = width;
+    selection->rect.y2 = height;
+
+    ev_view_get_page_extents_for_border (view, i, &border, &page_area);
+    if (gdk_rectangle_point_in (&page_area, start))
+      point = start;
+    else
+      point = stop;
+
+    if (i == first) {
+      _ev_view_transform_view_point_to_doc_point (view, point,
+                                                  &page_area, &border,
+                                                  &selection->rect.x1,
+                                                  &selection->rect.y1);
+    }
+
+    /* If the selection is contained within just one page,
+     * make sure we don't write 'start' into both points
+     * in selection->rect. */
+    if (first == last)
+      point = stop;
+
+    if (i == last) {
+      _ev_view_transform_view_point_to_doc_point (view, point,
+                                                  &page_area, &border,
+                                                  &selection->rect.x2,
+                                                  &selection->rect.y2);
+    }
+
+    list = g_list_prepend (list, selection);
+  }
+
+  return g_list_reverse (list);
 }
 
 /* This function takes the newly calculated list, and figures out which regions
@@ -9466,430 +9161,407 @@ compute_new_selection (EvView          *view,
  */
 static void
 merge_selection_region (EvView *view,
-			GList  *new_list)
-{
-	GList *old_list;
-	GList *new_list_ptr, *old_list_ptr;
-	GtkBorder border;
-
-	/* Update the selection */
-	old_list = ev_pixbuf_cache_get_selection_list (view->pixbuf_cache);
-	g_list_free_full (view->selection_info.selections, (GDestroyNotify)selection_free);
-	view->selection_info.selections = new_list;
-	ev_pixbuf_cache_set_selection_list (view->pixbuf_cache, new_list);
-	g_signal_emit (view, signals[SIGNAL_SELECTION_CHANGED], 0, NULL);
-
-	new_list_ptr = new_list;
-	old_list_ptr = old_list;
-
-	compute_border (view, &border);
-	while (new_list_ptr || old_list_ptr) {
-		EvViewSelection *old_sel, *new_sel;
-		int cur_page;
-		cairo_region_t *region = NULL;
-
-		new_sel = (new_list_ptr) ? (new_list_ptr->data) : NULL;
-		old_sel = (old_list_ptr) ? (old_list_ptr->data) : NULL;
-
-		/* Assume that the lists are in order, and we run through them
-		 * comparing them, one page at a time.  We come out with the
-		 * first page we see. */
-		if (new_sel && old_sel) {
-			if (new_sel->page < old_sel->page) {
-				new_list_ptr = new_list_ptr->next;
-				old_sel = NULL;
-			} else if (new_sel->page > old_sel->page) {
-				old_list_ptr = old_list_ptr->next;
-				new_sel = NULL;
-			} else {
-				new_list_ptr = new_list_ptr->next;
-				old_list_ptr = old_list_ptr->next;
-			}
-		} else if (new_sel) {
-			new_list_ptr = new_list_ptr->next;
-		} else if (old_sel) {
-			old_list_ptr = old_list_ptr->next;
-		}
-
-		g_assert (new_sel || old_sel);
-
-		/* is the page we're looking at on the screen?*/
-		cur_page = new_sel ? new_sel->page : old_sel->page;
-		if (cur_page < view->start_page || cur_page > view->end_page)
-			continue;
-
-		/* seed the cache with a new page.  We are going to need the new
-		 * region too. */
-		if (new_sel) {
-			cairo_region_t *tmp_region;
-
-			tmp_region = ev_pixbuf_cache_get_selection_region (view->pixbuf_cache,
-									   cur_page,
-									   view->scale);
-			if (tmp_region)
-				new_sel->covered_region = cairo_region_reference (tmp_region);
-		}
-
-		/* Now we figure out what needs redrawing */
-		if (old_sel && new_sel) {
-			if (old_sel->covered_region && new_sel->covered_region) {
-				if (!cairo_region_equal (old_sel->covered_region, new_sel->covered_region)) {
-					/* Anything that was previously or currently selected may
-					 * have changed */
-					region = cairo_region_copy (old_sel->covered_region);
-					cairo_region_union (region, new_sel->covered_region);
-				}
-			} else if (old_sel->covered_region) {
-				region = cairo_region_reference (old_sel->covered_region);
-			} else if (new_sel->covered_region) {
-				region = cairo_region_reference (new_sel->covered_region);
-			}
-		} else if (old_sel && !new_sel) {
-			if (old_sel->covered_region && !cairo_region_is_empty (old_sel->covered_region)) {
-				region = cairo_region_reference (old_sel->covered_region);
-			}
-		} else if (!old_sel && new_sel) {
-			if (new_sel->covered_region && !cairo_region_is_empty (new_sel->covered_region)) {
-				region = cairo_region_reference (new_sel->covered_region);
-			}
-		} else {
-			g_assert_not_reached ();
-		}
-
-		/* Redraw the damaged region! */
-		if (region) {
-			GdkRectangle    page_area;
-			cairo_region_t *damage_region;
-			gint            i, n_rects;
-
-			ev_view_get_page_extents_for_border (view, cur_page, &border, &page_area);
-
-			damage_region = cairo_region_create ();
-			/* Translate the region and grow it 2 pixels because for some zoom levels
-			 * the area actually drawn by cairo is larger than the selected region, due
-			 * to rounding errors or pixel alignment.
-			 */
-			n_rects = cairo_region_num_rectangles (region);
-			for (i = 0; i < n_rects; i++) {
-				cairo_rectangle_int_t rect;
-
-				cairo_region_get_rectangle (region, i, &rect);
-				rect.x += page_area.x + border.left - view->scroll_x - 2;
-				rect.y += page_area.y + border.top - view->scroll_y - 2;
-				rect.width += 4;
-				rect.height += 4;
-				cairo_region_union_rectangle (damage_region, &rect);
-			}
-			cairo_region_destroy (region);
-
-			gdk_window_invalidate_region (gtk_widget_get_window (GTK_WIDGET (view)),
-						      damage_region, TRUE);
-			cairo_region_destroy (damage_region);
-		}
-	}
-
-	ev_view_check_cursor_blink (view);
-
-	/* Free the old list, now that we're done with it. */
-	g_list_free_full (old_list, (GDestroyNotify)selection_free);
+                        GList  *new_list) {
+  GList *old_list;
+  GList *new_list_ptr, *old_list_ptr;
+  GtkBorder border;
+
+  /* Update the selection */
+  old_list = ev_pixbuf_cache_get_selection_list (view->pixbuf_cache);
+  g_list_free_full (view->selection_info.selections, (GDestroyNotify)selection_free);
+  view->selection_info.selections = new_list;
+  ev_pixbuf_cache_set_selection_list (view->pixbuf_cache, new_list);
+  g_signal_emit (view, signals[SIGNAL_SELECTION_CHANGED], 0, NULL);
+
+  new_list_ptr = new_list;
+  old_list_ptr = old_list;
+
+  compute_border (view, &border);
+  while (new_list_ptr || old_list_ptr) {
+    EvViewSelection *old_sel, *new_sel;
+    int cur_page;
+    cairo_region_t *region = NULL;
+
+    new_sel = (new_list_ptr) ? (new_list_ptr->data) : NULL;
+    old_sel = (old_list_ptr) ? (old_list_ptr->data) : NULL;
+
+    /* Assume that the lists are in order, and we run through them
+     * comparing them, one page at a time.  We come out with the
+     * first page we see. */
+    if (new_sel && old_sel) {
+      if (new_sel->page < old_sel->page) {
+        new_list_ptr = new_list_ptr->next;
+        old_sel = NULL;
+      } else if (new_sel->page > old_sel->page) {
+        old_list_ptr = old_list_ptr->next;
+        new_sel = NULL;
+      } else {
+        new_list_ptr = new_list_ptr->next;
+        old_list_ptr = old_list_ptr->next;
+      }
+    } else if (new_sel) {
+      new_list_ptr = new_list_ptr->next;
+    } else if (old_sel) {
+      old_list_ptr = old_list_ptr->next;
+    }
+
+    g_assert (new_sel || old_sel);
+
+    /* is the page we're looking at on the screen?*/
+    cur_page = new_sel ? new_sel->page : old_sel->page;
+    if (cur_page < view->start_page || cur_page > view->end_page)
+      continue;
+
+    /* seed the cache with a new page.  We are going to need the new
+     * region too. */
+    if (new_sel) {
+      cairo_region_t *tmp_region;
+
+      tmp_region = ev_pixbuf_cache_get_selection_region (view->pixbuf_cache,
+                                                         cur_page,
+                                                         view->scale);
+      if (tmp_region)
+        new_sel->covered_region = cairo_region_reference (tmp_region);
+    }
+
+    /* Now we figure out what needs redrawing */
+    if (old_sel && new_sel) {
+      if (old_sel->covered_region && new_sel->covered_region) {
+        if (!cairo_region_equal (old_sel->covered_region, new_sel->covered_region)) {
+          /* Anything that was previously or currently selected may
+           * have changed */
+          region = cairo_region_copy (old_sel->covered_region);
+          cairo_region_union (region, new_sel->covered_region);
+        }
+      } else if (old_sel->covered_region) {
+        region = cairo_region_reference (old_sel->covered_region);
+      } else if (new_sel->covered_region) {
+        region = cairo_region_reference (new_sel->covered_region);
+      }
+    } else if (old_sel && !new_sel) {
+      if (old_sel->covered_region && !cairo_region_is_empty (old_sel->covered_region)) {
+        region = cairo_region_reference (old_sel->covered_region);
+      }
+    } else if (!old_sel && new_sel) {
+      if (new_sel->covered_region && !cairo_region_is_empty (new_sel->covered_region)) {
+        region = cairo_region_reference (new_sel->covered_region);
+      }
+    } else {
+      g_assert_not_reached ();
+    }
+
+    /* Redraw the damaged region! */
+    if (region) {
+      GdkRectangle    page_area;
+      cairo_region_t *damage_region;
+      gint            i, n_rects;
+
+      ev_view_get_page_extents_for_border (view, cur_page, &border, &page_area);
+
+      damage_region = cairo_region_create ();
+      /* Translate the region and grow it 2 pixels because for some zoom levels
+       * the area actually drawn by cairo is larger than the selected region, due
+       * to rounding errors or pixel alignment.
+       */
+      n_rects = cairo_region_num_rectangles (region);
+      for (i = 0; i < n_rects; i++) {
+        cairo_rectangle_int_t rect;
+
+        cairo_region_get_rectangle (region, i, &rect);
+        rect.x += page_area.x + border.left - view->scroll_x - 2;
+        rect.y += page_area.y + border.top - view->scroll_y - 2;
+        rect.width += 4;
+        rect.height += 4;
+        cairo_region_union_rectangle (damage_region, &rect);
+      }
+      cairo_region_destroy (region);
+
+      gdk_window_invalidate_region (gtk_widget_get_window (GTK_WIDGET (view)),
+                                    damage_region, TRUE);
+      cairo_region_destroy (damage_region);
+    }
+  }
+
+  ev_view_check_cursor_blink (view);
+
+  /* Free the old list, now that we're done with it. */
+  g_list_free_full (old_list, (GDestroyNotify)selection_free);
 }
 
 static void
 compute_selections (EvView          *view,
-		    EvSelectionStyle style,
-		    GdkPoint        *start,
-		    GdkPoint        *stop)
-{
-	merge_selection_region (view, compute_new_selection (view, style, start, stop));
+                    EvSelectionStyle style,
+                    GdkPoint        *start,
+                    GdkPoint        *stop) {
+  merge_selection_region (view, compute_new_selection (view, style, start, stop));
 }
 
 /* Free's the selection.  It's up to the caller to queue redraws if needed.
  */
 static void
-selection_free (EvViewSelection *selection)
-{
-	if (selection->covered_region)
-		cairo_region_destroy (selection->covered_region);
-	g_slice_free (EvViewSelection, selection);
+selection_free (EvViewSelection *selection) {
+  if (selection->covered_region)
+    cairo_region_destroy (selection->covered_region);
+  g_slice_free (EvViewSelection, selection);
 }
 
 static void
-clear_selection (EvView *view)
-{
-	merge_selection_region (view, NULL);
+clear_selection (EvView *view) {
+  merge_selection_region (view, NULL);
 }
 
 void
-ev_view_select_all (EvView *view)
-{
-	GList *selections = NULL;
-	int n_pages, i;
+ev_view_select_all (EvView *view) {
+  GList *selections = NULL;
+  int n_pages, i;
 
-	/* Disable selection on rotated pages for the 0.4.0 series */
-	if (view->rotation != 0)
-		return;
+  /* Disable selection on rotated pages for the 0.4.0 series */
+  if (view->rotation != 0)
+    return;
 
-	n_pages = ev_document_get_n_pages (view->document);
-	for (i = 0; i < n_pages; i++) {
-		gdouble width, height;
-		EvViewSelection *selection;
+  n_pages = ev_document_get_n_pages (view->document);
+  for (i = 0; i < n_pages; i++) {
+    gdouble width, height;
+    EvViewSelection *selection;
 
-		get_doc_page_size (view, i, &width, &height);
+    get_doc_page_size (view, i, &width, &height);
 
-		selection = g_slice_new0 (EvViewSelection);
-		selection->page = i;
-		selection->style = EV_SELECTION_STYLE_GLYPH;
-		selection->rect.x1 = selection->rect.y1 = 0;
-		selection->rect.x2 = width;
-		selection->rect.y2 = height;
+    selection = g_slice_new0 (EvViewSelection);
+    selection->page = i;
+    selection->style = EV_SELECTION_STYLE_GLYPH;
+    selection->rect.x1 = selection->rect.y1 = 0;
+    selection->rect.x2 = width;
+    selection->rect.y2 = height;
 
-		selections = g_list_prepend (selections, selection);
-	}
+    selections = g_list_prepend (selections, selection);
+  }
 
-	merge_selection_region (view, g_list_reverse (selections));
+  merge_selection_region (view, g_list_reverse (selections));
 }
 
 gboolean
-ev_view_get_has_selection (EvView *view)
-{
-	return view->selection_info.selections != NULL;
+ev_view_get_has_selection (EvView *view) {
+  return view->selection_info.selections != NULL;
 }
 
 void
-_ev_view_clear_selection (EvView *view)
-{
-	clear_selection (view);
+_ev_view_clear_selection (EvView *view) {
+  clear_selection (view);
 }
 
 void
 _ev_view_set_selection (EvView   *view,
-			GdkPoint *start_point,
-			GdkPoint *end_point)
-{
-	compute_selections (view, EV_SELECTION_STYLE_GLYPH, start_point, end_point);
+                        GdkPoint *start_point,
+                        GdkPoint *end_point) {
+  compute_selections (view, EV_SELECTION_STYLE_GLYPH, start_point, end_point);
 }
 
 static char *
-get_selected_text (EvView *view)
-{
-	GString *text;
-	GList *l;
-	gchar *normalized_text;
+get_selected_text (EvView *view) {
+  GString *text;
+  GList *l;
+  gchar *normalized_text;
+
+  text = g_string_new (NULL);
 
-	text = g_string_new (NULL);
+  ev_document_doc_mutex_lock ();
 
-	ev_document_doc_mutex_lock ();
+  for (l = view->selection_info.selections; l != NULL; l = l->next) {
+    EvViewSelection *selection = (EvViewSelection *)l->data;
+    EvPage *page;
+    gchar *tmp;
 
-	for (l = view->selection_info.selections; l != NULL; l = l->next) {
-		EvViewSelection *selection = (EvViewSelection *)l->data;
-		EvPage *page;
-		gchar *tmp;
+    page = ev_document_get_page (view->document, selection->page);
+    tmp = ev_selection_get_selected_text (EV_SELECTION (view->document),
+                                          page, selection->style,
+                                          &(selection->rect));
+    g_object_unref (page);
+    g_string_append (text, tmp);
+    g_free (tmp);
+  }
 
-		page = ev_document_get_page (view->document, selection->page);
-		tmp = ev_selection_get_selected_text (EV_SELECTION (view->document),
-						      page, selection->style,
-						      &(selection->rect));
-		g_object_unref (page);
-		g_string_append (text, tmp);
-		g_free (tmp);
-	}
+  ev_document_doc_mutex_unlock ();
 
-	ev_document_doc_mutex_unlock ();
-	
-	normalized_text = g_utf8_normalize (text->str, text->len, G_NORMALIZE_NFKC);
-	g_string_free (text, TRUE);
-	return normalized_text;
+  normalized_text = g_utf8_normalize (text->str, text->len, G_NORMALIZE_NFKC);
+  g_string_free (text, TRUE);
+  return normalized_text;
 }
 
 static void
 ev_view_clipboard_copy (EvView      *view,
-			const gchar *text)
-{
-	GtkClipboard *clipboard;
+                        const gchar *text) {
+  GtkClipboard *clipboard;
 
-	clipboard = gtk_widget_get_clipboard (GTK_WIDGET (view),
-					      GDK_SELECTION_CLIPBOARD);
-	gtk_clipboard_set_text (clipboard, text, -1);
+  clipboard = gtk_widget_get_clipboard (GTK_WIDGET (view),
+                                        GDK_SELECTION_CLIPBOARD);
+  gtk_clipboard_set_text (clipboard, text, -1);
 }
 
 void
-ev_view_copy (EvView *ev_view)
-{
-	char *text;
+ev_view_copy (EvView *ev_view) {
+  char *text;
 
-	if (!EV_IS_SELECTION (ev_view->document))
-		return;
+  if (!EV_IS_SELECTION (ev_view->document))
+    return;
 
-	text = get_selected_text (ev_view);
-	ev_view_clipboard_copy (ev_view, text);
-	g_free (text);
+  text = get_selected_text (ev_view);
+  ev_view_clipboard_copy (ev_view, text);
+  g_free (text);
 }
 
 static void
 ev_view_primary_get_cb (GtkClipboard     *clipboard,
-			GtkSelectionData *selection_data,
-			guint             info,
-			gpointer          data)
-{
-	EvView *ev_view = EV_VIEW (data);
-
-	if (ev_view->link_selected) {
-		gtk_selection_data_set_text (selection_data,
-					     ev_link_action_get_uri (ev_view->link_selected),
-					     -1);
-	} else if (EV_IS_SELECTION (ev_view->document) &&
-		   ev_view->selection_info.selections) {
-		gchar *text;
-		
-		text = get_selected_text (ev_view);
-		if (text) {
-			gtk_selection_data_set_text (selection_data, text, -1);
-			g_free (text);
-		}
-	}
+                        GtkSelectionData *selection_data,
+                        guint             info,
+                        gpointer          data) {
+  EvView *ev_view = EV_VIEW (data);
+
+  if (ev_view->link_selected) {
+    gtk_selection_data_set_text (selection_data,
+                                 ev_link_action_get_uri (ev_view->link_selected),
+                                 -1);
+  } else if (EV_IS_SELECTION (ev_view->document) &&
+             ev_view->selection_info.selections) {
+    gchar *text;
+
+    text = get_selected_text (ev_view);
+    if (text) {
+      gtk_selection_data_set_text (selection_data, text, -1);
+      g_free (text);
+    }
+  }
 }
 
 static void
 ev_view_primary_clear_cb (GtkClipboard *clipboard,
-			  gpointer      data)
-{
-	EvView *view = EV_VIEW (data);
+                          gpointer      data) {
+  EvView *view = EV_VIEW (data);
 
-	clear_selection (view);
-	clear_link_selected (view);
+  clear_selection (view);
+  clear_link_selected (view);
 }
 
 static void
-ev_view_update_primary_selection (EvView *ev_view)
-{
-	GtkClipboard *clipboard;
+ev_view_update_primary_selection (EvView *ev_view) {
+  GtkClipboard *clipboard;
 
-	clipboard = gtk_widget_get_clipboard (GTK_WIDGET (ev_view),
-                                              GDK_SELECTION_PRIMARY);
+  clipboard = gtk_widget_get_clipboard (GTK_WIDGET (ev_view),
+                                        GDK_SELECTION_PRIMARY);
 
-	if (ev_view->selection_info.selections || ev_view->link_selected) {
-                GtkTargetList *target_list;
-                GtkTargetEntry *targets;
-                int n_targets;
+  if (ev_view->selection_info.selections || ev_view->link_selected) {
+    GtkTargetList *target_list;
+    GtkTargetEntry *targets;
+    int n_targets;
 
-                target_list = gtk_target_list_new (NULL, 0);
-                gtk_target_list_add_text_targets (target_list, 0);
-                targets = gtk_target_table_new_from_list (target_list, &n_targets);
-                gtk_target_list_unref (target_list);
+    target_list = gtk_target_list_new (NULL, 0);
+    gtk_target_list_add_text_targets (target_list, 0);
+    targets = gtk_target_table_new_from_list (target_list, &n_targets);
+    gtk_target_list_unref (target_list);
 
-		gtk_clipboard_set_with_owner (clipboard,
-					      targets, n_targets,
-					      ev_view_primary_get_cb,
-					      ev_view_primary_clear_cb,
-					      G_OBJECT (ev_view));
+    gtk_clipboard_set_with_owner (clipboard,
+                                  targets, n_targets,
+                                  ev_view_primary_get_cb,
+                                  ev_view_primary_clear_cb,
+                                  G_OBJECT (ev_view));
 
-                gtk_target_table_free (targets, n_targets);
-	} else {
-		if (gtk_clipboard_get_owner (clipboard) == G_OBJECT (ev_view))
-			gtk_clipboard_clear (clipboard);
-	}
+    gtk_target_table_free (targets, n_targets);
+  } else {
+    if (gtk_clipboard_get_owner (clipboard) == G_OBJECT (ev_view))
+      gtk_clipboard_clear (clipboard);
+  }
 }
 
 static void
-clear_link_selected (EvView *view)
-{
-	if (view->link_selected) {
-		g_object_unref (view->link_selected);
-		view->link_selected = NULL;
-	}
+clear_link_selected (EvView *view) {
+  if (view->link_selected) {
+    g_object_unref (view->link_selected);
+    view->link_selected = NULL;
+  }
 }
 
 void
 ev_view_copy_link_address (EvView       *view,
-			   EvLinkAction *action)
-{
-	clear_link_selected (view);
-	
-	ev_view_clipboard_copy (view, ev_link_action_get_uri (action));
-	
-	view->link_selected = g_object_ref (action);
-	ev_view_update_primary_selection (view);
+                           EvLinkAction *action) {
+  clear_link_selected (view);
+
+  ev_view_clipboard_copy (view, ev_link_action_get_uri (action));
+
+  view->link_selected = g_object_ref (action);
+  ev_view_update_primary_selection (view);
 }
 
 /*** Cursor operations ***/
 static void
-ev_view_set_cursor (EvView *view, EvViewCursor new_cursor)
-{
-	GdkCursor *cursor = NULL;
-	GtkWidget *widget;
-	GdkWindow *window;
+ev_view_set_cursor (EvView *view, EvViewCursor new_cursor) {
+  GdkCursor *cursor = NULL;
+  GtkWidget *widget;
+  GdkWindow *window;
 
-	if (view->cursor == new_cursor) {
-		return;
-	}
+  if (view->cursor == new_cursor) {
+    return;
+  }
 
-	view->cursor = new_cursor;
+  view->cursor = new_cursor;
 
-	window = gtk_widget_get_window (GTK_WIDGET (view));
-	widget = gtk_widget_get_toplevel (GTK_WIDGET (view));
-	cursor = ev_view_cursor_new (gtk_widget_get_display (widget), new_cursor);
-	gdk_window_set_cursor (window, cursor);
-	gdk_display_flush (gtk_widget_get_display (widget));
-	if (cursor)
-		g_object_unref (cursor);
+  window = gtk_widget_get_window (GTK_WIDGET (view));
+  widget = gtk_widget_get_toplevel (GTK_WIDGET (view));
+  cursor = ev_view_cursor_new (gtk_widget_get_display (widget), new_cursor);
+  gdk_window_set_cursor (window, cursor);
+  gdk_display_flush (gtk_widget_get_display (widget));
+  if (cursor)
+    g_object_unref (cursor);
 }
 
 void
-ev_view_hide_cursor (EvView *view)
-{
-       ev_view_set_cursor (view, EV_VIEW_CURSOR_HIDDEN);
+ev_view_hide_cursor (EvView *view) {
+  ev_view_set_cursor (view, EV_VIEW_CURSOR_HIDDEN);
 }
 
 void
-ev_view_show_cursor (EvView *view)
-{
-       ev_view_set_cursor (view, EV_VIEW_CURSOR_NORMAL);
+ev_view_show_cursor (EvView *view) {
+  ev_view_set_cursor (view, EV_VIEW_CURSOR_NORMAL);
 }
 
 gboolean
-ev_view_next_page (EvView *view)
-{
-	gint next_page;
+ev_view_next_page (EvView *view) {
+  gint next_page;
 
-	g_return_val_if_fail (EV_IS_VIEW (view), FALSE);
+  g_return_val_if_fail (EV_IS_VIEW (view), FALSE);
 
-	next_page = go_to_next_page (view, view->current_page);
-	if (next_page == -1)
-		return FALSE;
+  next_page = go_to_next_page (view, view->current_page);
+  if (next_page == -1)
+    return FALSE;
 
-	ev_document_model_set_page (view->model, next_page);
+  ev_document_model_set_page (view->model, next_page);
 
-	return TRUE;
+  return TRUE;
 }
 
 gboolean
-ev_view_previous_page (EvView *view)
-{
-	gint prev_page;
+ev_view_previous_page (EvView *view) {
+  gint prev_page;
 
-	g_return_val_if_fail (EV_IS_VIEW (view), FALSE);
+  g_return_val_if_fail (EV_IS_VIEW (view), FALSE);
 
-	prev_page = go_to_previous_page (view, view->current_page);
-	if (prev_page == -1)
-		return FALSE;
+  prev_page = go_to_previous_page (view, view->current_page);
+  if (prev_page == -1)
+    return FALSE;
 
-	ev_document_model_set_page (view->model, prev_page);
+  ev_document_model_set_page (view->model, prev_page);
 
-	return TRUE;
+  return TRUE;
 }
 
 void
-ev_view_set_allow_links_change_zoom (EvView *view, gboolean allowed)
-{
-	g_return_if_fail (EV_IS_VIEW (view));
+ev_view_set_allow_links_change_zoom (EvView *view, gboolean allowed) {
+  g_return_if_fail (EV_IS_VIEW (view));
 
-	view->allow_links_change_zoom = allowed;
+  view->allow_links_change_zoom = allowed;
 }
 
 gboolean
-ev_view_get_allow_links_change_zoom (EvView *view)
-{
-	g_return_val_if_fail (EV_IS_VIEW (view), FALSE);
+ev_view_get_allow_links_change_zoom (EvView *view) {
+  g_return_val_if_fail (EV_IS_VIEW (view), FALSE);
 
-	return view->allow_links_change_zoom;
+  return view->allow_links_change_zoom;
 }
diff --git a/shell/ev-metadata.c b/shell/ev-metadata.c
index b0e23a1..1cd2c6f 100644
--- a/shell/ev-metadata.c
+++ b/shell/ev-metadata.c
@@ -20,19 +20,19 @@
 
 #include <gio/gio.h>
 #include <string.h>
-
+#include <stdio.h>
 #include "ev-metadata.h"
 #include "ev-file-helpers.h"
 
 struct _EvMetadata {
-	GObject base;
+  GObject base;
 
-	GFile      *file;
-	GHashTable *items;
+  GFile      *file;
+  GHashTable *items;
 };
 
 struct _EvMetadataClass {
-	GObjectClass base_class;
+  GObjectClass base_class;
 };
 
 G_DEFINE_TYPE (EvMetadata, ev_metadata, G_TYPE_OBJECT)
@@ -40,286 +40,269 @@ G_DEFINE_TYPE (EvMetadata, ev_metadata, G_TYPE_OBJECT)
 #define EV_METADATA_NAMESPACE "metadata::evince"
 
 static void
-ev_metadata_finalize (GObject *object)
-{
-	EvMetadata *metadata = EV_METADATA (object);
+ev_metadata_finalize (GObject *object) {
+  EvMetadata *metadata = EV_METADATA (object);
 
-	if (metadata->items) {
-		g_hash_table_destroy (metadata->items);
-		metadata->items = NULL;
-	}
+  if (metadata->items) {
+    g_hash_table_destroy (metadata->items);
+    metadata->items = NULL;
+  }
 
-	if (metadata->file) {
-		g_object_unref (metadata->file);
-		metadata->file = NULL;
-	}
+  if (metadata->file) {
+    g_object_unref (metadata->file);
+    metadata->file = NULL;
+  }
 
-	G_OBJECT_CLASS (ev_metadata_parent_class)->finalize (object);
+  G_OBJECT_CLASS (ev_metadata_parent_class)->finalize (object);
 }
 
 static void
-ev_metadata_init (EvMetadata *metadata)
-{
-	metadata->items = g_hash_table_new_full (g_str_hash,
-						 g_str_equal,
-						 g_free,
-						 g_free);
+ev_metadata_init (EvMetadata *metadata) {
+  metadata->items = g_hash_table_new_full (g_str_hash,
+                                           g_str_equal,
+                                           g_free,
+                                           g_free);
 }
 
 static void
-ev_metadata_class_init (EvMetadataClass *klass)
-{
-	GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+ev_metadata_class_init (EvMetadataClass *klass) {
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 
-	gobject_class->finalize = ev_metadata_finalize;
+  gobject_class->finalize = ev_metadata_finalize;
 }
 
 static void
-ev_metadata_load (EvMetadata *metadata)
-{
-	GFileInfo *info;
-	gchar    **attrs;
-	gint       i;
-	GError    *error = NULL;
-
-	info = g_file_query_info (metadata->file, "metadata::*", 0, NULL, &error);
-	if (!info) {
-		g_warning ("%s", error->message);
-		g_error_free (error);
-
-		return;
-	}
-
-	if (!g_file_info_has_namespace (info, "metadata")) {
-		g_object_unref (info);
-
-		return;
-	}
-
-	attrs = g_file_info_list_attributes (info, "metadata");
-	for (i = 0; attrs[i]; i++) {
-		GFileAttributeType type;
-		gpointer           value;
-		const gchar       *key;
-
-		if (!g_str_has_prefix (attrs[i], EV_METADATA_NAMESPACE))
-			continue;
-
-		if (!g_file_info_get_attribute_data (info, attrs[i],
-						     &type, &value, NULL)) {
-			continue;
-		}
-
-		key = attrs[i] + strlen (EV_METADATA_NAMESPACE"::");
-
-		if (type == G_FILE_ATTRIBUTE_TYPE_STRING) {
-			g_hash_table_insert (metadata->items,
-					     g_strdup (key),
-					     g_strdup (value));
-		}
-	}
-	g_strfreev (attrs);
-	g_object_unref (info);
+ev_metadata_load (EvMetadata *metadata) {
+  GFileInfo *info;
+  gchar    **attrs;
+  gint       i;
+  GError    *error = NULL;
+
+  info = g_file_query_info (metadata->file, "metadata::*", 0, NULL, &error);
+  if (!info) {
+    g_warning ("%s", error->message);
+    g_error_free (error);
+
+    return;
+  }
+
+  if (!g_file_info_has_namespace (info, "metadata")) {
+    g_object_unref (info);
+
+    return;
+  }
+
+  attrs = g_file_info_list_attributes (info, "metadata");
+  for (i = 0; attrs[i]; i++) {
+    GFileAttributeType type;
+    gpointer           value;
+    const gchar       *key;
+
+    if (!g_str_has_prefix (attrs[i], EV_METADATA_NAMESPACE))
+      continue;
+
+    if (!g_file_info_get_attribute_data (info, attrs[i],
+                                         &type, &value, NULL)) {
+      continue;
+    }
+
+    key = attrs[i] + strlen (EV_METADATA_NAMESPACE"::");
+//        printf("print metadata keys: %s\n",key);
+    if (type == G_FILE_ATTRIBUTE_TYPE_STRING) {
+      g_hash_table_insert (metadata->items,
+                           g_strdup (key),
+                           g_strdup (value));
+    }
+  }
+  g_strfreev (attrs);
+  g_object_unref (info);
 }
 
 EvMetadata *
-ev_metadata_new (GFile *file)
-{
-	EvMetadata *metadata;
+ev_metadata_new (GFile *file) {
+  EvMetadata *metadata;
 
-	g_return_val_if_fail (G_IS_FILE (file), NULL);
+  g_return_val_if_fail (G_IS_FILE (file), NULL);
 
-	metadata = EV_METADATA (g_object_new (EV_TYPE_METADATA, NULL));
-        if (!ev_file_is_temp (file)) {
-                metadata->file = g_object_ref (file);
-                ev_metadata_load (metadata);
-        }
+  metadata = EV_METADATA (g_object_new (EV_TYPE_METADATA, NULL));
+  if (!ev_file_is_temp (file)) {
+    metadata->file = g_object_ref (file);
+    ev_metadata_load (metadata);
+  }
 
-	return metadata;
+  return metadata;
 }
 
 gboolean
-ev_metadata_is_empty (EvMetadata *metadata)
-{
-	return g_hash_table_size (metadata->items) == 0;
+ev_metadata_is_empty (EvMetadata *metadata) {
+  return g_hash_table_size (metadata->items) == 0;
 }
 
 gboolean
 ev_metadata_get_string (EvMetadata  *metadata,
-			const gchar *key,
-			gchar     **value)
-{
-	gchar *v;
+                        const gchar *key,
+                        gchar     **value) {
+  gchar *v;
 
-	v = g_hash_table_lookup (metadata->items, key);
-	if (!v)
-		return FALSE;
+  v = g_hash_table_lookup (metadata->items, key);
+  if (!v)
+    return FALSE;
 
-	*value = v;
-	return TRUE;
+  *value = v;
+  return TRUE;
 }
 
 static void
 metadata_set_callback (GObject      *file,
-		       GAsyncResult *result,
-		       EvMetadata   *metadata)
-{
-	GError *error = NULL;
-
-	if (!g_file_set_attributes_finish (G_FILE (file), result, NULL, &error)) {
-		g_warning ("%s", error->message);
-		g_error_free (error);
-	}
+                       GAsyncResult *result,
+                       EvMetadata   *metadata) {
+  GError *error = NULL;
+
+  if (!g_file_set_attributes_finish (G_FILE (file), result, NULL, &error)) {
+    g_warning ("%s", error->message);
+    g_error_free (error);
+  }
 }
 
 gboolean
-ev_metadata_set_string (EvMetadata  *metadata,
-			const gchar *key,
-			const gchar *value)
-{
-	GFileInfo *info;
-	gchar     *gio_key;
-
-        g_hash_table_insert (metadata->items, g_strdup (key), g_strdup (value));
-        if (!metadata->file)
-                return TRUE;
-
-	info = g_file_info_new ();
-
-	gio_key = g_strconcat (EV_METADATA_NAMESPACE"::", key, NULL);
-	if (value) {
-		g_file_info_set_attribute_string (info, gio_key, value);
-	} else {
-		g_file_info_set_attribute (info, gio_key,
-					   G_FILE_ATTRIBUTE_TYPE_INVALID,
-					   NULL);
-	}
-	g_free (gio_key);
-
-	g_file_set_attributes_async (metadata->file,
-				     info,
-				     0,
-				     G_PRIORITY_DEFAULT,
-				     NULL,
-				     (GAsyncReadyCallback)metadata_set_callback,
-				     metadata);
-	g_object_unref (info);
-
-	return TRUE;
+    ev_metadata_set_string (EvMetadata  *metadata,
+                        const gchar *key,
+                        const gchar *value) {
+  GFileInfo *info;
+  gchar     *gio_key;
+
+  g_hash_table_insert (metadata->items, g_strdup (key), g_strdup (value));
+  if (!metadata->file)
+    return TRUE;
+
+  info = g_file_info_new ();
+
+  gio_key = g_strconcat (EV_METADATA_NAMESPACE"::", key, NULL);
+  if (value) {
+    g_file_info_set_attribute_string (info, gio_key, value);
+  } else {
+    g_file_info_set_attribute (info, gio_key,
+                               G_FILE_ATTRIBUTE_TYPE_INVALID,
+                               NULL);
+  }
+  g_free (gio_key);
+
+  g_file_set_attributes_async (metadata->file,
+                               info,
+                               0,
+                               G_PRIORITY_DEFAULT,
+                               NULL,
+                               (GAsyncReadyCallback)metadata_set_callback,
+                               metadata);
+  g_object_unref (info);
+
+  return TRUE;
 }
 
 gboolean
 ev_metadata_get_int (EvMetadata  *metadata,
-		     const gchar *key,
-		     gint        *value)
-{
-	gchar *string_value;
-	gchar *endptr;
-	gint   int_value;
-
-	if (!ev_metadata_get_string (metadata, key, &string_value))
-		return FALSE;
-
-	int_value = g_ascii_strtoull (string_value, &endptr, 0);
-	if (int_value == 0 && string_value == endptr)
-		return FALSE;
-
-	*value = int_value;
-	return TRUE;
+                     const gchar *key,
+                     gint        *value) {
+  gchar *string_value;
+  gchar *endptr;
+  gint   int_value;
+
+  if (!ev_metadata_get_string (metadata, key, &string_value))
+    return FALSE;
+
+  int_value = g_ascii_strtoull (string_value, &endptr, 0);
+  if (int_value == 0 && string_value == endptr)
+    return FALSE;
+
+  *value = int_value;
+  return TRUE;
 }
 
 gboolean
 ev_metadata_set_int (EvMetadata  *metadata,
-		     const gchar *key,
-		     gint         value)
-{
-	gchar string_value[32];
+                     const gchar *key,
+                     gint         value) {
+  gchar string_value[32];
 
-	g_snprintf (string_value, sizeof (string_value), "%d", value);
+  g_snprintf (string_value, sizeof (string_value), "%d", value);
 
-	return ev_metadata_set_string (metadata, key, string_value);
+  return ev_metadata_set_string (metadata, key, string_value);
 }
 
 gboolean
 ev_metadata_get_double (EvMetadata  *metadata,
-			const gchar *key,
-			gdouble     *value)
-{
-	gchar  *string_value;
-	gchar  *endptr;
-	gdouble double_value;
-
-	if (!ev_metadata_get_string (metadata, key, &string_value))
-		return FALSE;
-
-	double_value = g_ascii_strtod (string_value, &endptr);
-	if (double_value == 0. && string_value == endptr)
-		return FALSE;
-
-	*value = double_value;
-	return TRUE;
+                        const gchar *key,
+                        gdouble     *value) {
+  gchar  *string_value;
+  gchar  *endptr;
+  gdouble double_value;
+
+  if (!ev_metadata_get_string (metadata, key, &string_value))
+    return FALSE;
+
+  double_value = g_ascii_strtod (string_value, &endptr);
+  if (double_value == 0. && string_value == endptr)
+    return FALSE;
+
+  *value = double_value;
+  return TRUE;
 }
 
 gboolean
 ev_metadata_set_double (EvMetadata  *metadata,
-			const gchar *key,
-			gdouble      value)
-{
-	gchar string_value[G_ASCII_DTOSTR_BUF_SIZE];
+                        const gchar *key,
+                        gdouble      value) {
+  gchar string_value[G_ASCII_DTOSTR_BUF_SIZE];
 
-	g_ascii_dtostr (string_value, G_ASCII_DTOSTR_BUF_SIZE, value);
+  g_ascii_dtostr (string_value, G_ASCII_DTOSTR_BUF_SIZE, value);
 
-	return ev_metadata_set_string (metadata, key, string_value);
+  return ev_metadata_set_string (metadata, key, string_value);
 }
 
 gboolean
 ev_metadata_get_boolean (EvMetadata  *metadata,
-			 const gchar *key,
-			 gboolean    *value)
-{
-	gint int_value;
+                         const gchar *key,
+                         gboolean    *value) {
+  gint int_value;
 
-	if (!ev_metadata_get_int (metadata, key, &int_value))
-		return FALSE;
+  if (!ev_metadata_get_int (metadata, key, &int_value))
+    return FALSE;
 
-	*value = int_value;
-	return TRUE;
+  *value = int_value;
+  return TRUE;
 }
 
 gboolean
 ev_metadata_set_boolean (EvMetadata  *metadata,
-			 const gchar *key,
-			 gboolean     value)
-{
-	return ev_metadata_set_string (metadata, key, value ? "1" : "0");
+                         const gchar *key,
+                         gboolean     value) {
+  return ev_metadata_set_string (metadata, key, value ? "1" : "0");
 }
 
 gboolean
 ev_metadata_has_key (EvMetadata  *metadata,
-                     const gchar *key)
-{
-        return g_hash_table_lookup (metadata->items, key) != NULL;
+                     const gchar *key) {
+  return g_hash_table_lookup (metadata->items, key) != NULL;
 }
 
 gboolean
-ev_is_metadata_supported_for_file (GFile *file)
-{
-	GFileAttributeInfoList *namespaces;
-	gint i;
-	gboolean retval = FALSE;
-
-	namespaces = g_file_query_writable_namespaces (file, NULL, NULL);
-	if (!namespaces)
-		return retval;
-
-	for (i = 0; i < namespaces->n_infos; i++) {
-		if (strcmp (namespaces->infos[i].name, "metadata") == 0) {
-			retval = TRUE;
-			break;
-		}
-	}
-
-	g_file_attribute_info_list_unref (namespaces);
-
-	return retval;
+ev_is_metadata_supported_for_file (GFile *file) {
+  GFileAttributeInfoList *namespaces;
+  gint i;
+  gboolean retval = FALSE;
+
+  namespaces = g_file_query_writable_namespaces (file, NULL, NULL);
+  if (!namespaces)
+    return retval;
+
+  for (i = 0; i < namespaces->n_infos; i++) {
+    if (strcmp (namespaces->infos[i].name, "metadata") == 0) {
+      retval = TRUE;
+      break;
+    }
+  }
+
+  g_file_attribute_info_list_unref (namespaces);
+
+  return retval;
 }
diff --git a/shell/ev-metadata.h b/shell/ev-metadata.h
index 7fd4f05..82d70b6 100644
--- a/shell/ev-metadata.h
+++ b/shell/ev-metadata.h
@@ -39,29 +39,29 @@ EvMetadata *ev_metadata_new                   (GFile       *file);
 gboolean    ev_metadata_is_empty              (EvMetadata  *metadata);
 
 gboolean    ev_metadata_get_string            (EvMetadata  *metadata,
-					       const gchar *key,
-					       gchar     **value);
+                                               const gchar *key,
+                                               gchar     **value);
 gboolean    ev_metadata_set_string            (EvMetadata  *metadata,
-					       const gchar *key,
-					       const gchar *value);
+                                               const gchar *key,
+                                               const gchar *value);
 gboolean    ev_metadata_get_int               (EvMetadata  *metadata,
-					       const gchar *key,
-					       gint        *value);
+                                               const gchar *key,
+                                               gint        *value);
 gboolean    ev_metadata_set_int               (EvMetadata  *metadata,
-					       const gchar *key,
-					       gint         value);
+                                               const gchar *key,
+                                               gint         value);
 gboolean    ev_metadata_get_double            (EvMetadata  *metadata,
-					       const gchar *key,
-					       gdouble     *value);
+                                               const gchar *key,
+                                               gdouble     *value);
 gboolean    ev_metadata_set_double            (EvMetadata  *metadata,
-					       const gchar *key,
-					       gdouble      value);
+                                               const gchar *key,
+                                               gdouble      value);
 gboolean    ev_metadata_get_boolean           (EvMetadata  *metadata,
-					       const gchar *key,
-					       gboolean    *value);
+                                               const gchar *key,
+                                               gboolean    *value);
 gboolean    ev_metadata_set_boolean           (EvMetadata  *metadata,
-					       const gchar *key,
-					       gboolean     value);
+                                               const gchar *key,
+                                               gboolean     value);
 gboolean    ev_metadata_has_key               (EvMetadata  *metadata,
                                                const gchar *key);
 
diff --git a/shell/ev-sidebar-annotations.c b/shell/ev-sidebar-annotations.c
index fd1be90..9c4642a 100644
--- a/shell/ev-sidebar-annotations.c
+++ b/shell/ev-sidebar-annotations.c
@@ -32,43 +32,43 @@
 #include "ev-utils.h"
 
 enum {
-	PROP_0,
-	PROP_WIDGET
+  PROP_0,
+  PROP_WIDGET
 };
 
 enum {
-	COLUMN_MARKUP,
-	COLUMN_ICON,
-	COLUMN_ANNOT_MAPPING,
-	N_COLUMNS
+  COLUMN_MARKUP,
+  COLUMN_ICON,
+  COLUMN_ANNOT_MAPPING,
+  N_COLUMNS
 };
 
 enum {
-	ANNOT_ACTIVATED,
-	N_SIGNALS
+  ANNOT_ACTIVATED,
+  N_SIGNALS
 };
 
 struct _EvSidebarAnnotationsPrivate {
-	EvDocument  *document;
+  EvDocument  *document;
 
-        GtkWidget   *swindow;
-	GtkWidget   *tree_view;
+  GtkWidget   *swindow;
+  GtkWidget   *tree_view;
 
-	GMenuModel  *popup_model;
-	GtkWidget   *popup;
+  GMenuModel  *popup_model;
+  GtkWidget   *popup;
 
-	EvJob       *job;
-	guint        selection_changed_id;
+  EvJob       *job;
+  guint        selection_changed_id;
 };
 
 static void ev_sidebar_annotations_page_iface_init (EvSidebarPageInterface *iface);
 static void ev_sidebar_annotations_load            (EvSidebarAnnotations   *sidebar_annots);
 static gboolean ev_sidebar_annotations_popup_menu (GtkWidget *widget);
 static gboolean ev_sidebar_annotations_popup_menu_show (EvSidebarAnnotations *sidebar_annots,
-							GdkWindow            *rect_window,
-							const GdkRectangle   *rect,
-							EvMapping            *annot_mapping,
-							const GdkEvent       *event);
+                                                        GdkWindow            *rect_window,
+                                                        const GdkRectangle   *rect,
+                                                        EvMapping            *annot_mapping,
+                                                        const GdkEvent       *event);
 static guint signals[N_SIGNALS];
 
 G_DEFINE_TYPE_EXTENDED (EvSidebarAnnotations,
@@ -77,161 +77,153 @@ G_DEFINE_TYPE_EXTENDED (EvSidebarAnnotations,
                         0,
                         G_ADD_PRIVATE (EvSidebarAnnotations)
                         G_IMPLEMENT_INTERFACE (EV_TYPE_SIDEBAR_PAGE,
-					       ev_sidebar_annotations_page_iface_init))
+                                               ev_sidebar_annotations_page_iface_init))
 
 #define ANNOT_ICON_SIZE 16
 
 static void
-ev_sidebar_annotations_dispose (GObject *object)
-{
-	EvSidebarAnnotations *sidebar_annots = EV_SIDEBAR_ANNOTATIONS (object);
-	EvSidebarAnnotationsPrivate *priv = sidebar_annots->priv;
-
-	if (priv->document) {
-		g_object_unref (priv->document);
-		priv->document = NULL;
-	}
-
-	g_clear_object (&priv->popup_model);
-	G_OBJECT_CLASS (ev_sidebar_annotations_parent_class)->dispose (object);
+ev_sidebar_annotations_dispose (GObject *object) {
+  EvSidebarAnnotations *sidebar_annots = EV_SIDEBAR_ANNOTATIONS (object);
+  EvSidebarAnnotationsPrivate *priv = sidebar_annots->priv;
+
+  if (priv->document) {
+    g_object_unref (priv->document);
+    priv->document = NULL;
+  }
+
+  g_clear_object (&priv->popup_model);
+  G_OBJECT_CLASS (ev_sidebar_annotations_parent_class)->dispose (object);
 }
 
 static GtkTreeModel *
-ev_sidebar_annotations_create_simple_model (const gchar *message)
-{
-	GtkTreeModel *retval;
-	GtkTreeIter iter;
-	gchar *markup;
-
-	/* Creates a fake model to indicate that we're loading */
-	retval = (GtkTreeModel *)gtk_list_store_new (N_COLUMNS,
-						     G_TYPE_STRING,
-						     GDK_TYPE_PIXBUF,
-						     G_TYPE_POINTER);
-
-	gtk_list_store_append (GTK_LIST_STORE (retval), &iter);
-	markup = g_strdup_printf ("<span size=\"larger\" style=\"italic\">%s</span>",
-				  message);
-	gtk_list_store_set (GTK_LIST_STORE (retval), &iter,
-			    COLUMN_MARKUP, markup,
-			    -1);
-	g_free (markup);
-
-	return retval;
+ev_sidebar_annotations_create_simple_model (const gchar *message) {
+  GtkTreeModel *retval;
+  GtkTreeIter iter;
+  gchar *markup;
+
+  /* Creates a fake model to indicate that we're loading */
+  retval = (GtkTreeModel *)gtk_list_store_new (N_COLUMNS,
+                                               G_TYPE_STRING,
+                                               GDK_TYPE_PIXBUF,
+                                               G_TYPE_POINTER);
+
+  gtk_list_store_append (GTK_LIST_STORE (retval), &iter);
+  markup = g_strdup_printf ("<span size=\"larger\" style=\"italic\">%s</span>",
+                            message);
+  gtk_list_store_set (GTK_LIST_STORE (retval), &iter,
+                      COLUMN_MARKUP, markup,
+                      -1);
+  g_free (markup);
+
+  return retval;
 }
 
 static void
-ev_sidebar_annotations_init (EvSidebarAnnotations *ev_annots)
-{
-	GtkTreeModel      *loading_model;
-	GtkCellRenderer   *renderer;
-	GtkTreeViewColumn *column;
-	GtkTreeSelection  *selection;
-	GtkBuilder        *builder;
-
-        ev_annots->priv = ev_sidebar_annotations_get_instance_private (ev_annots);
-
-	ev_annots->priv->swindow = gtk_scrolled_window_new (NULL, NULL);
-
-	/* Create tree view */
-	loading_model = ev_sidebar_annotations_create_simple_model (_("Loading…"));
-	ev_annots->priv->tree_view = gtk_tree_view_new_with_model (loading_model);
-	g_object_unref (loading_model);
-
-	gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (ev_annots->priv->tree_view),
-					   FALSE);
-	selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (ev_annots->priv->tree_view));
-	gtk_tree_selection_set_mode (selection, GTK_SELECTION_NONE);
-
-	column = gtk_tree_view_column_new ();
-
-	renderer = gtk_cell_renderer_pixbuf_new ();
-	gtk_tree_view_column_pack_start (column, renderer, FALSE);
-	gtk_tree_view_column_set_attributes (column, renderer,
-					     "pixbuf", COLUMN_ICON,
-					     NULL);
-
-	renderer = gtk_cell_renderer_text_new ();
-	gtk_tree_view_column_pack_start (column, renderer, TRUE);
-	gtk_tree_view_column_set_attributes (column, renderer,
-					     "markup", COLUMN_MARKUP,
-					     NULL);
-	gtk_tree_view_append_column (GTK_TREE_VIEW (ev_annots->priv->tree_view),
-				     column);
-
-	gtk_container_add (GTK_CONTAINER (ev_annots->priv->swindow), ev_annots->priv->tree_view);
-	gtk_widget_show (ev_annots->priv->tree_view);
-
-	/* Annotation pop-up */
-	builder = gtk_builder_new_from_resource ("/org/gnome/evince/gtk/menus.ui");
-	ev_annots->priv->popup_model = g_object_ref (G_MENU_MODEL (gtk_builder_get_object (builder, "annotation-popup")));
-	g_object_unref (builder);
-        gtk_box_pack_start (GTK_BOX (ev_annots), ev_annots->priv->swindow, TRUE, TRUE, 0);
-	gtk_widget_show (ev_annots->priv->swindow);
+ev_sidebar_annotations_init (EvSidebarAnnotations *ev_annots) {
+  GtkTreeModel      *loading_model;
+  GtkCellRenderer   *renderer;
+  GtkTreeViewColumn *column;
+  GtkTreeSelection  *selection;
+  GtkBuilder        *builder;
+
+  ev_annots->priv = ev_sidebar_annotations_get_instance_private (ev_annots);
+
+  ev_annots->priv->swindow = gtk_scrolled_window_new (NULL, NULL);
+
+  /* Create tree view */
+  loading_model = ev_sidebar_annotations_create_simple_model (_("Loading…"));
+  ev_annots->priv->tree_view = gtk_tree_view_new_with_model (loading_model);
+  g_object_unref (loading_model);
+
+  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (ev_annots->priv->tree_view),
+                                     FALSE);
+  selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (ev_annots->priv->tree_view));
+  gtk_tree_selection_set_mode (selection, GTK_SELECTION_NONE);
+
+  column = gtk_tree_view_column_new ();
+
+  renderer = gtk_cell_renderer_pixbuf_new ();
+  gtk_tree_view_column_pack_start (column, renderer, FALSE);
+  gtk_tree_view_column_set_attributes (column, renderer,
+                                       "pixbuf", COLUMN_ICON,
+                                       NULL);
+
+  renderer = gtk_cell_renderer_text_new ();
+  gtk_tree_view_column_pack_start (column, renderer, TRUE);
+  gtk_tree_view_column_set_attributes (column, renderer,
+                                       "markup", COLUMN_MARKUP,
+                                       NULL);
+  gtk_tree_view_append_column (GTK_TREE_VIEW (ev_annots->priv->tree_view),
+                               column);
+
+  gtk_container_add (GTK_CONTAINER (ev_annots->priv->swindow), ev_annots->priv->tree_view);
+  gtk_widget_show (ev_annots->priv->tree_view);
+
+  /* Annotation pop-up */
+  builder = gtk_builder_new_from_resource ("/org/gnome/evince/gtk/menus.ui");
+  ev_annots->priv->popup_model = g_object_ref (G_MENU_MODEL (gtk_builder_get_object (builder, "annotation-popup")));
+  g_object_unref (builder);
+  gtk_box_pack_start (GTK_BOX (ev_annots), ev_annots->priv->swindow, TRUE, TRUE, 0);
+  gtk_widget_show (ev_annots->priv->swindow);
 }
 
 static void
 ev_sidebar_annotations_get_property (GObject    *object,
-				     guint       prop_id,
-				     GValue     *value,
-				     GParamSpec *pspec)
-{
-	EvSidebarAnnotations *ev_sidebar_annots;
-
-	ev_sidebar_annots = EV_SIDEBAR_ANNOTATIONS (object);
-
-	switch (prop_id) {
-	        case PROP_WIDGET:
-			g_value_set_object (value, ev_sidebar_annots->priv->swindow);
-			break;
-	        default:
-			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-			break;
-	}
+                                     guint       prop_id,
+                                     GValue     *value,
+                                     GParamSpec *pspec) {
+  EvSidebarAnnotations *ev_sidebar_annots;
+
+  ev_sidebar_annots = EV_SIDEBAR_ANNOTATIONS (object);
+
+  switch (prop_id) {
+    case PROP_WIDGET:
+      g_value_set_object (value, ev_sidebar_annots->priv->swindow);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
 }
 
 static void
-ev_sidebar_annotations_class_init (EvSidebarAnnotationsClass *klass)
-{
-	GObjectClass *g_object_class = G_OBJECT_CLASS (klass);
-	GtkWidgetClass *gtk_widget_class = GTK_WIDGET_CLASS (klass);
-
-	g_object_class->get_property = ev_sidebar_annotations_get_property;
-	g_object_class->dispose = ev_sidebar_annotations_dispose;
-	gtk_widget_class->popup_menu = ev_sidebar_annotations_popup_menu;
-
-	g_object_class_override_property (g_object_class, PROP_WIDGET, "main-widget");
-
-	signals[ANNOT_ACTIVATED] =
-		g_signal_new ("annot-activated",
-			      G_TYPE_FROM_CLASS (g_object_class),
-			      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
-			      G_STRUCT_OFFSET (EvSidebarAnnotationsClass, annot_activated),
-			      NULL, NULL,
-			      g_cclosure_marshal_VOID__POINTER,
-			      G_TYPE_NONE, 1,
-			      G_TYPE_POINTER);
+ev_sidebar_annotations_class_init (EvSidebarAnnotationsClass *klass) {
+  GObjectClass *g_object_class = G_OBJECT_CLASS (klass);
+  GtkWidgetClass *gtk_widget_class = GTK_WIDGET_CLASS (klass);
+
+  g_object_class->get_property = ev_sidebar_annotations_get_property;
+  g_object_class->dispose = ev_sidebar_annotations_dispose;
+  gtk_widget_class->popup_menu = ev_sidebar_annotations_popup_menu;
+
+  g_object_class_override_property (g_object_class, PROP_WIDGET, "main-widget");
+
+  signals[ANNOT_ACTIVATED] =
+    g_signal_new ("annot-activated",
+                  G_TYPE_FROM_CLASS (g_object_class),
+                  G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+                  G_STRUCT_OFFSET (EvSidebarAnnotationsClass, annot_activated),
+                  NULL, NULL,
+                  g_cclosure_marshal_VOID__POINTER,
+                  G_TYPE_NONE, 1,
+                  G_TYPE_POINTER);
 }
 
 GtkWidget *
-ev_sidebar_annotations_new (void)
-{
-	return GTK_WIDGET (g_object_new (EV_TYPE_SIDEBAR_ANNOTATIONS,
-                                         "orientation", GTK_ORIENTATION_VERTICAL,
-                                         NULL));
+ev_sidebar_annotations_new (void) {
+  return GTK_WIDGET (g_object_new (EV_TYPE_SIDEBAR_ANNOTATIONS,
+                                   "orientation", GTK_ORIENTATION_VERTICAL,
+                                   NULL));
 }
 
 void
 ev_sidebar_annotations_annot_added (EvSidebarAnnotations *sidebar_annots,
-				    EvAnnotation         *annot)
-{
-	ev_sidebar_annotations_load (sidebar_annots);
+                                    EvAnnotation         *annot) {
+  ev_sidebar_annotations_load (sidebar_annots);
 }
 
 void
-ev_sidebar_annotations_annot_removed (EvSidebarAnnotations *sidebar_annots)
-{
-	ev_sidebar_annotations_load (sidebar_annots);
+ev_sidebar_annotations_annot_removed (EvSidebarAnnotations *sidebar_annots) {
+  ev_sidebar_annotations_load (sidebar_annots);
 }
 
 /**
@@ -246,415 +238,401 @@ ev_sidebar_annotations_annot_removed (EvSidebarAnnotations *sidebar_annots)
  */
 static gboolean
 iter_has_mapping (GtkTreeModel  *model,
-		  GtkTreeIter   *iter,
-		  EvMapping     **mapping_out)
-{
-	EvMapping *mapping = NULL;
+                  GtkTreeIter   *iter,
+                  EvMapping     **mapping_out) {
+  EvMapping *mapping = NULL;
 
-	gtk_tree_model_get (model, iter,
-			    COLUMN_ANNOT_MAPPING, &mapping,
-			    -1);
+  gtk_tree_model_get (model, iter,
+                      COLUMN_ANNOT_MAPPING, &mapping,
+                      -1);
 
-	if (mapping_out && mapping)
-		*mapping_out = mapping;
+  if (mapping_out && mapping)
+    *mapping_out = mapping;
 
-	return mapping != NULL;
+  return mapping != NULL;
 }
 
 static void
 ev_sidebar_annotations_activate_result_at_iter (EvSidebarAnnotations *sidebar_annots,
                                                 GtkTreeModel  *model,
-                                                GtkTreeIter   *iter)
-{
-		EvMapping *mapping;
+                                                GtkTreeIter   *iter) {
+  EvMapping *mapping;
 
-		if (iter_has_mapping (model, iter, &mapping))
-			g_signal_emit (sidebar_annots, signals[ANNOT_ACTIVATED], 0, mapping);
+  if (iter_has_mapping (model, iter, &mapping))
+    g_signal_emit (sidebar_annots, signals[ANNOT_ACTIVATED], 0, mapping);
 }
 
 static void
 selection_changed_cb (GtkTreeSelection     *selection,
-		      EvSidebarAnnotations *sidebar_annots)
-{
-	GtkTreeModel *model;
-	GtkTreeIter   iter;
+                      EvSidebarAnnotations *sidebar_annots) {
+  GtkTreeModel *model;
+  GtkTreeIter   iter;
 
-	if (gtk_tree_selection_get_selected (selection, &model, &iter))
-	    ev_sidebar_annotations_activate_result_at_iter (sidebar_annots, model, &iter);
+  if (gtk_tree_selection_get_selected (selection, &model, &iter))
+    ev_sidebar_annotations_activate_result_at_iter (sidebar_annots, model, &iter);
 }
 
 static gboolean
 sidebar_tree_button_press_cb (GtkTreeView    *view,
                               GdkEventButton *event,
-                              EvSidebarAnnotations  *sidebar_annots)
-{
-        GtkTreeModel         *model;
-        GtkTreePath          *path;
-        GtkTreeIter           iter;
-        GtkTreeSelection     *selection;
-        EvMapping            *annot_mapping;
-        GdkRectangle          rect;
-
-        gtk_tree_view_get_path_at_pos (view, event->x, event->y, &path,
-                                       NULL, NULL, NULL);
-        if (!path)
-                return GDK_EVENT_PROPAGATE;
-
-	model = gtk_tree_view_get_model (view);
-	gtk_tree_model_get_iter (model, &iter, path);
-	gtk_tree_path_free (path);
-        selection = gtk_tree_view_get_selection (view);
-
-	if (gdk_event_triggers_context_menu ((const GdkEvent *) event) &&
-	    iter_has_mapping (model, &iter, &annot_mapping)) {
-
-		ev_sidebar_annotations_activate_result_at_iter (sidebar_annots, model, &iter);
-
-		if (!EV_IS_ANNOTATION (annot_mapping->data))
-			return GDK_EVENT_PROPAGATE;
-
-		gtk_tree_selection_select_iter (selection, &iter);
-
-		rect.x = event->x;
-		rect.y = event->y;
-		rect.width = rect.height = 1;
-		ev_sidebar_annotations_popup_menu_show (sidebar_annots,
-							gtk_tree_view_get_bin_window (view),
-							&rect, annot_mapping, (GdkEvent *) event);
-
-		return GDK_EVENT_STOP;
-	} else {
-		if (!gtk_tree_selection_iter_is_selected (selection, &iter))
-			gtk_tree_selection_select_iter (selection, &iter);
-		else
-			/* This will reveal annotation again in case was scrolled out of EvView */
-			ev_sidebar_annotations_activate_result_at_iter (sidebar_annots, model, &iter);
-	}
-
-        /* Propagate so the tree view gets the event and can update the selection etc. */
-        return GDK_EVENT_PROPAGATE;
+                              EvSidebarAnnotations  *sidebar_annots) {
+  GtkTreeModel         *model;
+  GtkTreePath          *path;
+  GtkTreeIter           iter;
+  GtkTreeSelection     *selection;
+  EvMapping            *annot_mapping;
+  GdkRectangle          rect;
+
+  gtk_tree_view_get_path_at_pos (view, event->x, event->y, &path,
+                                 NULL, NULL, NULL);
+  if (!path)
+    return GDK_EVENT_PROPAGATE;
+
+  model = gtk_tree_view_get_model (view);
+  gtk_tree_model_get_iter (model, &iter, path);
+  gtk_tree_path_free (path);
+  selection = gtk_tree_view_get_selection (view);
+
+  if (gdk_event_triggers_context_menu ((const GdkEvent *) event) &&
+      iter_has_mapping (model, &iter, &annot_mapping)) {
+
+    ev_sidebar_annotations_activate_result_at_iter (sidebar_annots, model, &iter);
+
+    if (!EV_IS_ANNOTATION (annot_mapping->data))
+      return GDK_EVENT_PROPAGATE;
+
+    gtk_tree_selection_select_iter (selection, &iter);
+
+    rect.x = event->x;
+    rect.y = event->y;
+    rect.width = rect.height = 1;
+    ev_sidebar_annotations_popup_menu_show (sidebar_annots,
+                                            gtk_tree_view_get_bin_window (view),
+                                            &rect, annot_mapping, (GdkEvent *) event);
+
+    return GDK_EVENT_STOP;
+  } else {
+    if (!gtk_tree_selection_iter_is_selected (selection, &iter))
+      gtk_tree_selection_select_iter (selection, &iter);
+    else
+      /* This will reveal annotation again in case was scrolled out of EvView */
+      ev_sidebar_annotations_activate_result_at_iter (sidebar_annots, model, &iter);
+  }
+
+  /* Propagate so the tree view gets the event and can update the selection etc. */
+  return GDK_EVENT_PROPAGATE;
 }
 
 static void
 job_finished_callback (EvJobAnnots          *job,
-		       EvSidebarAnnotations *sidebar_annots)
-{
-	EvSidebarAnnotationsPrivate *priv;
-	GtkTreeStore *model;
-	GtkTreeSelection *selection;
-	GList *l;
-	GtkIconTheme *icon_theme;
-	GdkScreen *screen;
-	GdkPixbuf *text_icon = NULL;
-	GdkPixbuf *attachment_icon = NULL;
-        GdkPixbuf *highlight_icon = NULL;
-        GdkPixbuf *strike_out_icon = NULL;
-        GdkPixbuf *underline_icon = NULL;
-        GdkPixbuf *squiggly_icon = NULL;
-
-	priv = sidebar_annots->priv;
-
-	if (!job->annots) {
-		GtkTreeModel *list;
-
-		list = ev_sidebar_annotations_create_simple_model (_("Document contains no annotations"));
-		gtk_tree_view_set_model (GTK_TREE_VIEW (priv->tree_view), list);
-		g_object_unref (list);
-
-		g_object_unref (job);
-		priv->job = NULL;
-
-		return;
-	}
-
-	selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (priv->tree_view));
-	gtk_tree_selection_set_mode (selection, GTK_SELECTION_SINGLE);
-	if (priv->selection_changed_id == 0) {
-		priv->selection_changed_id =
-			g_signal_connect (selection, "changed",
-					  G_CALLBACK (selection_changed_cb),
-					  sidebar_annots);
-	}
-    g_signal_connect (priv->tree_view, "button-press-event",
-                      G_CALLBACK (sidebar_tree_button_press_cb),
-                      sidebar_annots);
-
-
-	model = gtk_tree_store_new (N_COLUMNS,
-				    G_TYPE_STRING,
-				    GDK_TYPE_PIXBUF,
-				    G_TYPE_POINTER);
-
-	screen = gtk_widget_get_screen (GTK_WIDGET (sidebar_annots));
-	icon_theme = gtk_icon_theme_get_for_screen (screen);
-
-	for (l = job->annots; l; l = g_list_next (l)) {
-		EvMappingList *mapping_list;
-		GList         *ll;
-		gchar         *page_label;
-		GtkTreeIter    iter;
-		gboolean       found = FALSE;
-
-		mapping_list = (EvMappingList *)l->data;
-		page_label = g_strdup_printf (_("Page %d"),
-					      ev_mapping_list_get_page (mapping_list) + 1);
-		gtk_tree_store_append (model, &iter, NULL);
-		gtk_tree_store_set (model, &iter,
-				    COLUMN_MARKUP, page_label,
-				    -1);
-		g_free (page_label);
-
-		for (ll = ev_mapping_list_get_list (mapping_list); ll; ll = g_list_next (ll)) {
-			EvAnnotation *annot;
-			const gchar  *label;
-			const gchar  *modified;
-			gchar        *markup;
-			GtkTreeIter   child_iter;
-			GdkPixbuf    *pixbuf = NULL;
-
-			annot = ((EvMapping *)(ll->data))->data;
-			if (!EV_IS_ANNOTATION_MARKUP (annot))
-				continue;
-
-			label = ev_annotation_markup_get_label (EV_ANNOTATION_MARKUP (annot));
-			modified = ev_annotation_get_modified (annot);
-			if (modified) {
-				markup = g_strdup_printf ("<span weight=\"bold\">%s</span>\n%s",
-							  label, modified);
-			} else {
-				markup = g_strdup_printf ("<span weight=\"bold\">%s</span>", label);
-			}
-
-			if (EV_IS_ANNOTATION_TEXT (annot)) {
-				if (!text_icon) {
-					text_icon = gtk_icon_theme_load_icon (icon_theme,
-									      EV_STOCK_ANNOT_TEXT,
-									      ANNOT_ICON_SIZE,
-									      0, NULL);
-				}
-				pixbuf = text_icon;
-			} else if (EV_IS_ANNOTATION_ATTACHMENT (annot)) {
-				if (!attachment_icon) {
-					attachment_icon = gtk_icon_theme_load_icon (icon_theme,
-										    "mail-attachment-symbolic",
-										    ANNOT_ICON_SIZE,
-										    0, NULL);
-				}
-				pixbuf = attachment_icon;
-			} else if (EV_IS_ANNOTATION_TEXT_MARKUP (annot)) {
-                                switch (ev_annotation_text_markup_get_markup_type (EV_ANNOTATION_TEXT_MARKUP (annot))) {
-                                case EV_ANNOTATION_TEXT_MARKUP_HIGHLIGHT:
-                                        if (!highlight_icon) {
-                                                /* FIXME: use better icon than select all */
-						highlight_icon = gtk_icon_theme_load_icon (icon_theme,
-											   "format-justify-left-symbolic",
-											   ANNOT_ICON_SIZE,
-											   0, NULL);
-                                        }
-                                        pixbuf = highlight_icon;
-
-                                        break;
-                                case EV_ANNOTATION_TEXT_MARKUP_STRIKE_OUT:
-                                        if (!strike_out_icon) {
-						strike_out_icon = gtk_icon_theme_load_icon (icon_theme,
-											    "format-text-strikethrough-symbolic",
-											    ANNOT_ICON_SIZE,
-											    0, NULL);
-                                        }
-                                        pixbuf = strike_out_icon;
-                                        break;
-                                case EV_ANNOTATION_TEXT_MARKUP_UNDERLINE:
-                                        if (!underline_icon) {
-						underline_icon = gtk_icon_theme_load_icon (icon_theme,
-											    "format-text-underline-symbolic",
-											    ANNOT_ICON_SIZE,
-											    0, NULL);
-                                        }
-                                        pixbuf = underline_icon;
-                                        break;
-                                case EV_ANNOTATION_TEXT_MARKUP_SQUIGGLY:
-                                        if (!squiggly_icon) {
-						squiggly_icon = gtk_icon_theme_load_icon (icon_theme,
-											  EV_STOCK_ANNOT_SQUIGGLY,
-											  ANNOT_ICON_SIZE,
-											  0, NULL);
-                                        }
-                                        pixbuf = squiggly_icon;
-                                        break;
-                                }
-                        }
-
-			gtk_tree_store_append (model, &child_iter, &iter);
-			gtk_tree_store_set (model, &child_iter,
-					    COLUMN_MARKUP, markup,
-					    COLUMN_ICON, pixbuf,
-					    COLUMN_ANNOT_MAPPING, ll->data,
-					    -1);
-			g_free (markup);
-			found = TRUE;
-		}
-
-		if (!found)
-			gtk_tree_store_remove (model, &iter);
-	}
-
-	gtk_tree_view_set_model (GTK_TREE_VIEW (priv->tree_view),
-				 GTK_TREE_MODEL (model));
-	g_object_unref (model);
-
-	if (text_icon)
-		g_object_unref (text_icon);
-	if (attachment_icon)
-		g_object_unref (attachment_icon);
-        if (highlight_icon)
-                g_object_unref (highlight_icon);
-        if (strike_out_icon)
-                g_object_unref (strike_out_icon);
-        if (underline_icon)
-                g_object_unref (underline_icon);
-        if (squiggly_icon)
-                g_object_unref (squiggly_icon);
-
-	g_object_unref (job);
-	priv->job = NULL;
+                       EvSidebarAnnotations *sidebar_annots) {
+  EvSidebarAnnotationsPrivate *priv;
+  GtkTreeStore *model;
+  GtkTreeSelection *selection;
+  GList *l;
+  GtkIconTheme *icon_theme;
+  GdkScreen *screen;
+  GdkPixbuf *text_icon = NULL;
+  GdkPixbuf *attachment_icon = NULL;
+  GdkPixbuf *highlight_icon = NULL;
+  GdkPixbuf *strike_out_icon = NULL;
+  GdkPixbuf *underline_icon = NULL;
+  GdkPixbuf *squiggly_icon = NULL;
+
+  priv = sidebar_annots->priv;
+
+  if (!job->annots) {
+    GtkTreeModel *list;
+
+    list = ev_sidebar_annotations_create_simple_model (_("Document contains no annotations"));
+    gtk_tree_view_set_model (GTK_TREE_VIEW (priv->tree_view), list);
+    g_object_unref (list);
+
+    g_object_unref (job);
+    priv->job = NULL;
+
+    return;
+  }
+
+  selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (priv->tree_view));
+  gtk_tree_selection_set_mode (selection, GTK_SELECTION_SINGLE);
+  if (priv->selection_changed_id == 0) {
+    priv->selection_changed_id =
+      g_signal_connect (selection, "changed",
+                        G_CALLBACK (selection_changed_cb),
+                        sidebar_annots);
+  }
+  g_signal_connect (priv->tree_view, "button-press-event",
+                    G_CALLBACK (sidebar_tree_button_press_cb),
+                    sidebar_annots);
+
+
+  model = gtk_tree_store_new (N_COLUMNS,
+                              G_TYPE_STRING,
+                              GDK_TYPE_PIXBUF,
+                              G_TYPE_POINTER);
+
+  screen = gtk_widget_get_screen (GTK_WIDGET (sidebar_annots));
+  icon_theme = gtk_icon_theme_get_for_screen (screen);
+
+  for (l = job->annots; l; l = g_list_next (l)) {
+    EvMappingList *mapping_list;
+    GList         *ll;
+    gchar         *page_label;
+    GtkTreeIter    iter;
+    gboolean       found = FALSE;
+
+    mapping_list = (EvMappingList *)l->data;
+    page_label = g_strdup_printf (_("Page %d"),
+                                  ev_mapping_list_get_page (mapping_list) + 1);
+    gtk_tree_store_append (model, &iter, NULL);
+    gtk_tree_store_set (model, &iter,
+                        COLUMN_MARKUP, page_label,
+                        -1);
+    g_free (page_label);
+
+    for (ll = ev_mapping_list_get_list (mapping_list); ll; ll = g_list_next (ll)) {
+      EvAnnotation *annot;
+      const gchar  *label;
+      const gchar  *modified;
+      gchar        *markup;
+      GtkTreeIter   child_iter;
+      GdkPixbuf    *pixbuf = NULL;
+
+      annot = ((EvMapping *)(ll->data))->data;
+      if (!EV_IS_ANNOTATION_MARKUP (annot))
+        continue;
+
+      label = ev_annotation_markup_get_label (EV_ANNOTATION_MARKUP (annot));
+      modified = ev_annotation_get_modified (annot);
+      if (modified) {
+        markup = g_strdup_printf ("<span weight=\"bold\">%s</span>\n%s",
+                                  label, modified);
+      } else {
+        markup = g_strdup_printf ("<span weight=\"bold\">%s</span>", label);
+      }
+
+      if (EV_IS_ANNOTATION_TEXT (annot)) {
+        if (!text_icon) {
+          text_icon = gtk_icon_theme_load_icon (icon_theme,
+                                                EV_STOCK_ANNOT_TEXT,
+                                                ANNOT_ICON_SIZE,
+                                                0, NULL);
+        }
+        pixbuf = text_icon;
+      } else if (EV_IS_ANNOTATION_ATTACHMENT (annot)) {
+        if (!attachment_icon) {
+          attachment_icon = gtk_icon_theme_load_icon (icon_theme,
+                                                      "mail-attachment-symbolic",
+                                                      ANNOT_ICON_SIZE,
+                                                      0, NULL);
+        }
+        pixbuf = attachment_icon;
+      } else if (EV_IS_ANNOTATION_TEXT_MARKUP (annot)) {
+        switch (ev_annotation_text_markup_get_markup_type (EV_ANNOTATION_TEXT_MARKUP (annot))) {
+          case EV_ANNOTATION_TEXT_MARKUP_HIGHLIGHT:
+            if (!highlight_icon) {
+              /* FIXME: use better icon than select all */
+              highlight_icon = gtk_icon_theme_load_icon (icon_theme,
+                                                         "format-justify-left-symbolic",
+                                                         ANNOT_ICON_SIZE,
+                                                         0, NULL);
+            }
+            pixbuf = highlight_icon;
+
+            break;
+          case EV_ANNOTATION_TEXT_MARKUP_STRIKE_OUT:
+            if (!strike_out_icon) {
+              strike_out_icon = gtk_icon_theme_load_icon (icon_theme,
+                                                          "format-text-strikethrough-symbolic",
+                                                          ANNOT_ICON_SIZE,
+                                                          0, NULL);
+            }
+            pixbuf = strike_out_icon;
+            break;
+          case EV_ANNOTATION_TEXT_MARKUP_UNDERLINE:
+            if (!underline_icon) {
+              underline_icon = gtk_icon_theme_load_icon (icon_theme,
+                                                         "format-text-underline-symbolic",
+                                                         ANNOT_ICON_SIZE,
+                                                         0, NULL);
+            }
+            pixbuf = underline_icon;
+            break;
+          case EV_ANNOTATION_TEXT_MARKUP_SQUIGGLY:
+            if (!squiggly_icon) {
+              squiggly_icon = gtk_icon_theme_load_icon (icon_theme,
+                                                        EV_STOCK_ANNOT_SQUIGGLY,
+                                                        ANNOT_ICON_SIZE,
+                                                        0, NULL);
+            }
+            pixbuf = squiggly_icon;
+            break;
+        }
+      }
+
+      gtk_tree_store_append (model, &child_iter, &iter);
+      gtk_tree_store_set (model, &child_iter,
+                          COLUMN_MARKUP, markup,
+                          COLUMN_ICON, pixbuf,
+                          COLUMN_ANNOT_MAPPING, ll->data,
+                          -1);
+      g_free (markup);
+      found = TRUE;
+    }
+
+    if (!found)
+      gtk_tree_store_remove (model, &iter);
+  }
+
+  gtk_tree_view_set_model (GTK_TREE_VIEW (priv->tree_view),
+                           GTK_TREE_MODEL (model));
+  g_object_unref (model);
+
+  if (text_icon)
+    g_object_unref (text_icon);
+  if (attachment_icon)
+    g_object_unref (attachment_icon);
+  if (highlight_icon)
+    g_object_unref (highlight_icon);
+  if (strike_out_icon)
+    g_object_unref (strike_out_icon);
+  if (underline_icon)
+    g_object_unref (underline_icon);
+  if (squiggly_icon)
+    g_object_unref (squiggly_icon);
+
+  g_object_unref (job);
+  priv->job = NULL;
 }
 
 static void
-ev_sidebar_annotations_load (EvSidebarAnnotations *sidebar_annots)
-{
-	EvSidebarAnnotationsPrivate *priv = sidebar_annots->priv;
-
-	if (priv->job) {
-		g_signal_handlers_disconnect_by_func (priv->job,
-						      job_finished_callback,
-						      sidebar_annots);
-		g_object_unref (priv->job);
-	}
-
-	priv->job = ev_job_annots_new (priv->document);
-	g_signal_connect (priv->job, "finished",
-			  G_CALLBACK (job_finished_callback),
-			  sidebar_annots);
-	/* The priority doesn't matter for this job */
-	ev_job_scheduler_push_job (priv->job, EV_JOB_PRIORITY_NONE);
+ev_sidebar_annotations_load (EvSidebarAnnotations *sidebar_annots) {
+  EvSidebarAnnotationsPrivate *priv = sidebar_annots->priv;
+
+  if (priv->job) {
+    g_signal_handlers_disconnect_by_func (priv->job,
+                                          job_finished_callback,
+                                          sidebar_annots);
+    g_object_unref (priv->job);
+  }
+
+  priv->job = ev_job_annots_new (priv->document);
+  g_signal_connect (priv->job, "finished",
+                    G_CALLBACK (job_finished_callback),
+                    sidebar_annots);
+  /* The priority doesn't matter for this job */
+  ev_job_scheduler_push_job (priv->job, EV_JOB_PRIORITY_NONE);
 }
 
 static void
 ev_sidebar_annotations_document_changed_cb (EvDocumentModel      *model,
-					    GParamSpec           *pspec,
-					    EvSidebarAnnotations *sidebar_annots)
-{
-	EvDocument *document = ev_document_model_get_document (model);
-	EvSidebarAnnotationsPrivate *priv = sidebar_annots->priv;
+                                            GParamSpec           *pspec,
+                                            EvSidebarAnnotations *sidebar_annots) {
+  EvDocument *document = ev_document_model_get_document (model);
+  EvSidebarAnnotationsPrivate *priv = sidebar_annots->priv;
 
-	if (!EV_IS_DOCUMENT_ANNOTATIONS (document))
-		return;
+  if (!EV_IS_DOCUMENT_ANNOTATIONS (document))
+    return;
 
-	if (priv->document)
-		g_object_unref (priv->document);
-	priv->document = g_object_ref (document);
+  if (priv->document)
+    g_object_unref (priv->document);
+  priv->document = g_object_ref (document);
 
-	ev_sidebar_annotations_load (sidebar_annots);
+  ev_sidebar_annotations_load (sidebar_annots);
 }
 
 static void
 ev_sidebar_annotations_popup_detach_cb (GtkWidget *widget,
-					GtkMenu   *menu)
-{
-	EvSidebarAnnotations *sidebar_annots = EV_SIDEBAR_ANNOTATIONS (widget);
-	sidebar_annots->priv->popup = NULL;
+                                        GtkMenu   *menu) {
+  EvSidebarAnnotations *sidebar_annots = EV_SIDEBAR_ANNOTATIONS (widget);
+  sidebar_annots->priv->popup = NULL;
 }
 
 /* event parameter can be NULL, that means popup was triggered from keyboard */
 static gboolean
 ev_sidebar_annotations_popup_menu_show (EvSidebarAnnotations *sidebar_annots,
-					GdkWindow            *rect_window,
-					const GdkRectangle   *rect,
-					EvMapping            *annot_mapping,
-					const GdkEvent       *event)
-{
-	GtkWidget *window;
-
-	EvSidebarAnnotationsPrivate *priv = sidebar_annots->priv;
-
-	if (!EV_IS_ANNOTATION (annot_mapping->data))
-		return FALSE;
-
-	if (!priv->popup) {
-		priv->popup = gtk_menu_new_from_model (priv->popup_model);
-		gtk_menu_attach_to_widget (GTK_MENU (priv->popup), GTK_WIDGET (sidebar_annots),
-					   ev_sidebar_annotations_popup_detach_cb);
-	}
-
-	window = gtk_widget_get_toplevel (GTK_WIDGET (sidebar_annots));
-
-	ev_window_handle_annot_popup (EV_WINDOW (window), EV_ANNOTATION (annot_mapping->data));
-	gtk_menu_popup_at_rect (GTK_MENU (priv->popup), rect_window, rect,
-				GDK_GRAVITY_SOUTH_WEST, GDK_GRAVITY_NORTH_WEST, event);
-	return TRUE;
+                                        GdkWindow            *rect_window,
+                                        const GdkRectangle   *rect,
+                                        EvMapping            *annot_mapping,
+                                        const GdkEvent       *event) {
+  GtkWidget *window;
+
+  EvSidebarAnnotationsPrivate *priv = sidebar_annots->priv;
+
+  if (!EV_IS_ANNOTATION (annot_mapping->data))
+    return FALSE;
+
+  if (!priv->popup) {
+    priv->popup = gtk_menu_new_from_model (priv->popup_model);
+    gtk_menu_attach_to_widget (GTK_MENU (priv->popup), GTK_WIDGET (sidebar_annots),
+                               ev_sidebar_annotations_popup_detach_cb);
+  }
+
+  window = gtk_widget_get_toplevel (GTK_WIDGET (sidebar_annots));
+
+  ev_window_handle_annot_popup (EV_WINDOW (window), EV_ANNOTATION (annot_mapping->data));
+  gtk_menu_popup_at_rect (GTK_MENU (priv->popup), rect_window, rect,
+                          GDK_GRAVITY_SOUTH_WEST, GDK_GRAVITY_NORTH_WEST, event);
+  return TRUE;
 }
 
 static gboolean
-ev_sidebar_annotations_popup_menu (GtkWidget *widget)
-{
-	GtkTreeView          *tree_view;
-	GtkTreeModel         *model;
-	GtkTreePath          *path;
-	GtkTreeSelection     *selection;
-	EvMapping            *annot_mapping;
-	GtkTreeIter           iter;
-	GdkRectangle          rect;
-
-	EvSidebarAnnotations *sidebar_annots = EV_SIDEBAR_ANNOTATIONS (widget);
-	EvSidebarAnnotationsPrivate *priv = sidebar_annots->priv;
-
-	tree_view = GTK_TREE_VIEW (priv->tree_view);
-	selection = gtk_tree_view_get_selection (tree_view);
-	if (!gtk_tree_selection_get_selected (selection, &model, &iter))
-		return FALSE;
-
-	if (!iter_has_mapping (model, &iter, &annot_mapping))
-		return FALSE;
-
-	path = gtk_tree_model_get_path (model, &iter);
-
-	gtk_tree_view_get_cell_area (tree_view, path,
-				     gtk_tree_view_get_column (tree_view, 0),
-				     &rect);
-	gtk_tree_path_free (path);
-
-	return ev_sidebar_annotations_popup_menu_show (sidebar_annots,
-						       gtk_tree_view_get_bin_window (tree_view),
-						       &rect, annot_mapping, NULL);
+ev_sidebar_annotations_popup_menu (GtkWidget *widget) {
+  GtkTreeView          *tree_view;
+  GtkTreeModel         *model;
+  GtkTreePath          *path;
+  GtkTreeSelection     *selection;
+  EvMapping            *annot_mapping;
+  GtkTreeIter           iter;
+  GdkRectangle          rect;
+
+  EvSidebarAnnotations *sidebar_annots = EV_SIDEBAR_ANNOTATIONS (widget);
+  EvSidebarAnnotationsPrivate *priv = sidebar_annots->priv;
+
+  tree_view = GTK_TREE_VIEW (priv->tree_view);
+  selection = gtk_tree_view_get_selection (tree_view);
+  if (!gtk_tree_selection_get_selected (selection, &model, &iter))
+    return FALSE;
+
+  if (!iter_has_mapping (model, &iter, &annot_mapping))
+    return FALSE;
+
+  path = gtk_tree_model_get_path (model, &iter);
+
+  gtk_tree_view_get_cell_area (tree_view, path,
+                               gtk_tree_view_get_column (tree_view, 0),
+                               &rect);
+  gtk_tree_path_free (path);
+
+  return ev_sidebar_annotations_popup_menu_show (sidebar_annots,
+                                                 gtk_tree_view_get_bin_window (tree_view),
+                                                 &rect, annot_mapping, NULL);
 }
 
 /* EvSidebarPageIface */
 static void
 ev_sidebar_annotations_set_model (EvSidebarPage   *sidebar_page,
-				  EvDocumentModel *model)
-{
-	g_signal_connect (model, "notify::document",
-			  G_CALLBACK (ev_sidebar_annotations_document_changed_cb),
-			  sidebar_page);
+                                  EvDocumentModel *model) {
+  g_signal_connect (model, "notify::document",
+                    G_CALLBACK (ev_sidebar_annotations_document_changed_cb),
+                    sidebar_page);
 }
 
 static gboolean
 ev_sidebar_annotations_support_document (EvSidebarPage *sidebar_page,
-					 EvDocument    *document)
-{
-	return (EV_IS_DOCUMENT_ANNOTATIONS (document));
+                                         EvDocument    *document) {
+  return (EV_IS_DOCUMENT_ANNOTATIONS (document));
 }
 
 static const gchar *
-ev_sidebar_annotations_get_label (EvSidebarPage *sidebar_page)
-{
-	return _("Annotations");
+ev_sidebar_annotations_get_label (EvSidebarPage *sidebar_page) {
+  return _("Annotations");
 }
 
 static void
-ev_sidebar_annotations_page_iface_init (EvSidebarPageInterface *iface)
-{
-	iface->support_document = ev_sidebar_annotations_support_document;
-	iface->set_model = ev_sidebar_annotations_set_model;
-	iface->get_label = ev_sidebar_annotations_get_label;
+ev_sidebar_annotations_page_iface_init (EvSidebarPageInterface *iface) {
+  iface->support_document = ev_sidebar_annotations_support_document;
+  iface->set_model = ev_sidebar_annotations_set_model;
+  iface->get_label = ev_sidebar_annotations_get_label;
 }
diff --git a/shell/ev-sidebar-links.h b/shell/ev-sidebar-links.h
index 12da4d1..c004659 100644
--- a/shell/ev-sidebar-links.h
+++ b/shell/ev-sidebar-links.h
@@ -1,6 +1,6 @@
 /* ev-sidebar-links.h
  *  this file is part of evince, a gnome document viewer
- * 
+ *
  * Copyright (C) 2004 Red Hat, Inc.
  *
  * Author:
@@ -44,16 +44,16 @@ typedef struct _EvSidebarLinksPrivate EvSidebarLinksPrivate;
 #define EV_SIDEBAR_LINKS_GET_CLASS(object) (G_TYPE_INSTANCE_GET_CLASS((object), EV_TYPE_SIDEBAR_LINKS, EvSidebarLinksClass))
 
 struct _EvSidebarLinks {
-	GtkBox base_instance;
+  GtkBox base_instance;
 
-	EvSidebarLinksPrivate *priv;
+  EvSidebarLinksPrivate *priv;
 };
 
 struct _EvSidebarLinksClass {
-	GtkBoxClass base_class;
+  GtkBoxClass base_class;
 
-	void    (* link_activated) (EvSidebarLinks *sidebar_links,
-				    EvLink         *link);
+  void    (* link_activated) (EvSidebarLinks *sidebar_links,
+                              EvLink         *link);
 };
 
 GType      ev_sidebar_links_get_type       (void);
diff --git a/shell/ev-toolbar.c b/shell/ev-toolbar.c
index 44a293d..7f69a94 100644
--- a/shell/ev-toolbar.c
+++ b/shell/ev-toolbar.c
@@ -33,25 +33,24 @@
 #include "ev-page-action-widget.h"
 #include <math.h>
 
-enum
-{
-        PROP_0,
-        PROP_WINDOW
+enum {
+  PROP_0,
+  PROP_WINDOW
 };
 
 typedef struct {
-        EvWindow  *window;
-
-        GtkWidget *action_menu_button;
-        GtkWidget *zoom_action;
-        GtkWidget *page_selector;
-        GtkWidget *navigation_action;
-        GtkWidget *find_button;
-        GtkWidget *open_button;
-        GtkWidget *annots_button;
-        GtkWidget *sidebar_button;
-
-        EvToolbarMode toolbar_mode;
+  EvWindow  *window;
+
+  GtkWidget *action_menu_button;
+  GtkWidget *zoom_action;
+  GtkWidget *page_selector;
+  GtkWidget *navigation_action;
+  GtkWidget *find_button;
+  GtkWidget *open_button;
+  GtkWidget *annots_button;
+  GtkWidget *sidebar_button;
+
+  EvToolbarMode toolbar_mode;
 } EvToolbarPrivate;
 
 G_DEFINE_TYPE_WITH_PRIVATE (EvToolbar, ev_toolbar, GTK_TYPE_HEADER_BAR)
@@ -62,31 +61,29 @@ static void
 ev_toolbar_set_property (GObject      *object,
                          guint         prop_id,
                          const GValue *value,
-                         GParamSpec   *pspec)
-{
-        EvToolbar *ev_toolbar = EV_TOOLBAR (object);
-	EvToolbarPrivate *priv = GET_PRIVATE (ev_toolbar);
-
-        switch (prop_id) {
-        case PROP_WINDOW:
-                priv->window = g_value_get_object (value);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-        }
+                         GParamSpec   *pspec) {
+  EvToolbar *ev_toolbar = EV_TOOLBAR (object);
+  EvToolbarPrivate *priv = GET_PRIVATE (ev_toolbar);
+
+  switch (prop_id) {
+    case PROP_WINDOW:
+      priv->window = g_value_get_object (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+  }
 }
 
 static void
 ev_toolbar_set_button_action (EvToolbar   *ev_toolbar,
                               GtkButton   *button,
                               const gchar *action_name,
-                              const gchar *tooltip)
-{
-        gtk_actionable_set_action_name (GTK_ACTIONABLE (button), action_name);
-        gtk_button_set_label (button, NULL);
-        gtk_widget_set_focus_on_click (GTK_WIDGET (button), FALSE);
-        if (tooltip)
-                gtk_widget_set_tooltip_text (GTK_WIDGET (button), tooltip);
+                              const gchar *tooltip) {
+  gtk_actionable_set_action_name (GTK_ACTIONABLE (button), action_name);
+  gtk_button_set_label (button, NULL);
+  gtk_widget_set_focus_on_click (GTK_WIDGET (button), FALSE);
+  if (tooltip)
+    gtk_widget_set_tooltip_text (GTK_WIDGET (button), tooltip);
 }
 
 static GtkWidget *
@@ -94,298 +91,284 @@ ev_toolbar_create_button (EvToolbar   *ev_toolbar,
                           const gchar *action_name,
                           const gchar *icon_name,
                           const gchar *label,
-                          const gchar *tooltip)
-{
-        GtkWidget *button = gtk_button_new ();
-        GtkWidget *image;
+                          const gchar *tooltip) {
+  GtkWidget *button = gtk_button_new ();
+  GtkWidget *image;
 
-        image = gtk_image_new_from_icon_name (icon_name, GTK_ICON_SIZE_MENU);
+  image = gtk_image_new_from_icon_name (icon_name, GTK_ICON_SIZE_MENU);
 
-        gtk_widget_set_valign (button, GTK_ALIGN_CENTER);
-        if (icon_name)
-                gtk_button_set_image (GTK_BUTTON (button), image);
-        if (label)
-                gtk_button_set_label (GTK_BUTTON (button), label);
-        ev_toolbar_set_button_action (ev_toolbar, GTK_BUTTON (button), action_name, tooltip);
+  gtk_widget_set_valign (button, GTK_ALIGN_CENTER);
+  if (icon_name)
+    gtk_button_set_image (GTK_BUTTON (button), image);
+  if (label)
+    gtk_button_set_label (GTK_BUTTON (button), label);
+  ev_toolbar_set_button_action (ev_toolbar, GTK_BUTTON (button), action_name, tooltip);
 
-        return button;
+  return button;
 }
 
 static GtkWidget *
 ev_toolbar_create_toggle_button (EvToolbar *ev_toolbar,
                                  const gchar *action_name,
                                  const gchar *icon_name,
-                                 const gchar *tooltip)
-{
-        GtkWidget *button = gtk_toggle_button_new ();
-        GtkWidget *image;
+                                 const gchar *tooltip) {
+  GtkWidget *button = gtk_toggle_button_new ();
+  GtkWidget *image;
 
-        image = gtk_image_new_from_icon_name (icon_name, GTK_ICON_SIZE_MENU);
+  image = gtk_image_new_from_icon_name (icon_name, GTK_ICON_SIZE_MENU);
 
-        gtk_widget_set_valign (button, GTK_ALIGN_CENTER);
-        gtk_button_set_image (GTK_BUTTON (button), image);
-        ev_toolbar_set_button_action (ev_toolbar, GTK_BUTTON (button), action_name, tooltip);
+  gtk_widget_set_valign (button, GTK_ALIGN_CENTER);
+  gtk_button_set_image (GTK_BUTTON (button), image);
+  ev_toolbar_set_button_action (ev_toolbar, GTK_BUTTON (button), action_name, tooltip);
 
-        return button;
+  return button;
 }
 
 static GtkWidget *
 ev_toolbar_create_menu_button (EvToolbar   *ev_toolbar,
                                const gchar *icon_name,
                                GMenuModel  *menu,
-                               GtkAlign     menu_align)
-{
-        GtkWidget  *button;
-        GtkPopover *popup;
-
-        button = gtk_menu_button_new ();
-        gtk_widget_set_valign (button, GTK_ALIGN_CENTER);
-        gtk_button_set_image (GTK_BUTTON (button), gtk_image_new ());
-        gtk_image_set_from_icon_name (GTK_IMAGE (gtk_button_get_image (GTK_BUTTON (button))),
-                                      icon_name, GTK_ICON_SIZE_MENU);
-        gtk_menu_button_set_menu_model (GTK_MENU_BUTTON (button), menu);
-        popup = gtk_menu_button_get_popover (GTK_MENU_BUTTON (button));
-        gtk_popover_set_position (popup, GTK_POS_BOTTOM);
-        gtk_widget_set_halign (GTK_WIDGET (popup), menu_align);
-
-        return button;
+                               GtkAlign     menu_align) {
+  GtkWidget  *button;
+  GtkPopover *popup;
+
+  button = gtk_menu_button_new ();
+  gtk_widget_set_valign (button, GTK_ALIGN_CENTER);
+  gtk_button_set_image (GTK_BUTTON (button), gtk_image_new ());
+  gtk_image_set_from_icon_name (GTK_IMAGE (gtk_button_get_image (GTK_BUTTON (button))),
+                                icon_name, GTK_ICON_SIZE_MENU);
+  gtk_menu_button_set_menu_model (GTK_MENU_BUTTON (button), menu);
+  popup = gtk_menu_button_get_popover (GTK_MENU_BUTTON (button));
+  gtk_popover_set_position (popup, GTK_POS_BOTTOM);
+  gtk_widget_set_halign (GTK_WIDGET (popup), menu_align);
+
+  return button;
 }
 
 static void
 zoom_selector_activated (GtkWidget *zoom_action,
-                         EvToolbar *ev_toolbar)
-{
-	EvToolbarPrivate *priv = GET_PRIVATE (ev_toolbar);
+                         EvToolbar *ev_toolbar) {
+  EvToolbarPrivate *priv = GET_PRIVATE (ev_toolbar);
 
-        ev_window_focus_view (priv->window);
+  ev_window_focus_view (priv->window);
 }
 
 static void
 ev_toolbar_find_button_sensitive_changed (GtkWidget  *find_button,
-					  GParamSpec *pspec,
-					  EvToolbar *ev_toolbar)
-{
-        GtkWidget *image;
-
-        if (gtk_widget_is_sensitive (find_button)) {
-                gtk_widget_set_tooltip_text (find_button,
-                                             _("Find a word or phrase in the document"));
-		image = gtk_image_new_from_icon_name ("edit-find-symbolic",
-						      GTK_ICON_SIZE_MENU);
-		gtk_button_set_image (GTK_BUTTON (find_button), image);
-	} else {
-                gtk_widget_set_tooltip_text (find_button,
-                                             _("Search not available for this document"));
-		image = gtk_image_new_from_icon_name (EV_STOCK_FIND_UNSUPPORTED,
-						      GTK_ICON_SIZE_MENU);
-		gtk_button_set_image (GTK_BUTTON (find_button), image);
-	}
+                                          GParamSpec *pspec,
+                                          EvToolbar *ev_toolbar) {
+  GtkWidget *image;
+
+  if (gtk_widget_is_sensitive (find_button)) {
+    gtk_widget_set_tooltip_text (find_button,
+                                 _("Find a word or phrase in the document"));
+    image = gtk_image_new_from_icon_name ("edit-find-symbolic",
+                                          GTK_ICON_SIZE_MENU);
+    gtk_button_set_image (GTK_BUTTON (find_button), image);
+  } else {
+    gtk_widget_set_tooltip_text (find_button,
+                                 _("Search not available for this document"));
+    image = gtk_image_new_from_icon_name (EV_STOCK_FIND_UNSUPPORTED,
+                                          GTK_ICON_SIZE_MENU);
+    gtk_button_set_image (GTK_BUTTON (find_button), image);
+  }
 }
 
 static void
-ev_toolbar_constructed (GObject *object)
-{
-        EvToolbar      *ev_toolbar = EV_TOOLBAR (object);
-	EvToolbarPrivate *priv = GET_PRIVATE (ev_toolbar);
-        GtkBuilder     *builder;
-        GtkWidget      *tool_item;
-        GtkWidget      *vbox;
-        GtkWidget      *button;
-        GMenuModel     *menu;
-
-        G_OBJECT_CLASS (ev_toolbar_parent_class)->constructed (object);
-
-        builder = gtk_builder_new_from_resource ("/org/gnome/evince/gtk/menus.ui");
-
-        button = ev_toolbar_create_button (ev_toolbar, "win.open",
-                                           NULL,
-                                           _("Open…"),
-                                           _("Open an existing document"));
-        priv->open_button = button;
-        gtk_container_add (GTK_CONTAINER (ev_toolbar), button);
-
-        /* Sidebar */
-        button = ev_toolbar_create_toggle_button (ev_toolbar, "win.show-side-pane",
-                                                  EV_STOCK_VIEW_SIDEBAR,
-                                                  _("Side pane"));
-        priv->sidebar_button = button;
-        gtk_header_bar_pack_start (GTK_HEADER_BAR (ev_toolbar), button);
-
-        /* Page selector */
-        /* Use EvPageActionWidget for now, since the page selector action is also used by the previewer */
-        tool_item = GTK_WIDGET (g_object_new (EV_TYPE_PAGE_ACTION_WIDGET, NULL));
-        gtk_widget_set_tooltip_text (tool_item, _("Select page or search in the index"));
-        atk_object_set_name (gtk_widget_get_accessible (tool_item), _("Select page"));
-        priv->page_selector = tool_item;
-        ev_page_action_widget_set_model (EV_PAGE_ACTION_WIDGET (tool_item),
-                                         ev_window_get_document_model (priv->window));
-        gtk_header_bar_pack_start (GTK_HEADER_BAR (ev_toolbar), tool_item);
-
-        /* Edit Annots */
-        button = ev_toolbar_create_toggle_button (ev_toolbar, "win.toggle-edit-annots", "document-edit-symbolic",
-                                                  _("Annotate the document"));
-        atk_object_set_name (gtk_widget_get_accessible (button), _("Annotate document"));
-        priv->annots_button = button;
-        gtk_header_bar_pack_start (GTK_HEADER_BAR (ev_toolbar), button);
-
-        /* Action Menu */
-        menu = G_MENU_MODEL (gtk_builder_get_object (builder, "action-menu"));
-        button = ev_toolbar_create_menu_button (ev_toolbar, "open-menu-symbolic",
-                                                menu, GTK_ALIGN_END);
-        gtk_widget_set_tooltip_text (button, _("File options"));
-        atk_object_set_name (gtk_widget_get_accessible (button), _("File options"));
-
-        priv->action_menu_button = button;
-        gtk_header_bar_pack_end (GTK_HEADER_BAR (ev_toolbar), button);
-
-        /* Find */
-        button = ev_toolbar_create_toggle_button (ev_toolbar, "win.toggle-find", "edit-find-symbolic",
-                                                  NULL);
-        priv->find_button = button;
-        gtk_header_bar_pack_end (GTK_HEADER_BAR (ev_toolbar), button);
-        g_signal_connect (button,
-                          "notify::sensitive",
-                          G_CALLBACK (ev_toolbar_find_button_sensitive_changed),
-                          ev_toolbar);
-
-        /* Zoom selector */
-        vbox = ev_zoom_action_new (ev_window_get_document_model (priv->window),
-                                   G_MENU (gtk_builder_get_object (builder, "zoom-menu")));
-        priv->zoom_action = vbox;
-        gtk_widget_set_tooltip_text (vbox, _("Select or set the zoom level of the document"));
-        atk_object_set_name (gtk_widget_get_accessible (vbox), _("Set zoom level"));
-        g_signal_connect (vbox, "activated",
-                          G_CALLBACK (zoom_selector_activated),
-                          ev_toolbar);
-        gtk_header_bar_pack_end (GTK_HEADER_BAR (ev_toolbar), vbox);
-
-        g_object_unref (builder);
+ev_toolbar_constructed (GObject *object) {
+  EvToolbar      *ev_toolbar = EV_TOOLBAR (object);
+  EvToolbarPrivate *priv = GET_PRIVATE (ev_toolbar);
+  GtkBuilder     *builder;
+  GtkWidget      *tool_item;
+  GtkWidget      *vbox;
+  GtkWidget      *button;
+  GMenuModel     *menu;
+
+  G_OBJECT_CLASS (ev_toolbar_parent_class)->constructed (object);
+
+  builder = gtk_builder_new_from_resource ("/org/gnome/evince/gtk/menus.ui");
+
+  button = ev_toolbar_create_button (ev_toolbar, "win.open",
+                                     NULL,
+                                     _("Open…"),
+                                     _("Open an existing document"));
+  priv->open_button = button;
+  gtk_container_add (GTK_CONTAINER (ev_toolbar), button);
+
+  /* Sidebar */
+  button = ev_toolbar_create_toggle_button (ev_toolbar, "win.show-side-pane",
+                                            EV_STOCK_VIEW_SIDEBAR,
+                                            _("Side pane"));
+  priv->sidebar_button = button;
+  gtk_header_bar_pack_start (GTK_HEADER_BAR (ev_toolbar), button);
+
+  /* Page selector */
+  /* Use EvPageActionWidget for now, since the page selector action is also used by the previewer */
+  tool_item = GTK_WIDGET (g_object_new (EV_TYPE_PAGE_ACTION_WIDGET, NULL));
+  gtk_widget_set_tooltip_text (tool_item, _("Select page or search in the index"));
+  atk_object_set_name (gtk_widget_get_accessible (tool_item), _("Select page"));
+  priv->page_selector = tool_item;
+  ev_page_action_widget_set_model (EV_PAGE_ACTION_WIDGET (tool_item),
+                                   ev_window_get_document_model (priv->window));
+  gtk_header_bar_pack_start (GTK_HEADER_BAR (ev_toolbar), tool_item);
+
+  /* Edit Annots */
+  button = ev_toolbar_create_toggle_button (ev_toolbar, "win.toggle-edit-annots", "document-edit-symbolic",
+                                            _("Annotate the document"));
+  atk_object_set_name (gtk_widget_get_accessible (button), _("Annotate document"));
+  priv->annots_button = button;
+  gtk_header_bar_pack_start (GTK_HEADER_BAR (ev_toolbar), button);
+
+  /* Action Menu */
+  menu = G_MENU_MODEL (gtk_builder_get_object (builder, "action-menu"));
+  button = ev_toolbar_create_menu_button (ev_toolbar, "open-menu-symbolic",
+                                          menu, GTK_ALIGN_END);
+  gtk_widget_set_tooltip_text (button, _("File options"));
+  atk_object_set_name (gtk_widget_get_accessible (button), _("File options"));
+
+  priv->action_menu_button = button;
+  gtk_header_bar_pack_end (GTK_HEADER_BAR (ev_toolbar), button);
+
+  /* Find */
+  button = ev_toolbar_create_toggle_button (ev_toolbar, "win.toggle-find", "edit-find-symbolic",
+                                            NULL);
+  priv->find_button = button;
+  gtk_header_bar_pack_end (GTK_HEADER_BAR (ev_toolbar), button);
+  g_signal_connect (button,
+                    "notify::sensitive",
+                    G_CALLBACK (ev_toolbar_find_button_sensitive_changed),
+                    ev_toolbar);
+
+  /* Zoom selector */
+  vbox = ev_zoom_action_new (ev_window_get_document_model (priv->window),
+                             G_MENU (gtk_builder_get_object (builder, "zoom-menu")));
+  priv->zoom_action = vbox;
+  gtk_widget_set_tooltip_text (vbox, _("Select or set the zoom level of the document"));
+  atk_object_set_name (gtk_widget_get_accessible (vbox), _("Set zoom level"));
+  g_signal_connect (vbox, "activated",
+                    G_CALLBACK (zoom_selector_activated),
+                    ev_toolbar);
+  gtk_header_bar_pack_end (GTK_HEADER_BAR (ev_toolbar), vbox);
+
+  g_object_unref (builder);
 }
 
 static void
-ev_toolbar_class_init (EvToolbarClass *klass)
-{
-        GObjectClass *g_object_class = G_OBJECT_CLASS (klass);
-
-        g_object_class->set_property = ev_toolbar_set_property;
-        g_object_class->constructed = ev_toolbar_constructed;
-
-        g_object_class_install_property (g_object_class,
-                                         PROP_WINDOW,
-                                         g_param_spec_object ("window",
-                                                              "Window",
-                                                              "The evince window",
-                                                              EV_TYPE_WINDOW,
-                                                              G_PARAM_WRITABLE |
-                                                              G_PARAM_CONSTRUCT_ONLY |
-                                                              G_PARAM_STATIC_STRINGS));
+ev_toolbar_class_init (EvToolbarClass *klass) {
+  GObjectClass *g_object_class = G_OBJECT_CLASS (klass);
+
+  g_object_class->set_property = ev_toolbar_set_property;
+  g_object_class->constructed = ev_toolbar_constructed;
+
+  g_object_class_install_property (g_object_class,
+                                   PROP_WINDOW,
+                                   g_param_spec_object ("window",
+                                                        "Window",
+                                                        "The evince window",
+                                                        EV_TYPE_WINDOW,
+                                                        G_PARAM_WRITABLE |
+                                                        G_PARAM_CONSTRUCT_ONLY |
+                                                        G_PARAM_STATIC_STRINGS));
 }
 
 static void
-ev_toolbar_init (EvToolbar *ev_toolbar)
-{
-	EvToolbarPrivate *priv = GET_PRIVATE (ev_toolbar);
+ev_toolbar_init (EvToolbar *ev_toolbar) {
+  EvToolbarPrivate *priv = GET_PRIVATE (ev_toolbar);
 
-        priv->toolbar_mode = EV_TOOLBAR_MODE_NORMAL;
+  priv->toolbar_mode = EV_TOOLBAR_MODE_NORMAL;
 }
 
 GtkWidget *
-ev_toolbar_new (EvWindow *window)
-{
-        g_return_val_if_fail (EV_IS_WINDOW (window), NULL);
+ev_toolbar_new (EvWindow *window) {
+  g_return_val_if_fail (EV_IS_WINDOW (window), NULL);
 
-        return GTK_WIDGET (g_object_new (EV_TYPE_TOOLBAR,
-                                         "window", window,
-                                         NULL));
+  return GTK_WIDGET (g_object_new (EV_TYPE_TOOLBAR,
+                                   "window", window,
+                                   NULL));
 }
 
 gboolean
-ev_toolbar_has_visible_popups (EvToolbar *ev_toolbar)
-{
-        GtkPopover       *popover;
-        EvToolbarPrivate *priv;
+ev_toolbar_has_visible_popups (EvToolbar *ev_toolbar) {
+  GtkPopover       *popover;
+  EvToolbarPrivate *priv;
 
-        g_return_val_if_fail (EV_IS_TOOLBAR (ev_toolbar), FALSE);
+  g_return_val_if_fail (EV_IS_TOOLBAR (ev_toolbar), FALSE);
 
-        priv = GET_PRIVATE (ev_toolbar);
+  priv = GET_PRIVATE (ev_toolbar);
 
-        popover = gtk_menu_button_get_popover (GTK_MENU_BUTTON (priv->action_menu_button));
-        if (gtk_widget_get_visible (GTK_WIDGET (popover)))
-                return TRUE;
+  popover = gtk_menu_button_get_popover (GTK_MENU_BUTTON (priv->action_menu_button));
+  if (gtk_widget_get_visible (GTK_WIDGET (popover)))
+    return TRUE;
 
-        if (ev_zoom_action_get_popup_shown (EV_ZOOM_ACTION (priv->zoom_action)))
-                return TRUE;
+  if (ev_zoom_action_get_popup_shown (EV_ZOOM_ACTION (priv->zoom_action)))
+    return TRUE;
 
-        return FALSE;
+  return FALSE;
 }
 
 void
-ev_toolbar_action_menu_popup (EvToolbar *ev_toolbar)
-{
-	EvToolbarPrivate *priv;
+ev_toolbar_action_menu_popup (EvToolbar *ev_toolbar) {
+  EvToolbarPrivate *priv;
 
-        g_return_if_fail (EV_IS_TOOLBAR (ev_toolbar));
+  g_return_if_fail (EV_IS_TOOLBAR (ev_toolbar));
 
-        priv = GET_PRIVATE (ev_toolbar);
+  priv = GET_PRIVATE (ev_toolbar);
 
-        gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (priv->action_menu_button),
-                                      TRUE);
+  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (priv->action_menu_button),
+                                TRUE);
 }
 
 GtkWidget *
-ev_toolbar_get_page_selector (EvToolbar *ev_toolbar)
-{
-	EvToolbarPrivate *priv;
+ev_toolbar_get_page_selector (EvToolbar *ev_toolbar) {
+  EvToolbarPrivate *priv;
 
-        g_return_val_if_fail (EV_IS_TOOLBAR (ev_toolbar), NULL);
+  g_return_val_if_fail (EV_IS_TOOLBAR (ev_toolbar), NULL);
 
-        priv = GET_PRIVATE (ev_toolbar);
+  priv = GET_PRIVATE (ev_toolbar);
 
-        return priv->page_selector;
+  return priv->page_selector;
 }
 
 void
 ev_toolbar_set_mode (EvToolbar     *ev_toolbar,
-                     EvToolbarMode  mode)
-{
-        EvToolbarPrivate *priv;
-
-        g_return_if_fail (EV_IS_TOOLBAR (ev_toolbar));
-
-        priv = GET_PRIVATE (ev_toolbar);
-        priv->toolbar_mode = mode;
-
-        switch (mode) {
-        case EV_TOOLBAR_MODE_NORMAL:
-        case EV_TOOLBAR_MODE_FULLSCREEN:
-                gtk_widget_show (priv->sidebar_button);
-                gtk_widget_show (priv->action_menu_button);
-                gtk_widget_show (priv->zoom_action);
-                gtk_widget_show (priv->page_selector);
-                gtk_widget_show (priv->find_button);
-                gtk_widget_show (priv->annots_button);
-                gtk_widget_hide (priv->open_button);
-                break;
-	case EV_TOOLBAR_MODE_RECENT_VIEW:
-                gtk_widget_hide (priv->sidebar_button);
-                gtk_widget_hide (priv->action_menu_button);
-                gtk_widget_hide (priv->zoom_action);
-                gtk_widget_hide (priv->page_selector);
-                gtk_widget_hide (priv->find_button);
-                gtk_widget_hide (priv->annots_button);
-                gtk_widget_show (priv->open_button);
-                break;
-        }
+                     EvToolbarMode  mode) {
+  EvToolbarPrivate *priv;
+
+  g_return_if_fail (EV_IS_TOOLBAR (ev_toolbar));
+
+  priv = GET_PRIVATE (ev_toolbar);
+  priv->toolbar_mode = mode;
+
+  switch (mode) {
+    case EV_TOOLBAR_MODE_NORMAL:
+    case EV_TOOLBAR_MODE_FULLSCREEN:
+      gtk_widget_show (priv->sidebar_button);
+      gtk_widget_show (priv->action_menu_button);
+      gtk_widget_show (priv->zoom_action);
+      gtk_widget_show (priv->page_selector);
+      gtk_widget_show (priv->find_button);
+      gtk_widget_show (priv->annots_button);
+      gtk_widget_hide (priv->open_button);
+      break;
+    case EV_TOOLBAR_MODE_RECENT_VIEW:
+      gtk_widget_hide (priv->sidebar_button);
+      gtk_widget_hide (priv->action_menu_button);
+      gtk_widget_hide (priv->zoom_action);
+      gtk_widget_hide (priv->page_selector);
+      gtk_widget_hide (priv->find_button);
+      gtk_widget_hide (priv->annots_button);
+      gtk_widget_show (priv->open_button);
+      break;
+  }
 }
 
 EvToolbarMode
-ev_toolbar_get_mode (EvToolbar *ev_toolbar)
-{
-        EvToolbarPrivate *priv;
+ev_toolbar_get_mode (EvToolbar *ev_toolbar) {
+  EvToolbarPrivate *priv;
 
-        g_return_val_if_fail (EV_IS_TOOLBAR (ev_toolbar), EV_TOOLBAR_MODE_NORMAL);
+  g_return_val_if_fail (EV_IS_TOOLBAR (ev_toolbar), EV_TOOLBAR_MODE_NORMAL);
 
-        priv = GET_PRIVATE (ev_toolbar);
+  priv = GET_PRIVATE (ev_toolbar);
 
-        return priv->toolbar_mode;
+  return priv->toolbar_mode;
 }
diff --git a/shell/ev-window-title.c b/shell/ev-window-title.c
index e25fb40..93e222a 100644
--- a/shell/ev-window-title.c
+++ b/shell/ev-window-title.c
@@ -32,238 +32,229 @@
 #define EV_BACKEND_PS  "PSDocument"
 #define EV_BACKEND_PDF "PdfDocument"
 
-typedef struct
-{
-	const gchar *backend;
-	const gchar *text;
+typedef struct {
+  const gchar *backend;
+  const gchar *text;
 } BadTitleEntry;
 
-struct _EvWindowTitle
-{
-	EvWindow *window;
-	EvWindowTitleType type;
-	EvDocument *document;
-	char *filename;
-	char *doc_title;
-	char *dirname;
+struct _EvWindowTitle {
+  EvWindow *window;
+  EvWindowTitleType type;
+  EvDocument *document;
+  char *filename;
+  char *doc_title;
+  char *dirname;
 };
 
 static const BadTitleEntry bad_extensions[] = {
-	{ EV_BACKEND_PS, ".dvi" },
-	{ EV_BACKEND_PDF, ".doc" },
-	{ EV_BACKEND_PDF, ".dvi" },
-	{ EV_BACKEND_PDF, ".indd" },
-	{ EV_BACKEND_PDF, ".rtf" }
+  { EV_BACKEND_PS, ".dvi" },
+  { EV_BACKEND_PDF, ".doc" },
+  { EV_BACKEND_PDF, ".dvi" },
+  { EV_BACKEND_PDF, ".indd" },
+  { EV_BACKEND_PDF, ".rtf" }
 };
 
 static const BadTitleEntry bad_prefixes[] = {
-	{ EV_BACKEND_PDF, "Microsoft Word - " },
-	{ EV_BACKEND_PDF, "Microsoft PowerPoint - " }
+  { EV_BACKEND_PDF, "Microsoft Word - " },
+  { EV_BACKEND_PDF, "Microsoft PowerPoint - " }
 };
 
 /* Some docs report titles with confusing extensions (ex. .doc for pdf).
 	   Erase the confusing extension of the title */
 static void
 ev_window_title_sanitize_title (EvWindowTitle *window_title, char **title) {
-	const gchar *backend;
-	int i;
-
-	backend = G_OBJECT_TYPE_NAME (window_title->document);
-
-	for (i = 0; i < G_N_ELEMENTS (bad_extensions); i++) {
-		if (g_ascii_strcasecmp (bad_extensions[i].backend, backend) == 0 && 
-		    g_str_has_suffix (*title, bad_extensions[i].text)) {
-			char *new_title;
-
-			new_title = g_strndup (*title, strlen(*title) - strlen(bad_extensions[i].text));
-			g_free (*title);
-			*title = new_title;
-		}
-	}
-	for (i = 0; i < G_N_ELEMENTS (bad_prefixes); i++) {
-		if (g_ascii_strcasecmp (bad_prefixes[i].backend, backend) == 0 &&
-		    g_str_has_prefix (*title, bad_prefixes[i].text)) {
-			char *new_title;
-			int len = strlen(bad_prefixes[i].text);
-			
-			new_title = g_strdup_printf ("%s", (*title) + len);
-			g_free (*title);
-			*title = new_title;
-		}
-	}
+  const gchar *backend;
+  int i;
+
+  backend = G_OBJECT_TYPE_NAME (window_title->document);
+
+  for (i = 0; i < G_N_ELEMENTS (bad_extensions); i++) {
+    if (g_ascii_strcasecmp (bad_extensions[i].backend, backend) == 0 &&
+        g_str_has_suffix (*title, bad_extensions[i].text)) {
+      char *new_title;
+
+      new_title = g_strndup (*title, strlen(*title) - strlen(bad_extensions[i].text));
+      g_free (*title);
+      *title = new_title;
+    }
+  }
+  for (i = 0; i < G_N_ELEMENTS (bad_prefixes); i++) {
+    if (g_ascii_strcasecmp (bad_prefixes[i].backend, backend) == 0 &&
+        g_str_has_prefix (*title, bad_prefixes[i].text)) {
+      char *new_title;
+      int len = strlen(bad_prefixes[i].text);
+
+      new_title = g_strdup_printf ("%s", (*title) + len);
+      g_free (*title);
+      *title = new_title;
+    }
+  }
 }
 
 static void
-ev_window_title_update (EvWindowTitle *window_title)
-{
-	GtkWindow *window = GTK_WINDOW (window_title->window);
-	GtkHeaderBar *toolbar = GTK_HEADER_BAR (ev_window_get_toolbar (EV_WINDOW (window)));
-	char *title = NULL, *p;
-	char *subtitle = NULL, *title_header = NULL;
-	gboolean ltr;
-
-        if (window_title->type == EV_WINDOW_TITLE_RECENT) {
-                gtk_header_bar_set_subtitle (toolbar, NULL);
-                gtk_window_set_title (window, _("Recent Documents"));
-                return;
-        }
-
-	ltr = gtk_widget_get_direction (GTK_WIDGET (window)) == GTK_TEXT_DIR_LTR;
-
-	if (window_title->doc_title && window_title->filename) {
-                title = g_strdup (window_title->doc_title);
-                ev_window_title_sanitize_title (window_title, &title);
-
-		subtitle = window_title->filename;
-
-		title_header = title;
-		if (ltr)
-			title = g_strdup_printf ("%s — %s", subtitle, title);
-		else
-			title = g_strdup_printf ("%s — %s", title, subtitle);
-
-                for (p = title; *p; ++p) {
-                        /* an '\n' byte is always ASCII, no need for UTF-8 special casing */
-                        if (*p == '\n')
-                                *p = ' ';
-                }
-	} else if (window_title->filename) {
-		title = g_strdup (window_title->filename);
-	} else if (!title) {
-		title = g_strdup (_("Document Viewer"));
-	}
-
-	switch (window_title->type) {
-	case EV_WINDOW_TITLE_DOCUMENT:
-		gtk_window_set_title (window, title);
-		if (title_header && subtitle) {
-			gtk_header_bar_set_title (toolbar, title_header);
-			gtk_header_bar_set_subtitle (toolbar, subtitle);
-		}
-		if (window_title->dirname)
-			gtk_widget_set_tooltip_text (GTK_WIDGET (toolbar),
-						     window_title->dirname);
-		break;
-	case EV_WINDOW_TITLE_PASSWORD: {
-                gchar *password_title;
-
-		if (ltr)
-			password_title = g_strdup_printf ("%s — %s", title, _("Password Required"));
-		else
-			password_title = g_strdup_printf ("%s — %s", _("Password Required"), title);
-
-		gtk_window_set_title (window, password_title);
-		g_free (password_title);
-
-                gtk_header_bar_set_title (toolbar, _("Password Required"));
-                gtk_header_bar_set_subtitle (toolbar, title);
-        }
-		break;
-        case EV_WINDOW_TITLE_RECENT:
-                g_assert_not_reached ();
-                break;
-	}
-
-	g_free (title);
-	g_free (title_header);
+ev_window_title_update (EvWindowTitle *window_title) {
+  GtkWindow *window = GTK_WINDOW (window_title->window);
+  GtkHeaderBar *toolbar = GTK_HEADER_BAR (ev_window_get_toolbar (EV_WINDOW (window)));
+  char *title = NULL, *p;
+  char *subtitle = NULL, *title_header = NULL;
+  gboolean ltr;
+
+  if (window_title->type == EV_WINDOW_TITLE_RECENT) {
+    gtk_header_bar_set_subtitle (toolbar, NULL);
+    gtk_window_set_title (window, _("Recent Documents"));
+    return;
+  }
+
+  ltr = gtk_widget_get_direction (GTK_WIDGET (window)) == GTK_TEXT_DIR_LTR;
+
+  if (window_title->doc_title && window_title->filename) {
+    title = g_strdup (window_title->doc_title);
+    ev_window_title_sanitize_title (window_title, &title);
+
+    subtitle = window_title->filename;
+
+    title_header = title;
+    if (ltr)
+      title = g_strdup_printf ("%s — %s", subtitle, title);
+    else
+      title = g_strdup_printf ("%s — %s", title, subtitle);
+
+    for (p = title; *p; ++p) {
+      /* an '\n' byte is always ASCII, no need for UTF-8 special casing */
+      if (*p == '\n')
+        *p = ' ';
+    }
+  } else if (window_title->filename) {
+    title = g_strdup (window_title->filename);
+  } else if (!title) {
+    title = g_strdup (_("Document Viewer"));
+  }
+
+  switch (window_title->type) {
+    case EV_WINDOW_TITLE_DOCUMENT:
+      gtk_window_set_title (window, title);
+      if (title_header && subtitle) {
+        gtk_header_bar_set_title (toolbar, title_header);
+        gtk_header_bar_set_subtitle (toolbar, subtitle);
+      }
+      if (window_title->dirname)
+        gtk_widget_set_tooltip_text (GTK_WIDGET (toolbar),
+                                     window_title->dirname);
+      break;
+    case EV_WINDOW_TITLE_PASSWORD: {
+      gchar *password_title;
+
+      if (ltr)
+        password_title = g_strdup_printf ("%s — %s", title, _("Password Required"));
+      else
+        password_title = g_strdup_printf ("%s — %s", _("Password Required"), title);
+
+      gtk_window_set_title (window, password_title);
+      g_free (password_title);
+
+      gtk_header_bar_set_title (toolbar, _("Password Required"));
+      gtk_header_bar_set_subtitle (toolbar, title);
+    }
+    break;
+    case EV_WINDOW_TITLE_RECENT:
+      g_assert_not_reached ();
+      break;
+  }
+
+  g_free (title);
+  g_free (title_header);
 }
 
 EvWindowTitle *
-ev_window_title_new (EvWindow *window)
-{
-	EvWindowTitle *window_title;
+ev_window_title_new (EvWindow *window) {
+  EvWindowTitle *window_title;
 
-	window_title = g_new0 (EvWindowTitle, 1);
-	window_title->window = window;
-	window_title->type = EV_WINDOW_TITLE_DOCUMENT;
+  window_title = g_new0 (EvWindowTitle, 1);
+  window_title->window = window;
+  window_title->type = EV_WINDOW_TITLE_DOCUMENT;
 
-        ev_window_title_update (window_title);
+  ev_window_title_update (window_title);
 
-	return window_title;
+  return window_title;
 }
 
 void
-ev_window_title_set_type (EvWindowTitle *window_title, EvWindowTitleType type)
-{
-	window_title->type = type;
+ev_window_title_set_type (EvWindowTitle *window_title, EvWindowTitleType type) {
+  window_title->type = type;
 
-	ev_window_title_update (window_title);
+  ev_window_title_update (window_title);
 }
 
 static void
 document_destroyed_cb (EvWindowTitle *window_title,
-                       GObject       *document)
-{
-        window_title->document = NULL;
-        g_clear_pointer (&window_title->doc_title, g_free);
-        g_clear_pointer (&window_title->dirname, g_free);
+                       GObject       *document) {
+  window_title->document = NULL;
+  g_clear_pointer (&window_title->doc_title, g_free);
+  g_clear_pointer (&window_title->dirname, g_free);
 }
 
 void
 ev_window_title_set_document (EvWindowTitle *window_title,
-			      EvDocument    *document)
-{
-        if (window_title->document == document)
-                return;
-
-        if (window_title->document)
-                g_object_weak_unref (G_OBJECT (window_title->document), (GWeakNotify)document_destroyed_cb, window_title);
-	window_title->document = document;
-        g_object_weak_ref (G_OBJECT (window_title->document), (GWeakNotify)document_destroyed_cb, window_title);
-        g_clear_pointer (&window_title->doc_title, g_free);
-        g_clear_pointer (&window_title->dirname, g_free);
-
-	if (window_title->document != NULL) {
-		gchar *doc_title;
-		gchar *filepath;
-		gchar *dirname;
-
-		doc_title = g_strdup (ev_document_get_title (window_title->document));
-
-		/* Make sure we get a valid title back */
-		if (doc_title != NULL) {
-			doc_title = g_strstrip (doc_title);
-
-			if (doc_title[0] != '\0' &&
-                            g_utf8_validate (doc_title, -1, NULL)) {
-				window_title->doc_title = doc_title;
-			} else {
-                                g_free (doc_title);
-                        }
-		}
-
-		filepath = g_filename_from_uri (ev_document_get_uri (window_title->document),
-						NULL, NULL);
-		dirname = g_path_get_dirname (filepath);
-		g_free (filepath);
-
-		if (dirname)
-			window_title->dirname = dirname;
-	}
-
-	ev_window_title_update (window_title);
+                              EvDocument    *document) {
+  if (window_title->document == document)
+    return;
+
+  if (window_title->document)
+    g_object_weak_unref (G_OBJECT (window_title->document), (GWeakNotify)document_destroyed_cb, window_title);
+  window_title->document = document;
+  g_object_weak_ref (G_OBJECT (window_title->document), (GWeakNotify)document_destroyed_cb, window_title);
+  g_clear_pointer (&window_title->doc_title, g_free);
+  g_clear_pointer (&window_title->dirname, g_free);
+
+  if (window_title->document != NULL) {
+    gchar *doc_title;
+    gchar *filepath;
+    gchar *dirname;
+
+    doc_title = g_strdup (ev_document_get_title (window_title->document));
+
+    /* Make sure we get a valid title back */
+    if (doc_title != NULL) {
+      doc_title = g_strstrip (doc_title);
+
+      if (doc_title[0] != '\0' &&
+          g_utf8_validate (doc_title, -1, NULL)) {
+        window_title->doc_title = doc_title;
+      } else {
+        g_free (doc_title);
+      }
+    }
+
+    filepath = g_filename_from_uri (ev_document_get_uri (window_title->document),
+                                    NULL, NULL);
+    dirname = g_path_get_dirname (filepath);
+    g_free (filepath);
+
+    if (dirname)
+      window_title->dirname = dirname;
+  }
+
+  ev_window_title_update (window_title);
 }
 
 void
 ev_window_title_set_filename (EvWindowTitle *window_title,
-			      const char    *filename)
-{
-        if (g_strcmp0 (filename, window_title->filename) == 0)
-                return;
+                              const char    *filename) {
+  if (g_strcmp0 (filename, window_title->filename) == 0)
+    return;
 
-	g_free (window_title->filename);
-	window_title->filename = g_strdup (filename);
+  g_free (window_title->filename);
+  window_title->filename = g_strdup (filename);
 
-	ev_window_title_update (window_title);
+  ev_window_title_update (window_title);
 }
 
 void
-ev_window_title_free (EvWindowTitle *window_title)
-{
-        if (window_title->document)
-                g_object_weak_unref (G_OBJECT (window_title->document), (GWeakNotify)document_destroyed_cb, window_title);
-        g_free (window_title->doc_title);
-	g_free (window_title->filename);
-	g_free (window_title->dirname);
-	g_free (window_title);
+ev_window_title_free (EvWindowTitle *window_title) {
+  if (window_title->document)
+    g_object_weak_unref (G_OBJECT (window_title->document), (GWeakNotify)document_destroyed_cb, window_title);
+  g_free (window_title->doc_title);
+  g_free (window_title->filename);
+  g_free (window_title->dirname);
+  g_free (window_title);
 }
diff --git a/shell/ev-window.c b/shell/ev-window.c
index 8e9a86f..9895a34 100644
--- a/shell/ev-window.c
+++ b/shell/ev-window.c
@@ -103,145 +103,145 @@
 #define MOUSE_FORWARD_BUTTON 9
 
 typedef enum {
-	PAGE_MODE_DOCUMENT,
-	PAGE_MODE_PASSWORD
+  PAGE_MODE_DOCUMENT,
+  PAGE_MODE_PASSWORD
 } EvWindowPageMode;
 
 typedef enum {
-        EV_CHROME_TOOLBAR            = 1 << 0,
-        EV_CHROME_FINDBAR            = 1 << 1,
-        EV_CHROME_RAISE_TOOLBAR      = 1 << 2,
-        EV_CHROME_FULLSCREEN_TOOLBAR = 1 << 3,
-        EV_CHROME_SIDEBAR            = 1 << 4,
-        EV_CHROME_NORMAL             = EV_CHROME_TOOLBAR | EV_CHROME_SIDEBAR
+  EV_CHROME_TOOLBAR            = 1 << 0,
+  EV_CHROME_FINDBAR            = 1 << 1,
+  EV_CHROME_RAISE_TOOLBAR      = 1 << 2,
+  EV_CHROME_FULLSCREEN_TOOLBAR = 1 << 3,
+  EV_CHROME_SIDEBAR            = 1 << 4,
+  EV_CHROME_NORMAL             = EV_CHROME_TOOLBAR | EV_CHROME_SIDEBAR
 } EvChrome;
 
 typedef enum {
-	EV_SAVE_DOCUMENT,
-	EV_SAVE_ATTACHMENT,
-	EV_SAVE_IMAGE
+  EV_SAVE_DOCUMENT,
+  EV_SAVE_ATTACHMENT,
+  EV_SAVE_IMAGE
 } EvSaveType;
 
 typedef enum {
-	EV_WINDOW_ACTION_RELOAD,
-	EV_WINDOW_ACTION_CLOSE
+  EV_WINDOW_ACTION_RELOAD,
+  EV_WINDOW_ACTION_CLOSE
 } EvWindowAction;
 
 typedef struct {
-	/* UI */
-	EvChrome chrome;
-
-	GtkWidget *main_box;
-	GtkWidget *toolbar;
-	GtkWidget *hpaned;
-	GtkWidget *view_box;
-	GtkWidget *sidebar;
-	GtkWidget *search_box;
-	GtkWidget *search_bar;
-	GtkWidget *scrolled_window;
-	GtkWidget *view;
-	GtkWidget *loading_message;
-	GtkWidget *presentation_view;
-	GtkWidget *message_area;
-	GtkWidget *password_view;
-	GtkWidget *sidebar_thumbs;
-	GtkWidget *sidebar_links;
-	GtkWidget *find_sidebar;
-	GtkWidget *sidebar_attachments;
-	GtkWidget *sidebar_layers;
-	GtkWidget *sidebar_annots;
-	GtkWidget *sidebar_bookmarks;
-	GtkWidget *annots_toolbar;
-
-	/* Settings */
-	GSettings *settings;
-	GSettings *default_settings;
-	GSettings *lockdown_settings;
-
-	/* Progress Messages */
-	guint progress_idle;
-	GCancellable *progress_cancellable;
-
-	/* Fullscreen */
-	GtkWidget *fs_overlay;
-	GtkWidget *fs_eventbox;
-	GtkWidget *fs_revealer;
-	GtkWidget *fs_toolbar;
-	gboolean   fs_pointer_on_toolbar;
-	guint      fs_timeout_id;
-
-	/* Loading message */
-	guint loading_message_timeout;
-
-	/* Dialogs */
-	GtkWidget *properties;
-	GtkWidget *print_dialog;
-
-	GtkRecentManager *recent_manager;
-
-	/* Popup view */
-	GMenuModel   *view_popup_menu;
-	GtkWidget    *view_popup;
-	EvLink       *link;
-	EvImage      *image;
-	EvAnnotation *annot;
-
-	/* Popup attachment */
-	GMenuModel   *attachment_popup_menu;
-	GtkWidget    *attachment_popup;
-	GList        *attach_list;
-
-	/* For bookshelf view of recent items*/
-	EvRecentView *recent_view;
-
-	/* Document */
-	EvDocumentModel *model;
-	char *uri;
-	glong uri_mtime;
-	char *local_uri;
-	char *display_name;
-	char *edit_name;
-	gboolean in_reload;
-	EvFileMonitor *monitor;
-	guint setup_document_idle;
-	
-	EvDocument *document;
-	EvHistory *history;
-	EvWindowPageMode page_mode;
-	EvWindowTitle *title;
-	EvMetadata *metadata;
-	EvBookmarks *bookmarks;
-	GMenu *bookmarks_menu;
-
-	/* Load params */
-	EvLinkDest       *dest;
-	gchar            *search_string;
-	EvWindowRunMode   window_mode;
-
-	EvJob            *load_job;
-	EvJob            *reload_job;
-	EvJob            *save_job;
-	gboolean          close_after_save;
-
-	/* Printing */
-	GQueue           *print_queue;
-	GtkPrintSettings *print_settings;
-	GtkPageSetup     *print_page_setup;
-	gboolean          close_after_print;
+  /* UI */
+  EvChrome chrome;
+
+  GtkWidget *main_box;
+  GtkWidget *toolbar;
+  GtkWidget *hpaned;
+  GtkWidget *view_box;
+  GtkWidget *sidebar;
+  GtkWidget *search_box;
+  GtkWidget *search_bar;
+  GtkWidget *scrolled_window;
+  GtkWidget *view;
+  GtkWidget *loading_message;
+  GtkWidget *presentation_view;
+  GtkWidget *message_area;
+  GtkWidget *password_view;
+  GtkWidget *sidebar_thumbs;
+  GtkWidget *sidebar_links;
+  GtkWidget *find_sidebar;
+  GtkWidget *sidebar_attachments;
+  GtkWidget *sidebar_layers;
+  GtkWidget *sidebar_annots;
+  GtkWidget *sidebar_bookmarks;
+  GtkWidget *annots_toolbar;
+
+  /* Settings */
+  GSettings *settings;
+  GSettings *default_settings;
+  GSettings *lockdown_settings;
+
+  /* Progress Messages */
+  guint progress_idle;
+  GCancellable *progress_cancellable;
+
+  /* Fullscreen */
+  GtkWidget *fs_overlay;
+  GtkWidget *fs_eventbox;
+  GtkWidget *fs_revealer;
+  GtkWidget *fs_toolbar;
+  gboolean   fs_pointer_on_toolbar;
+  guint      fs_timeout_id;
+
+  /* Loading message */
+  guint loading_message_timeout;
+
+  /* Dialogs */
+  GtkWidget *properties;
+  GtkWidget *print_dialog;
+
+  GtkRecentManager *recent_manager;
+
+  /* Popup view */
+  GMenuModel   *view_popup_menu;
+  GtkWidget    *view_popup;
+  EvLink       *link;
+  EvImage      *image;
+  EvAnnotation *annot;
+
+  /* Popup attachment */
+  GMenuModel   *attachment_popup_menu;
+  GtkWidget    *attachment_popup;
+  GList        *attach_list;
+
+  /* For bookshelf view of recent items*/
+  EvRecentView *recent_view;
+
+  /* Document */
+  EvDocumentModel *model;
+  char *uri;
+  glong uri_mtime;
+  char *local_uri;
+  char *display_name;
+  char *edit_name;
+  gboolean in_reload;
+  EvFileMonitor *monitor;
+  guint setup_document_idle;
+
+  EvDocument *document;
+  EvHistory *history;
+  EvWindowPageMode page_mode;
+  EvWindowTitle *title;
+  EvMetadata *metadata;
+  EvBookmarks *bookmarks;
+  GMenu *bookmarks_menu;
+
+  /* Load params */
+  EvLinkDest       *dest;
+  gchar            *search_string;
+  EvWindowRunMode   window_mode;
+
+  EvJob            *load_job;
+  EvJob            *reload_job;
+  EvJob            *save_job;
+  gboolean          close_after_save;
+
+  /* Printing */
+  GQueue           *print_queue;
+  GtkPrintSettings *print_settings;
+  GtkPageSetup     *print_page_setup;
+  gboolean          close_after_print;
 
 #ifdef ENABLE_DBUS
-	/* DBus */
-	EvEvinceWindow *skeleton;
-	gchar          *dbus_object_path;
+  /* DBus */
+  EvEvinceWindow *skeleton;
+  gchar          *dbus_object_path;
 #endif
 
-        guint presentation_mode_inhibit_id;
+  guint presentation_mode_inhibit_id;
 
-	/* Caret navigation */
-	GtkWidget *ask_caret_navigation_check;
+  /* Caret navigation */
+  GtkWidget *ask_caret_navigation_check;
 
-	/* Send to */
-	gboolean has_mailto_handler;
+  /* Send to */
+  gboolean has_mailto_handler;
 } EvWindowPrivate;
 
 #define GET_PRIVATE(o) ev_window_get_instance_private (o)
@@ -292,87 +292,87 @@ typedef struct {
 #define FULLSCREEN_TRANSITION_DURATION 1000 /* in milliseconds */
 
 static const gchar *document_print_settings[] = {
-	GTK_PRINT_SETTINGS_COLLATE,
-	GTK_PRINT_SETTINGS_REVERSE,
-	GTK_PRINT_SETTINGS_NUMBER_UP,
-	GTK_PRINT_SETTINGS_SCALE,
-	GTK_PRINT_SETTINGS_PRINT_PAGES,
-	GTK_PRINT_SETTINGS_PAGE_RANGES,
-	GTK_PRINT_SETTINGS_PAGE_SET,
-	GTK_PRINT_SETTINGS_OUTPUT_URI
+  GTK_PRINT_SETTINGS_COLLATE,
+  GTK_PRINT_SETTINGS_REVERSE,
+  GTK_PRINT_SETTINGS_NUMBER_UP,
+  GTK_PRINT_SETTINGS_SCALE,
+  GTK_PRINT_SETTINGS_PRINT_PAGES,
+  GTK_PRINT_SETTINGS_PAGE_RANGES,
+  GTK_PRINT_SETTINGS_PAGE_SET,
+  GTK_PRINT_SETTINGS_OUTPUT_URI
 };
 
 static void	ev_window_update_actions_sensitivity    (EvWindow         *ev_window);
 static void     ev_window_sidebar_visibility_changed_cb (EvSidebar        *ev_sidebar,
-							 GParamSpec       *pspec,
-							 EvWindow         *ev_window);
+                                                         GParamSpec       *pspec,
+                                                         EvWindow         *ev_window);
 static void     ev_window_set_page_mode                 (EvWindow         *window,
-							 EvWindowPageMode  page_mode);
+                                                         EvWindowPageMode  page_mode);
 static void	ev_window_load_job_cb  			(EvJob            *job,
-							 gpointer          data);
+                                         gpointer          data);
 static void     ev_window_reload_document               (EvWindow         *window,
-							 EvLinkDest *dest);
+                                                         EvLinkDest *dest);
 static void     ev_window_reload_job_cb                 (EvJob            *job,
-							 EvWindow         *window);
+                                                         EvWindow         *window);
 static void     ev_window_save_job_cb                   (EvJob            *save,
-							 EvWindow         *window);
+                                                         EvWindow         *window);
 static void     ev_window_sizing_mode_changed_cb        (EvDocumentModel  *model,
-							 GParamSpec       *pspec,
-							 EvWindow         *ev_window);
+                                                         GParamSpec       *pspec,
+                                                         EvWindow         *ev_window);
 static void     ev_window_zoom_changed_cb 	        (EvDocumentModel  *model,
-							 GParamSpec       *pspec,
-							 EvWindow         *ev_window);
+                                                     GParamSpec       *pspec,
+                                                     EvWindow         *ev_window);
 static void     ev_window_add_recent                    (EvWindow         *window,
-							 const char       *uri);
+                                                         const char       *uri);
 static void     ev_window_run_fullscreen                (EvWindow         *window);
 static void     ev_window_stop_fullscreen               (EvWindow         *window,
-							 gboolean          unfullscreen_window);
+                                                         gboolean          unfullscreen_window);
 static void     ev_window_run_presentation              (EvWindow         *window);
 static void     ev_window_stop_presentation             (EvWindow         *window,
-							 gboolean          unfullscreen_window);
+                                                         gboolean          unfullscreen_window);
 static void     ev_window_popup_cmd_open_link           (GSimpleAction    *action,
-							 GVariant         *parameter,
-							 gpointer          user_data);
+                                                         GVariant         *parameter,
+                                                         gpointer          user_data);
 static void     ev_window_popup_cmd_open_link_new_window(GSimpleAction    *action,
-							 GVariant         *parameter,
-							 gpointer          user_data);
+                                                         GVariant         *parameter,
+                                                         gpointer          user_data);
 static void     ev_window_popup_cmd_copy_link_address   (GSimpleAction    *action,
-							 GVariant         *parameter,
-							 gpointer          user_data);
+                                                         GVariant         *parameter,
+                                                         gpointer          user_data);
 static void     ev_window_popup_cmd_annotate_selected_text (GSimpleAction    *action,
-							    GVariant         *parameter,
-							    gpointer          user_data);
+                                                            GVariant         *parameter,
+                                                            gpointer          user_data);
 static void     ev_window_popup_cmd_save_image_as       (GSimpleAction    *action,
-							 GVariant         *parameter,
-							 gpointer          user_data);
+                                                         GVariant         *parameter,
+                                                         gpointer          user_data);
 static void     ev_window_popup_cmd_copy_image          (GSimpleAction    *action,
-							 GVariant         *parameter,
-							 gpointer          user_data);
+                                                         GVariant         *parameter,
+                                                         gpointer          user_data);
 static void     ev_window_popup_cmd_annot_properties    (GSimpleAction    *action,
-							 GVariant         *parameter,
-							 gpointer          user_data);
+                                                         GVariant         *parameter,
+                                                         gpointer          user_data);
 static void     ev_window_popup_cmd_remove_annotation   (GSimpleAction    *action,
-							 GVariant         *parameter,
-							 gpointer          user_data);
+                                                         GVariant         *parameter,
+                                                         gpointer          user_data);
 static void	ev_window_popup_cmd_open_attachment     (GSimpleAction    *action,
-							 GVariant         *parameter,
-							 gpointer          user_data);
+                                                     GVariant         *parameter,
+                                                     gpointer          user_data);
 static void	ev_window_popup_cmd_save_attachment_as  (GSimpleAction    *action,
-							 GVariant         *parameter,
-							 gpointer          user_data);
-static void	view_handle_link_cb 			(EvView           *view, 
-							 EvLink           *link, 
-							 EvWindow         *window);
+                                                     GVariant         *parameter,
+                                                     gpointer          user_data);
+static void	view_handle_link_cb 			(EvView           *view,
+                                       EvLink           *link,
+                                       EvWindow         *window);
 static void     activate_link_cb                        (GObject          *object,
-							 EvLink           *link,
-							 EvWindow         *window);
+                                                         EvLink           *link,
+                                                         EvWindow         *window);
 static void     view_external_link_cb                   (EvWindow         *window,
-							 EvLinkAction     *action);
+                                                         EvLinkAction     *action);
 static void     ev_window_load_file_remote              (EvWindow         *ev_window,
-							 GFile            *source_file);
+                                                         GFile            *source_file);
 static void     ev_window_media_player_key_pressed      (EvWindow         *window,
-							 const gchar      *key,
-							 gpointer          user_data);
+                                                         const gchar      *key,
+                                                         gpointer          user_data);
 #ifdef ENABLE_DBUS
 static void	ev_window_emit_closed			(EvWindow         *window);
 static void 	ev_window_emit_doc_loaded		(EvWindow	  *window);
@@ -380,7 +380,7 @@ static void 	ev_window_emit_doc_loaded		(EvWindow	  *window);
 static void     ev_window_setup_bookmarks               (EvWindow         *window);
 
 static void     ev_window_show_find_bar                 (EvWindow         *ev_window,
-							 gboolean          restart);
+                                                         gboolean          restart);
 static void     ev_window_close_find_bar                (EvWindow         *ev_window);
 static void     ev_window_destroy_recent_view           (EvWindow         *ev_window);
 static void     recent_view_item_activated_cb           (EvRecentView     *recent_view,
@@ -388,319 +388,314 @@ static void     recent_view_item_activated_cb           (EvRecentView     *recen
                                                          EvWindow         *ev_window);
 static void     ev_window_fullscreen_show_toolbar       (EvWindow         *ev_window);
 static void     ev_window_begin_add_annot               (EvWindow         *ev_window,
-							 EvAnnotationType  annot_type);
+                                                         EvAnnotationType  annot_type);
 
 static gchar *nautilus_sendto = NULL;
 
 G_DEFINE_TYPE_WITH_PRIVATE (EvWindow, ev_window, GTK_TYPE_APPLICATION_WINDOW)
 
 static gboolean
-ev_window_is_recent_view (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+ev_window_is_recent_view (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	return ev_toolbar_get_mode (EV_TOOLBAR (priv->toolbar)) == EV_TOOLBAR_MODE_RECENT_VIEW;
+  return ev_toolbar_get_mode (EV_TOOLBAR (priv->toolbar)) == EV_TOOLBAR_MODE_RECENT_VIEW;
 }
 
 static void
 ev_window_set_action_enabled (EvWindow   *ev_window,
-			      const char *name,
-			      gboolean    enabled)
-{
-	GAction *action;
-
-	action = g_action_map_lookup_action (G_ACTION_MAP (ev_window), name);
-	g_simple_action_set_enabled (G_SIMPLE_ACTION (action), enabled);
-}
-
-static void
-ev_window_update_actions_sensitivity (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	EvDocument *document = priv->document;
-	EvView     *view = EV_VIEW (priv->view);
-	const EvDocumentInfo *info = NULL;
-	gboolean has_document = FALSE;
-	gboolean ok_to_print = TRUE;
-	gboolean ok_to_copy = TRUE;
-	gboolean has_properties = TRUE;
-	gboolean override_restrictions = TRUE;
-	gboolean can_get_text = FALSE;
-	gboolean can_find = FALSE;
-	gboolean can_find_in_page;
-	gboolean can_annotate = FALSE;
-	gboolean presentation_mode;
-	gboolean recent_view_mode;
-	gboolean dual_mode = FALSE;
-	gboolean has_pages = FALSE;
-	int      n_pages = 0, page = -1;
-
-	if (document) {
-		has_document = TRUE;
-		info = ev_document_get_info (document);
-		page = ev_document_model_get_page (priv->model);
-		n_pages = ev_document_get_n_pages (priv->document);
-		has_pages = n_pages > 0;
-		dual_mode = ev_document_model_get_dual_page (priv->model);
-	}
-
-	if (!info || info->fields_mask == 0) {
-		has_properties = FALSE;
-	}
-
-	if (has_document && EV_IS_SELECTION (document)) {
-		can_get_text = TRUE;
-	}
-
-	if (has_pages && EV_IS_DOCUMENT_FIND (document)) {
-		can_find = TRUE;
-	}
-
-	if (has_document && EV_IS_DOCUMENT_ANNOTATIONS (document)) {
-		can_annotate = ev_document_annotations_can_add_annotation (EV_DOCUMENT_ANNOTATIONS (document));
-	}
-
-	if (has_document && priv->settings) {
-		override_restrictions =
-			g_settings_get_boolean (priv->settings,
-						GS_OVERRIDE_RESTRICTIONS);
-	}
-
-	if (!override_restrictions && info && info->fields_mask & EV_DOCUMENT_INFO_PERMISSIONS) {
-		ok_to_print = (info->permissions & EV_DOCUMENT_PERMISSIONS_OK_TO_PRINT);
-		ok_to_copy = (info->permissions & EV_DOCUMENT_PERMISSIONS_OK_TO_COPY);
-	}
-
-	if (has_document && !ev_print_operation_exists_for_document(document))
-		ok_to_print = FALSE;
-
-	if (has_document && priv->lockdown_settings &&
-	    g_settings_get_boolean (priv->lockdown_settings, GS_LOCKDOWN_SAVE)) {
-		ok_to_copy = FALSE;
-	}
-
-	if (has_document && priv->lockdown_settings &&
-	    g_settings_get_boolean (priv->lockdown_settings, GS_LOCKDOWN_PRINT)) {
-		ok_to_print = FALSE;
-	}
-
-	/* Get modes */
-	presentation_mode = EV_WINDOW_IS_PRESENTATION (priv);
-	recent_view_mode = ev_window_is_recent_view (ev_window);
-
-	/* File menu */
-	ev_window_set_action_enabled (ev_window, "open-copy", has_document);
-	ev_window_set_action_enabled (ev_window, "save-as", has_document &&
-				      ok_to_copy && !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "print", has_pages &&
-				      ok_to_print && !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "show-properties",
-				      has_document && has_properties &&
-				      !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "open-containing-folder",
-				      has_document && !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "send-to", has_document &&
-				      priv->has_mailto_handler &&
-	                              nautilus_sendto &&
-				      !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "fullscreen",
-				      has_document && !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "presentation",
-				      has_document && !recent_view_mode);
-
-        /* Edit menu */
-	ev_window_set_action_enabled (ev_window, "select-all", has_pages &&
-				      can_get_text && !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "find", can_find &&
-				      !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "toggle-find", can_find &&
-				      !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "toggle-edit-annots", can_annotate &&
-				      !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "rotate-left", has_pages &&
-				      !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "rotate-right", has_pages &&
-				      !recent_view_mode);
-
-        /* View menu */
-	ev_window_set_action_enabled (ev_window, "continuous", has_pages &&
-				      !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "dual-page", has_pages &&
-				      !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "rtl", has_pages &&
-				      !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "reload", has_pages &&
-				      !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "auto-scroll", has_pages &&
-				      !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "inverted-colors",
-				      has_pages && !recent_view_mode);
+                              const char *name,
+                              gboolean    enabled) {
+  GAction *action;
+
+  action = g_action_map_lookup_action (G_ACTION_MAP (ev_window), name);
+  g_simple_action_set_enabled (G_SIMPLE_ACTION (action), enabled);
+}
+
+static void
+ev_window_update_actions_sensitivity (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  EvDocument *document = priv->document;
+  EvView     *view = EV_VIEW (priv->view);
+  const EvDocumentInfo *info = NULL;
+  gboolean has_document = FALSE;
+  gboolean ok_to_print = TRUE;
+  gboolean ok_to_copy = TRUE;
+  gboolean has_properties = TRUE;
+  gboolean override_restrictions = TRUE;
+  gboolean can_get_text = FALSE;
+  gboolean can_find = FALSE;
+  gboolean can_find_in_page;
+  gboolean can_annotate = FALSE;
+  gboolean presentation_mode;
+  gboolean recent_view_mode;
+  gboolean dual_mode = FALSE;
+  gboolean has_pages = FALSE;
+  int      n_pages = 0, page = -1;
+
+  if (document) {
+    has_document = TRUE;
+    info = ev_document_get_info (document);
+    page = ev_document_model_get_page (priv->model);
+    n_pages = ev_document_get_n_pages (priv->document);
+    has_pages = n_pages > 0;
+    dual_mode = ev_document_model_get_dual_page (priv->model);
+  }
+
+  if (!info || info->fields_mask == 0) {
+    has_properties = FALSE;
+  }
+
+  if (has_document && EV_IS_SELECTION (document)) {
+    can_get_text = TRUE;
+  }
+
+  if (has_pages && EV_IS_DOCUMENT_FIND (document)) {
+    can_find = TRUE;
+  }
+
+  if (has_document && EV_IS_DOCUMENT_ANNOTATIONS (document)) {
+    can_annotate = ev_document_annotations_can_add_annotation (EV_DOCUMENT_ANNOTATIONS (document));
+  }
+
+  if (has_document && priv->settings) {
+    override_restrictions =
+      g_settings_get_boolean (priv->settings,
+                              GS_OVERRIDE_RESTRICTIONS);
+  }
+
+  if (!override_restrictions && info && info->fields_mask & EV_DOCUMENT_INFO_PERMISSIONS) {
+    ok_to_print = (info->permissions & EV_DOCUMENT_PERMISSIONS_OK_TO_PRINT);
+    ok_to_copy = (info->permissions & EV_DOCUMENT_PERMISSIONS_OK_TO_COPY);
+  }
+
+  if (has_document && !ev_print_operation_exists_for_document(document))
+    ok_to_print = FALSE;
+
+  if (has_document && priv->lockdown_settings &&
+      g_settings_get_boolean (priv->lockdown_settings, GS_LOCKDOWN_SAVE)) {
+    ok_to_copy = FALSE;
+  }
+
+  if (has_document && priv->lockdown_settings &&
+      g_settings_get_boolean (priv->lockdown_settings, GS_LOCKDOWN_PRINT)) {
+    ok_to_print = FALSE;
+  }
+
+  /* Get modes */
+  presentation_mode = EV_WINDOW_IS_PRESENTATION (priv);
+  recent_view_mode = ev_window_is_recent_view (ev_window);
+
+  /* File menu */
+  ev_window_set_action_enabled (ev_window, "open-copy", has_document);
+  ev_window_set_action_enabled (ev_window, "save-as", has_document &&
+                                ok_to_copy && !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "print", has_pages &&
+                                ok_to_print && !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "show-properties",
+                                has_document && has_properties &&
+                                !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "open-containing-folder",
+                                has_document && !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "send-to", has_document &&
+                                priv->has_mailto_handler &&
+                                nautilus_sendto &&
+                                !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "fullscreen",
+                                has_document && !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "presentation",
+                                has_document && !recent_view_mode);
+
+  /* Edit menu */
+  ev_window_set_action_enabled (ev_window, "select-all", has_pages &&
+                                can_get_text && !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "find", can_find &&
+                                !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "toggle-find", can_find &&
+                                !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "toggle-edit-annots", can_annotate &&
+                                !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "rotate-left", has_pages &&
+                                !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "rotate-right", has_pages &&
+                                !recent_view_mode);
+
+  /* View menu */
+  ev_window_set_action_enabled (ev_window, "continuous", has_pages &&
+                                !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "creator-mode", has_pages &&
+                                !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "dual-page", has_pages &&
+                                !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "rtl", has_pages &&
+                                !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "reload", has_pages &&
+                                !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "auto-scroll", has_pages &&
+                                !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "inverted-colors",
+                                has_pages && !recent_view_mode);
 #if WITH_GSPELL
-	ev_window_set_action_enabled (ev_window, "enable-spellchecking", TRUE);
+  ev_window_set_action_enabled (ev_window, "enable-spellchecking", TRUE);
 #else
-	ev_window_set_action_enabled (ev_window, "enable-spellchecking", FALSE);
+  ev_window_set_action_enabled (ev_window, "enable-spellchecking", FALSE);
 #endif
 
-	/* Bookmarks menu */
-	ev_window_set_action_enabled (ev_window, "add-bookmark",
-				      has_pages && priv->bookmarks &&
-				      !recent_view_mode);
-
-	/* Other actions that must be disabled in recent view, in
-	 * case they have a shortcut or gesture associated
-	 */
-	ev_window_set_action_enabled (ev_window, "save-settings", !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "show-side-pane", !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "goto-bookmark", !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "scroll-forward", !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "scroll-backwards", !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "sizing-mode", !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "zoom", !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "escape", !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "open-menu", !recent_view_mode);
-
-	/* Don't enable popup actions here because the page can change while a
-	 * popup is visible due to kinetic scrolling. The 'popup' functions
-	 * will enable appropriate actions when the popup is shown. */
-	if (recent_view_mode) {
-		ev_window_set_action_enabled (ev_window, "annotate-selected-text", FALSE);
-		ev_window_set_action_enabled (ev_window, "open-link", FALSE);
-		ev_window_set_action_enabled (ev_window, "open-link-new-window", FALSE);
-		ev_window_set_action_enabled (ev_window, "go-to-link", FALSE);
-		ev_window_set_action_enabled (ev_window, "copy-link-address", FALSE);
-		ev_window_set_action_enabled (ev_window, "save-image", FALSE);
-		ev_window_set_action_enabled (ev_window, "copy-image", FALSE);
-		ev_window_set_action_enabled (ev_window, "open-attachment", FALSE);
-		ev_window_set_action_enabled (ev_window, "save-attachment", FALSE);
-		ev_window_set_action_enabled (ev_window, "annot-properties", FALSE);
-		ev_window_set_action_enabled (ev_window, "remove-annot", FALSE);
-	}
-
-	can_find_in_page = ev_search_box_has_results (EV_SEARCH_BOX (priv->search_box));
-
-	ev_window_set_action_enabled (ev_window, "copy",
-					has_pages &&
-					ev_view_get_has_selection (view) &&
-					!recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "find-next",
-				      has_pages && can_find_in_page &&
-				      !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "find-previous",
-				      has_pages && can_find_in_page &&
-				      !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "dual-odd-left", dual_mode &&
-				      has_pages && !recent_view_mode);
-
-	ev_window_set_action_enabled (ev_window, "zoom-in",
-				      has_pages &&
-				      ev_view_can_zoom_in (view) &&
-				      !presentation_mode &&
-				      !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "zoom-out",
-				      has_pages &&
-				      ev_view_can_zoom_out (view) &&
-				      !presentation_mode &&
-				      !recent_view_mode);
-
-        /* Go menu */
-	if (has_pages) {
-		ev_window_set_action_enabled (ev_window, "go-previous-page", page > 0);
-		ev_window_set_action_enabled (ev_window, "go-next-page", page < n_pages - 1);
-		ev_window_set_action_enabled (ev_window, "go-first-page", page > 0);
-		ev_window_set_action_enabled (ev_window, "go-last-page", page < n_pages - 1);
-		ev_window_set_action_enabled (ev_window, "select-page", TRUE);
-	} else {
-  		ev_window_set_action_enabled (ev_window, "go-first-page", FALSE);
-		ev_window_set_action_enabled (ev_window, "go-previous-page", FALSE);
-		ev_window_set_action_enabled (ev_window, "go-next-page", FALSE);
-		ev_window_set_action_enabled (ev_window, "go-last-page", FALSE);
-		ev_window_set_action_enabled (ev_window, "select-page", FALSE);
-	}
-
-	ev_window_set_action_enabled (ev_window, "go-back-history",
-				      !ev_history_is_frozen (priv->history) &&
-				      ev_history_can_go_back (priv->history) &&
-				      !recent_view_mode);
-	ev_window_set_action_enabled (ev_window, "go-forward-history",
-				      !ev_history_is_frozen (priv->history) &&
-				      ev_history_can_go_forward (priv->history) &&
-				      !recent_view_mode);
-
-	ev_window_set_action_enabled (ev_window, "caret-navigation",
-				      has_pages &&
-				      ev_view_supports_caret_navigation (view) &&
-				      !presentation_mode &&
-				      !recent_view_mode);
-}
-
-static void
-set_widget_visibility (GtkWidget *widget, gboolean visible)
-{
-	g_assert (GTK_IS_WIDGET (widget));
-	
-	if (visible)
-		gtk_widget_show (widget);
-	else
-		gtk_widget_hide (widget);
-}
-
-static void
-update_chrome_visibility (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	gboolean toolbar, sidebar;
-	gboolean presentation;
-
-	presentation = EV_WINDOW_IS_PRESENTATION (priv);
-
-	toolbar = ((priv->chrome & EV_CHROME_TOOLBAR) != 0  || 
-		   (priv->chrome & EV_CHROME_RAISE_TOOLBAR) != 0) && !presentation;
-	sidebar = (priv->chrome & EV_CHROME_SIDEBAR) != 0 && priv->document && !presentation;
-
-	set_widget_visibility (priv->toolbar, toolbar);
-	set_widget_visibility (priv->sidebar, sidebar);
-
-	if (toolbar && ev_document_model_get_fullscreen (priv->model))
-		ev_window_fullscreen_show_toolbar (window);
-}
-
-static void
-update_chrome_flag (EvWindow *window, EvChrome flag, gboolean active)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-
-	if (active) {
-		priv->chrome |= flag;
-	} else {
-		priv->chrome &= ~flag;
-	}
-}
+  /* Bookmarks menu */
+  ev_window_set_action_enabled (ev_window, "add-bookmark",
+                                has_pages && priv->bookmarks &&
+                                !recent_view_mode);
+
+  /* Other actions that must be disabled in recent view, in
+   * case they have a shortcut or gesture associated
+   */
+  ev_window_set_action_enabled (ev_window, "save-settings", !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "show-side-pane", !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "goto-bookmark", !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "scroll-forward", !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "scroll-backwards", !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "sizing-mode", !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "zoom", !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "escape", !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "open-menu", !recent_view_mode);
+
+  /* Don't enable popup actions here because the page can change while a
+   * popup is visible due to kinetic scrolling. The 'popup' functions
+   * will enable appropriate actions when the popup is shown. */
+  if (recent_view_mode) {
+    ev_window_set_action_enabled (ev_window, "annotate-selected-text", FALSE);
+    ev_window_set_action_enabled (ev_window, "open-link", FALSE);
+    ev_window_set_action_enabled (ev_window, "open-link-new-window", FALSE);
+    ev_window_set_action_enabled (ev_window, "go-to-link", FALSE);
+    ev_window_set_action_enabled (ev_window, "copy-link-address", FALSE);
+    ev_window_set_action_enabled (ev_window, "save-image", FALSE);
+    ev_window_set_action_enabled (ev_window, "copy-image", FALSE);
+    ev_window_set_action_enabled (ev_window, "open-attachment", FALSE);
+    ev_window_set_action_enabled (ev_window, "save-attachment", FALSE);
+    ev_window_set_action_enabled (ev_window, "annot-properties", FALSE);
+    ev_window_set_action_enabled (ev_window, "remove-annot", FALSE);
+  }
+
+  can_find_in_page = ev_search_box_has_results (EV_SEARCH_BOX (priv->search_box));
+
+  ev_window_set_action_enabled (ev_window, "copy",
+                                has_pages &&
+                                ev_view_get_has_selection (view) &&
+                                !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "find-next",
+                                has_pages && can_find_in_page &&
+                                !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "find-previous",
+                                has_pages && can_find_in_page &&
+                                !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "dual-odd-left", dual_mode &&
+                                has_pages && !recent_view_mode);
+
+  ev_window_set_action_enabled (ev_window, "zoom-in",
+                                has_pages &&
+                                ev_view_can_zoom_in (view) &&
+                                !presentation_mode &&
+                                !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "zoom-out",
+                                has_pages &&
+                                ev_view_can_zoom_out (view) &&
+                                !presentation_mode &&
+                                !recent_view_mode);
+
+  /* Go menu */
+  if (has_pages) {
+    ev_window_set_action_enabled (ev_window, "go-previous-page", page > 0);
+    ev_window_set_action_enabled (ev_window, "go-next-page", page < n_pages - 1);
+    ev_window_set_action_enabled (ev_window, "go-first-page", page > 0);
+    ev_window_set_action_enabled (ev_window, "go-last-page", page < n_pages - 1);
+    ev_window_set_action_enabled (ev_window, "select-page", TRUE);
+  } else {
+    ev_window_set_action_enabled (ev_window, "go-first-page", FALSE);
+    ev_window_set_action_enabled (ev_window, "go-previous-page", FALSE);
+    ev_window_set_action_enabled (ev_window, "go-next-page", FALSE);
+    ev_window_set_action_enabled (ev_window, "go-last-page", FALSE);
+    ev_window_set_action_enabled (ev_window, "select-page", FALSE);
+  }
+
+  ev_window_set_action_enabled (ev_window, "go-back-history",
+                                !ev_history_is_frozen (priv->history) &&
+                                ev_history_can_go_back (priv->history) &&
+                                !recent_view_mode);
+  ev_window_set_action_enabled (ev_window, "go-forward-history",
+                                !ev_history_is_frozen (priv->history) &&
+                                ev_history_can_go_forward (priv->history) &&
+                                !recent_view_mode);
+
+  ev_window_set_action_enabled (ev_window, "caret-navigation",
+                                has_pages &&
+                                ev_view_supports_caret_navigation (view) &&
+                                !presentation_mode &&
+                                !recent_view_mode);
+}
+
+static void
+set_widget_visibility (GtkWidget *widget, gboolean visible) {
+  g_assert (GTK_IS_WIDGET (widget));
+
+  if (visible)
+    gtk_widget_show (widget);
+  else
+    gtk_widget_hide (widget);
+}
+
+static void
+update_chrome_visibility (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  gboolean toolbar, sidebar;
+  gboolean presentation;
+
+  presentation = EV_WINDOW_IS_PRESENTATION (priv);
+
+  toolbar = ((priv->chrome & EV_CHROME_TOOLBAR) != 0  ||
+             (priv->chrome & EV_CHROME_RAISE_TOOLBAR) != 0) && !presentation;
+  sidebar = (priv->chrome & EV_CHROME_SIDEBAR) != 0 && priv->document && !presentation;
+
+  set_widget_visibility (priv->toolbar, toolbar);
+  set_widget_visibility (priv->sidebar, sidebar);
+
+  if (toolbar && ev_document_model_get_fullscreen (priv->model))
+    ev_window_fullscreen_show_toolbar (window);
+}
+
+static void
+update_chrome_flag (EvWindow *window, EvChrome flag, gboolean active) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+
+  if (active) {
+    priv->chrome |= flag;
+  } else {
+    priv->chrome &= ~flag;
+  }
+}
+
+static void
+update_sizing_buttons (EvWindow *window) {
+  GAction     *action;
+  const gchar *mode = NULL;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+
+  action = g_action_map_lookup_action (G_ACTION_MAP (window), "sizing-mode");
+
+  switch (ev_document_model_get_sizing_mode (priv->model)) {
+    case EV_SIZING_FIT_PAGE:
+      mode = "fit-page";
+      break;
+    case EV_SIZING_FIT_WIDTH:
+      mode = "fit-width";
+      break;
+    case EV_SIZING_AUTOMATIC:
+      mode = "automatic";
+      break;
+    case EV_SIZING_FREE:
+      mode = "free";
+      break;
+  }
 
-static void
-update_sizing_buttons (EvWindow *window)
-{
-	GAction     *action;
-	const gchar *mode = NULL;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-
-	action = g_action_map_lookup_action (G_ACTION_MAP (window), "sizing-mode");
-
-	switch (ev_document_model_get_sizing_mode (priv->model)) {
-	case EV_SIZING_FIT_PAGE:
-		mode = "fit-page";
-		break;
-	case EV_SIZING_FIT_WIDTH:
-		mode = "fit-width";
-		break;
-	case EV_SIZING_AUTOMATIC:
-		mode = "automatic";
-		break;
-	case EV_SIZING_FREE:
-		mode = "free";
-		break;
-	}
-
-	g_simple_action_set_state (G_SIMPLE_ACTION (action), g_variant_new_string (mode));
+  g_simple_action_set_state (G_SIMPLE_ACTION (action), g_variant_new_string (mode));
 }
 
 /**
@@ -714,1058 +709,1035 @@ update_sizing_buttons (EvWindow *window)
  *          loaded, %FALSE in other case.
  */
 gboolean
-ev_window_is_empty (const EvWindow *ev_window)
-{
-	EvWindowPrivate *priv;
+ev_window_is_empty (const EvWindow *ev_window) {
+  EvWindowPrivate *priv;
 
-	g_return_val_if_fail (EV_IS_WINDOW (ev_window), FALSE);
+  g_return_val_if_fail (EV_IS_WINDOW (ev_window), FALSE);
 
-	priv = GET_PRIVATE (EV_WINDOW (ev_window));
+  priv = GET_PRIVATE (EV_WINDOW (ev_window));
 
-	return (priv->document == NULL) &&
-		(priv->load_job == NULL);
+  return (priv->document == NULL) &&
+         (priv->load_job == NULL);
 }
 
 static void
 ev_window_set_message_area (EvWindow  *window,
-			    GtkWidget *area)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                            GtkWidget *area) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	if (priv->message_area == area)
-		return;
+  if (priv->message_area == area)
+    return;
 
-	if (priv->message_area)
-		gtk_widget_destroy (priv->message_area);
-	priv->message_area = area;
+  if (priv->message_area)
+    gtk_widget_destroy (priv->message_area);
+  priv->message_area = area;
 
-	if (!area)
-		return;
+  if (!area)
+    return;
 
-	gtk_box_pack_start (GTK_BOX (priv->main_box),
-			    priv->message_area,
-			    FALSE, FALSE, 0);
-        /* Pack the message area right after the search bar */
-        gtk_box_reorder_child (GTK_BOX (priv->main_box),
-                               priv->message_area, 2);
-	g_object_add_weak_pointer (G_OBJECT (priv->message_area),
-				   (gpointer) &(priv->message_area));
+  gtk_box_pack_start (GTK_BOX (priv->main_box),
+                      priv->message_area,
+                      FALSE, FALSE, 0);
+  /* Pack the message area right after the search bar */
+  gtk_box_reorder_child (GTK_BOX (priv->main_box),
+                         priv->message_area, 2);
+  g_object_add_weak_pointer (G_OBJECT (priv->message_area),
+                             (gpointer) & (priv->message_area));
 }
 
 static void
 ev_window_message_area_response_cb (EvMessageArea *area,
-				    gint           response_id,
-				    EvWindow      *window)
-{
-	ev_window_set_message_area (window, NULL);
+                                    gint           response_id,
+                                    EvWindow      *window) {
+  ev_window_set_message_area (window, NULL);
 }
 
 G_GNUC_PRINTF (3, 4) static void
 ev_window_error_message (EvWindow    *window,
-			 GError      *error,
-			 const gchar *format,
-			 ...)
-{
-	GtkWidget *area;
-	va_list    args;
-	gchar     *msg = NULL;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-
-	if (priv->message_area)
-		return;
-
-	va_start (args, format);
-	msg = g_strdup_vprintf (format, args);
-	va_end (args);
-	
-	area = ev_message_area_new (GTK_MESSAGE_ERROR,
-				    msg,
-				    NULL);
-	g_free (msg);
-	
-	if (error)
-		ev_message_area_set_secondary_text (EV_MESSAGE_AREA (area), error->message);
-	g_signal_connect (area, "response",
-			  G_CALLBACK (ev_window_message_area_response_cb),
-			  window);
-	gtk_widget_show (area);
-	ev_window_set_message_area (window, area);
+                         GError      *error,
+                         const gchar *format,
+                         ...) {
+  GtkWidget *area;
+  va_list    args;
+  gchar     *msg = NULL;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+
+  if (priv->message_area)
+    return;
+
+  va_start (args, format);
+  msg = g_strdup_vprintf (format, args);
+  va_end (args);
+
+  area = ev_message_area_new (GTK_MESSAGE_ERROR,
+                              msg,
+                              NULL);
+  g_free (msg);
+
+  if (error)
+    ev_message_area_set_secondary_text (EV_MESSAGE_AREA (area), error->message);
+  g_signal_connect (area, "response",
+                    G_CALLBACK (ev_window_message_area_response_cb),
+                    window);
+  gtk_widget_show (area);
+  ev_window_set_message_area (window, area);
 }
 
 G_GNUC_PRINTF (2, 3) static void
 ev_window_warning_message (EvWindow    *window,
-			   const gchar *format,
-			   ...)
-{
-	GtkWidget *area;
-	va_list    args;
-	gchar     *msg = NULL;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-
-	if (priv->message_area)
-		return;
-
-	va_start (args, format);
-	msg = g_strdup_vprintf (format, args);
-	va_end (args);
-
-	area = ev_message_area_new (GTK_MESSAGE_WARNING,
-				    msg,
-				    NULL);
-	g_free (msg);
-	
-	g_signal_connect (area, "response",
-			  G_CALLBACK (ev_window_message_area_response_cb),
-			  window);
-	gtk_widget_show (area);
-	ev_window_set_message_area (window, area);
+                           const gchar *format,
+                           ...) {
+  GtkWidget *area;
+  va_list    args;
+  gchar     *msg = NULL;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+
+  if (priv->message_area)
+    return;
+
+  va_start (args, format);
+  msg = g_strdup_vprintf (format, args);
+  va_end (args);
+
+  area = ev_message_area_new (GTK_MESSAGE_WARNING,
+                              msg,
+                              NULL);
+  g_free (msg);
+
+  g_signal_connect (area, "response",
+                    G_CALLBACK (ev_window_message_area_response_cb),
+                    window);
+  gtk_widget_show (area);
+  ev_window_set_message_area (window, area);
 }
 
 static gboolean
-show_loading_message_cb (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+show_loading_message_cb (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	priv->loading_message_timeout = 0;
-	gtk_widget_show (priv->loading_message);
+  priv->loading_message_timeout = 0;
+  gtk_widget_show (priv->loading_message);
 
-	return FALSE;
+  return FALSE;
 }
 
 static void
-ev_window_show_loading_message (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+ev_window_show_loading_message (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	if (priv->loading_message_timeout)
-		return;
-	priv->loading_message_timeout =
-		g_timeout_add_full (G_PRIORITY_LOW, 0.5, (GSourceFunc)show_loading_message_cb, window, NULL);
+  if (priv->loading_message_timeout)
+    return;
+  priv->loading_message_timeout =
+    g_timeout_add_full (G_PRIORITY_LOW, 0.5, (GSourceFunc)show_loading_message_cb, window, NULL);
 }
 
 static void
-ev_window_hide_loading_message (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+ev_window_hide_loading_message (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	if (priv->loading_message_timeout) {
-		g_source_remove (priv->loading_message_timeout);
-		priv->loading_message_timeout = 0;
-	}
+  if (priv->loading_message_timeout) {
+    g_source_remove (priv->loading_message_timeout);
+    priv->loading_message_timeout = 0;
+  }
 
-	gtk_widget_hide (priv->loading_message);
+  gtk_widget_hide (priv->loading_message);
 }
 
 typedef struct _LinkTitleData {
-	EvLink      *link;
-	const gchar *link_title;
+  EvLink      *link;
+  const gchar *link_title;
 } LinkTitleData;
 
 static gboolean
 find_link_cb (GtkTreeModel  *tree_model,
-	      GtkTreePath   *path,
-	      GtkTreeIter   *iter,
-	      LinkTitleData *data)
-{
-	EvLink *link;
-	gboolean retval = FALSE;
+              GtkTreePath   *path,
+              GtkTreeIter   *iter,
+              LinkTitleData *data) {
+  EvLink *link;
+  gboolean retval = FALSE;
 
-	gtk_tree_model_get (tree_model, iter,
-			    EV_DOCUMENT_LINKS_COLUMN_LINK, &link,
-			    -1);
-	if (!link)
-		return retval;
+  gtk_tree_model_get (tree_model, iter,
+                      EV_DOCUMENT_LINKS_COLUMN_LINK, &link,
+                      -1);
+  if (!link)
+    return retval;
 
-	if (ev_link_action_equal (ev_link_get_action (data->link), ev_link_get_action (link))) {
-		data->link_title = ev_link_get_title (link);
-		retval = TRUE;
-	}
+  if (ev_link_action_equal (ev_link_get_action (data->link), ev_link_get_action (link))) {
+    data->link_title = ev_link_get_title (link);
+    retval = TRUE;
+  }
 
-	g_object_unref (link);
+  g_object_unref (link);
 
-	return retval;
+  return retval;
 }
 
 static const gchar *
 ev_window_find_title_for_link (EvWindow *window,
-			       EvLink   *link)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                               EvLink   *link) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	if (EV_IS_DOCUMENT_LINKS (priv->document) &&
-	    ev_document_links_has_document_links (EV_DOCUMENT_LINKS (priv->document))) {
-		LinkTitleData data;
-		GtkTreeModel *model;
+  if (EV_IS_DOCUMENT_LINKS (priv->document) &&
+      ev_document_links_has_document_links (EV_DOCUMENT_LINKS (priv->document))) {
+    LinkTitleData data;
+    GtkTreeModel *model;
 
-		data.link = link;
-		data.link_title = NULL;
+    data.link = link;
+    data.link_title = NULL;
 
-		g_object_get (G_OBJECT (priv->sidebar_links),
-			      "model", &model,
-			      NULL);
-		if (model) {
-			gtk_tree_model_foreach (model,
-						(GtkTreeModelForeachFunc)find_link_cb,
-						&data);
+    g_object_get (G_OBJECT (priv->sidebar_links),
+                  "model", &model,
+                  NULL);
+    if (model) {
+      gtk_tree_model_foreach (model,
+                              (GtkTreeModelForeachFunc)find_link_cb,
+                              &data);
 
-			g_object_unref (model);
-		}
+      g_object_unref (model);
+    }
 
-		return data.link_title;
-	}
+    return data.link_title;
+  }
 
-	return NULL;
+  return NULL;
 }
 
 static void
-view_handle_link_cb (EvView *view, EvLink *link, EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	EvLink *new_link = NULL;
+view_handle_link_cb (EvView *view, EvLink *link, EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  EvLink *new_link = NULL;
 
-	if (!ev_link_get_title (link)) {
-		const gchar *link_title;
+  if (!ev_link_get_title (link)) {
+    const gchar *link_title;
 
-		link_title = ev_window_find_title_for_link (window, link);
-		if (link_title) {
-			new_link = ev_link_new (link_title, ev_link_get_action (link));
-		} else {
-			EvLinkAction *action;
-			EvLinkDest   *dest;
-			gchar        *page_label;
-			gchar        *title;
+    link_title = ev_window_find_title_for_link (window, link);
+    if (link_title) {
+      new_link = ev_link_new (link_title, ev_link_get_action (link));
+    } else {
+      EvLinkAction *action;
+      EvLinkDest   *dest;
+      gchar        *page_label;
+      gchar        *title;
 
-			action = ev_link_get_action (link);
-			dest = ev_link_action_get_dest (action);
-			page_label = ev_document_links_get_dest_page_label (EV_DOCUMENT_LINKS (priv->document), dest);
-			if (!page_label)
-				return;
+      action = ev_link_get_action (link);
+      dest = ev_link_action_get_dest (action);
+      page_label = ev_document_links_get_dest_page_label (EV_DOCUMENT_LINKS (priv->document), dest);
+      if (!page_label)
+        return;
 
-			title = g_strdup_printf (_("Page %s"), page_label);
-			g_free (page_label);
+      title = g_strdup_printf (_("Page %s"), page_label);
+      g_free (page_label);
 
-			new_link = ev_link_new (title, action);
-			g_free (title);
-		}
-	}
-	ev_history_add_link (priv->history, new_link ? new_link : link);
-	if (new_link)
-		g_object_unref (new_link);
+      new_link = ev_link_new (title, action);
+      g_free (title);
+    }
+  }
+  ev_history_add_link (priv->history, new_link ? new_link : link);
+  if (new_link)
+    g_object_unref (new_link);
 }
 
 static void
 view_selection_changed_cb (EvView   *view,
-			   EvWindow *window)
-{
-	ev_window_set_action_enabled (window, "copy",
-					ev_view_get_has_selection (view));
+                           EvWindow *window) {
+  ev_window_set_action_enabled (window, "copy",
+                                ev_view_get_has_selection (view));
 }
 
 static void
 view_layers_changed_cb (EvView   *view,
-			EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                        EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_sidebar_layers_update_layers_state (EV_SIDEBAR_LAYERS (priv->sidebar_layers));
+  ev_sidebar_layers_update_layers_state (EV_SIDEBAR_LAYERS (priv->sidebar_layers));
 }
 
 static void
 view_is_loading_changed_cb (EvView     *view,
-			    GParamSpec *spec,
-			    EvWindow   *window)
-{
-	if (ev_view_is_loading (view))
-		ev_window_show_loading_message (window);
-	else
-		ev_window_hide_loading_message (window);
+                            GParamSpec *spec,
+                            EvWindow   *window) {
+  if (ev_view_is_loading (view))
+    ev_window_show_loading_message (window);
+  else
+    ev_window_hide_loading_message (window);
 }
 
 static void
 view_caret_cursor_moved_cb (EvView   *view,
-			    guint     page,
-			    guint     offset,
-			    EvWindow *window)
-{
-	GVariant *position;
-	gchar    *caret_position;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                            guint     page,
+                            guint     offset,
+                            EvWindow *window) {
+  GVariant *position;
+  gchar    *caret_position;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	if (!priv->metadata)
-		return;
+  if (!priv->metadata)
+    return;
 
-	position = g_variant_new ("(uu)", page, offset);
-	caret_position = g_variant_print (position, FALSE);
-	g_variant_unref (position);
+  position = g_variant_new ("(uu)", page, offset);
+  caret_position = g_variant_print (position, FALSE);
+  g_variant_unref (position);
 
-	ev_metadata_set_string (priv->metadata, "caret-position", caret_position);
-	g_free (caret_position);
+  ev_metadata_set_string (priv->metadata, "caret-position", caret_position);
+  g_free (caret_position);
 }
 
 static void
 ev_window_page_changed_cb (EvWindow        *ev_window,
-			   gint             old_page,
-			   gint             new_page,
-			   EvDocumentModel *model)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                           gint             old_page,
+                           gint             new_page,
+                           EvDocumentModel *model) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	ev_window_update_actions_sensitivity (ev_window);
+  ev_window_update_actions_sensitivity (ev_window);
 
-	if (priv->metadata && !ev_window_is_empty (ev_window))
-		ev_metadata_set_int (priv->metadata, "page", new_page);
+  if (priv->metadata && !ev_window_is_empty (ev_window))
+    ev_metadata_set_int (priv->metadata, "page", new_page);
 }
 
 static const gchar *
-ev_window_sidebar_get_current_page_id (EvWindow *ev_window)
-{
-	GtkWidget   *current_page;
-	const gchar *id;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+ev_window_sidebar_get_current_page_id (EvWindow *ev_window) {
+  GtkWidget   *current_page;
+  const gchar *id;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	g_object_get (priv->sidebar,
-		      "current_page", &current_page,
-		      NULL);
+  g_object_get (priv->sidebar,
+                "current_page", &current_page,
+                NULL);
 
-	if (current_page == priv->sidebar_links) {
-		id = LINKS_SIDEBAR_ID;
-	} else if (current_page == priv->sidebar_thumbs) {
-		id = THUMBNAILS_SIDEBAR_ID;
-	} else if (current_page == priv->sidebar_attachments) {
-		id = ATTACHMENTS_SIDEBAR_ID;
-	} else if (current_page == priv->sidebar_layers) {
-		id = LAYERS_SIDEBAR_ID;
-	} else if (current_page == priv->sidebar_annots) {
-		id = ANNOTS_SIDEBAR_ID;
-	} else if (current_page == priv->sidebar_bookmarks) {
-		id = BOOKMARKS_SIDEBAR_ID;
-	} else {
-		g_assert_not_reached();
-	}
+  if (current_page == priv->sidebar_links) {
+    id = LINKS_SIDEBAR_ID;
+  } else if (current_page == priv->sidebar_thumbs) {
+    id = THUMBNAILS_SIDEBAR_ID;
+  } else if (current_page == priv->sidebar_attachments) {
+    id = ATTACHMENTS_SIDEBAR_ID;
+  } else if (current_page == priv->sidebar_layers) {
+    id = LAYERS_SIDEBAR_ID;
+  } else if (current_page == priv->sidebar_annots) {
+    id = ANNOTS_SIDEBAR_ID;
+  } else if (current_page == priv->sidebar_bookmarks) {
+    id = BOOKMARKS_SIDEBAR_ID;
+  } else {
+    g_assert_not_reached();
+  }
 
-	g_object_unref (current_page);
+  g_object_unref (current_page);
 
-	return id;
+  return id;
 }
 
 static void
 ev_window_sidebar_set_current_page (EvWindow    *window,
-				    const gchar *page_id)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	EvDocument *document = priv->document;
-	EvSidebar  *sidebar = EV_SIDEBAR (priv->sidebar);
-	GtkWidget  *links = priv->sidebar_links;
-	GtkWidget  *thumbs = priv->sidebar_thumbs;
-	GtkWidget  *attachments = priv->sidebar_attachments;
-	GtkWidget  *annots = priv->sidebar_annots;
-	GtkWidget  *layers = priv->sidebar_layers;
-	GtkWidget  *bookmarks = priv->sidebar_bookmarks;
-
-	if (strcmp (page_id, LINKS_SIDEBAR_ID) == 0 &&
-	    ev_sidebar_page_support_document (EV_SIDEBAR_PAGE (links), document)) {
-		ev_sidebar_set_page (sidebar, links);
-	} else if (strcmp (page_id, THUMBNAILS_SIDEBAR_ID) == 0 &&
-		   ev_sidebar_page_support_document (EV_SIDEBAR_PAGE (thumbs), document)) {
-		ev_sidebar_set_page (sidebar, thumbs);
-	} else if (strcmp (page_id, ATTACHMENTS_SIDEBAR_ID) == 0 &&
-		   ev_sidebar_page_support_document (EV_SIDEBAR_PAGE (attachments), document)) {
-		ev_sidebar_set_page (sidebar, attachments);
-	} else if (strcmp (page_id, LAYERS_SIDEBAR_ID) == 0 &&
-		   ev_sidebar_page_support_document (EV_SIDEBAR_PAGE (layers), document)) {
-		ev_sidebar_set_page (sidebar, layers);
-	} else if (strcmp (page_id, ANNOTS_SIDEBAR_ID) == 0 &&
-		   ev_sidebar_page_support_document (EV_SIDEBAR_PAGE (annots), document)) {
-		ev_sidebar_set_page (sidebar, annots);
-	} else if (strcmp (page_id, BOOKMARKS_SIDEBAR_ID) == 0 &&
-		   ev_sidebar_page_support_document (EV_SIDEBAR_PAGE (bookmarks), document)) {
-		ev_sidebar_set_page (sidebar, bookmarks);
-	} else {
-		/* setup thumbnails by default */
-		ev_sidebar_set_page (sidebar, thumbs);
-	}
-}
-
-static void
-update_document_mode (EvWindow *window, EvDocumentMode mode)
-{
-	if (mode == EV_DOCUMENT_MODE_PRESENTATION) {
-		ev_window_run_presentation (window);
-	}
-	else if (mode == EV_DOCUMENT_MODE_FULL_SCREEN) {
-		ev_window_run_fullscreen (window);
-	}
-}
+                                    const gchar *page_id) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  EvDocument *document = priv->document;
+  EvSidebar  *sidebar = EV_SIDEBAR (priv->sidebar);
+  GtkWidget  *links = priv->sidebar_links;
+  GtkWidget  *thumbs = priv->sidebar_thumbs;
+  GtkWidget  *attachments = priv->sidebar_attachments;
+  GtkWidget  *annots = priv->sidebar_annots;
+  GtkWidget  *layers = priv->sidebar_layers;
+  GtkWidget  *bookmarks = priv->sidebar_bookmarks;
+
+  if (strcmp (page_id, LINKS_SIDEBAR_ID) == 0 &&
+      ev_sidebar_page_support_document (EV_SIDEBAR_PAGE (links), document)) {
+    ev_sidebar_set_page (sidebar, links);
+  } else if (strcmp (page_id, THUMBNAILS_SIDEBAR_ID) == 0 &&
+             ev_sidebar_page_support_document (EV_SIDEBAR_PAGE (thumbs), document)) {
+    ev_sidebar_set_page (sidebar, thumbs);
+  } else if (strcmp (page_id, ATTACHMENTS_SIDEBAR_ID) == 0 &&
+             ev_sidebar_page_support_document (EV_SIDEBAR_PAGE (attachments), document)) {
+    ev_sidebar_set_page (sidebar, attachments);
+  } else if (strcmp (page_id, LAYERS_SIDEBAR_ID) == 0 &&
+             ev_sidebar_page_support_document (EV_SIDEBAR_PAGE (layers), document)) {
+    ev_sidebar_set_page (sidebar, layers);
+  } else if (strcmp (page_id, ANNOTS_SIDEBAR_ID) == 0 &&
+             ev_sidebar_page_support_document (EV_SIDEBAR_PAGE (annots), document)) {
+    ev_sidebar_set_page (sidebar, annots);
+  } else if (strcmp (page_id, BOOKMARKS_SIDEBAR_ID) == 0 &&
+             ev_sidebar_page_support_document (EV_SIDEBAR_PAGE (bookmarks), document)) {
+    ev_sidebar_set_page (sidebar, bookmarks);
+  } else {
+    /* setup thumbnails by default */
+    ev_sidebar_set_page (sidebar, thumbs);
+  }
+}
+
+static void
+update_document_mode (EvWindow *window, EvDocumentMode mode) {
+  if (mode == EV_DOCUMENT_MODE_PRESENTATION) {
+    ev_window_run_presentation (window);
+  } else if (mode == EV_DOCUMENT_MODE_FULL_SCREEN) {
+    ev_window_run_fullscreen (window);
+  }
+}
+
+static void
+ev_window_init_metadata_with_default_values (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  GSettings  *settings = priv->default_settings;
+  EvMetadata *metadata = priv->metadata;
+
+  /* Chrome */
+  if (!ev_metadata_has_key (metadata, "sidebar_visibility")) {
+    ev_metadata_set_boolean (metadata, "sidebar_visibility",
+                             g_settings_get_boolean (settings, "show-sidebar"));
+  }
+
+  /* Sidebar */
+  if (!ev_metadata_has_key (metadata, "sidebar_size")) {
+    ev_metadata_set_int (metadata, "sidebar_size",
+                         g_settings_get_int (settings, "sidebar-size"));
+  }
+  if (!ev_metadata_has_key (metadata, "sidebar_page")) {
+    gchar *sidebar_page_id = g_settings_get_string (settings, "sidebar-page");
+
+    ev_metadata_set_string (metadata, "sidebar_page", sidebar_page_id);
+    g_free (sidebar_page_id);
+  }
+
+  /* Document model */
+  if (!ev_metadata_has_key (metadata, "continuous")) {
+    ev_metadata_set_boolean (metadata, "continuous",
+                             g_settings_get_boolean (settings, "continuous"));
+  }
+  if (!ev_metadata_has_key (metadata, "dual-page")) {
+    ev_metadata_set_boolean (metadata, "dual-page",
+                             g_settings_get_boolean (settings, "dual-page"));
+  }
+  if (!ev_metadata_has_key (metadata, "dual-page-odd-left")) {
+    ev_metadata_set_boolean (metadata, "dual-page-odd-left",
+                             g_settings_get_boolean (settings, "dual-page-odd-left"));
+  }
+  if (!ev_metadata_has_key (metadata, "rtl")) {
+    ev_metadata_set_boolean (metadata, "rtl",
+                             gtk_widget_get_default_direction () == GTK_TEXT_DIR_RTL ? TRUE : FALSE);
+  }
+  if (!ev_metadata_has_key (metadata, "inverted-colors")) {
+    ev_metadata_set_boolean (metadata, "inverted-colors",
+                             g_settings_get_boolean (settings, "inverted-colors"));
+  }
+  if (!ev_metadata_has_key (metadata, "sizing_mode")) {
+    EvSizingMode mode = g_settings_get_enum (settings, "sizing-mode");
+    GEnumValue *enum_value = g_enum_get_value (g_type_class_peek (EV_TYPE_SIZING_MODE), mode);
+
+    ev_metadata_set_string (metadata, "sizing_mode", enum_value->value_nick);
+  }
+
+  if (!ev_metadata_has_key (metadata, "zoom")) {
+    ev_metadata_set_double (metadata, "zoom",
+                            g_settings_get_double (settings, "zoom"));
+  }
+
+  if (!ev_metadata_has_key (metadata, "fullscreen")) {
+    ev_metadata_set_boolean (metadata, "fullscreen",
+                             g_settings_get_boolean (settings, "fullscreen"));
+  }
+
+  if (!ev_metadata_has_key (metadata, "creator-mode")) {
+    printf("Set the meta data? \n");
+    ev_metadata_set_boolean (metadata, "creator-mode",
+                             g_settings_get_boolean (settings, "creator-mode"));
+  }/*else
+    {
+        gboolean val;
+        ev_metadata_get_boolean (metadata, "creator-mode",&val);
+        printf("current vaL %d ? \n",val);
+
+    }*/
+}
+
+static void
+setup_chrome_from_metadata (EvWindow *window) {
+  gboolean show_toolbar;
+  gboolean show_sidebar;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+
+  if (!priv->metadata)
+    return;
+
+  if (ev_metadata_get_boolean (priv->metadata, "show_toolbar", &show_toolbar))
+    update_chrome_flag (window, EV_CHROME_TOOLBAR, show_toolbar);
+  if (ev_metadata_get_boolean (priv->metadata, "sidebar_visibility", &show_sidebar))
+    update_chrome_flag (window, EV_CHROME_SIDEBAR, show_sidebar);
+  update_chrome_visibility (window);
+}
+
+static void
+setup_sidebar_from_metadata (EvWindow *window) {
+  gchar *page_id;
+  gint   sidebar_size;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+
+  if (!priv->metadata)
+    return;
+
+  if (ev_metadata_get_int (priv->metadata, "sidebar_size", &sidebar_size))
+    gtk_paned_set_position (GTK_PANED (priv->hpaned), sidebar_size);
+
+  if (ev_metadata_get_string (priv->metadata, "sidebar_page", &page_id))
+    ev_window_sidebar_set_current_page (window, page_id);
+}
+
+static void
+setup_model_from_metadata (EvWindow *window) {
+  gint     page;
+  gchar   *sizing_mode;
+  gdouble  zoom;
+  gint     rotation;
+  gboolean inverted_colors = FALSE;
+  gboolean continuous = FALSE;
+  gboolean dual_page = FALSE;
+  gboolean dual_page_odd_left = FALSE;
+  gboolean rtl = FALSE;
+  gboolean fullscreen = FALSE;
+  gboolean creatormode = FALSE;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+
+  if (!priv->metadata)
+    return;
+  if (ev_metadata_get_boolean (priv->metadata, "creator-mode", &creatormode)) {
+    ev_document_model_set_creator_mode( priv->model, creatormode);
+  }
+  /* Current page */
+  if (!priv->dest &&
+      ev_metadata_get_int (priv->metadata, "page", &page)) {
+    ev_document_model_set_page (priv->model, page);
+  }
+
+  /* Sizing mode */
+  if (ev_metadata_get_string (priv->metadata, "sizing_mode", &sizing_mode)) {
+    GEnumValue *enum_value;
+
+    enum_value = g_enum_get_value_by_nick
+                 (g_type_class_peek (EV_TYPE_SIZING_MODE), sizing_mode);
+    ev_document_model_set_sizing_mode (priv->model, enum_value->value);
+  }
+
+  /* Zoom */
+  if (ev_document_model_get_sizing_mode (priv->model) == EV_SIZING_FREE) {
+    if (ev_metadata_get_double (priv->metadata, "zoom", &zoom)) {
+      zoom *= ev_document_misc_get_widget_dpi  (GTK_WIDGET (window)) / 72.0;
+      ev_document_model_set_scale (priv->model, zoom);
+    }
+  }
+
+  /* Rotation */
+  if (ev_metadata_get_int (priv->metadata, "rotation", &rotation)) {
+    switch (rotation) {
+      case 90:
+        rotation = 90;
+        break;
+      case 180:
+        rotation = 180;
+        break;
+      case 270:
+        rotation = 270;
+        break;
+      default:
+        rotation = 0;
+        break;
+    }
+    ev_document_model_set_rotation (priv->model, rotation);
+  }
 
-static void
-ev_window_init_metadata_with_default_values (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	GSettings  *settings = priv->default_settings;
-	EvMetadata *metadata = priv->metadata;
-
-	/* Chrome */
-	if (!ev_metadata_has_key (metadata, "sidebar_visibility")) {
-		ev_metadata_set_boolean (metadata, "sidebar_visibility",
-					 g_settings_get_boolean (settings, "show-sidebar"));
-	}
-
-	/* Sidebar */
-	if (!ev_metadata_has_key (metadata, "sidebar_size")) {
-		ev_metadata_set_int (metadata, "sidebar_size",
-				     g_settings_get_int (settings, "sidebar-size"));
-	}
-	if (!ev_metadata_has_key (metadata, "sidebar_page")) {
-		gchar *sidebar_page_id = g_settings_get_string (settings, "sidebar-page");
-
-		ev_metadata_set_string (metadata, "sidebar_page", sidebar_page_id);
-		g_free (sidebar_page_id);
-	}
-
-	/* Document model */
-	if (!ev_metadata_has_key (metadata, "continuous")) {
-		ev_metadata_set_boolean (metadata, "continuous",
-					 g_settings_get_boolean (settings, "continuous"));
-	}
-	if (!ev_metadata_has_key (metadata, "dual-page")) {
-		ev_metadata_set_boolean (metadata, "dual-page",
-					 g_settings_get_boolean (settings, "dual-page"));
-	}
-	if (!ev_metadata_has_key (metadata, "dual-page-odd-left")) {
-		ev_metadata_set_boolean (metadata, "dual-page-odd-left",
-					 g_settings_get_boolean (settings, "dual-page-odd-left"));
-	}
-	if (!ev_metadata_has_key (metadata, "rtl")) {
-		ev_metadata_set_boolean (metadata, "rtl",
-					 gtk_widget_get_default_direction () == GTK_TEXT_DIR_RTL ? TRUE : FALSE);
-	}
-	if (!ev_metadata_has_key (metadata, "inverted-colors")) {
-		ev_metadata_set_boolean (metadata, "inverted-colors",
-					 g_settings_get_boolean (settings, "inverted-colors"));
-	}
-	if (!ev_metadata_has_key (metadata, "sizing_mode")) {
-		EvSizingMode mode = g_settings_get_enum (settings, "sizing-mode");
-		GEnumValue *enum_value = g_enum_get_value (g_type_class_peek (EV_TYPE_SIZING_MODE), mode);
-
-		ev_metadata_set_string (metadata, "sizing_mode", enum_value->value_nick);
-	}
-
-	if (!ev_metadata_has_key (metadata, "zoom")) {
-		ev_metadata_set_double (metadata, "zoom",
-					g_settings_get_double (settings, "zoom"));
-	}
-
-	if (!ev_metadata_has_key (metadata, "fullscreen")) {
-		ev_metadata_set_boolean (metadata, "fullscreen",
-					 g_settings_get_boolean (settings, "fullscreen"));
-	}
-}
-
-static void
-setup_chrome_from_metadata (EvWindow *window)
-{
-	gboolean show_toolbar;
-	gboolean show_sidebar;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+  /* Inverted Colors */
+  if (ev_metadata_get_boolean (priv->metadata, "inverted-colors", &inverted_colors)) {
+    ev_document_model_set_inverted_colors (priv->model, inverted_colors);
+  }
 
-	if (!priv->metadata)
-		return;
+  /* Continuous */
+  if (ev_metadata_get_boolean (priv->metadata, "continuous", &continuous)) {
+    ev_document_model_set_continuous (priv->model, continuous);
+  }
+
+  /* Dual page */
+  if (ev_metadata_get_boolean (priv->metadata, "dual-page", &dual_page)) {
+    ev_document_model_set_dual_page (priv->model, dual_page);
+  }
+
+  /* Dual page odd pages left */
+  if (ev_metadata_get_boolean (priv->metadata, "dual-page-odd-left", &dual_page_odd_left)) {
+    ev_document_model_set_dual_page_odd_pages_left (priv->model, dual_page_odd_left);
+  }
+
+  /* Right to left document */
+  if (ev_metadata_get_boolean (priv->metadata, "rtl", &rtl)) {
+    ev_document_model_set_rtl (priv->model, rtl);
+  }
+
+  /* Fullscreen */
+  if (ev_metadata_get_boolean (priv->metadata, "fullscreen", &fullscreen)) {
+    if (fullscreen)
+      ev_window_run_fullscreen (window);
+  }
 
-	if (ev_metadata_get_boolean (priv->metadata, "show_toolbar", &show_toolbar))
-		update_chrome_flag (window, EV_CHROME_TOOLBAR, show_toolbar);
-	if (ev_metadata_get_boolean (priv->metadata, "sidebar_visibility", &show_sidebar))
-		update_chrome_flag (window, EV_CHROME_SIDEBAR, show_sidebar);
-	update_chrome_visibility (window);
-}
-
-static void
-setup_sidebar_from_metadata (EvWindow *window)
-{
-	gchar *page_id;
-	gint   sidebar_size;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	if (!priv->metadata)
-		return;
 
-	if (ev_metadata_get_int (priv->metadata, "sidebar_size", &sidebar_size))
-		gtk_paned_set_position (GTK_PANED (priv->hpaned), sidebar_size);
 
-	if (ev_metadata_get_string (priv->metadata, "sidebar_page", &page_id))
-		ev_window_sidebar_set_current_page (window, page_id);
-}
 
-static void
-setup_model_from_metadata (EvWindow *window)
-{
-	gint     page;
-	gchar   *sizing_mode;
-	gdouble  zoom;
-	gint     rotation;
-	gboolean inverted_colors = FALSE;
-	gboolean continuous = FALSE;
-	gboolean dual_page = FALSE;
-	gboolean dual_page_odd_left = FALSE;
-	gboolean rtl = FALSE;
-	gboolean fullscreen = FALSE;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-
-	if (!priv->metadata)
-		return;
-
-	/* Current page */
-	if (!priv->dest &&
-	    ev_metadata_get_int (priv->metadata, "page", &page)) {
-		ev_document_model_set_page (priv->model, page);
-	}
-
-	/* Sizing mode */
-	if (ev_metadata_get_string (priv->metadata, "sizing_mode", &sizing_mode)) {
-		GEnumValue *enum_value;
-
-		enum_value = g_enum_get_value_by_nick
-			(g_type_class_peek (EV_TYPE_SIZING_MODE), sizing_mode);
-		ev_document_model_set_sizing_mode (priv->model, enum_value->value);
-	}
-
-	/* Zoom */
-	if (ev_document_model_get_sizing_mode (priv->model) == EV_SIZING_FREE) {
-		if (ev_metadata_get_double (priv->metadata, "zoom", &zoom)) {
-			zoom *= ev_document_misc_get_widget_dpi  (GTK_WIDGET (window)) / 72.0;
-			ev_document_model_set_scale (priv->model, zoom);
-		}
-	}
-
-	/* Rotation */
-	if (ev_metadata_get_int (priv->metadata, "rotation", &rotation)) {
-		switch (rotation) {
-		case 90:
-			rotation = 90;
-			break;
-		case 180:
-			rotation = 180;
-			break;
-		case 270:
-			rotation = 270;
-			break;
-		default:
-			rotation = 0;
-			break;
-		}
-		ev_document_model_set_rotation (priv->model, rotation);
-	}
-
-	/* Inverted Colors */
-	if (ev_metadata_get_boolean (priv->metadata, "inverted-colors", &inverted_colors)) {
-		ev_document_model_set_inverted_colors (priv->model, inverted_colors);
-	}
-
-	/* Continuous */
-	if (ev_metadata_get_boolean (priv->metadata, "continuous", &continuous)) {
-		ev_document_model_set_continuous (priv->model, continuous);
-	}
-
-	/* Dual page */
-	if (ev_metadata_get_boolean (priv->metadata, "dual-page", &dual_page)) {
-		ev_document_model_set_dual_page (priv->model, dual_page);
-	}
-
-	/* Dual page odd pages left */
-	if (ev_metadata_get_boolean (priv->metadata, "dual-page-odd-left", &dual_page_odd_left)) {
-		ev_document_model_set_dual_page_odd_pages_left (priv->model, dual_page_odd_left);
-	}
-
-	/* Right to left document */
-	if (ev_metadata_get_boolean (priv->metadata, "rtl", &rtl)) {
-		ev_document_model_set_rtl (priv->model, rtl);
-	}
-
-	/* Fullscreen */
-	if (ev_metadata_get_boolean (priv->metadata, "fullscreen", &fullscreen)) {
-		if (fullscreen)
-			ev_window_run_fullscreen (window);
-	}
 }
 
 static void
 monitor_get_dimesions (EvWindow *ev_window,
                        gint     *width,
-                       gint     *height)
-{
-	GdkDisplay  *display;
-	GdkWindow   *gdk_window;
-	GdkMonitor  *monitor;
-	GdkRectangle geometry;
-
-	*width = 0;
-	*height = 0;
-
-	display = gtk_widget_get_display (GTK_WIDGET (ev_window));
-	gdk_window = gtk_widget_get_window (GTK_WIDGET (ev_window));
-
-	if (gdk_window) {
-		monitor = gdk_display_get_monitor_at_window (display,
-							     gdk_window);
-		gdk_monitor_get_workarea (monitor, &geometry);
-		*width = geometry.width;
-		*height = geometry.height;
-	}
-}
-
-static void
-setup_document_from_metadata (EvWindow *window)
-{
-	gint    page, n_pages;
-	gint    width;
-	gint    height;
-	gdouble width_ratio;
-	gdouble height_ratio;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-
-	if (!priv->metadata)
-		return;
-
-	setup_sidebar_from_metadata (window);
-
-	/* Make sure to not open a document on the last page,
-	 * since closing it on the last page most likely means the
-	 * user was finished reading the document. In that case, reopening should
-	 * show the first page. */
-	page = ev_document_model_get_page (priv->model);
-	n_pages = ev_document_get_n_pages (priv->document);
-	if (page == n_pages - 1)
-		ev_document_model_set_page (priv->model, 0);
-
-	if (ev_metadata_get_int (priv->metadata, "window_width", &width) &&
-	    ev_metadata_get_int (priv->metadata, "window_height", &height))
-		return; /* size was already set in setup_size_from_metadata */
-
-	/* Following code is intended to be executed first time a document is opened
-	 * in Evince, that's why is located *after* the previous return that exits
-	 * when evince metadata for window_width{height} already exists. */
-	if (n_pages == 1)
-		ev_document_model_set_dual_page (priv->model, FALSE);
-	else if (n_pages == 2)
-		ev_document_model_set_dual_page_odd_pages_left (priv->model, TRUE);
-
-	g_settings_get (priv->default_settings, "window-ratio", "(dd)", &width_ratio, &height_ratio);
-	if (width_ratio > 0. && height_ratio > 0.) {
-		gdouble    document_width;
-		gdouble    document_height;
-		gint       request_width;
-		gint       request_height;
-		gint       monitor_width;
-		gint       monitor_height;
-
-		ev_document_get_max_page_size (priv->document,
-					       &document_width, &document_height);
-
-		request_width = (gint)(width_ratio * document_width + 0.5);
-		request_height = (gint)(height_ratio * document_height + 0.5);
-
-		monitor_get_dimesions (window, &monitor_width, &monitor_height);
-		if (monitor_width > 0 && monitor_height > 0) {
-			request_width = MIN (request_width, monitor_width);
-			request_height = MIN (request_height, monitor_height);
-		}
-
-		if (request_width > 0 && request_height > 0) {
-			gtk_window_resize (GTK_WINDOW (window),
-					   request_width,
-					   request_height);
-		}
-	}
-}
-
-static void
-setup_size_from_metadata (EvWindow *window)
-{
-	gint     width;
-	gint     height;
-	gboolean maximized;
-	gint     x;
-	gint     y;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-
-	if (!priv->metadata)
-		return;
+                       gint     *height) {
+  GdkDisplay  *display;
+  GdkWindow   *gdk_window;
+  GdkMonitor  *monitor;
+  GdkRectangle geometry;
+
+  *width = 0;
+  *height = 0;
+
+  display = gtk_widget_get_display (GTK_WIDGET (ev_window));
+  gdk_window = gtk_widget_get_window (GTK_WIDGET (ev_window));
+
+  if (gdk_window) {
+    monitor = gdk_display_get_monitor_at_window (display,
+                                                 gdk_window);
+    gdk_monitor_get_workarea (monitor, &geometry);
+    *width = geometry.width;
+    *height = geometry.height;
+  }
+}
+
+static void
+setup_document_from_metadata (EvWindow *window) {
+  gint    page, n_pages;
+  gint    width;
+  gint    height;
+  gdouble width_ratio;
+  gdouble height_ratio;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+
+  if (!priv->metadata)
+    return;
+
+  setup_sidebar_from_metadata (window);
+
+  /* Make sure to not open a document on the last page,
+   * since closing it on the last page most likely means the
+   * user was finished reading the document. In that case, reopening should
+   * show the first page. */
+  page = ev_document_model_get_page (priv->model);
+  n_pages = ev_document_get_n_pages (priv->document);
+  if (page == n_pages - 1 && !ev_document_model_get_creator_mode(priv->model))
+    ev_document_model_set_page (priv->model, 0);
+
+  if (ev_metadata_get_int (priv->metadata, "window_width", &width) &&
+      ev_metadata_get_int (priv->metadata, "window_height", &height))
+    return; /* size was already set in setup_size_from_metadata */
+
+  /* Following code is intended to be executed first time a document is opened
+   * in Evince, that's why is located *after* the previous return that exits
+   * when evince metadata for window_width{height} already exists. */
+  if (n_pages == 1)
+    ev_document_model_set_dual_page (priv->model, FALSE);
+  else if (n_pages == 2)
+    ev_document_model_set_dual_page_odd_pages_left (priv->model, TRUE);
+
+  g_settings_get (priv->default_settings, "window-ratio", "(dd)", &width_ratio, &height_ratio);
+  if (width_ratio > 0. && height_ratio > 0.) {
+    gdouble    document_width;
+    gdouble    document_height;
+    gint       request_width;
+    gint       request_height;
+    gint       monitor_width;
+    gint       monitor_height;
+
+    ev_document_get_max_page_size (priv->document,
+                                   &document_width, &document_height);
+
+    request_width = (gint)(width_ratio * document_width + 0.5);
+    request_height = (gint)(height_ratio * document_height + 0.5);
+
+    monitor_get_dimesions (window, &monitor_width, &monitor_height);
+    if (monitor_width > 0 && monitor_height > 0) {
+      request_width = MIN (request_width, monitor_width);
+      request_height = MIN (request_height, monitor_height);
+    }
+
+    if (request_width > 0 && request_height > 0) {
+      gtk_window_resize (GTK_WINDOW (window),
+                         request_width,
+                         request_height);
+    }
+  }
+}
+
+static void
+setup_size_from_metadata (EvWindow *window) {
+  gint     width;
+  gint     height;
+  gboolean maximized;
+  gint     x;
+  gint     y;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+
+  if (!priv->metadata)
+    return;
+
+  if (ev_metadata_get_int (priv->metadata, "window_x", &x) &&
+      ev_metadata_get_int (priv->metadata, "window_y", &y)) {
+    gtk_window_move (GTK_WINDOW (window), x, y);
+  }
+
+  if (ev_metadata_get_int (priv->metadata, "window_width", &width) &&
+      ev_metadata_get_int (priv->metadata, "window_height", &height)) {
+    gtk_window_resize (GTK_WINDOW (window), width, height);
+  }
+
+  if (ev_metadata_get_boolean (priv->metadata, "window_maximized", &maximized)) {
+    if (maximized) {
+      gtk_window_maximize (GTK_WINDOW (window));
+    } else {
+      gtk_window_unmaximize (GTK_WINDOW (window));
+    }
+  }
+}
+
+static void
+setup_view_from_metadata (EvWindow *window) {
+  gboolean presentation;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+
+  if (!priv->metadata)
+    return;
+
+  /* Presentation */
+  if (ev_metadata_get_boolean (priv->metadata, "presentation", &presentation)) {
+    if (presentation)
+      ev_window_run_presentation (window);
+  }
 
-	if (ev_metadata_get_int (priv->metadata, "window_x", &x) &&
-	    ev_metadata_get_int (priv->metadata, "window_y", &y)) {
-		gtk_window_move (GTK_WINDOW (window), x, y);
-	}
+  /* Caret navigation mode */
+  if (ev_view_supports_caret_navigation (EV_VIEW (priv->view))) {
+    gboolean caret_navigation;
+    gchar   *caret_position;
+
+    if (ev_metadata_get_string (priv->metadata, "caret-position", &caret_position)) {
+      GVariant *position;
+
+      position = g_variant_parse (G_VARIANT_TYPE ("(uu)"), caret_position, NULL, NULL, NULL);
+      if (position) {
+        guint page, offset;
 
-        if (ev_metadata_get_int (priv->metadata, "window_width", &width) &&
-	    ev_metadata_get_int (priv->metadata, "window_height", &height)) {
-		gtk_window_resize (GTK_WINDOW (window), width, height);
-	}
+        g_variant_get (position, "(uu)", &page, &offset);
+        g_variant_unref (position);
+
+        ev_view_set_caret_cursor_position (EV_VIEW (priv->view),
+                                           page, offset);
+      }
+    }
 
-	if (ev_metadata_get_boolean (priv->metadata, "window_maximized", &maximized)) {
-		if (maximized) {
-			gtk_window_maximize (GTK_WINDOW (window));
-		} else {
-			gtk_window_unmaximize (GTK_WINDOW (window));
-		}
-	}
-}
-
-static void
-setup_view_from_metadata (EvWindow *window)
-{
-	gboolean presentation;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-
-	if (!priv->metadata)
-		return;
-
-	/* Presentation */
-	if (ev_metadata_get_boolean (priv->metadata, "presentation", &presentation)) {
-		if (presentation)
-			ev_window_run_presentation (window);
-	}
-
-	/* Caret navigation mode */
-	if (ev_view_supports_caret_navigation (EV_VIEW (priv->view))) {
-		gboolean caret_navigation;
-		gchar   *caret_position;
-
-		if (ev_metadata_get_string (priv->metadata, "caret-position", &caret_position)) {
-			GVariant *position;
-
-			position = g_variant_parse (G_VARIANT_TYPE ("(uu)"), caret_position, NULL, NULL, NULL);
-			if (position) {
-				guint page, offset;
-
-				g_variant_get (position, "(uu)", &page, &offset);
-				g_variant_unref (position);
-
-				ev_view_set_caret_cursor_position (EV_VIEW (priv->view),
-								   page, offset);
-			}
-		}
-
-		if (ev_metadata_get_boolean (priv->metadata, "caret-navigation", &caret_navigation))
-			ev_view_set_caret_navigation_enabled (EV_VIEW (priv->view), caret_navigation);
-	}
+    if (ev_metadata_get_boolean (priv->metadata, "caret-navigation", &caret_navigation))
+      ev_view_set_caret_navigation_enabled (EV_VIEW (priv->view), caret_navigation);
+  }
 }
 
 static void
 page_cache_size_changed (GSettings *settings,
-			 gchar     *key,
-			 EvWindow  *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	guint page_cache_mb;
+                         gchar     *key,
+                         EvWindow  *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  guint page_cache_mb;
 
-	page_cache_mb = g_settings_get_uint (settings, GS_PAGE_CACHE_SIZE);
-	ev_view_set_page_cache_size (EV_VIEW (priv->view),
-				     page_cache_mb * 1024 * 1024);
+  page_cache_mb = g_settings_get_uint (settings, GS_PAGE_CACHE_SIZE);
+  ev_view_set_page_cache_size (EV_VIEW (priv->view),
+                               page_cache_mb * 1024 * 1024);
 }
 
 static void
 allow_links_change_zoom_changed (GSettings *settings,
-			 gchar     *key,
-			 EvWindow  *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gboolean allow_links_change_zoom = g_settings_get_boolean (settings, GS_ALLOW_LINKS_CHANGE_ZOOM);
-
-	ev_view_set_allow_links_change_zoom (EV_VIEW (priv->view), allow_links_change_zoom);
-}
-
-static void
-ev_window_setup_default (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	EvDocumentModel *model = priv->model;
-	GSettings       *settings = priv->default_settings;
-
-	/* Chrome */
-	update_chrome_flag (ev_window, EV_CHROME_SIDEBAR,
-			    g_settings_get_boolean (settings, "show-sidebar"));
-	update_chrome_visibility (ev_window);
-
-	/* Sidebar */
-	gtk_paned_set_position (GTK_PANED (priv->hpaned),
-				g_settings_get_int (settings, "sidebar-size"));
-
-	/* Document model */
-	ev_document_model_set_continuous (model, g_settings_get_boolean (settings, "continuous"));
-	ev_document_model_set_dual_page (model, g_settings_get_boolean (settings, "dual-page"));
-	ev_document_model_set_dual_page_odd_pages_left (model, g_settings_get_boolean (settings, "dual-page-odd-left"));
-	ev_document_model_set_rtl (model, gtk_widget_get_default_direction () == GTK_TEXT_DIR_RTL ? TRUE : FALSE);
-	ev_document_model_set_inverted_colors (model, g_settings_get_boolean (settings, "inverted-colors"));
-	ev_document_model_set_sizing_mode (model, g_settings_get_enum (settings, "sizing-mode"));
-	if (ev_document_model_get_sizing_mode (model) == EV_SIZING_FREE)
-		ev_document_model_set_scale (model, g_settings_get_double (settings, "zoom"));
-
-	g_simple_action_set_state (
-		G_SIMPLE_ACTION (g_action_map_lookup_action (G_ACTION_MAP (ev_window),
-		                                             "enable-spellchecking")),
-		g_variant_new_boolean (
+                                 gchar     *key,
+                                 EvWindow  *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gboolean allow_links_change_zoom = g_settings_get_boolean (settings, GS_ALLOW_LINKS_CHANGE_ZOOM);
+
+  ev_view_set_allow_links_change_zoom (EV_VIEW (priv->view), allow_links_change_zoom);
+}
+
+static void
+ev_window_setup_default (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  EvDocumentModel *model = priv->model;
+  GSettings       *settings = priv->default_settings;
+
+  /* Chrome */
+  update_chrome_flag (ev_window, EV_CHROME_SIDEBAR,
+                      g_settings_get_boolean (settings, "show-sidebar"));
+  update_chrome_visibility (ev_window);
+
+  /* Sidebar */
+  gtk_paned_set_position (GTK_PANED (priv->hpaned),
+                          g_settings_get_int (settings, "sidebar-size"));
+
+  /* Document model */
+  ev_document_model_set_continuous (model, g_settings_get_boolean (settings, "continuous"));
+  ev_document_model_set_dual_page (model, g_settings_get_boolean (settings, "dual-page"));
+  ev_document_model_set_dual_page_odd_pages_left (model, g_settings_get_boolean (settings, "dual-page-odd-left"));
+  ev_document_model_set_rtl (model, gtk_widget_get_default_direction () == GTK_TEXT_DIR_RTL ? TRUE : FALSE);
+  ev_document_model_set_inverted_colors (model, g_settings_get_boolean (settings, "inverted-colors"));
+  ev_document_model_set_sizing_mode (model, g_settings_get_enum (settings, "sizing-mode"));
+  if (ev_document_model_get_sizing_mode (model) == EV_SIZING_FREE)
+    ev_document_model_set_scale (model, g_settings_get_double (settings, "zoom"));
+
+  g_simple_action_set_state (
+    G_SIMPLE_ACTION (g_action_map_lookup_action (G_ACTION_MAP (ev_window),
+                                                 "enable-spellchecking")),
+    g_variant_new_boolean (
 #ifdef WITH_GSPELL
-		g_settings_get_boolean (settings, "enable-spellchecking")
+      g_settings_get_boolean (settings, "enable-spellchecking")
 #else
-		FALSE
+      FALSE
 #endif
-		)
-	);
-	ev_view_set_enable_spellchecking (EV_VIEW (priv->view),
-		g_settings_get_boolean (settings, "enable-spellchecking"));
+    )
+  );
+  ev_view_set_enable_spellchecking (EV_VIEW (priv->view),
+                                    g_settings_get_boolean (settings, "enable-spellchecking"));
 }
 
 static void
 override_restrictions_changed (GSettings *settings,
-			       gchar     *key,
-			       EvWindow  *ev_window)
-{
-	ev_window_update_actions_sensitivity (ev_window);
+                               gchar     *key,
+                               EvWindow  *ev_window) {
+  ev_window_update_actions_sensitivity (ev_window);
 }
 
 #ifdef HAVE_DESKTOP_SCHEMAS
 static void
 lockdown_changed (GSettings   *lockdown,
-		  const gchar *key,
-		  EvWindow    *ev_window)
-{
-	ev_window_update_actions_sensitivity (ev_window);
+                  const gchar *key,
+                  EvWindow    *ev_window) {
+  ev_window_update_actions_sensitivity (ev_window);
 }
 #endif
 
 static GSettings *
-ev_window_ensure_settings (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+ev_window_ensure_settings (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-        if (priv->settings != NULL)
-                return priv->settings;
+  if (priv->settings != NULL)
+    return priv->settings;
 
-        priv->settings = g_settings_new (GS_SCHEMA_NAME);
-        g_signal_connect (priv->settings,
-                          "changed::"GS_OVERRIDE_RESTRICTIONS,
-                          G_CALLBACK (override_restrictions_changed),
-                          ev_window);
-        g_signal_connect (priv->settings,
-			  "changed::"GS_PAGE_CACHE_SIZE,
-			  G_CALLBACK (page_cache_size_changed),
-			  ev_window);
-        g_signal_connect (priv->settings,
-			  "changed::"GS_ALLOW_LINKS_CHANGE_ZOOM,
-			  G_CALLBACK (allow_links_change_zoom_changed),
-			  ev_window);
+  priv->settings = g_settings_new (GS_SCHEMA_NAME);
+  g_signal_connect (priv->settings,
+                    "changed::"GS_OVERRIDE_RESTRICTIONS,
+                    G_CALLBACK (override_restrictions_changed),
+                    ev_window);
+  g_signal_connect (priv->settings,
+                    "changed::"GS_PAGE_CACHE_SIZE,
+                    G_CALLBACK (page_cache_size_changed),
+                    ev_window);
+  g_signal_connect (priv->settings,
+                    "changed::"GS_ALLOW_LINKS_CHANGE_ZOOM,
+                    G_CALLBACK (allow_links_change_zoom_changed),
+                    ev_window);
 
-        return priv->settings;
+  return priv->settings;
 }
 
 static gboolean
-ev_window_setup_document (EvWindow *ev_window)
-{
-	const EvDocumentInfo *info;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	EvDocument *document = priv->document;
+ev_window_setup_document (EvWindow *ev_window) {
+  const EvDocumentInfo *info;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  EvDocument *document = priv->document;
 
-	priv->setup_document_idle = 0;
+  priv->setup_document_idle = 0;
 
-	ev_window_set_page_mode (ev_window, PAGE_MODE_DOCUMENT);
-	ev_window_title_set_document (priv->title, document);
-	ev_window_title_set_filename (priv->title,
-				      priv->display_name);
+  ev_window_set_page_mode (ev_window, PAGE_MODE_DOCUMENT);
+  ev_window_title_set_document (priv->title, document);
+  ev_window_title_set_filename (priv->title,
+                                priv->display_name);
 
-        ev_window_ensure_settings (ev_window);
+  ev_window_ensure_settings (ev_window);
 
 #ifdef HAVE_DESKTOP_SCHEMAS
-	if (!priv->lockdown_settings) {
-		priv->lockdown_settings = g_settings_new (GS_LOCKDOWN_SCHEMA_NAME);
-		g_signal_connect (priv->lockdown_settings,
-				  "changed",
-				  G_CALLBACK (lockdown_changed),
-				  ev_window);
-	}
+  if (!priv->lockdown_settings) {
+    priv->lockdown_settings = g_settings_new (GS_LOCKDOWN_SCHEMA_NAME);
+    g_signal_connect (priv->lockdown_settings,
+                      "changed",
+                      G_CALLBACK (lockdown_changed),
+                      ev_window);
+  }
 #endif
 
-	ev_window_update_actions_sensitivity (ev_window);
+  ev_window_update_actions_sensitivity (ev_window);
 
-	if (priv->properties) {
-		ev_properties_dialog_set_document (EV_PROPERTIES_DIALOG (priv->properties),
-						   priv->uri,
-					           priv->document);
-	}
+  if (priv->properties) {
+    ev_properties_dialog_set_document (EV_PROPERTIES_DIALOG (priv->properties),
+                                       priv->uri,
+                                       priv->document);
+  }
 
-	info = ev_document_get_info (document);
-	update_document_mode (ev_window, info->mode);
+  info = ev_document_get_info (document);
+  update_document_mode (ev_window, info->mode);
 
-	if (priv->search_string && EV_IS_DOCUMENT_FIND (document) &&
-	    !EV_WINDOW_IS_PRESENTATION (priv)) {
-		GtkSearchEntry *entry;
+  if (priv->search_string && EV_IS_DOCUMENT_FIND (document) &&
+      !EV_WINDOW_IS_PRESENTATION (priv)) {
+    GtkSearchEntry *entry;
 
-		ev_window_show_find_bar (ev_window, FALSE);
-		entry = ev_search_box_get_entry (EV_SEARCH_BOX (priv->search_box));
-		gtk_entry_set_text (GTK_ENTRY (entry), priv->search_string);
-	}
+    ev_window_show_find_bar (ev_window, FALSE);
+    entry = ev_search_box_get_entry (EV_SEARCH_BOX (priv->search_box));
+    gtk_entry_set_text (GTK_ENTRY (entry), priv->search_string);
+  }
 
-	g_clear_pointer (&priv->search_string, g_free);
+  g_clear_pointer (&priv->search_string, g_free);
 
-	if (EV_WINDOW_IS_PRESENTATION (priv))
-		gtk_widget_grab_focus (priv->presentation_view);
-	else if (!gtk_search_bar_get_search_mode (GTK_SEARCH_BAR (priv->search_bar)))
-		gtk_widget_grab_focus (priv->view);
+  if (EV_WINDOW_IS_PRESENTATION (priv))
+    gtk_widget_grab_focus (priv->presentation_view);
+  else if (!gtk_search_bar_get_search_mode (GTK_SEARCH_BAR (priv->search_bar)))
+    gtk_widget_grab_focus (priv->view);
 
-	return FALSE;
+  return FALSE;
 }
 
 static void
-ev_window_set_document_metadata (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	const EvDocumentInfo *info;
+ev_window_set_document_metadata (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  const EvDocumentInfo *info;
 
-	if (!priv->metadata)
-		return;
+  if (!priv->metadata)
+    return;
 
-	info = ev_document_get_info (priv->document);
-	if (info->fields_mask & EV_DOCUMENT_INFO_TITLE && info->title && info->title[0] != '\0')
-		ev_metadata_set_string (priv->metadata, "title", info->title);
-	else
-		ev_metadata_set_string (priv->metadata, "title", "");
+  info = ev_document_get_info (priv->document);
+  if (info->fields_mask & EV_DOCUMENT_INFO_TITLE && info->title && info->title[0] != '\0')
+    ev_metadata_set_string (priv->metadata, "title", info->title);
+  else
+    ev_metadata_set_string (priv->metadata, "title", "");
 
-	if (info->fields_mask & EV_DOCUMENT_INFO_AUTHOR && info->author && info->author[0] != '\0')
-		ev_metadata_set_string (priv->metadata, "author", info->author);
-	else
-		ev_metadata_set_string (priv->metadata, "author", "");
+  if (info->fields_mask & EV_DOCUMENT_INFO_AUTHOR && info->author && info->author[0] != '\0')
+    ev_metadata_set_string (priv->metadata, "author", info->author);
+  else
+    ev_metadata_set_string (priv->metadata, "author", "");
 }
 
 static void
-ev_window_set_document (EvWindow *ev_window, EvDocument *document)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+ev_window_set_document (EvWindow *ev_window, EvDocument *document) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (priv->document == document)
-		return;
+  if (priv->document == document)
+    return;
 
-	if (priv->document)
-		g_object_unref (priv->document);
-	priv->document = g_object_ref (document);
+  if (priv->document)
+    g_object_unref (priv->document);
+  priv->document = g_object_ref (document);
 
-	ev_window_set_message_area (ev_window, NULL);
+  ev_window_set_message_area (ev_window, NULL);
 
-	ev_window_set_document_metadata (ev_window);
+  ev_window_set_document_metadata (ev_window);
 
-	if (ev_document_get_n_pages (document) <= 0) {
-		ev_window_warning_message (ev_window, "%s",
-					   _("The document contains no pages"));
-	} else if (!ev_document_check_dimensions (document)) {
-		ev_window_warning_message (ev_window, "%s",
-					   _("The document contains only empty pages"));
-	}
+  if (ev_document_get_n_pages (document) <= 0) {
+    ev_window_warning_message (ev_window, "%s",
+                               _("The document contains no pages"));
+  } else if (!ev_document_check_dimensions (document)) {
+    ev_window_warning_message (ev_window, "%s",
+                               _("The document contains only empty pages"));
+  }
 
-	ev_window_destroy_recent_view (ev_window);
+  ev_window_destroy_recent_view (ev_window);
 
-	ev_toolbar_set_mode (EV_TOOLBAR (priv->toolbar),
-			     EV_TOOLBAR_MODE_NORMAL);
-	ev_window_title_set_type (priv->title, EV_WINDOW_TITLE_DOCUMENT);
-	ev_window_update_actions_sensitivity (ev_window);
+  ev_toolbar_set_mode (EV_TOOLBAR (priv->toolbar),
+                       EV_TOOLBAR_MODE_NORMAL);
+  ev_window_title_set_type (priv->title, EV_WINDOW_TITLE_DOCUMENT);
+  ev_window_update_actions_sensitivity (ev_window);
 
-	if (EV_WINDOW_IS_PRESENTATION (priv)) {
-		gint current_page;
+  if (EV_WINDOW_IS_PRESENTATION (priv)) {
+    gint current_page;
 
-		current_page = ev_view_presentation_get_current_page (
-			EV_VIEW_PRESENTATION (priv->presentation_view));
-		gtk_widget_destroy (priv->presentation_view);
-		priv->presentation_view = NULL;
+    current_page = ev_view_presentation_get_current_page (
+                     EV_VIEW_PRESENTATION (priv->presentation_view));
+    gtk_widget_destroy (priv->presentation_view);
+    priv->presentation_view = NULL;
 
-		/* Update the model with the current presentation page */
-		ev_document_model_set_page (priv->model, current_page);
-		ev_window_run_presentation (ev_window);
-	}
+    /* Update the model with the current presentation page */
+    ev_document_model_set_page (priv->model, current_page);
+    ev_window_run_presentation (ev_window);
+  }
 
-	if (priv->setup_document_idle > 0)
-		g_source_remove (priv->setup_document_idle);
+  if (priv->setup_document_idle > 0)
+    g_source_remove (priv->setup_document_idle);
 
-	priv->setup_document_idle = g_idle_add ((GSourceFunc)ev_window_setup_document, ev_window);
+  priv->setup_document_idle = g_idle_add ((GSourceFunc)ev_window_setup_document, ev_window);
 }
 
 static void
 ev_window_file_changed (EvWindow *ev_window,
-			gpointer  user_data)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                        gpointer  user_data) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (priv->settings &&
-	    g_settings_get_boolean (priv->settings, GS_AUTO_RELOAD))
-		ev_window_reload_document (ev_window, NULL);
+  if (priv->settings &&
+      g_settings_get_boolean (priv->settings, GS_AUTO_RELOAD))
+    ev_window_reload_document (ev_window, NULL);
 }
 
 static void
-ev_window_password_view_unlock (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	const gchar *password;
+ev_window_password_view_unlock (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  const gchar *password;
 
-	g_assert (priv->load_job);
+  g_assert (priv->load_job);
 
-	password = ev_password_view_get_password (EV_PASSWORD_VIEW (priv->password_view));
-	ev_job_load_set_password (EV_JOB_LOAD (priv->load_job), password);
-	ev_job_scheduler_push_job (priv->load_job, EV_JOB_PRIORITY_NONE);
+  password = ev_password_view_get_password (EV_PASSWORD_VIEW (priv->password_view));
+  ev_job_load_set_password (EV_JOB_LOAD (priv->load_job), password);
+  ev_job_scheduler_push_job (priv->load_job, EV_JOB_PRIORITY_NONE);
 }
 
 static void
-ev_window_clear_load_job (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+ev_window_clear_load_job (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (priv->load_job != NULL) {
-		if (!ev_job_is_finished (priv->load_job))
-			ev_job_cancel (priv->load_job);
+  if (priv->load_job != NULL) {
+    if (!ev_job_is_finished (priv->load_job))
+      ev_job_cancel (priv->load_job);
 
-		g_signal_handlers_disconnect_by_func (priv->load_job, ev_window_load_job_cb, ev_window);
-		g_object_unref (priv->load_job);
-		priv->load_job = NULL;
-	}
+    g_signal_handlers_disconnect_by_func (priv->load_job, ev_window_load_job_cb, ev_window);
+    g_object_unref (priv->load_job);
+    priv->load_job = NULL;
+  }
 }
 
 static void
-ev_window_clear_reload_job (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+ev_window_clear_reload_job (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+
+  if (priv->reload_job != NULL) {
+    if (!ev_job_is_finished (priv->reload_job))
+      ev_job_cancel (priv->reload_job);
 
-	if (priv->reload_job != NULL) {
-		if (!ev_job_is_finished (priv->reload_job))
-			ev_job_cancel (priv->reload_job);
-		
-		g_signal_handlers_disconnect_by_func (priv->reload_job, ev_window_reload_job_cb, ev_window);
-		g_object_unref (priv->reload_job);
-		priv->reload_job = NULL;
-	}
+    g_signal_handlers_disconnect_by_func (priv->reload_job, ev_window_reload_job_cb, ev_window);
+    g_object_unref (priv->reload_job);
+    priv->reload_job = NULL;
+  }
 }
 
 static void
-ev_window_clear_local_uri (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+ev_window_clear_local_uri (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (priv->local_uri) {
-		ev_tmp_uri_unlink (priv->local_uri);
-		g_free (priv->local_uri);
-		priv->local_uri = NULL;
-	}
+  if (priv->local_uri) {
+    ev_tmp_uri_unlink (priv->local_uri);
+    g_free (priv->local_uri);
+    priv->local_uri = NULL;
+  }
 }
 
 static void
 ev_window_handle_link (EvWindow *ev_window,
-		       EvLinkDest *dest)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                       EvLinkDest *dest) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (dest) {
-		EvLink *link;
-		EvLinkAction *link_action;
+  if (dest) {
+    EvLink *link;
+    EvLinkAction *link_action;
 
-		link_action = ev_link_action_new_dest (dest);
-		link = ev_link_new (NULL, link_action);
-		ev_view_handle_link (EV_VIEW (priv->view), link);
-		g_object_unref (link_action);
-		g_object_unref (link);
-	}
+    link_action = ev_link_action_new_dest (dest);
+    link = ev_link_new (NULL, link_action);
+    ev_view_handle_link (EV_VIEW (priv->view), link);
+    g_object_unref (link_action);
+    g_object_unref (link);
+  }
 }
 
 /* This callback will executed when load job will be finished.
@@ -1778,148 +1750,146 @@ ev_window_handle_link (EvWindow *ev_window,
  * called. */
 static void
 ev_window_load_job_cb (EvJob *job,
-		       gpointer data)
-{
-	EvWindow *ev_window = EV_WINDOW (data);
-	EvDocument *document = EV_JOB (job)->document;
-	EvJobLoad *job_load = EV_JOB_LOAD (job);
-	gchar     *text;
-	gchar 	  *display_name;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                       gpointer data) {
+  EvWindow *ev_window = EV_WINDOW (data);
+  EvDocument *document = EV_JOB (job)->document;
+  EvJobLoad *job_load = EV_JOB_LOAD (job);
+  gchar     *text;
+  gchar 	  *display_name;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	g_assert (job_load->uri);
+  g_assert (job_load->uri);
 
-	ev_window_hide_loading_message (ev_window);
+  ev_window_hide_loading_message (ev_window);
 
-	/* Success! */
-	if (!ev_job_is_failed (job)) {
-		ev_document_model_set_document (priv->model, document);
+  /* Success! */
+  if (!ev_job_is_failed (job)) {
+    ev_document_model_set_document (priv->model, document);
 
 #ifdef ENABLE_DBUS
-		ev_window_emit_doc_loaded (ev_window);
+    ev_window_emit_doc_loaded (ev_window);
 #endif
-		setup_chrome_from_metadata (ev_window);
-		setup_document_from_metadata (ev_window);
-		setup_view_from_metadata (ev_window);
-
-		ev_window_add_recent (ev_window, priv->uri);
-
-		ev_window_title_set_type (priv->title,
-					  EV_WINDOW_TITLE_DOCUMENT);
-		if (job_load->password) {
-			GPasswordSave flags;
-
-			flags = ev_password_view_get_password_save_flags (
-				EV_PASSWORD_VIEW (priv->password_view));
-			ev_keyring_save_password (priv->uri,
-						  job_load->password,
-						  flags);
-		}
-
-		ev_window_handle_link (ev_window, priv->dest);
-		g_clear_object (&priv->dest);
-
-		switch (priv->window_mode) {
-		        case EV_WINDOW_MODE_FULLSCREEN:
-				ev_window_run_fullscreen (ev_window);
-				break;
-		        case EV_WINDOW_MODE_PRESENTATION:
-				ev_window_run_presentation (ev_window);
-				break;
-		        default:
-				break;
-		}
-
-		/* Create a monitor for the document */
-		priv->monitor = ev_file_monitor_new (priv->uri);
-		g_signal_connect_swapped (priv->monitor, "changed",
-					  G_CALLBACK (ev_window_file_changed),
-					  ev_window);
-		
-		ev_window_clear_load_job (ev_window);
-		return;
-	}
-
-	if (g_error_matches (job->error, EV_DOCUMENT_ERROR, EV_DOCUMENT_ERROR_ENCRYPTED) &&
-	    EV_IS_DOCUMENT_SECURITY (document)) {
-		gchar *password;
-		
-		setup_view_from_metadata (ev_window);
-		
-		/* First look whether password is in keyring */
-		password = ev_keyring_lookup_password (priv->uri);
-		if (password) {
-			if (job_load->password && strcmp (password, job_load->password) == 0) {
-				/* Password in keyring is wrong */
-				ev_job_load_set_password (job_load, NULL);
-				/* FIXME: delete password from keyring? */
-			} else {
-				ev_job_load_set_password (job_load, password);
-				ev_job_scheduler_push_job (job, EV_JOB_PRIORITY_NONE);
-				g_free (password);
-				return;
-			}
-
-			g_free (password);
-		}
-
-		/* We need to ask the user for a password */
-		ev_window_title_set_filename (priv->title,
-					      priv->display_name);
-		ev_window_title_set_type (priv->title,
-					  EV_WINDOW_TITLE_PASSWORD);
-
-		ev_password_view_set_filename (EV_PASSWORD_VIEW (priv->password_view),
-					       priv->display_name);
-
-		ev_window_set_page_mode (ev_window, PAGE_MODE_PASSWORD);
-
-		ev_job_load_set_password (job_load, NULL);
-		ev_password_view_ask_password (EV_PASSWORD_VIEW (priv->password_view));
-	} else {
-		ev_toolbar_set_mode (EV_TOOLBAR (priv->toolbar),
-				     EV_TOOLBAR_MODE_RECENT_VIEW);
-		text = g_uri_unescape_string (job_load->uri, NULL);
-		display_name = g_markup_escape_text (text, -1);
-		g_free (text);
-		ev_window_error_message (ev_window, job->error,
-					 _("Unable to open document “%s”."),
-					 display_name);
-		g_free (display_name);
-		ev_window_clear_load_job (ev_window);
-	}	
+    setup_chrome_from_metadata (ev_window);
+    setup_document_from_metadata (ev_window);
+    setup_view_from_metadata (ev_window);
+
+    ev_window_add_recent (ev_window, priv->uri);
+
+    ev_window_title_set_type (priv->title,
+                              EV_WINDOW_TITLE_DOCUMENT);
+    if (job_load->password) {
+      GPasswordSave flags;
+
+      flags = ev_password_view_get_password_save_flags (
+                EV_PASSWORD_VIEW (priv->password_view));
+      ev_keyring_save_password (priv->uri,
+                                job_load->password,
+                                flags);
+    }
+
+    ev_window_handle_link (ev_window, priv->dest);
+    g_clear_object (&priv->dest);
+
+    switch (priv->window_mode) {
+      case EV_WINDOW_MODE_FULLSCREEN:
+        ev_window_run_fullscreen (ev_window);
+        break;
+      case EV_WINDOW_MODE_PRESENTATION:
+        ev_window_run_presentation (ev_window);
+        break;
+      default:
+        break;
+    }
+
+    /* Create a monitor for the document */
+    priv->monitor = ev_file_monitor_new (priv->uri);
+    g_signal_connect_swapped (priv->monitor, "changed",
+                              G_CALLBACK (ev_window_file_changed),
+                              ev_window);
+
+    ev_window_clear_load_job (ev_window);
+    return;
+  }
+
+  if (g_error_matches (job->error, EV_DOCUMENT_ERROR, EV_DOCUMENT_ERROR_ENCRYPTED) &&
+      EV_IS_DOCUMENT_SECURITY (document)) {
+    gchar *password;
+
+    setup_view_from_metadata (ev_window);
+
+    /* First look whether password is in keyring */
+    password = ev_keyring_lookup_password (priv->uri);
+    if (password) {
+      if (job_load->password && strcmp (password, job_load->password) == 0) {
+        /* Password in keyring is wrong */
+        ev_job_load_set_password (job_load, NULL);
+        /* FIXME: delete password from keyring? */
+      } else {
+        ev_job_load_set_password (job_load, password);
+        ev_job_scheduler_push_job (job, EV_JOB_PRIORITY_NONE);
+        g_free (password);
+        return;
+      }
+
+      g_free (password);
+    }
+
+    /* We need to ask the user for a password */
+    ev_window_title_set_filename (priv->title,
+                                  priv->display_name);
+    ev_window_title_set_type (priv->title,
+                              EV_WINDOW_TITLE_PASSWORD);
+
+    ev_password_view_set_filename (EV_PASSWORD_VIEW (priv->password_view),
+                                   priv->display_name);
+
+    ev_window_set_page_mode (ev_window, PAGE_MODE_PASSWORD);
+
+    ev_job_load_set_password (job_load, NULL);
+    ev_password_view_ask_password (EV_PASSWORD_VIEW (priv->password_view));
+  } else {
+    ev_toolbar_set_mode (EV_TOOLBAR (priv->toolbar),
+                         EV_TOOLBAR_MODE_RECENT_VIEW);
+    text = g_uri_unescape_string (job_load->uri, NULL);
+    display_name = g_markup_escape_text (text, -1);
+    g_free (text);
+    ev_window_error_message (ev_window, job->error,
+                             _("Unable to open document “%s”."),
+                             display_name);
+    g_free (display_name);
+    ev_window_clear_load_job (ev_window);
+  }
 }
 
 static void
 ev_window_reload_job_cb (EvJob    *job,
-			 EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                         EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (ev_job_is_failed (job)) {
-		ev_window_clear_reload_job (ev_window);
-		priv->in_reload = FALSE;
-		if (priv->dest) {
-			g_object_unref (priv->dest);
-			priv->dest = NULL;
-		}
+  if (ev_job_is_failed (job)) {
+    ev_window_clear_reload_job (ev_window);
+    priv->in_reload = FALSE;
+    if (priv->dest) {
+      g_object_unref (priv->dest);
+      priv->dest = NULL;
+    }
 
-		return;
-	}
+    return;
+  }
 
-	ev_document_model_set_document (priv->model,
-					job->document);
-	if (priv->dest) {
-		ev_window_handle_link (ev_window, priv->dest);
-		g_clear_object (&priv->dest);
-	}
+  ev_document_model_set_document (priv->model,
+                                  job->document);
+  if (priv->dest) {
+    ev_window_handle_link (ev_window, priv->dest);
+    g_clear_object (&priv->dest);
+  }
 
-	/* Restart the search after reloading */
-	if (gtk_search_bar_get_search_mode (GTK_SEARCH_BAR (priv->search_bar)))
-		ev_search_box_restart (EV_SEARCH_BOX (priv->search_box));
+  /* Restart the search after reloading */
+  if (gtk_search_bar_get_search_mode (GTK_SEARCH_BAR (priv->search_bar)))
+    ev_search_box_restart (EV_SEARCH_BOX (priv->search_box));
 
-	ev_window_clear_reload_job (ev_window);
-	priv->in_reload = FALSE;
+  ev_window_clear_reload_job (ev_window);
+  priv->in_reload = FALSE;
 }
 
 /**
@@ -1931,11 +1901,10 @@ ev_window_reload_job_cb (EvJob    *job,
  * Returns: the uri of the document showed in the #EvWindow.
  */
 const char *
-ev_window_get_uri (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+ev_window_get_uri (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	return priv->uri;
+  return priv->uri;
 }
 
 /**
@@ -1946,2046 +1915,1975 @@ ev_window_get_uri (EvWindow *ev_window)
  * frees them from memory. If there is any print job it does free it too.
  */
 static void
-ev_window_close_dialogs (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+ev_window_close_dialogs (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+
+  if (priv->print_dialog)
+    gtk_widget_destroy (priv->print_dialog);
+  priv->print_dialog = NULL;
 
-	if (priv->print_dialog)
-		gtk_widget_destroy (priv->print_dialog);
-	priv->print_dialog = NULL;
-	
-	if (priv->properties)
-		gtk_widget_destroy (priv->properties);
-	priv->properties = NULL;
+  if (priv->properties)
+    gtk_widget_destroy (priv->properties);
+  priv->properties = NULL;
 }
 
 static void
-ev_window_clear_progress_idle (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+ev_window_clear_progress_idle (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (priv->progress_idle > 0)
-		g_source_remove (priv->progress_idle);
-	priv->progress_idle = 0;
+  if (priv->progress_idle > 0)
+    g_source_remove (priv->progress_idle);
+  priv->progress_idle = 0;
 }
 
 static void
-reset_progress_idle (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+reset_progress_idle (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	priv->progress_idle = 0;
+  priv->progress_idle = 0;
 }
 
 static void
 ev_window_show_progress_message (EvWindow   *ev_window,
-				 guint       interval,
-				 GSourceFunc function)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                                 guint       interval,
+                                 GSourceFunc function) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (priv->progress_idle > 0)
-		g_source_remove (priv->progress_idle);
-	priv->progress_idle =
-		g_timeout_add_seconds_full (G_PRIORITY_DEFAULT,
-					    interval, function,
-					    ev_window,
-					    (GDestroyNotify)reset_progress_idle);
+  if (priv->progress_idle > 0)
+    g_source_remove (priv->progress_idle);
+  priv->progress_idle =
+    g_timeout_add_seconds_full (G_PRIORITY_DEFAULT,
+                                interval, function,
+                                ev_window,
+                                (GDestroyNotify)reset_progress_idle);
 }
 
 static void
-ev_window_reset_progress_cancellable (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+ev_window_reset_progress_cancellable (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (priv->progress_cancellable)
-		g_cancellable_reset (priv->progress_cancellable);
-	else
-		priv->progress_cancellable = g_cancellable_new ();
+  if (priv->progress_cancellable)
+    g_cancellable_reset (priv->progress_cancellable);
+  else
+    priv->progress_cancellable = g_cancellable_new ();
 }
 
 static void
 ev_window_progress_response_cb (EvProgressMessageArea *area,
-				gint                   response,
-				EvWindow              *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                                gint                   response,
+                                EvWindow              *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (response == GTK_RESPONSE_CANCEL)
-		g_cancellable_cancel (priv->progress_cancellable);
-	ev_window_set_message_area (ev_window, NULL);
+  if (response == GTK_RESPONSE_CANCEL)
+    g_cancellable_cancel (priv->progress_cancellable);
+  ev_window_set_message_area (ev_window, NULL);
 }
 
 static gboolean
-show_loading_progress (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	GtkWidget *area;
-	gchar     *text;
-	gchar 	  *display_name;
+show_loading_progress (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  GtkWidget *area;
+  gchar     *text;
+  gchar 	  *display_name;
 
-	if (priv->message_area)
-		return FALSE;
+  if (priv->message_area)
+    return FALSE;
 
-	text = g_uri_unescape_string (priv->uri, NULL);
-	display_name = g_markup_escape_text (text, -1);
-	g_free (text);
-	text = g_strdup_printf (_("Loading document from “%s”"),
-				display_name);
+  text = g_uri_unescape_string (priv->uri, NULL);
+  display_name = g_markup_escape_text (text, -1);
+  g_free (text);
+  text = g_strdup_printf (_("Loading document from “%s”"),
+                          display_name);
 
-	area = ev_progress_message_area_new ("document-open-symbolic",
-					     text,
-					     _("C_ancel"),
-					     GTK_RESPONSE_CANCEL,
-					     NULL);
-	g_signal_connect (area, "response",
-			  G_CALLBACK (ev_window_progress_response_cb),
-			  ev_window);
-	gtk_widget_show (area);
-	ev_window_set_message_area (ev_window, area);
+  area = ev_progress_message_area_new ("document-open-symbolic",
+                                       text,
+                                       _("C_ancel"),
+                                       GTK_RESPONSE_CANCEL,
+                                       NULL);
+  g_signal_connect (area, "response",
+                    G_CALLBACK (ev_window_progress_response_cb),
+                    ev_window);
+  gtk_widget_show (area);
+  ev_window_set_message_area (ev_window, area);
 
-	g_free (text);
-	g_free (display_name);
+  g_free (text);
+  g_free (display_name);
 
-	return FALSE;
+  return FALSE;
 }
 
 static void
 ev_window_load_remote_failed (EvWindow *ev_window,
-			      GError   *error)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gchar *text;
-	gchar *display_name;
+                              GError   *error) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gchar *text;
+  gchar *display_name;
 
-	ev_window_hide_loading_message (ev_window);
-	priv->in_reload = FALSE;
+  ev_window_hide_loading_message (ev_window);
+  priv->in_reload = FALSE;
 
-	text = g_uri_unescape_string (priv->local_uri, NULL);
-	display_name = g_markup_escape_text (text, -1);
-	g_free (text);
-	ev_window_error_message (ev_window, error,
-				 _("Unable to open document “%s”."),
-				 display_name);
-	g_free (display_name);
-	g_free (priv->local_uri);
-	priv->local_uri = NULL;
-	priv->uri_mtime = 0;
+  text = g_uri_unescape_string (priv->local_uri, NULL);
+  display_name = g_markup_escape_text (text, -1);
+  g_free (text);
+  ev_window_error_message (ev_window, error,
+                           _("Unable to open document “%s”."),
+                           display_name);
+  g_free (display_name);
+  g_free (priv->local_uri);
+  priv->local_uri = NULL;
+  priv->uri_mtime = 0;
 }
 
 static void
 set_uri_mtime (GFile        *source,
-	       GAsyncResult *async_result,
-	       EvWindow     *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	GFileInfo *info;
-	GError *error = NULL;
+               GAsyncResult *async_result,
+               EvWindow     *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  GFileInfo *info;
+  GError *error = NULL;
 
-	info = g_file_query_info_finish (source, async_result, &error);
+  info = g_file_query_info_finish (source, async_result, &error);
 
-	if (error) {
-		priv->uri_mtime = 0;
-		g_error_free (error);
-	} else {
-		GTimeVal mtime;
+  if (error) {
+    priv->uri_mtime = 0;
+    g_error_free (error);
+  } else {
+    GTimeVal mtime;
 
-		g_file_info_get_modification_time (info, &mtime);
-		priv->uri_mtime = mtime.tv_sec;
-		g_object_unref (info);
-	}
+    g_file_info_get_modification_time (info, &mtime);
+    priv->uri_mtime = mtime.tv_sec;
+    g_object_unref (info);
+  }
 
-	g_object_unref (source);
+  g_object_unref (source);
 }
 
 static void
 mount_volume_ready_cb (GFile        *source,
-		       GAsyncResult *async_result,
-		       EvWindow     *ev_window)
-{
-	GError *error = NULL;
+                       GAsyncResult *async_result,
+                       EvWindow     *ev_window) {
+  GError *error = NULL;
 
-	g_file_mount_enclosing_volume_finish (source, async_result, &error);
+  g_file_mount_enclosing_volume_finish (source, async_result, &error);
 
-	if (error) {
-		ev_window_load_remote_failed (ev_window, error);
-		g_object_unref (source);
-		g_error_free (error);
-	} else {
-		/* Volume successfully mounted,
-		   try opening the file again */
-		ev_window_load_file_remote (ev_window, source);
-	}
+  if (error) {
+    ev_window_load_remote_failed (ev_window, error);
+    g_object_unref (source);
+    g_error_free (error);
+  } else {
+    /* Volume successfully mounted,
+       try opening the file again */
+    ev_window_load_file_remote (ev_window, source);
+  }
 }
 
 static void
 window_open_file_copy_ready_cb (GFile        *source,
-				GAsyncResult *async_result,
-				EvWindow     *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	GError *error = NULL;
-
-	ev_window_clear_progress_idle (ev_window);
-	ev_window_set_message_area (ev_window, NULL);
-
-	g_file_copy_finish (source, async_result, &error);
-	if (!error) {
-		ev_job_scheduler_push_job (priv->load_job, EV_JOB_PRIORITY_NONE);
-		g_file_query_info_async (source,
-					 G_FILE_ATTRIBUTE_TIME_MODIFIED,
-					 0, G_PRIORITY_DEFAULT,
-					 NULL,
-					 (GAsyncReadyCallback)set_uri_mtime,
-					 ev_window);
-		return;
-	}
-
-	if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_MOUNTED)) {
-		GMountOperation *operation;
-
-		operation = gtk_mount_operation_new (GTK_WINDOW (ev_window));
-		g_file_mount_enclosing_volume (source,
-					       G_MOUNT_MOUNT_NONE,
-					       operation, NULL,
-					       (GAsyncReadyCallback)mount_volume_ready_cb,
-					       ev_window);
-		g_object_unref (operation);
-	} else if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
-		ev_window_clear_load_job (ev_window);
-		ev_window_clear_local_uri (ev_window);
-		g_free (priv->uri);
-		priv->uri = NULL;
-		g_clear_pointer (&priv->display_name, g_free);
-		g_clear_pointer (&priv->edit_name, g_free);
-		g_object_unref (source);
-
-		ev_window_hide_loading_message (ev_window);
-	} else {
-		ev_window_load_remote_failed (ev_window, error);
-		g_object_unref (source);
-	}
-	
-	g_error_free (error);
+                                GAsyncResult *async_result,
+                                EvWindow     *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  GError *error = NULL;
+
+  ev_window_clear_progress_idle (ev_window);
+  ev_window_set_message_area (ev_window, NULL);
+
+  g_file_copy_finish (source, async_result, &error);
+  if (!error) {
+    ev_job_scheduler_push_job (priv->load_job, EV_JOB_PRIORITY_NONE);
+    g_file_query_info_async (source,
+                             G_FILE_ATTRIBUTE_TIME_MODIFIED,
+                             0, G_PRIORITY_DEFAULT,
+                             NULL,
+                             (GAsyncReadyCallback)set_uri_mtime,
+                             ev_window);
+    return;
+  }
+
+  if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_MOUNTED)) {
+    GMountOperation *operation;
+
+    operation = gtk_mount_operation_new (GTK_WINDOW (ev_window));
+    g_file_mount_enclosing_volume (source,
+                                   G_MOUNT_MOUNT_NONE,
+                                   operation, NULL,
+                                   (GAsyncReadyCallback)mount_volume_ready_cb,
+                                   ev_window);
+    g_object_unref (operation);
+  } else if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+    ev_window_clear_load_job (ev_window);
+    ev_window_clear_local_uri (ev_window);
+    g_free (priv->uri);
+    priv->uri = NULL;
+    g_clear_pointer (&priv->display_name, g_free);
+    g_clear_pointer (&priv->edit_name, g_free);
+    g_object_unref (source);
+
+    ev_window_hide_loading_message (ev_window);
+  } else {
+    ev_window_load_remote_failed (ev_window, error);
+    g_object_unref (source);
+  }
+
+  g_error_free (error);
 }
 
 static void
 window_open_file_copy_progress_cb (goffset   n_bytes,
-				   goffset   total_bytes,
-				   EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gchar *status;
-	gdouble fraction;
-	
-	if (!priv->message_area)
-		return;
+                                   goffset   total_bytes,
+                                   EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gchar *status;
+  gdouble fraction;
+
+  if (!priv->message_area)
+    return;
 
-	if (total_bytes <= 0)
-		return;
+  if (total_bytes <= 0)
+    return;
 
-	fraction = n_bytes / (gdouble)total_bytes;
-	status = g_strdup_printf (_("Downloading document (%d%%)"),
-				  (gint)(fraction * 100));
-	
-	ev_progress_message_area_set_status (EV_PROGRESS_MESSAGE_AREA (priv->message_area),
-					     status);
-	ev_progress_message_area_set_fraction (EV_PROGRESS_MESSAGE_AREA (priv->message_area),
-					       fraction);
+  fraction = n_bytes / (gdouble)total_bytes;
+  status = g_strdup_printf (_("Downloading document (%d%%)"),
+                            (gint)(fraction * 100));
 
-	g_free (status);
+  ev_progress_message_area_set_status (EV_PROGRESS_MESSAGE_AREA (priv->message_area),
+                                       status);
+  ev_progress_message_area_set_fraction (EV_PROGRESS_MESSAGE_AREA (priv->message_area),
+                                         fraction);
+
+  g_free (status);
 }
 
 static void
 ev_window_load_file_remote (EvWindow *ev_window,
-			    GFile    *source_file)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	GFile *target_file;
+                            GFile    *source_file) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  GFile *target_file;
 
-	if (!priv->local_uri) {
-		char *base_name, *template;
-                GFile *tmp_file;
-                GError *err = NULL;
+  if (!priv->local_uri) {
+    char *base_name, *template;
+    GFile *tmp_file;
+    GError *err = NULL;
 
-		/* We'd like to keep extension of source uri since
-		 * it helps to resolve some mime types, say cbz.
+    /* We'd like to keep extension of source uri since
+     * it helps to resolve some mime types, say cbz.
                  */
-		base_name = priv->edit_name;
-                template = g_strdup_printf ("document.XXXXXX-%s", base_name);
-
-                tmp_file = ev_mkstemp_file (template, &err);
-		g_free (template);
-                if (tmp_file == NULL) {
-                        ev_window_error_message (ev_window, err,
-                                                 "%s", _("Failed to load remote file."));
-                        g_error_free (err);
-                        return;
-                }
-
-		priv->local_uri = g_file_get_uri (tmp_file);
-		g_object_unref (tmp_file);
-
-		ev_job_load_set_uri (EV_JOB_LOAD (priv->load_job),
-				     priv->local_uri);
-	}
-
-	ev_window_reset_progress_cancellable (ev_window);
-
-	target_file = g_file_new_for_uri (priv->local_uri);
-	g_file_copy_async (source_file, target_file,
-			   G_FILE_COPY_OVERWRITE,
-			   G_PRIORITY_DEFAULT,
-			   priv->progress_cancellable,
-			   (GFileProgressCallback)window_open_file_copy_progress_cb,
-			   ev_window, 
-			   (GAsyncReadyCallback)window_open_file_copy_ready_cb,
-			   ev_window);
-	g_object_unref (target_file);
-
-	ev_window_show_progress_message (ev_window, 1,
-					 (GSourceFunc)show_loading_progress);
-}
-
-static void
-set_filenames (EvWindow *ev_window, GFile *f)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	GFileInfo       *info;
-	GError          *error = NULL;
-
-	g_clear_pointer (&priv->display_name, g_free);
-	g_clear_pointer (&priv->edit_name, g_free);
-
-	info = g_file_query_info (f,
-				  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME ","
-				  G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME,
-			          G_FILE_QUERY_INFO_NONE, NULL, &error);
-	if (info) {
-		priv->display_name = g_strdup (g_file_info_get_display_name (info));
-		priv->edit_name = g_strdup (g_file_info_get_edit_name (info));
-		g_object_unref (info);
-	} else {
-		g_warning ("%s: %s", G_STRFUNC, error->message);
-		g_error_free (error);
-	}
-
-	if (!priv->display_name)
-		priv->display_name = g_file_get_basename (f);
-	if (!priv->edit_name)
-		priv->edit_name = g_file_get_basename (f);
+    base_name = priv->edit_name;
+    template = g_strdup_printf ("document.XXXXXX-%s", base_name);
+
+    tmp_file = ev_mkstemp_file (template, &err);
+    g_free (template);
+    if (tmp_file == NULL) {
+      ev_window_error_message (ev_window, err,
+                               "%s", _("Failed to load remote file."));
+      g_error_free (err);
+      return;
+    }
+
+    priv->local_uri = g_file_get_uri (tmp_file);
+    g_object_unref (tmp_file);
+
+    ev_job_load_set_uri (EV_JOB_LOAD (priv->load_job),
+                         priv->local_uri);
+  }
+
+  ev_window_reset_progress_cancellable (ev_window);
+
+  target_file = g_file_new_for_uri (priv->local_uri);
+  g_file_copy_async (source_file, target_file,
+                     G_FILE_COPY_OVERWRITE,
+                     G_PRIORITY_DEFAULT,
+                     priv->progress_cancellable,
+                     (GFileProgressCallback)window_open_file_copy_progress_cb,
+                     ev_window,
+                     (GAsyncReadyCallback)window_open_file_copy_ready_cb,
+                     ev_window);
+  g_object_unref (target_file);
+
+  ev_window_show_progress_message (ev_window, 1,
+                                   (GSourceFunc)show_loading_progress);
+}
+
+static void
+set_filenames (EvWindow *ev_window, GFile *f) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  GFileInfo       *info;
+  GError          *error = NULL;
+
+  g_clear_pointer (&priv->display_name, g_free);
+  g_clear_pointer (&priv->edit_name, g_free);
+
+  info = g_file_query_info (f,
+                            G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME ","
+                            G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME,
+                            G_FILE_QUERY_INFO_NONE, NULL, &error);
+  if (info) {
+    priv->display_name = g_strdup (g_file_info_get_display_name (info));
+    priv->edit_name = g_strdup (g_file_info_get_edit_name (info));
+    g_object_unref (info);
+  } else {
+    g_warning ("%s: %s", G_STRFUNC, error->message);
+    g_error_free (error);
+  }
+
+  if (!priv->display_name)
+    priv->display_name = g_file_get_basename (f);
+  if (!priv->edit_name)
+    priv->edit_name = g_file_get_basename (f);
 }
 
 void
 ev_window_open_uri (EvWindow       *ev_window,
-		    const char     *uri,
-		    EvLinkDest     *dest,
-		    EvWindowRunMode mode,
-		    const gchar    *search_string)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	GFile *source_file;
-
-	priv->in_reload = FALSE;
-
-	g_clear_pointer (&priv->search_string, g_free);
-	priv->search_string = search_string ?
-		g_strdup (search_string) : NULL;
-
-	if (priv->uri &&
-	    g_ascii_strcasecmp (priv->uri, uri) == 0) {
-		ev_window_reload_document (ev_window, dest);
-		return;
-	}
-
-	if (priv->monitor) {
-		g_object_unref (priv->monitor);
-		priv->monitor = NULL;
-	}
-	
-	ev_window_close_dialogs (ev_window);
-	ev_window_clear_load_job (ev_window);
-	ev_window_clear_local_uri (ev_window);
-
-	priv->window_mode = mode;
-
-	if (priv->uri)
-		g_free (priv->uri);
-	priv->uri = g_strdup (uri);
-
-	if (priv->metadata)
-		g_object_unref (priv->metadata);
-	if (priv->bookmarks)
-		g_object_unref (priv->bookmarks);
-
-	source_file = g_file_new_for_uri (uri);
-	if (ev_is_metadata_supported_for_file (source_file)) {
-		priv->metadata = ev_metadata_new (source_file);
-		ev_window_init_metadata_with_default_values (ev_window);
-	} else {
-		priv->metadata = NULL;
-	}
-
-	if (priv->metadata) {
-		priv->bookmarks = ev_bookmarks_new (priv->metadata);
-		ev_sidebar_bookmarks_set_bookmarks (EV_SIDEBAR_BOOKMARKS (priv->sidebar_bookmarks),
-						    priv->bookmarks);
-		g_signal_connect_swapped (priv->bookmarks, "changed",
-					  G_CALLBACK (ev_window_setup_bookmarks),
-					  ev_window);
-		ev_window_setup_bookmarks (ev_window);
-	} else {
-		priv->bookmarks = NULL;
-	}
-
-	if (priv->dest)
-		g_object_unref (priv->dest);
-	priv->dest = dest ? g_object_ref (dest) : NULL;
-
-	set_filenames (ev_window, source_file);
-	setup_size_from_metadata (ev_window);
-	setup_model_from_metadata (ev_window);
-
-	priv->load_job = ev_job_load_new (uri);
-	g_signal_connect (priv->load_job,
-			  "finished",
-			  G_CALLBACK (ev_window_load_job_cb),
-			  ev_window);
-
-	if (!g_file_is_native (source_file) && !priv->local_uri) {
-		ev_window_load_file_remote (ev_window, source_file);
-	} else {
-		ev_window_show_loading_message (ev_window);
-		g_object_unref (source_file);
-		ev_job_scheduler_push_job (priv->load_job, EV_JOB_PRIORITY_NONE);
-	}
+                    const char     *uri,
+                    EvLinkDest     *dest,
+                    EvWindowRunMode mode,
+                    const gchar    *search_string) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  GFile *source_file;
+
+  priv->in_reload = FALSE;
+
+  g_clear_pointer (&priv->search_string, g_free);
+  priv->search_string = search_string ?
+                        g_strdup (search_string) : NULL;
+
+  if (priv->uri &&
+      g_ascii_strcasecmp (priv->uri, uri) == 0) {
+    ev_window_reload_document (ev_window, dest);
+    return;
+  }
+
+  if (priv->monitor) {
+    g_object_unref (priv->monitor);
+    priv->monitor = NULL;
+  }
+
+  ev_window_close_dialogs (ev_window);
+  ev_window_clear_load_job (ev_window);
+  ev_window_clear_local_uri (ev_window);
+
+  priv->window_mode = mode;
+
+  if (priv->uri)
+    g_free (priv->uri);
+  priv->uri = g_strdup (uri);
+
+  if (priv->metadata)
+    g_object_unref (priv->metadata);
+  if (priv->bookmarks)
+    g_object_unref (priv->bookmarks);
+
+  source_file = g_file_new_for_uri (uri);
+  if (ev_is_metadata_supported_for_file (source_file)) {
+    priv->metadata = ev_metadata_new (source_file);
+    ev_window_init_metadata_with_default_values (ev_window);
+  } else {
+    priv->metadata = NULL;
+  }
+
+  if (priv->metadata) {
+    priv->bookmarks = ev_bookmarks_new (priv->metadata);
+    ev_sidebar_bookmarks_set_bookmarks (EV_SIDEBAR_BOOKMARKS (priv->sidebar_bookmarks),
+                                        priv->bookmarks);
+    g_signal_connect_swapped (priv->bookmarks, "changed",
+                              G_CALLBACK (ev_window_setup_bookmarks),
+                              ev_window);
+    ev_window_setup_bookmarks (ev_window);
+  } else {
+    priv->bookmarks = NULL;
+  }
+
+  if (priv->dest)
+    g_object_unref (priv->dest);
+  priv->dest = dest ? g_object_ref (dest) : NULL;
+
+  set_filenames (ev_window, source_file);
+  setup_size_from_metadata (ev_window);
+  setup_model_from_metadata (ev_window);
+
+  priv->load_job = ev_job_load_new (uri);
+  g_signal_connect (priv->load_job,
+                    "finished",
+                    G_CALLBACK (ev_window_load_job_cb),
+                    ev_window);
+
+  if (!g_file_is_native (source_file) && !priv->local_uri) {
+    ev_window_load_file_remote (ev_window, source_file);
+  } else {
+    ev_window_show_loading_message (ev_window);
+    g_object_unref (source_file);
+    ev_job_scheduler_push_job (priv->load_job, EV_JOB_PRIORITY_NONE);
+  }
 }
 
 void
 ev_window_open_document (EvWindow       *ev_window,
-			 EvDocument     *document,
-			 EvLinkDest     *dest,
-			 EvWindowRunMode mode,
-			 const gchar    *search_string)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-
-	if (document == priv->document)
-		return;
-
-	ev_window_close_dialogs (ev_window);
-	ev_window_clear_load_job (ev_window);
-	ev_window_clear_local_uri (ev_window);
-
-	if (priv->monitor) {
-		g_object_unref (priv->monitor);
-		priv->monitor = NULL;
-	}
-
-	if (priv->uri)
-		g_free (priv->uri);
-	priv->uri = g_strdup (ev_document_get_uri (document));
-
-	setup_size_from_metadata (ev_window);
-	setup_model_from_metadata (ev_window);
-
-	ev_document_model_set_document (priv->model, document);
-
-	setup_document_from_metadata (ev_window);
-	setup_view_from_metadata (ev_window);
-
-	if (dest) {
-		EvLink *link;
-		EvLinkAction *link_action;
-
-		link_action = ev_link_action_new_dest (dest);
-		link = ev_link_new (NULL, link_action);
-		ev_view_handle_link (EV_VIEW (priv->view), link);
-		g_object_unref (link_action);
-		g_object_unref (link);
-	}
-
-	switch (mode) {
-	case EV_WINDOW_MODE_FULLSCREEN:
-		ev_window_run_fullscreen (ev_window);
-		break;
-	case EV_WINDOW_MODE_PRESENTATION:
-		ev_window_run_presentation (ev_window);
-		break;
-	default:
-		break;
-	}
-
-	if (search_string && EV_IS_DOCUMENT_FIND (document) &&
-	    mode != EV_WINDOW_MODE_PRESENTATION) {
-		GtkSearchEntry *entry;
-
-		ev_window_show_find_bar (ev_window, FALSE);
-		entry = ev_search_box_get_entry (EV_SEARCH_BOX (priv->search_box));
-		gtk_entry_set_text (GTK_ENTRY (entry), search_string);
-	}
-
-	/* Create a monitor for the document */
-	priv->monitor = ev_file_monitor_new (priv->uri);
-	g_signal_connect_swapped (priv->monitor, "changed",
-				  G_CALLBACK (ev_window_file_changed),
-				  ev_window);
+                         EvDocument     *document,
+                         EvLinkDest     *dest,
+                         EvWindowRunMode mode,
+                         const gchar    *search_string) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+
+  if (document == priv->document)
+    return;
+
+  ev_window_close_dialogs (ev_window);
+  ev_window_clear_load_job (ev_window);
+  ev_window_clear_local_uri (ev_window);
+
+  if (priv->monitor) {
+    g_object_unref (priv->monitor);
+    priv->monitor = NULL;
+  }
+
+  if (priv->uri)
+    g_free (priv->uri);
+  priv->uri = g_strdup (ev_document_get_uri (document));
+
+  setup_size_from_metadata (ev_window);
+  setup_model_from_metadata (ev_window);
+
+  ev_document_model_set_document (priv->model, document);
+
+  setup_document_from_metadata (ev_window);
+  setup_view_from_metadata (ev_window);
+
+  if (dest) {
+    EvLink *link;
+    EvLinkAction *link_action;
+
+    link_action = ev_link_action_new_dest (dest);
+    link = ev_link_new (NULL, link_action);
+    ev_view_handle_link (EV_VIEW (priv->view), link);
+    g_object_unref (link_action);
+    g_object_unref (link);
+  }
+
+  switch (mode) {
+    case EV_WINDOW_MODE_FULLSCREEN:
+      ev_window_run_fullscreen (ev_window);
+      break;
+    case EV_WINDOW_MODE_PRESENTATION:
+      ev_window_run_presentation (ev_window);
+      break;
+    default:
+      break;
+  }
+
+  if (search_string && EV_IS_DOCUMENT_FIND (document) &&
+      mode != EV_WINDOW_MODE_PRESENTATION) {
+    GtkSearchEntry *entry;
+
+    ev_window_show_find_bar (ev_window, FALSE);
+    entry = ev_search_box_get_entry (EV_SEARCH_BOX (priv->search_box));
+    gtk_entry_set_text (GTK_ENTRY (entry), search_string);
+  }
+
+  /* Create a monitor for the document */
+  priv->monitor = ev_file_monitor_new (priv->uri);
+  g_signal_connect_swapped (priv->monitor, "changed",
+                            G_CALLBACK (ev_window_file_changed),
+                            ev_window);
 }
 
 void
-ev_window_open_recent_view (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+ev_window_open_recent_view (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (priv->recent_view)
-		return;
+  if (priv->recent_view)
+    return;
 
-	gtk_widget_hide (priv->hpaned);
+  gtk_widget_hide (priv->hpaned);
 
-	priv->recent_view = EV_RECENT_VIEW (ev_recent_view_new ());
-	g_signal_connect_object (priv->recent_view,
-				 "item-activated",
-				 G_CALLBACK (recent_view_item_activated_cb),
-				 ev_window, 0);
-	gtk_box_pack_start (GTK_BOX (priv->main_box),
-			    GTK_WIDGET (priv->recent_view),
-			    TRUE, TRUE, 0);
+  priv->recent_view = EV_RECENT_VIEW (ev_recent_view_new ());
+  g_signal_connect_object (priv->recent_view,
+                           "item-activated",
+                           G_CALLBACK (recent_view_item_activated_cb),
+                           ev_window, 0);
+  gtk_box_pack_start (GTK_BOX (priv->main_box),
+                      GTK_WIDGET (priv->recent_view),
+                      TRUE, TRUE, 0);
 
-	gtk_widget_show (GTK_WIDGET (priv->recent_view));
-	ev_toolbar_set_mode (EV_TOOLBAR (priv->toolbar),
-			     EV_TOOLBAR_MODE_RECENT_VIEW);
-	ev_window_title_set_type (priv->title, EV_WINDOW_TITLE_RECENT);
+  gtk_widget_show (GTK_WIDGET (priv->recent_view));
+  ev_toolbar_set_mode (EV_TOOLBAR (priv->toolbar),
+                       EV_TOOLBAR_MODE_RECENT_VIEW);
+  ev_window_title_set_type (priv->title, EV_WINDOW_TITLE_RECENT);
 
-	ev_window_update_actions_sensitivity (ev_window);
+  ev_window_update_actions_sensitivity (ev_window);
 }
 
 static void
-ev_window_destroy_recent_view (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+ev_window_destroy_recent_view (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (!priv->recent_view)
-		return;
+  if (!priv->recent_view)
+    return;
 
-	gtk_widget_destroy (GTK_WIDGET (priv->recent_view));
-	priv->recent_view = NULL;
-	gtk_widget_show (priv->hpaned);
+  gtk_widget_destroy (GTK_WIDGET (priv->recent_view));
+  priv->recent_view = NULL;
+  gtk_widget_show (priv->hpaned);
 }
 
 static void
-ev_window_reload_local (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	const gchar *uri;
+ev_window_reload_local (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  const gchar *uri;
 
-	uri = priv->local_uri ? priv->local_uri : priv->uri;
-	priv->reload_job = ev_job_load_new (uri);
-	g_signal_connect (priv->reload_job, "finished",
-			  G_CALLBACK (ev_window_reload_job_cb),
-			  ev_window);
-	ev_job_scheduler_push_job (priv->reload_job, EV_JOB_PRIORITY_NONE);
+  uri = priv->local_uri ? priv->local_uri : priv->uri;
+  priv->reload_job = ev_job_load_new (uri);
+  g_signal_connect (priv->reload_job, "finished",
+                    G_CALLBACK (ev_window_reload_job_cb),
+                    ev_window);
+  ev_job_scheduler_push_job (priv->reload_job, EV_JOB_PRIORITY_NONE);
 }
 
 static gboolean
-show_reloading_progress (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	GtkWidget *area;
-	gchar     *text;
-
-	if (priv->message_area)
-		return FALSE;
-	
-	text = g_strdup_printf (_("Reloading document from %s"),
-				priv->uri);
-	area = ev_progress_message_area_new ("view-refresh-symbolic",
-					     text,
-					     _("C_ancel"),
-					     GTK_RESPONSE_CANCEL,
-					     NULL);
-	g_signal_connect (area, "response",
-			  G_CALLBACK (ev_window_progress_response_cb),
-			  ev_window);
-	gtk_widget_show (area);
-	ev_window_set_message_area (ev_window, area);
-	g_free (text);
-
-	return FALSE;
+show_reloading_progress (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  GtkWidget *area;
+  gchar     *text;
+
+  if (priv->message_area)
+    return FALSE;
+
+  text = g_strdup_printf (_("Reloading document from %s"),
+                          priv->uri);
+  area = ev_progress_message_area_new ("view-refresh-symbolic",
+                                       text,
+                                       _("C_ancel"),
+                                       GTK_RESPONSE_CANCEL,
+                                       NULL);
+  g_signal_connect (area, "response",
+                    G_CALLBACK (ev_window_progress_response_cb),
+                    ev_window);
+  gtk_widget_show (area);
+  ev_window_set_message_area (ev_window, area);
+  g_free (text);
+
+  return FALSE;
 }
 
 static void
 reload_remote_copy_ready_cb (GFile        *remote,
-			     GAsyncResult *async_result,
-			     EvWindow     *ev_window)
-{
-	GError *error = NULL;
+                             GAsyncResult *async_result,
+                             EvWindow     *ev_window) {
+  GError *error = NULL;
+
+  ev_window_clear_progress_idle (ev_window);
 
-	ev_window_clear_progress_idle (ev_window);
+  g_file_copy_finish (remote, async_result, &error);
+  if (error) {
+    if (!g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
+      ev_window_error_message (ev_window, error,
+                               "%s", _("Failed to reload document."));
+    g_error_free (error);
+  } else {
+    ev_window_reload_local (ev_window);
+  }
 
-	g_file_copy_finish (remote, async_result, &error);
-	if (error) {
-		if (!g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
-			ev_window_error_message (ev_window, error,
-						 "%s", _("Failed to reload document."));
-		g_error_free (error);
-	} else {
-		ev_window_reload_local (ev_window);
-	}
-		
-	g_object_unref (remote);
+  g_object_unref (remote);
 }
 
 static void
 reload_remote_copy_progress_cb (goffset   n_bytes,
-				goffset   total_bytes,
-				EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gchar *status;
-	gdouble fraction;
-	
-	if (!priv->message_area)
-		return;
+                                goffset   total_bytes,
+                                EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gchar *status;
+  gdouble fraction;
+
+  if (!priv->message_area)
+    return;
 
-	if (total_bytes <= 0)
-		return;
+  if (total_bytes <= 0)
+    return;
 
-	fraction = n_bytes / (gdouble)total_bytes;
-	status = g_strdup_printf (_("Downloading document (%d%%)"),
-				  (gint)(fraction * 100));
-	
-	ev_progress_message_area_set_status (EV_PROGRESS_MESSAGE_AREA (priv->message_area),
-					     status);
-	ev_progress_message_area_set_fraction (EV_PROGRESS_MESSAGE_AREA (priv->message_area),
-					       fraction);
+  fraction = n_bytes / (gdouble)total_bytes;
+  status = g_strdup_printf (_("Downloading document (%d%%)"),
+                            (gint)(fraction * 100));
 
-	g_free (status);
+  ev_progress_message_area_set_status (EV_PROGRESS_MESSAGE_AREA (priv->message_area),
+                                       status);
+  ev_progress_message_area_set_fraction (EV_PROGRESS_MESSAGE_AREA (priv->message_area),
+                                         fraction);
+
+  g_free (status);
 }
 
 static void
 query_remote_uri_mtime_cb (GFile        *remote,
-			   GAsyncResult *async_result,
-			   EvWindow     *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	GFileInfo *info;
-	GTimeVal   mtime;
-	GError    *error = NULL;
-
-	info = g_file_query_info_finish (remote, async_result, &error);
-	if (error) {
-		g_error_free (error);
-		g_object_unref (remote);
-		ev_window_reload_local (ev_window);
-
-		return;
-	}
-
-	g_file_info_get_modification_time (info, &mtime);
-	if (priv->uri_mtime != mtime.tv_sec) {
-		GFile *target_file;
-
-		/* Remote file has changed */
-		priv->uri_mtime = mtime.tv_sec;
-
-		ev_window_reset_progress_cancellable (ev_window);
-		
-		target_file = g_file_new_for_uri (priv->local_uri);
-		g_file_copy_async (remote, target_file,
-				   G_FILE_COPY_OVERWRITE,
-				   G_PRIORITY_DEFAULT,
-				   priv->progress_cancellable,
-				   (GFileProgressCallback)reload_remote_copy_progress_cb,
-				   ev_window, 
-				   (GAsyncReadyCallback)reload_remote_copy_ready_cb,
-				   ev_window);
-		g_object_unref (target_file);
-		ev_window_show_progress_message (ev_window, 1,
-						 (GSourceFunc)show_reloading_progress);
-	} else {
-		g_object_unref (remote);
-		ev_window_reload_local (ev_window);
-	}
-	
-	g_object_unref (info);
-}
-
-static void
-ev_window_reload_remote (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	GFile *remote;
-
-	remote = g_file_new_for_uri (priv->uri);
-	/* Reload the remote uri only if it has changed */
-	g_file_query_info_async (remote,
-				 G_FILE_ATTRIBUTE_TIME_MODIFIED,
-				 0, G_PRIORITY_DEFAULT,
-				 NULL,
-				 (GAsyncReadyCallback)query_remote_uri_mtime_cb,
-				 ev_window);
+                           GAsyncResult *async_result,
+                           EvWindow     *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  GFileInfo *info;
+  GTimeVal   mtime;
+  GError    *error = NULL;
+
+  info = g_file_query_info_finish (remote, async_result, &error);
+  if (error) {
+    g_error_free (error);
+    g_object_unref (remote);
+    ev_window_reload_local (ev_window);
+
+    return;
+  }
+
+  g_file_info_get_modification_time (info, &mtime);
+  if (priv->uri_mtime != mtime.tv_sec) {
+    GFile *target_file;
+
+    /* Remote file has changed */
+    priv->uri_mtime = mtime.tv_sec;
+
+    ev_window_reset_progress_cancellable (ev_window);
+
+    target_file = g_file_new_for_uri (priv->local_uri);
+    g_file_copy_async (remote, target_file,
+                       G_FILE_COPY_OVERWRITE,
+                       G_PRIORITY_DEFAULT,
+                       priv->progress_cancellable,
+                       (GFileProgressCallback)reload_remote_copy_progress_cb,
+                       ev_window,
+                       (GAsyncReadyCallback)reload_remote_copy_ready_cb,
+                       ev_window);
+    g_object_unref (target_file);
+    ev_window_show_progress_message (ev_window, 1,
+                                     (GSourceFunc)show_reloading_progress);
+  } else {
+    g_object_unref (remote);
+    ev_window_reload_local (ev_window);
+  }
+
+  g_object_unref (info);
+}
+
+static void
+ev_window_reload_remote (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  GFile *remote;
+
+  remote = g_file_new_for_uri (priv->uri);
+  /* Reload the remote uri only if it has changed */
+  g_file_query_info_async (remote,
+                           G_FILE_ATTRIBUTE_TIME_MODIFIED,
+                           0, G_PRIORITY_DEFAULT,
+                           NULL,
+                           (GAsyncReadyCallback)query_remote_uri_mtime_cb,
+                           ev_window);
 }
 
 static void
 ev_window_reload_document (EvWindow *ev_window,
-			   EvLinkDest *dest)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                           EvLinkDest *dest) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	ev_window_clear_reload_job (ev_window);
-	priv->in_reload = TRUE;
+  ev_window_clear_reload_job (ev_window);
+  priv->in_reload = TRUE;
 
-	if (priv->dest)
-		g_object_unref (priv->dest);
-	priv->dest = dest ? g_object_ref (dest) : NULL;
+  if (priv->dest)
+    g_object_unref (priv->dest);
+  priv->dest = dest ? g_object_ref (dest) : NULL;
 
-	if (priv->local_uri) {
-		ev_window_reload_remote (ev_window);
-	} else {
-		ev_window_reload_local (ev_window);
-	}
+  if (priv->local_uri) {
+    ev_window_reload_remote (ev_window);
+  } else {
+    ev_window_reload_local (ev_window);
+  }
 }
 
 static const gchar *
-get_settings_key_for_directory (GUserDirectory directory)
-{
-        switch (directory) {
-                case G_USER_DIRECTORY_PICTURES:
-                        return GS_LAST_PICTURES_DIRECTORY;
-                case G_USER_DIRECTORY_DOCUMENTS:
-                default:
-                        return GS_LAST_DOCUMENT_DIRECTORY;
-        }
+get_settings_key_for_directory (GUserDirectory directory) {
+  switch (directory) {
+    case G_USER_DIRECTORY_PICTURES:
+      return GS_LAST_PICTURES_DIRECTORY;
+    case G_USER_DIRECTORY_DOCUMENTS:
+    default:
+      return GS_LAST_DOCUMENT_DIRECTORY;
+  }
 }
 
 static void
 ev_window_file_chooser_restore_folder (EvWindow       *window,
                                        GtkFileChooser *file_chooser,
                                        const gchar    *uri,
-                                       GUserDirectory  directory)
-{
-        const gchar *dir;
-        gchar *folder_uri;
+                                       GUserDirectory  directory) {
+  const gchar *dir;
+  gchar *folder_uri;
 
-        g_settings_get (ev_window_ensure_settings (window),
-                        get_settings_key_for_directory (directory),
-                        "ms", &folder_uri);
-        if (folder_uri == NULL && uri != NULL) {
-                GFile *file, *parent;
+  g_settings_get (ev_window_ensure_settings (window),
+                  get_settings_key_for_directory (directory),
+                  "ms", &folder_uri);
+  if (folder_uri == NULL && uri != NULL) {
+    GFile *file, *parent;
 
-                file = g_file_new_for_uri (uri);
-                parent = g_file_get_parent (file);
-                g_object_unref (file);
-                if (parent) {
-                        folder_uri = g_file_get_uri (parent);
-                        g_object_unref (parent);
-                }
-        }
+    file = g_file_new_for_uri (uri);
+    parent = g_file_get_parent (file);
+    g_object_unref (file);
+    if (parent) {
+      folder_uri = g_file_get_uri (parent);
+      g_object_unref (parent);
+    }
+  }
 
-        if (folder_uri) {
-                gtk_file_chooser_set_current_folder_uri (file_chooser, folder_uri);
-        } else {
-                dir = g_get_user_special_dir (directory);
-                gtk_file_chooser_set_current_folder (file_chooser,
-                                                     dir ? dir : g_get_home_dir ());
-        }
+  if (folder_uri) {
+    gtk_file_chooser_set_current_folder_uri (file_chooser, folder_uri);
+  } else {
+    dir = g_get_user_special_dir (directory);
+    gtk_file_chooser_set_current_folder (file_chooser,
+                                         dir ? dir : g_get_home_dir ());
+  }
 
-        g_free (folder_uri);
+  g_free (folder_uri);
 }
 
 static void
 ev_window_file_chooser_save_folder (EvWindow       *window,
                                     GtkFileChooser *file_chooser,
-                                    GUserDirectory  directory)
-{
-        gchar *uri, *folder;
+                                    GUserDirectory  directory) {
+  gchar *uri, *folder;
 
-        folder = gtk_file_chooser_get_current_folder (file_chooser);
-        if (g_strcmp0 (folder, g_get_user_special_dir (directory)) == 0) {
-                /* Store 'nothing' if the folder is the default one */
-                uri = NULL;
-        } else {
-                uri = gtk_file_chooser_get_current_folder_uri (file_chooser);
-        }
-        g_free (folder);
+  folder = gtk_file_chooser_get_current_folder (file_chooser);
+  if (g_strcmp0 (folder, g_get_user_special_dir (directory)) == 0) {
+    /* Store 'nothing' if the folder is the default one */
+    uri = NULL;
+  } else {
+    uri = gtk_file_chooser_get_current_folder_uri (file_chooser);
+  }
+  g_free (folder);
 
-        g_settings_set (ev_window_ensure_settings (window),
-                        get_settings_key_for_directory (directory),
-                        "ms", uri);
-        g_free (uri);
+  g_settings_set (ev_window_ensure_settings (window),
+                  get_settings_key_for_directory (directory),
+                  "ms", uri);
+  g_free (uri);
 }
 
 static void
 file_open_dialog_response_cb (GtkWidget *chooser,
-			      gint       response_id,
-			      EvWindow  *ev_window)
-{
-	if (response_id == GTK_RESPONSE_OK) {
-		GSList *uris;
+                              gint       response_id,
+                              EvWindow  *ev_window) {
+  if (response_id == GTK_RESPONSE_OK) {
+    GSList *uris;
 
-                ev_window_file_chooser_save_folder (ev_window, GTK_FILE_CHOOSER (chooser),
-                                                    G_USER_DIRECTORY_DOCUMENTS);
+    ev_window_file_chooser_save_folder (ev_window, GTK_FILE_CHOOSER (chooser),
+                                        G_USER_DIRECTORY_DOCUMENTS);
 
-		uris = gtk_file_chooser_get_uris (GTK_FILE_CHOOSER (chooser));
+    uris = gtk_file_chooser_get_uris (GTK_FILE_CHOOSER (chooser));
 
-		ev_application_open_uri_list (EV_APP, uris,
-					      gtk_window_get_screen (GTK_WINDOW (ev_window)),
-					      gtk_get_current_event_time ());
+    ev_application_open_uri_list (EV_APP, uris,
+                                  gtk_window_get_screen (GTK_WINDOW (ev_window)),
+                                  gtk_get_current_event_time ());
 
-		g_slist_foreach (uris, (GFunc)g_free, NULL);
-		g_slist_free (uris);
-	}
+    g_slist_foreach (uris, (GFunc)g_free, NULL);
+    g_slist_free (uris);
+  }
 
-	gtk_widget_destroy (chooser);
+  gtk_widget_destroy (chooser);
 }
 
 static void
 ev_window_cmd_new_window (GSimpleAction *action,
-			  GVariant      *parameter,
-			  gpointer       user_data)
-{
+                          GVariant      *parameter,
+                          gpointer       user_data) {
 
-	EvWindow  *window = user_data;
-	GdkScreen *screen;
-	guint32    timestamp;
+  EvWindow  *window = user_data;
+  GdkScreen *screen;
+  guint32    timestamp;
 
-	screen = gtk_window_get_screen (GTK_WINDOW (window));
-        timestamp = gtk_get_current_event_time ();
+  screen = gtk_window_get_screen (GTK_WINDOW (window));
+  timestamp = gtk_get_current_event_time ();
 
-	ev_application_new_window (EV_APP, screen, timestamp);
+  ev_application_new_window (EV_APP, screen, timestamp);
 }
 
 static void
 ev_window_cmd_file_open (GSimpleAction *action,
-			 GVariant      *parameter,
-			 gpointer       user_data)
-{
-	EvWindow  *window = user_data;
-	GtkWidget *chooser;
+                         GVariant      *parameter,
+                         gpointer       user_data) {
+  EvWindow  *window = user_data;
+  GtkWidget *chooser;
 
-	chooser = gtk_file_chooser_dialog_new (_("Open Document"),
-					       GTK_WINDOW (window),
-					       GTK_FILE_CHOOSER_ACTION_OPEN,
-					       _("_Cancel"),
-					       GTK_RESPONSE_CANCEL,
-					       _("_Open"), GTK_RESPONSE_OK,
-					       NULL);
+  chooser = gtk_file_chooser_dialog_new (_("Open Document"),
+                                         GTK_WINDOW (window),
+                                         GTK_FILE_CHOOSER_ACTION_OPEN,
+                                         _("_Cancel"),
+                                         GTK_RESPONSE_CANCEL,
+                                         _("_Open"), GTK_RESPONSE_OK,
+                                         NULL);
 
-	ev_document_factory_add_filters (chooser, NULL);
-	gtk_file_chooser_set_select_multiple (GTK_FILE_CHOOSER (chooser), TRUE);
-	gtk_file_chooser_set_local_only (GTK_FILE_CHOOSER (chooser), FALSE);
+  ev_document_factory_add_filters (chooser, NULL);
+  gtk_file_chooser_set_select_multiple (GTK_FILE_CHOOSER (chooser), TRUE);
+  gtk_file_chooser_set_local_only (GTK_FILE_CHOOSER (chooser), FALSE);
 
-        ev_window_file_chooser_restore_folder (window, GTK_FILE_CHOOSER (chooser),
-                                               NULL, G_USER_DIRECTORY_DOCUMENTS);
+  ev_window_file_chooser_restore_folder (window, GTK_FILE_CHOOSER (chooser),
+                                         NULL, G_USER_DIRECTORY_DOCUMENTS);
 
-	g_signal_connect (chooser, "response",
-			  G_CALLBACK (file_open_dialog_response_cb),
-			  window);
+  g_signal_connect (chooser, "response",
+                    G_CALLBACK (file_open_dialog_response_cb),
+                    window);
 
-	gtk_widget_show (chooser);
+  gtk_widget_show (chooser);
 }
 
 static void
 ev_window_open_copy_at_dest (EvWindow   *window,
-			     EvLinkDest *dest)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	EvWindow *new_window = EV_WINDOW (ev_window_new ());
-	EvWindowPrivate *new_priv = GET_PRIVATE (new_window);
+                             EvLinkDest *dest) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  EvWindow *new_window = EV_WINDOW (ev_window_new ());
+  EvWindowPrivate *new_priv = GET_PRIVATE (new_window);
 
-	if (priv->metadata)
-		new_priv->metadata = g_object_ref (priv->metadata);
-	new_priv->display_name = g_strdup (priv->display_name);
-	new_priv->edit_name = g_strdup (priv->edit_name);
-	ev_window_open_document (new_window,
-				 priv->document,
-				 dest, 0, NULL);
-	new_priv->chrome = priv->chrome;
+  if (priv->metadata)
+    new_priv->metadata = g_object_ref (priv->metadata);
+  new_priv->display_name = g_strdup (priv->display_name);
+  new_priv->edit_name = g_strdup (priv->edit_name);
+  ev_window_open_document (new_window,
+                           priv->document,
+                           dest, 0, NULL);
+  new_priv->chrome = priv->chrome;
 
-	gtk_window_present (GTK_WINDOW (new_window));
+  gtk_window_present (GTK_WINDOW (new_window));
 }
 
 static void
 ev_window_cmd_file_open_copy (GSimpleAction *action,
-			      GVariant      *parameter,
-			      gpointer       user_data)
-{
-	EvWindow *window = user_data;
+                              GVariant      *parameter,
+                              gpointer       user_data) {
+  EvWindow *window = user_data;
 
-	ev_window_open_copy_at_dest (window, NULL);
+  ev_window_open_copy_at_dest (window, NULL);
 }
 
 static void
-ev_window_add_recent (EvWindow *window, const char *uri)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+ev_window_add_recent (EvWindow *window, const char *uri) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	gtk_recent_manager_add_item (priv->recent_manager, uri);
+  gtk_recent_manager_add_item (priv->recent_manager, uri);
 }
 
 static gboolean
-show_saving_progress (GFile *dst)
-{
-	EvWindow  *ev_window;
-	GtkWidget *area;
-	gchar     *text;
-	gchar     *uri;
-	EvSaveType save_type;
-
-	ev_window = EV_WINDOW (g_object_get_data (G_OBJECT (dst), "ev-window"));
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	priv->progress_idle = 0;
-
-	if (priv->message_area)
-		return FALSE;
-
-	save_type = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (dst), "save-type"));
-	uri = g_file_get_uri (dst);
-	switch (save_type) {
-	case EV_SAVE_DOCUMENT:
-		text = g_strdup_printf (_("Saving document to %s"), uri);
-		break;
-	case EV_SAVE_ATTACHMENT:
-		text = g_strdup_printf (_("Saving attachment to %s"), uri);
-		break;
-	case EV_SAVE_IMAGE:
-		text = g_strdup_printf (_("Saving image to %s"), uri);
-		break;
-	default:
-		g_assert_not_reached ();
-	}
-	g_free (uri);
-	area = ev_progress_message_area_new ("document-save-symbolic",
-					     text,
-					     _("C_ancel"),
-					     GTK_RESPONSE_CANCEL,
-					     NULL);
-	g_signal_connect (area, "response",
-			  G_CALLBACK (ev_window_progress_response_cb),
-			  ev_window);
-	gtk_widget_show (area);
-	ev_window_set_message_area (ev_window, area);
-	g_free (text);
-
-	return FALSE;
+show_saving_progress (GFile *dst) {
+  EvWindow  *ev_window;
+  GtkWidget *area;
+  gchar     *text;
+  gchar     *uri;
+  EvSaveType save_type;
+
+  ev_window = EV_WINDOW (g_object_get_data (G_OBJECT (dst), "ev-window"));
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  priv->progress_idle = 0;
+
+  if (priv->message_area)
+    return FALSE;
+
+  save_type = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (dst), "save-type"));
+  uri = g_file_get_uri (dst);
+  switch (save_type) {
+    case EV_SAVE_DOCUMENT:
+      text = g_strdup_printf (_("Saving document to %s"), uri);
+      break;
+    case EV_SAVE_ATTACHMENT:
+      text = g_strdup_printf (_("Saving attachment to %s"), uri);
+      break;
+    case EV_SAVE_IMAGE:
+      text = g_strdup_printf (_("Saving image to %s"), uri);
+      break;
+    default:
+      g_assert_not_reached ();
+  }
+  g_free (uri);
+  area = ev_progress_message_area_new ("document-save-symbolic",
+                                       text,
+                                       _("C_ancel"),
+                                       GTK_RESPONSE_CANCEL,
+                                       NULL);
+  g_signal_connect (area, "response",
+                    G_CALLBACK (ev_window_progress_response_cb),
+                    ev_window);
+  gtk_widget_show (area);
+  ev_window_set_message_area (ev_window, area);
+  g_free (text);
+
+  return FALSE;
 }
 
 static void
 window_save_file_copy_ready_cb (GFile        *src,
-				GAsyncResult *async_result,
-				GFile        *dst)
-{
-	EvWindow *ev_window;
-	GError   *error = NULL;
+                                GAsyncResult *async_result,
+                                GFile        *dst) {
+  EvWindow *ev_window;
+  GError   *error = NULL;
 
-	ev_window = EV_WINDOW (g_object_get_data (G_OBJECT (dst), "ev-window"));
-	ev_window_clear_progress_idle (ev_window);
+  ev_window = EV_WINDOW (g_object_get_data (G_OBJECT (dst), "ev-window"));
+  ev_window_clear_progress_idle (ev_window);
 
-	if (g_file_copy_finish (src, async_result, &error)) {
-		ev_tmp_file_unlink (src);
-		return;
-	}
+  if (g_file_copy_finish (src, async_result, &error)) {
+    ev_tmp_file_unlink (src);
+    return;
+  }
 
-	if (!g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
-		gchar *name;
-		
-		name = g_file_get_basename (dst);
-		ev_window_error_message (ev_window, error,
-					 _("The file could not be saved as “%s”."),
-					 name);
-		g_free (name);
-	}
-	ev_tmp_file_unlink (src);
-	g_error_free (error);
+  if (!g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+    gchar *name;
+
+    name = g_file_get_basename (dst);
+    ev_window_error_message (ev_window, error,
+                             _("The file could not be saved as “%s”."),
+                             name);
+    g_free (name);
+  }
+  ev_tmp_file_unlink (src);
+  g_error_free (error);
 }
 
 static void
 window_save_file_copy_progress_cb (goffset n_bytes,
-				   goffset total_bytes,
-				   GFile  *dst)
-{
-	EvWindow  *ev_window;
-	EvSaveType save_type;
-	gchar     *status;
-	gdouble    fraction;
-
-	ev_window = EV_WINDOW (g_object_get_data (G_OBJECT (dst), "ev-window"));
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	
-	if (!priv->message_area)
-		return;
-
-	if (total_bytes <= 0)
-		return;
-
-	fraction = n_bytes / (gdouble)total_bytes;
-	save_type = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (dst), "save-type"));
-
-	switch (save_type) {
-	case EV_SAVE_DOCUMENT:
-		status = g_strdup_printf (_("Uploading document (%d%%)"),
-					  (gint)(fraction * 100));
-		break;
-	case EV_SAVE_ATTACHMENT:
-		status = g_strdup_printf (_("Uploading attachment (%d%%)"),
-					  (gint)(fraction * 100));
-		break;
-	case EV_SAVE_IMAGE:
-		status = g_strdup_printf (_("Uploading image (%d%%)"),
-					  (gint)(fraction * 100));
-		break;
-	default:
-		g_assert_not_reached ();
-	}
-
-	ev_progress_message_area_set_status (EV_PROGRESS_MESSAGE_AREA (priv->message_area),
-					     status);
-	ev_progress_message_area_set_fraction (EV_PROGRESS_MESSAGE_AREA (priv->message_area),
-					       fraction);
-
-	g_free (status);
+                                   goffset total_bytes,
+                                   GFile  *dst) {
+  EvWindow  *ev_window;
+  EvSaveType save_type;
+  gchar     *status;
+  gdouble    fraction;
+
+  ev_window = EV_WINDOW (g_object_get_data (G_OBJECT (dst), "ev-window"));
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+
+  if (!priv->message_area)
+    return;
+
+  if (total_bytes <= 0)
+    return;
+
+  fraction = n_bytes / (gdouble)total_bytes;
+  save_type = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (dst), "save-type"));
+
+  switch (save_type) {
+    case EV_SAVE_DOCUMENT:
+      status = g_strdup_printf (_("Uploading document (%d%%)"),
+                                (gint)(fraction * 100));
+      break;
+    case EV_SAVE_ATTACHMENT:
+      status = g_strdup_printf (_("Uploading attachment (%d%%)"),
+                                (gint)(fraction * 100));
+      break;
+    case EV_SAVE_IMAGE:
+      status = g_strdup_printf (_("Uploading image (%d%%)"),
+                                (gint)(fraction * 100));
+      break;
+    default:
+      g_assert_not_reached ();
+  }
+
+  ev_progress_message_area_set_status (EV_PROGRESS_MESSAGE_AREA (priv->message_area),
+                                       status);
+  ev_progress_message_area_set_fraction (EV_PROGRESS_MESSAGE_AREA (priv->message_area),
+                                         fraction);
+
+  g_free (status);
 }
 
 static void
 ev_window_save_remote (EvWindow  *ev_window,
-		       EvSaveType save_type,
-		       GFile     *src,
-		       GFile     *dst)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-
-	ev_window_reset_progress_cancellable (ev_window);
-	g_object_set_data (G_OBJECT (dst), "ev-window", ev_window);
-	g_object_set_data (G_OBJECT (dst), "save-type", GINT_TO_POINTER (save_type));
-	g_file_copy_async (src, dst,
-			   G_FILE_COPY_OVERWRITE,
-			   G_PRIORITY_DEFAULT,
-			   priv->progress_cancellable,
-			   (GFileProgressCallback)window_save_file_copy_progress_cb,
-			   dst,
-			   (GAsyncReadyCallback)window_save_file_copy_ready_cb,
-			   dst);
-	priv->progress_idle =
-		g_timeout_add_seconds_full (G_PRIORITY_DEFAULT,
-					    1,
-					    (GSourceFunc)show_saving_progress,
-					    dst,
-					    NULL);
-}
-
-static void
-ev_window_clear_save_job (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-
-	if (priv->save_job != NULL) {
-		if (!ev_job_is_finished (priv->save_job))
-			ev_job_cancel (priv->save_job);
-		
-		g_signal_handlers_disconnect_by_func (priv->save_job,
-						      ev_window_save_job_cb,
-						      ev_window);
-		g_object_unref (priv->save_job);
-		priv->save_job = NULL;
-	}
+                       EvSaveType save_type,
+                       GFile     *src,
+                       GFile     *dst) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+
+  ev_window_reset_progress_cancellable (ev_window);
+  g_object_set_data (G_OBJECT (dst), "ev-window", ev_window);
+  g_object_set_data (G_OBJECT (dst), "save-type", GINT_TO_POINTER (save_type));
+  g_file_copy_async (src, dst,
+                     G_FILE_COPY_OVERWRITE,
+                     G_PRIORITY_DEFAULT,
+                     priv->progress_cancellable,
+                     (GFileProgressCallback)window_save_file_copy_progress_cb,
+                     dst,
+                     (GAsyncReadyCallback)window_save_file_copy_ready_cb,
+                     dst);
+  priv->progress_idle =
+    g_timeout_add_seconds_full (G_PRIORITY_DEFAULT,
+                                1,
+                                (GSourceFunc)show_saving_progress,
+                                dst,
+                                NULL);
+}
+
+static void
+ev_window_clear_save_job (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+
+  if (priv->save_job != NULL) {
+    if (!ev_job_is_finished (priv->save_job))
+      ev_job_cancel (priv->save_job);
+
+    g_signal_handlers_disconnect_by_func (priv->save_job,
+                                          ev_window_save_job_cb,
+                                          ev_window);
+    g_object_unref (priv->save_job);
+    priv->save_job = NULL;
+  }
 }
 
 static gboolean
-destroy_window (GtkWidget *window)
-{
-	gtk_widget_destroy (window);
+destroy_window (GtkWidget *window) {
+  gtk_widget_destroy (window);
 
-	return FALSE;
+  return FALSE;
 }
 
 static void
 ev_window_save_job_cb (EvJob     *job,
-		       EvWindow  *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	if (ev_job_is_failed (job)) {
-		priv->close_after_save = FALSE;
-		ev_window_error_message (window, job->error,
-					 _("The file could not be saved as “%s”."),
-					 EV_JOB_SAVE (job)->uri);
-	} else {
-		ev_window_add_recent (window, EV_JOB_SAVE (job)->uri);
-	}
+                       EvWindow  *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  if (ev_job_is_failed (job)) {
+    priv->close_after_save = FALSE;
+    ev_window_error_message (window, job->error,
+                             _("The file could not be saved as “%s”."),
+                             EV_JOB_SAVE (job)->uri);
+  } else {
+    ev_window_add_recent (window, EV_JOB_SAVE (job)->uri);
+  }
 
-	ev_window_clear_save_job (window);
+  ev_window_clear_save_job (window);
 
-	if (priv->close_after_save)
-		g_idle_add ((GSourceFunc)destroy_window, window);
+  if (priv->close_after_save)
+    g_idle_add ((GSourceFunc)destroy_window, window);
 }
 
 static void
 file_save_dialog_response_cb (GtkWidget *fc,
-			      gint       response_id,
-			      EvWindow  *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gchar *uri;
+                              gint       response_id,
+                              EvWindow  *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gchar *uri;
 
-	if (response_id != GTK_RESPONSE_OK) {
-		priv->close_after_save = FALSE;
-		gtk_widget_destroy (fc);
-		return;
-	}
+  if (response_id != GTK_RESPONSE_OK) {
+    priv->close_after_save = FALSE;
+    gtk_widget_destroy (fc);
+    return;
+  }
 
-        ev_window_file_chooser_save_folder (ev_window, GTK_FILE_CHOOSER (fc),
-                                            G_USER_DIRECTORY_DOCUMENTS);
+  ev_window_file_chooser_save_folder (ev_window, GTK_FILE_CHOOSER (fc),
+                                      G_USER_DIRECTORY_DOCUMENTS);
 
-	uri = gtk_file_chooser_get_uri (GTK_FILE_CHOOSER (fc));
+  uri = gtk_file_chooser_get_uri (GTK_FILE_CHOOSER (fc));
 
-	/* FIXME: remote copy should be done here rather than in the save job,
-	 * so that we can track progress and cancel the operation
-	 */
+  /* FIXME: remote copy should be done here rather than in the save job,
+   * so that we can track progress and cancel the operation
+   */
 
-	ev_window_clear_save_job (ev_window);
-	priv->save_job = ev_job_save_new (priv->document,
-						     uri, priv->uri);
-	g_signal_connect (priv->save_job, "finished",
-			  G_CALLBACK (ev_window_save_job_cb),
-			  ev_window);
-	/* The priority doesn't matter for this job */
-	ev_job_scheduler_push_job (priv->save_job, EV_JOB_PRIORITY_NONE);
+  ev_window_clear_save_job (ev_window);
+  priv->save_job = ev_job_save_new (priv->document,
+                                    uri, priv->uri);
+  g_signal_connect (priv->save_job, "finished",
+                    G_CALLBACK (ev_window_save_job_cb),
+                    ev_window);
+  /* The priority doesn't matter for this job */
+  ev_job_scheduler_push_job (priv->save_job, EV_JOB_PRIORITY_NONE);
 
-	g_free (uri);
-	gtk_widget_destroy (fc);
+  g_free (uri);
+  gtk_widget_destroy (fc);
 }
 
 static void
-ev_window_save_as (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	GtkWidget *fc;
-	gchar *base_name, *dir_name, *var_tmp_dir, *tmp_dir;
-	GFile *file, *parent;
-	const gchar *default_dir, *dest_dir, *documents_dir;
+ev_window_save_as (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  GtkWidget *fc;
+  gchar *base_name, *dir_name, *var_tmp_dir, *tmp_dir;
+  GFile *file, *parent;
+  const gchar *default_dir, *dest_dir, *documents_dir;
 
-	fc = gtk_file_chooser_dialog_new (
-		_("Save As…"),
-		GTK_WINDOW (ev_window), GTK_FILE_CHOOSER_ACTION_SAVE,
-		_("_Cancel"), GTK_RESPONSE_CANCEL,
-		_("_Save"), GTK_RESPONSE_OK,
-		NULL);
+  fc = gtk_file_chooser_dialog_new (
+         _("Save As…"),
+         GTK_WINDOW (ev_window), GTK_FILE_CHOOSER_ACTION_SAVE,
+         _("_Cancel"), GTK_RESPONSE_CANCEL,
+         _("_Save"), GTK_RESPONSE_OK,
+         NULL);
 
-	ev_document_factory_add_filters (fc, priv->document);
-	gtk_dialog_set_default_response (GTK_DIALOG (fc), GTK_RESPONSE_OK);
+  ev_document_factory_add_filters (fc, priv->document);
+  gtk_dialog_set_default_response (GTK_DIALOG (fc), GTK_RESPONSE_OK);
 
-	gtk_file_chooser_set_local_only (GTK_FILE_CHOOSER (fc), FALSE);
-	gtk_file_chooser_set_do_overwrite_confirmation (GTK_FILE_CHOOSER (fc), TRUE);
+  gtk_file_chooser_set_local_only (GTK_FILE_CHOOSER (fc), FALSE);
+  gtk_file_chooser_set_do_overwrite_confirmation (GTK_FILE_CHOOSER (fc), TRUE);
 
-	file = g_file_new_for_uri (priv->uri);
-	base_name = priv->edit_name;
-	parent = g_file_get_parent (file);
-	dir_name = g_file_get_path (parent);
-	g_object_unref (parent);
+  file = g_file_new_for_uri (priv->uri);
+  base_name = priv->edit_name;
+  parent = g_file_get_parent (file);
+  dir_name = g_file_get_path (parent);
+  g_object_unref (parent);
 
-	gtk_file_chooser_set_current_name (GTK_FILE_CHOOSER (fc), base_name);
+  gtk_file_chooser_set_current_name (GTK_FILE_CHOOSER (fc), base_name);
 
-	documents_dir = g_get_user_special_dir (G_USER_DIRECTORY_DOCUMENTS);
-	default_dir = g_file_test (documents_dir, G_FILE_TEST_EXISTS | G_FILE_TEST_IS_DIR) ?
-	              documents_dir : g_get_home_dir ();
+  documents_dir = g_get_user_special_dir (G_USER_DIRECTORY_DOCUMENTS);
+  default_dir = g_file_test (documents_dir, G_FILE_TEST_EXISTS | G_FILE_TEST_IS_DIR) ?
+                documents_dir : g_get_home_dir ();
 
-	tmp_dir = g_build_filename ("tmp", NULL);
-	var_tmp_dir = g_build_filename ("var", "tmp", NULL);
-	dest_dir = dir_name && !g_str_has_prefix (dir_name, g_get_tmp_dir ()) &&
-			    !g_str_has_prefix (dir_name, tmp_dir) &&
-	                    !g_str_has_prefix (dir_name, var_tmp_dir) ?
-	                    dir_name : default_dir;
+  tmp_dir = g_build_filename ("tmp", NULL);
+  var_tmp_dir = g_build_filename ("var", "tmp", NULL);
+  dest_dir = dir_name && !g_str_has_prefix (dir_name, g_get_tmp_dir ()) &&
+             !g_str_has_prefix (dir_name, tmp_dir) &&
+             !g_str_has_prefix (dir_name, var_tmp_dir) ?
+             dir_name : default_dir;
 
-	gtk_file_chooser_set_current_folder (GTK_FILE_CHOOSER (fc),
-					     dest_dir);
+  gtk_file_chooser_set_current_folder (GTK_FILE_CHOOSER (fc),
+                                       dest_dir);
 
-	g_object_unref (file);
-	g_free (tmp_dir);
-	g_free (var_tmp_dir);
-	g_free (dir_name);
+  g_object_unref (file);
+  g_free (tmp_dir);
+  g_free (var_tmp_dir);
+  g_free (dir_name);
 
-	g_signal_connect (fc, "response",
-			  G_CALLBACK (file_save_dialog_response_cb),
-			  ev_window);
+  g_signal_connect (fc, "response",
+                    G_CALLBACK (file_save_dialog_response_cb),
+                    ev_window);
 
-	gtk_widget_show (fc);
+  gtk_widget_show (fc);
 }
 
 static void
 ev_window_cmd_save_as (GSimpleAction *action,
-		       GVariant      *parameter,
-		       gpointer       user_data)
-{
-	EvWindow *window = user_data;
+                       GVariant      *parameter,
+                       gpointer       user_data) {
+  EvWindow *window = user_data;
 
-	ev_window_save_as (window);
+  ev_window_save_as (window);
 }
 
 static void
 ev_window_cmd_send_to (GSimpleAction *action,
-		       GVariant      *parameter,
-		       gpointer       user_data)
-{
-	EvWindow   *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	GAppInfo   *app_info;
-	gchar      *command;
-	const char *uri;
-	char       *unescaped_uri;
-	GError     *error = NULL;
-
-	uri = priv->local_uri ? priv->local_uri : priv->uri;
-	unescaped_uri = g_uri_unescape_string (uri, NULL);
-	command = g_strdup_printf ("%s \"%s\"", nautilus_sendto, unescaped_uri);
-	g_free (unescaped_uri);
-	app_info = g_app_info_create_from_commandline (command, NULL, 0, &error);
-	if (app_info) {
-		GdkAppLaunchContext *context;
-		GdkScreen           *screen;
-
-		screen = gtk_window_get_screen (GTK_WINDOW (ev_window));
-		context = gdk_display_get_app_launch_context (gdk_screen_get_display (screen));
-		gdk_app_launch_context_set_screen (context, screen);
-		gdk_app_launch_context_set_timestamp (context, gtk_get_current_event_time ());
-		g_app_info_launch (app_info, NULL, G_APP_LAUNCH_CONTEXT (context), &error);
-		g_object_unref (context);
-
-		g_object_unref (app_info);
-	}
-	g_free (command);
-
-	if (error) {
-		ev_window_error_message (ev_window, error, "%s",
-					 _("Could not send current document"));
-		g_error_free (error);
-	}
+                       GVariant      *parameter,
+                       gpointer       user_data) {
+  EvWindow   *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  GAppInfo   *app_info;
+  gchar      *command;
+  const char *uri;
+  char       *unescaped_uri;
+  GError     *error = NULL;
+
+  uri = priv->local_uri ? priv->local_uri : priv->uri;
+  unescaped_uri = g_uri_unescape_string (uri, NULL);
+  command = g_strdup_printf ("%s \"%s\"", nautilus_sendto, unescaped_uri);
+  g_free (unescaped_uri);
+  app_info = g_app_info_create_from_commandline (command, NULL, 0, &error);
+  if (app_info) {
+    GdkAppLaunchContext *context;
+    GdkScreen           *screen;
+
+    screen = gtk_window_get_screen (GTK_WINDOW (ev_window));
+    context = gdk_display_get_app_launch_context (gdk_screen_get_display (screen));
+    gdk_app_launch_context_set_screen (context, screen);
+    gdk_app_launch_context_set_timestamp (context, gtk_get_current_event_time ());
+    g_app_info_launch (app_info, NULL, G_APP_LAUNCH_CONTEXT (context), &error);
+    g_object_unref (context);
+
+    g_object_unref (app_info);
+  }
+  g_free (command);
+
+  if (error) {
+    ev_window_error_message (ev_window, error, "%s",
+                             _("Could not send current document"));
+    g_error_free (error);
+  }
 }
 
 static void
 ev_window_cmd_open_containing_folder (GSimpleAction *action,
-				      GVariant      *parameter,
-				      gpointer       user_data)
-{
-	EvWindow *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                                      GVariant      *parameter,
+                                      gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	guint32 timestamp;
-	GAppInfo *app = NULL;
-	GdkAppLaunchContext *context;
-	GdkDisplay *display;
-	GdkScreen *screen;
-	GFile *file;
-	GList list;
-	GError *error = NULL;
+  guint32 timestamp;
+  GAppInfo *app = NULL;
+  GdkAppLaunchContext *context;
+  GdkDisplay *display;
+  GdkScreen *screen;
+  GFile *file;
+  GList list;
+  GError *error = NULL;
 
-	app =  g_app_info_get_default_for_type ("inode/directory", FALSE);
+  app =  g_app_info_get_default_for_type ("inode/directory", FALSE);
 
-	if (app == NULL) {
-		return;
-	}
+  if (app == NULL) {
+    return;
+  }
 
-	file = g_file_new_for_uri (priv->uri);
-	list.next = list.prev = NULL;
-	list.data = file;
+  file = g_file_new_for_uri (priv->uri);
+  list.next = list.prev = NULL;
+  list.data = file;
 
-	display = gtk_widget_get_display (GTK_WIDGET (window));
-	screen = gtk_widget_get_screen (GTK_WIDGET (window));
-	timestamp = gtk_get_current_event_time ();
+  display = gtk_widget_get_display (GTK_WIDGET (window));
+  screen = gtk_widget_get_screen (GTK_WIDGET (window));
+  timestamp = gtk_get_current_event_time ();
 
-	context = gdk_display_get_app_launch_context (display);
-	gdk_app_launch_context_set_screen (context, screen);
-	gdk_app_launch_context_set_timestamp (context, timestamp);
+  context = gdk_display_get_app_launch_context (display);
+  gdk_app_launch_context_set_screen (context, screen);
+  gdk_app_launch_context_set_timestamp (context, timestamp);
 
-	g_app_info_launch (app, &list,
-                           G_APP_LAUNCH_CONTEXT (context), &error);
+  g_app_info_launch (app, &list,
+                     G_APP_LAUNCH_CONTEXT (context), &error);
 
-	if (error != NULL) {
-		gchar *uri;
+  if (error != NULL) {
+    gchar *uri;
 
-		uri = g_file_get_uri (file);
-		g_warning ("Could not show containing folder for \"%s\": %s",
-			   uri, error->message);
+    uri = g_file_get_uri (file);
+    g_warning ("Could not show containing folder for \"%s\": %s",
+               uri, error->message);
 
-		g_error_free (error);
-		g_free (uri);
-	}
+    g_error_free (error);
+    g_free (uri);
+  }
 
-	g_object_unref (context);
-	g_object_unref (app);
+  g_object_unref (context);
+  g_object_unref (app);
 }
 
 static GKeyFile *
-get_print_settings_file (void)
-{
-	GKeyFile *print_settings_file;
-	gchar    *filename;
-        GError *error = NULL;
+get_print_settings_file (void) {
+  GKeyFile *print_settings_file;
+  gchar    *filename;
+  GError *error = NULL;
 
-	print_settings_file = g_key_file_new ();
+  print_settings_file = g_key_file_new ();
 
-	filename = g_build_filename (ev_application_get_dot_dir (EV_APP, FALSE),
-                                     EV_PRINT_SETTINGS_FILE, NULL);
-        if (!g_key_file_load_from_file (print_settings_file,
-                                        filename,
-                                        G_KEY_FILE_KEEP_COMMENTS |
-                                        G_KEY_FILE_KEEP_TRANSLATIONS,
-                                        &error)) {
+  filename = g_build_filename (ev_application_get_dot_dir (EV_APP, FALSE),
+                               EV_PRINT_SETTINGS_FILE, NULL);
+  if (!g_key_file_load_from_file (print_settings_file,
+                                  filename,
+                                  G_KEY_FILE_KEEP_COMMENTS |
+                                  G_KEY_FILE_KEEP_TRANSLATIONS,
+                                  &error)) {
 
-                /* Don't warn if the file simply doesn't exist */
-                if (!g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_NOENT))
-			g_warning ("%s", error->message);
+    /* Don't warn if the file simply doesn't exist */
+    if (!g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_NOENT))
+      g_warning ("%s", error->message);
 
-                g_error_free (error);
-	}
+    g_error_free (error);
+  }
 
-	g_free (filename);
+  g_free (filename);
 
-	return print_settings_file;
+  return print_settings_file;
 }
 
 static void
-save_print_setting_file (GKeyFile *key_file)
-{
-	gchar  *filename;
-	gchar  *data;
-	gsize  data_length;
-	GError *error = NULL;
+save_print_setting_file (GKeyFile *key_file) {
+  gchar  *filename;
+  gchar  *data;
+  gsize  data_length;
+  GError *error = NULL;
 
-	filename = g_build_filename (ev_application_get_dot_dir (EV_APP, TRUE),
-				     EV_PRINT_SETTINGS_FILE, NULL);
-	data = g_key_file_to_data (key_file, &data_length, NULL);
-	g_file_set_contents (filename, data, data_length, &error);
-	if (error) {
-		g_warning ("Failed to save print settings: %s", error->message);
-		g_error_free (error);
-	}
-	g_free (data);
-	g_free (filename);
+  filename = g_build_filename (ev_application_get_dot_dir (EV_APP, TRUE),
+                               EV_PRINT_SETTINGS_FILE, NULL);
+  data = g_key_file_to_data (key_file, &data_length, NULL);
+  g_file_set_contents (filename, data, data_length, &error);
+  if (error) {
+    g_warning ("Failed to save print settings: %s", error->message);
+    g_error_free (error);
+  }
+  g_free (data);
+  g_free (filename);
 }
 
 static void
 ev_window_save_print_settings (EvWindow         *window,
-			       GtkPrintSettings *print_settings)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	GKeyFile *key_file;
-	gint      i;
+                               GtkPrintSettings *print_settings) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  GKeyFile *key_file;
+  gint      i;
 
-	key_file = get_print_settings_file ();
-	gtk_print_settings_to_key_file (print_settings, key_file, EV_PRINT_SETTINGS_GROUP);
+  key_file = get_print_settings_file ();
+  gtk_print_settings_to_key_file (print_settings, key_file, EV_PRINT_SETTINGS_GROUP);
 
-	/* Always Remove n_copies from global settings */
-	g_key_file_remove_key (key_file, EV_PRINT_SETTINGS_GROUP, GTK_PRINT_SETTINGS_N_COPIES, NULL);
+  /* Always Remove n_copies from global settings */
+  g_key_file_remove_key (key_file, EV_PRINT_SETTINGS_GROUP, GTK_PRINT_SETTINGS_N_COPIES, NULL);
 
-	/* Save print settings that are specific to the document */
-	for (i = 0; i < G_N_ELEMENTS (document_print_settings); i++) {
-		/* Remove it from global settings */
-		g_key_file_remove_key (key_file, EV_PRINT_SETTINGS_GROUP,
-				       document_print_settings[i], NULL);
+  /* Save print settings that are specific to the document */
+  for (i = 0; i < G_N_ELEMENTS (document_print_settings); i++) {
+    /* Remove it from global settings */
+    g_key_file_remove_key (key_file, EV_PRINT_SETTINGS_GROUP,
+                           document_print_settings[i], NULL);
 
-		if (priv->metadata) {
-			const gchar *value;
+    if (priv->metadata) {
+      const gchar *value;
 
-			value = gtk_print_settings_get (print_settings,
-							document_print_settings[i]);
-			ev_metadata_set_string (priv->metadata,
-						document_print_settings[i], value);
-		}
-	}
+      value = gtk_print_settings_get (print_settings,
+                                      document_print_settings[i]);
+      ev_metadata_set_string (priv->metadata,
+                              document_print_settings[i], value);
+    }
+  }
 
-	save_print_setting_file (key_file);
-	g_key_file_free (key_file);
+  save_print_setting_file (key_file);
+  g_key_file_free (key_file);
 }
 
 static void
 ev_window_save_print_page_setup (EvWindow     *window,
-				 GtkPageSetup *page_setup)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	GKeyFile *key_file;
-
-	key_file = get_print_settings_file ();
-	gtk_page_setup_to_key_file (page_setup, key_file, EV_PAGE_SETUP_GROUP);
-
-	/* Do not save document settings in global file */
-	g_key_file_remove_key (key_file, EV_PAGE_SETUP_GROUP,
-			       "page-setup-orientation", NULL);
-	g_key_file_remove_key (key_file, EV_PAGE_SETUP_GROUP,
-			       "page-setup-margin-top", NULL);
-	g_key_file_remove_key (key_file, EV_PAGE_SETUP_GROUP,
-			       "page-setup-margin-bottom", NULL);
-	g_key_file_remove_key (key_file, EV_PAGE_SETUP_GROUP,
-			       "page-setup-margin-left", NULL);
-	g_key_file_remove_key (key_file, EV_PAGE_SETUP_GROUP,
-			       "page-setup-margin-right", NULL);
-
-	save_print_setting_file (key_file);
-	g_key_file_free (key_file);
-
-	if (!priv->metadata)
-		return;
-
-	/* Save page setup options that are specific to the document */
-	ev_metadata_set_int (priv->metadata, "page-setup-orientation",
-			     gtk_page_setup_get_orientation (page_setup));
-	ev_metadata_set_double (priv->metadata, "page-setup-margin-top",
-				gtk_page_setup_get_top_margin (page_setup, GTK_UNIT_MM));
-	ev_metadata_set_double (priv->metadata, "page-setup-margin-bottom",
-				gtk_page_setup_get_bottom_margin (page_setup, GTK_UNIT_MM));
-	ev_metadata_set_double (priv->metadata, "page-setup-margin-left",
-				gtk_page_setup_get_left_margin (page_setup, GTK_UNIT_MM));
-	ev_metadata_set_double (priv->metadata, "page-setup-margin-right",
-				gtk_page_setup_get_right_margin (page_setup, GTK_UNIT_MM));
+                                 GtkPageSetup *page_setup) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  GKeyFile *key_file;
+
+  key_file = get_print_settings_file ();
+  gtk_page_setup_to_key_file (page_setup, key_file, EV_PAGE_SETUP_GROUP);
+
+  /* Do not save document settings in global file */
+  g_key_file_remove_key (key_file, EV_PAGE_SETUP_GROUP,
+                         "page-setup-orientation", NULL);
+  g_key_file_remove_key (key_file, EV_PAGE_SETUP_GROUP,
+                         "page-setup-margin-top", NULL);
+  g_key_file_remove_key (key_file, EV_PAGE_SETUP_GROUP,
+                         "page-setup-margin-bottom", NULL);
+  g_key_file_remove_key (key_file, EV_PAGE_SETUP_GROUP,
+                         "page-setup-margin-left", NULL);
+  g_key_file_remove_key (key_file, EV_PAGE_SETUP_GROUP,
+                         "page-setup-margin-right", NULL);
+
+  save_print_setting_file (key_file);
+  g_key_file_free (key_file);
+
+  if (!priv->metadata)
+    return;
+
+  /* Save page setup options that are specific to the document */
+  ev_metadata_set_int (priv->metadata, "page-setup-orientation",
+                       gtk_page_setup_get_orientation (page_setup));
+  ev_metadata_set_double (priv->metadata, "page-setup-margin-top",
+                          gtk_page_setup_get_top_margin (page_setup, GTK_UNIT_MM));
+  ev_metadata_set_double (priv->metadata, "page-setup-margin-bottom",
+                          gtk_page_setup_get_bottom_margin (page_setup, GTK_UNIT_MM));
+  ev_metadata_set_double (priv->metadata, "page-setup-margin-left",
+                          gtk_page_setup_get_left_margin (page_setup, GTK_UNIT_MM));
+  ev_metadata_set_double (priv->metadata, "page-setup-margin-right",
+                          gtk_page_setup_get_right_margin (page_setup, GTK_UNIT_MM));
 }
 
 static void
 ev_window_load_print_settings_from_metadata (EvWindow         *window,
-					     GtkPrintSettings *print_settings)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	gint i;
+                                             GtkPrintSettings *print_settings) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  gint i;
 
-	if (!priv->metadata)
-		return;
+  if (!priv->metadata)
+    return;
 
-	/* Load print setting that are specific to the document */
-	for (i = 0; i < G_N_ELEMENTS (document_print_settings); i++) {
-		gchar *value = NULL;
+  /* Load print setting that are specific to the document */
+  for (i = 0; i < G_N_ELEMENTS (document_print_settings); i++) {
+    gchar *value = NULL;
 
-		ev_metadata_get_string (priv->metadata,
-					document_print_settings[i], &value);
-		gtk_print_settings_set (print_settings,
-					document_print_settings[i], value);
-	}
+    ev_metadata_get_string (priv->metadata,
+                            document_print_settings[i], &value);
+    gtk_print_settings_set (print_settings,
+                            document_print_settings[i], value);
+  }
 }
 
 static void
 ev_window_load_print_page_setup_from_metadata (EvWindow     *window,
-					       GtkPageSetup *page_setup)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	gint          int_value;
-	gdouble       double_value;
-	GtkPaperSize *paper_size = gtk_page_setup_get_paper_size (page_setup);
-
-	/* Load page setup options that are specific to the document */
-	if (priv->metadata &&
-	    ev_metadata_get_int (priv->metadata, "page-setup-orientation", &int_value)) {
-		gtk_page_setup_set_orientation (page_setup, int_value);
-	} else {
-		gtk_page_setup_set_orientation (page_setup, GTK_PAGE_ORIENTATION_PORTRAIT);
-	}
-
-	if (priv->metadata &&
-	    ev_metadata_get_double (priv->metadata, "page-setup-margin-top", &double_value)) {
-		gtk_page_setup_set_top_margin (page_setup, double_value, GTK_UNIT_MM);
-	} else {
-		gtk_page_setup_set_top_margin (page_setup,
-					       gtk_paper_size_get_default_top_margin (paper_size, GTK_UNIT_MM),
-					       GTK_UNIT_MM);
-	}
-
-	if (priv->metadata &&
-	    ev_metadata_get_double (priv->metadata, "page-setup-margin-bottom", &double_value)) {
-		gtk_page_setup_set_bottom_margin (page_setup, double_value, GTK_UNIT_MM);
-	} else {
-		gtk_page_setup_set_bottom_margin (page_setup,
-						  gtk_paper_size_get_default_bottom_margin (paper_size, GTK_UNIT_MM),
-						  GTK_UNIT_MM);
-	}
-
-	if (priv->metadata &&
-	    ev_metadata_get_double (priv->metadata, "page-setup-margin-left", &double_value)) {
-		gtk_page_setup_set_left_margin (page_setup, double_value, GTK_UNIT_MM);
-	} else {
-		gtk_page_setup_set_left_margin (page_setup,
-						gtk_paper_size_get_default_left_margin (paper_size, GTK_UNIT_MM),
-						GTK_UNIT_MM);
-	}
-
-	if (priv->metadata &&
-	    ev_metadata_get_double (priv->metadata, "page-setup-margin-right", &double_value)) {
-		gtk_page_setup_set_right_margin (page_setup, double_value, GTK_UNIT_MM);
-	} else {
-		gtk_page_setup_set_right_margin (page_setup,
-						 gtk_paper_size_get_default_right_margin (paper_size, GTK_UNIT_MM),
-						 GTK_UNIT_MM);
-	}
+                                               GtkPageSetup *page_setup) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  gint          int_value;
+  gdouble       double_value;
+  GtkPaperSize *paper_size = gtk_page_setup_get_paper_size (page_setup);
+
+  /* Load page setup options that are specific to the document */
+  if (priv->metadata &&
+      ev_metadata_get_int (priv->metadata, "page-setup-orientation", &int_value)) {
+    gtk_page_setup_set_orientation (page_setup, int_value);
+  } else {
+    gtk_page_setup_set_orientation (page_setup, GTK_PAGE_ORIENTATION_PORTRAIT);
+  }
+
+  if (priv->metadata &&
+      ev_metadata_get_double (priv->metadata, "page-setup-margin-top", &double_value)) {
+    gtk_page_setup_set_top_margin (page_setup, double_value, GTK_UNIT_MM);
+  } else {
+    gtk_page_setup_set_top_margin (page_setup,
+                                   gtk_paper_size_get_default_top_margin (paper_size, GTK_UNIT_MM),
+                                   GTK_UNIT_MM);
+  }
+
+  if (priv->metadata &&
+      ev_metadata_get_double (priv->metadata, "page-setup-margin-bottom", &double_value)) {
+    gtk_page_setup_set_bottom_margin (page_setup, double_value, GTK_UNIT_MM);
+  } else {
+    gtk_page_setup_set_bottom_margin (page_setup,
+                                      gtk_paper_size_get_default_bottom_margin (paper_size, GTK_UNIT_MM),
+                                      GTK_UNIT_MM);
+  }
+
+  if (priv->metadata &&
+      ev_metadata_get_double (priv->metadata, "page-setup-margin-left", &double_value)) {
+    gtk_page_setup_set_left_margin (page_setup, double_value, GTK_UNIT_MM);
+  } else {
+    gtk_page_setup_set_left_margin (page_setup,
+                                    gtk_paper_size_get_default_left_margin (paper_size, GTK_UNIT_MM),
+                                    GTK_UNIT_MM);
+  }
+
+  if (priv->metadata &&
+      ev_metadata_get_double (priv->metadata, "page-setup-margin-right", &double_value)) {
+    gtk_page_setup_set_right_margin (page_setup, double_value, GTK_UNIT_MM);
+  } else {
+    gtk_page_setup_set_right_margin (page_setup,
+                                     gtk_paper_size_get_default_right_margin (paper_size, GTK_UNIT_MM),
+                                     GTK_UNIT_MM);
+  }
 }
 
 static GtkPrintSettings *
-get_print_settings (GKeyFile *key_file)
-{
-	GtkPrintSettings *print_settings;
+get_print_settings (GKeyFile *key_file) {
+  GtkPrintSettings *print_settings;
 
-	print_settings = g_key_file_has_group (key_file, EV_PRINT_SETTINGS_GROUP) ?
-		gtk_print_settings_new_from_key_file (key_file, EV_PRINT_SETTINGS_GROUP, NULL) :
-		gtk_print_settings_new ();
+  print_settings = g_key_file_has_group (key_file, EV_PRINT_SETTINGS_GROUP) ?
+                   gtk_print_settings_new_from_key_file (key_file, EV_PRINT_SETTINGS_GROUP, NULL) :
+                   gtk_print_settings_new ();
 
-	return print_settings ? print_settings : gtk_print_settings_new ();
+  return print_settings ? print_settings : gtk_print_settings_new ();
 }
 
 static GtkPageSetup *
-get_print_page_setup (GKeyFile *key_file)
-{
-	GtkPageSetup *page_setup;
+get_print_page_setup (GKeyFile *key_file) {
+  GtkPageSetup *page_setup;
 
-	page_setup = g_key_file_has_group (key_file, EV_PAGE_SETUP_GROUP) ?
-		gtk_page_setup_new_from_key_file (key_file, EV_PAGE_SETUP_GROUP, NULL) :
-		gtk_page_setup_new ();
+  page_setup = g_key_file_has_group (key_file, EV_PAGE_SETUP_GROUP) ?
+               gtk_page_setup_new_from_key_file (key_file, EV_PAGE_SETUP_GROUP, NULL) :
+               gtk_page_setup_new ();
 
-	return page_setup ? page_setup : gtk_page_setup_new ();
+  return page_setup ? page_setup : gtk_page_setup_new ();
 }
 
 static void
-ev_window_print_cancel (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	EvPrintOperation *op;
+ev_window_print_cancel (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  EvPrintOperation *op;
 
-	if (!priv->print_queue)
-		return;
+  if (!priv->print_queue)
+    return;
 
-	while ((op = g_queue_peek_tail (priv->print_queue))) {
-		ev_print_operation_cancel (op);
-	}
+  while ((op = g_queue_peek_tail (priv->print_queue))) {
+    ev_print_operation_cancel (op);
+  }
 }
 
 static void
 ev_window_print_update_pending_jobs_message (EvWindow *ev_window,
-					     gint      n_jobs)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gchar *text = NULL;
+                                             gint      n_jobs) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gchar *text = NULL;
+
+  if (!EV_IS_PROGRESS_MESSAGE_AREA (priv->message_area) ||
+      !priv->print_queue)
+    return;
 
-	if (!EV_IS_PROGRESS_MESSAGE_AREA (priv->message_area) ||
-	    !priv->print_queue)
-		return;
+  if (n_jobs == 0) {
+    ev_window_set_message_area (ev_window, NULL);
+    return;
+  }
 
-	if (n_jobs == 0) {
-		ev_window_set_message_area (ev_window, NULL);
-		return;
-	}
-	
-	if (n_jobs > 1) {
-		text = g_strdup_printf (ngettext ("%d pending job in queue",
-						  "%d pending jobs in queue",
-						  n_jobs - 1), n_jobs - 1);
-	}
+  if (n_jobs > 1) {
+    text = g_strdup_printf (ngettext ("%d pending job in queue",
+                                      "%d pending jobs in queue",
+                                      n_jobs - 1), n_jobs - 1);
+  }
 
-	ev_message_area_set_secondary_text (EV_MESSAGE_AREA (priv->message_area),
-					    text);
-	g_free (text);
+  ev_message_area_set_secondary_text (EV_MESSAGE_AREA (priv->message_area),
+                                      text);
+  g_free (text);
 }
 
 static void
 ev_window_print_operation_done (EvPrintOperation       *op,
-				GtkPrintOperationResult result,
-				EvWindow               *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gint n_jobs;
-
-	switch (result) {
-	case GTK_PRINT_OPERATION_RESULT_APPLY: {
-		GtkPrintSettings *print_settings;
-
-		print_settings = ev_print_operation_get_print_settings (op);
-		ev_window_save_print_settings (ev_window, print_settings);
-
-		if (ev_print_operation_get_embed_page_setup (op)) {
-			GtkPageSetup *page_setup;
-
-			page_setup = ev_print_operation_get_default_page_setup (op);
-			ev_window_save_print_page_setup (ev_window, page_setup);
-		}
-	}
-
-		break;
-	case GTK_PRINT_OPERATION_RESULT_ERROR: {
-		GtkWidget *dialog;
-		GError    *error = NULL;
-
-
-		ev_print_operation_get_error (op, &error);
-		
-		/* The message area is already used by
-		 * the printing progress, so it's better to
-		 * use a popup dialog in this case
-		 */
-		dialog = gtk_message_dialog_new (GTK_WINDOW (ev_window),
-						 GTK_DIALOG_DESTROY_WITH_PARENT,
-						 GTK_MESSAGE_ERROR,
-						 GTK_BUTTONS_CLOSE,
-						 "%s", _("Failed to print document"));
-		gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog),
-							  "%s", error->message);
-		g_signal_connect (dialog, "response",
-				  G_CALLBACK (gtk_widget_destroy),
-				  NULL);
-		gtk_widget_show (dialog);
-		
-		g_error_free (error);
-	}
-		break;
-	case GTK_PRINT_OPERATION_RESULT_CANCEL:
-	default:
-		break;
-	}
-
-	g_queue_remove (priv->print_queue, op);
-	g_object_unref (op);
-	n_jobs = g_queue_get_length (priv->print_queue);
-	ev_window_print_update_pending_jobs_message (ev_window, n_jobs);
-
-	if (n_jobs == 0 && priv->close_after_print)
-		g_idle_add ((GSourceFunc)destroy_window,
-			    ev_window);
+                                GtkPrintOperationResult result,
+                                EvWindow               *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gint n_jobs;
+
+  switch (result) {
+    case GTK_PRINT_OPERATION_RESULT_APPLY: {
+      GtkPrintSettings *print_settings;
+
+      print_settings = ev_print_operation_get_print_settings (op);
+      ev_window_save_print_settings (ev_window, print_settings);
+
+      if (ev_print_operation_get_embed_page_setup (op)) {
+        GtkPageSetup *page_setup;
+
+        page_setup = ev_print_operation_get_default_page_setup (op);
+        ev_window_save_print_page_setup (ev_window, page_setup);
+      }
+    }
+
+    break;
+    case GTK_PRINT_OPERATION_RESULT_ERROR: {
+      GtkWidget *dialog;
+      GError    *error = NULL;
+
+
+      ev_print_operation_get_error (op, &error);
+
+      /* The message area is already used by
+       * the printing progress, so it's better to
+       * use a popup dialog in this case
+       */
+      dialog = gtk_message_dialog_new (GTK_WINDOW (ev_window),
+                                       GTK_DIALOG_DESTROY_WITH_PARENT,
+                                       GTK_MESSAGE_ERROR,
+                                       GTK_BUTTONS_CLOSE,
+                                       "%s", _("Failed to print document"));
+      gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog),
+                                                "%s", error->message);
+      g_signal_connect (dialog, "response",
+                        G_CALLBACK (gtk_widget_destroy),
+                        NULL);
+      gtk_widget_show (dialog);
+
+      g_error_free (error);
+    }
+    break;
+    case GTK_PRINT_OPERATION_RESULT_CANCEL:
+    default:
+      break;
+  }
+
+  g_queue_remove (priv->print_queue, op);
+  g_object_unref (op);
+  n_jobs = g_queue_get_length (priv->print_queue);
+  ev_window_print_update_pending_jobs_message (ev_window, n_jobs);
+
+  if (n_jobs == 0 && priv->close_after_print)
+    g_idle_add ((GSourceFunc)destroy_window,
+                ev_window);
 }
 
 static void
 ev_window_print_progress_response_cb (EvProgressMessageArea *area,
-				      gint                   response,
-				      EvWindow              *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                                      gint                   response,
+                                      EvWindow              *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (response == GTK_RESPONSE_CANCEL) {
-		EvPrintOperation *op;
+  if (response == GTK_RESPONSE_CANCEL) {
+    EvPrintOperation *op;
 
-		op = g_queue_peek_tail (priv->print_queue);
-		ev_print_operation_cancel (op);
-	} else {
-		gtk_widget_hide (GTK_WIDGET (area));
-	}
+    op = g_queue_peek_tail (priv->print_queue);
+    ev_print_operation_cancel (op);
+  } else {
+    gtk_widget_hide (GTK_WIDGET (area));
+  }
 }
 
 static void
 ev_window_print_operation_status_changed (EvPrintOperation *op,
-					  EvWindow         *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	const gchar *status;
-	gdouble      fraction;
-
-	status = ev_print_operation_get_status (op);
-	fraction = ev_print_operation_get_progress (op);
-	
-	if (!priv->message_area) {
-		GtkWidget   *area;
-		const gchar *job_name;
-		gchar       *text;
-
-		job_name = ev_print_operation_get_job_name (op);
-		text = g_strdup_printf (_("Printing job “%s”"), job_name);
-
-		area = ev_progress_message_area_new ("document-print-symbolic",
-						     text,
-						     _("C_ancel"),
-						     GTK_RESPONSE_CANCEL,
-						     NULL);
-		ev_window_print_update_pending_jobs_message (ev_window, 1);
-		g_signal_connect (area, "response",
-				  G_CALLBACK (ev_window_print_progress_response_cb),
-				  ev_window);
-		gtk_widget_show (area);
-		ev_window_set_message_area (ev_window, area);
-		g_free (text);
-	}
-
-	ev_progress_message_area_set_status (EV_PROGRESS_MESSAGE_AREA (priv->message_area),
-					     status);
-	ev_progress_message_area_set_fraction (EV_PROGRESS_MESSAGE_AREA (priv->message_area),
-					       fraction);
+                                          EvWindow         *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  const gchar *status;
+  gdouble      fraction;
+
+  status = ev_print_operation_get_status (op);
+  fraction = ev_print_operation_get_progress (op);
+
+  if (!priv->message_area) {
+    GtkWidget   *area;
+    const gchar *job_name;
+    gchar       *text;
+
+    job_name = ev_print_operation_get_job_name (op);
+    text = g_strdup_printf (_("Printing job “%s”"), job_name);
+
+    area = ev_progress_message_area_new ("document-print-symbolic",
+                                         text,
+                                         _("C_ancel"),
+                                         GTK_RESPONSE_CANCEL,
+                                         NULL);
+    ev_window_print_update_pending_jobs_message (ev_window, 1);
+    g_signal_connect (area, "response",
+                      G_CALLBACK (ev_window_print_progress_response_cb),
+                      ev_window);
+    gtk_widget_show (area);
+    ev_window_set_message_area (ev_window, area);
+    g_free (text);
+  }
+
+  ev_progress_message_area_set_status (EV_PROGRESS_MESSAGE_AREA (priv->message_area),
+                                       status);
+  ev_progress_message_area_set_fraction (EV_PROGRESS_MESSAGE_AREA (priv->message_area),
+                                         fraction);
 }
 
 static void
 ev_window_print_operation_begin_print (EvPrintOperation *op,
-				       EvWindow         *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                                       EvWindow         *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (!priv->print_queue)
-		priv->print_queue = g_queue_new ();
+  if (!priv->print_queue)
+    priv->print_queue = g_queue_new ();
 
-	g_queue_push_head (priv->print_queue, op);
-	ev_window_print_update_pending_jobs_message (ev_window,
-						     g_queue_get_length (priv->print_queue));
+  g_queue_push_head (priv->print_queue, op);
+  ev_window_print_update_pending_jobs_message (ev_window,
+                                               g_queue_get_length (priv->print_queue));
 }
 
 void
 ev_window_print_range (EvWindow *ev_window,
-		       gint      first_page,
-		       gint      last_page)
-{
-	EvPrintOperation *op;
-	GKeyFile         *print_settings_file;
-	GtkPrintSettings *print_settings;
-	GtkPageSetup     *print_page_setup;
-	gint              current_page;
-	gint              document_last_page;
-	gboolean          embed_page_setup;
-	gchar            *output_basename;
-	gchar            *dot;
-	EvWindowPrivate *priv;
-
-	g_return_if_fail (EV_IS_WINDOW (ev_window));
-	priv = GET_PRIVATE (ev_window);
-	g_return_if_fail (priv->document != NULL);
-
-	if (!priv->print_queue)
-		priv->print_queue = g_queue_new ();
-
-	op = ev_print_operation_new (priv->document);
-	if (!op) {
-		g_warning ("%s", "Printing is not supported for document\n");
-		return;
-	}
-
-	g_signal_connect (op, "begin_print",
-			  G_CALLBACK (ev_window_print_operation_begin_print),
-			  (gpointer)ev_window);
-	g_signal_connect (op, "status_changed",
-			  G_CALLBACK (ev_window_print_operation_status_changed),
-			  (gpointer)ev_window);
-	g_signal_connect (op, "done",
-			  G_CALLBACK (ev_window_print_operation_done),
-			  (gpointer)ev_window);
-
-	current_page = ev_document_model_get_page (priv->model);
-	document_last_page = ev_document_get_n_pages (priv->document);
-
-	print_settings_file = get_print_settings_file ();
-
-	print_settings = get_print_settings (print_settings_file);
-	ev_window_load_print_settings_from_metadata (ev_window, print_settings);
-
-	print_page_setup = get_print_page_setup (print_settings_file);
-	ev_window_load_print_page_setup_from_metadata (ev_window, print_page_setup);
-
-	if (first_page != 1 || last_page != document_last_page) {
-		GtkPageRange range;
-
-		/* Ranges in GtkPrint are 0 - N */
-		range.start = first_page - 1;
-		range.end = last_page - 1;
-
-		gtk_print_settings_set_print_pages (print_settings,
-						    GTK_PRINT_PAGES_RANGES);
-		gtk_print_settings_set_page_ranges (print_settings,
-						    &range, 1);
-	}
-
-	output_basename = g_strdup (priv->edit_name);
-	dot = g_strrstr (output_basename, ".");
-	if (dot)
-		dot[0] = '\0';
-
-	/* Set output basename for printing to file */
-	gtk_print_settings_set (print_settings,
-			        GTK_PRINT_SETTINGS_OUTPUT_BASENAME,
-			        output_basename);
-	g_free (output_basename);
-
-	ev_print_operation_set_job_name (op, gtk_window_get_title (GTK_WINDOW (ev_window)));
-	ev_print_operation_set_current_page (op, current_page);
-	ev_print_operation_set_print_settings (op, print_settings);
-	ev_print_operation_set_default_page_setup (op, print_page_setup);
-	embed_page_setup = priv->lockdown_settings ?
-		!g_settings_get_boolean (priv->lockdown_settings,
-					 GS_LOCKDOWN_PRINT_SETUP) :
-		TRUE;
-	ev_print_operation_set_embed_page_setup (op, embed_page_setup);
-
-	g_object_unref (print_settings);
-	g_object_unref (print_page_setup);
-	g_key_file_free (print_settings_file);
-
-	ev_print_operation_run (op, GTK_WINDOW (ev_window));
-}
-
-static void
-ev_window_print (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-
-	ev_window_print_range (window, 1,
-			       ev_document_get_n_pages (priv->document));
+                       gint      first_page,
+                       gint      last_page) {
+  EvPrintOperation *op;
+  GKeyFile         *print_settings_file;
+  GtkPrintSettings *print_settings;
+  GtkPageSetup     *print_page_setup;
+  gint              current_page;
+  gint              document_last_page;
+  gboolean          embed_page_setup;
+  gchar            *output_basename;
+  gchar            *dot;
+  EvWindowPrivate *priv;
+
+  g_return_if_fail (EV_IS_WINDOW (ev_window));
+  priv = GET_PRIVATE (ev_window);
+  g_return_if_fail (priv->document != NULL);
+
+  if (!priv->print_queue)
+    priv->print_queue = g_queue_new ();
+
+  op = ev_print_operation_new (priv->document);
+  if (!op) {
+    g_warning ("%s", "Printing is not supported for document\n");
+    return;
+  }
+
+  g_signal_connect (op, "begin_print",
+                    G_CALLBACK (ev_window_print_operation_begin_print),
+                    (gpointer)ev_window);
+  g_signal_connect (op, "status_changed",
+                    G_CALLBACK (ev_window_print_operation_status_changed),
+                    (gpointer)ev_window);
+  g_signal_connect (op, "done",
+                    G_CALLBACK (ev_window_print_operation_done),
+                    (gpointer)ev_window);
+
+  current_page = ev_document_model_get_page (priv->model);
+  document_last_page = ev_document_get_n_pages (priv->document);
+
+  print_settings_file = get_print_settings_file ();
+
+  print_settings = get_print_settings (print_settings_file);
+  ev_window_load_print_settings_from_metadata (ev_window, print_settings);
+
+  print_page_setup = get_print_page_setup (print_settings_file);
+  ev_window_load_print_page_setup_from_metadata (ev_window, print_page_setup);
+
+  if (first_page != 1 || last_page != document_last_page) {
+    GtkPageRange range;
+
+    /* Ranges in GtkPrint are 0 - N */
+    range.start = first_page - 1;
+    range.end = last_page - 1;
+
+    gtk_print_settings_set_print_pages (print_settings,
+                                        GTK_PRINT_PAGES_RANGES);
+    gtk_print_settings_set_page_ranges (print_settings,
+                                        &range, 1);
+  }
+
+  output_basename = g_strdup (priv->edit_name);
+  dot = g_strrstr (output_basename, ".");
+  if (dot)
+    dot[0] = '\0';
+
+  /* Set output basename for printing to file */
+  gtk_print_settings_set (print_settings,
+                          GTK_PRINT_SETTINGS_OUTPUT_BASENAME,
+                          output_basename);
+  g_free (output_basename);
+
+  ev_print_operation_set_job_name (op, gtk_window_get_title (GTK_WINDOW (ev_window)));
+  ev_print_operation_set_current_page (op, current_page);
+  ev_print_operation_set_print_settings (op, print_settings);
+  ev_print_operation_set_default_page_setup (op, print_page_setup);
+  embed_page_setup = priv->lockdown_settings ?
+                     !g_settings_get_boolean (priv->lockdown_settings,
+                                              GS_LOCKDOWN_PRINT_SETUP) :
+                     TRUE;
+  ev_print_operation_set_embed_page_setup (op, embed_page_setup);
+
+  g_object_unref (print_settings);
+  g_object_unref (print_page_setup);
+  g_key_file_free (print_settings_file);
+
+  ev_print_operation_run (op, GTK_WINDOW (ev_window));
+}
+
+static void
+ev_window_print (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+
+  ev_window_print_range (window, 1,
+                         ev_document_get_n_pages (priv->document));
 }
 
 static void
 ev_window_cmd_file_print (GSimpleAction *action,
-			  GVariant      *state,
-			  gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
+                          GVariant      *state,
+                          gpointer       user_data) {
+  EvWindow *ev_window = user_data;
 
-	ev_window_print (ev_window);
+  ev_window_print (ev_window);
 }
 
 static void
 ev_window_cmd_file_properties (GSimpleAction *action,
-			       GVariant      *state,
-			       gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                               GVariant      *state,
+                               gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (priv->properties == NULL) {
-		priv->properties = ev_properties_dialog_new ();
-		ev_properties_dialog_set_document (EV_PROPERTIES_DIALOG (priv->properties),
-						   priv->uri,
-					           priv->document);
-		g_object_add_weak_pointer (G_OBJECT (priv->properties),
-					   (gpointer) &(priv->properties));
-		gtk_window_set_transient_for (GTK_WINDOW (priv->properties),
-					      GTK_WINDOW (ev_window));
-	}
+  if (priv->properties == NULL) {
+    priv->properties = ev_properties_dialog_new ();
+    ev_properties_dialog_set_document (EV_PROPERTIES_DIALOG (priv->properties),
+                                       priv->uri,
+                                       priv->document);
+    g_object_add_weak_pointer (G_OBJECT (priv->properties),
+                               (gpointer) & (priv->properties));
+    gtk_window_set_transient_for (GTK_WINDOW (priv->properties),
+                                  GTK_WINDOW (ev_window));
+  }
 
-	ev_document_fc_mutex_lock ();
-	gtk_widget_show (priv->properties);
-	ev_document_fc_mutex_unlock ();
+  ev_document_fc_mutex_lock ();
+  gtk_widget_show (priv->properties);
+  ev_document_fc_mutex_unlock ();
 }
 
 static void
 document_modified_reload_dialog_response (GtkDialog *dialog,
-					  gint	     response,
-					  EvWindow  *ev_window)
-{
-	gtk_widget_destroy (GTK_WIDGET (dialog));
+                                          gint	     response,
+                                          EvWindow  *ev_window) {
+  gtk_widget_destroy (GTK_WIDGET (dialog));
 
-	if (response == GTK_RESPONSE_YES)
-	        ev_window_reload_document (ev_window, NULL);
+  if (response == GTK_RESPONSE_YES)
+    ev_window_reload_document (ev_window, NULL);
 }
 
 static void
 document_modified_confirmation_dialog_response (GtkDialog *dialog,
-						gint       response,
-						EvWindow  *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gtk_widget_destroy (GTK_WIDGET (dialog));
-
-	switch (response) {
-	case GTK_RESPONSE_YES:
-		priv->close_after_save = TRUE;
-		ev_window_save_as (ev_window);
-		break;
-	case GTK_RESPONSE_NO:
-		gtk_widget_destroy (GTK_WIDGET (ev_window));
-		break;
-	case GTK_RESPONSE_CANCEL:
-	default:
-		priv->close_after_save = FALSE;
-	}
+                                                gint       response,
+                                                EvWindow  *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gtk_widget_destroy (GTK_WIDGET (dialog));
+
+  switch (response) {
+    case GTK_RESPONSE_YES:
+      priv->close_after_save = TRUE;
+      ev_window_save_as (ev_window);
+      break;
+    case GTK_RESPONSE_NO:
+      gtk_widget_destroy (GTK_WIDGET (ev_window));
+      break;
+    case GTK_RESPONSE_CANCEL:
+    default:
+      priv->close_after_save = FALSE;
+  }
 }
 
 static gboolean
 ev_window_check_document_modified (EvWindow      *ev_window,
-				   EvWindowAction command)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	EvDocument  *document = priv->document;
-	GtkWidget   *dialog;
-	gchar       *text, *markup;
-	const gchar *secondary_text, *secondary_text_command;
-
-	if (!document)
-		return FALSE;
-
-	if (EV_IS_DOCUMENT_FORMS (document) &&
-	    ev_document_forms_document_is_modified (EV_DOCUMENT_FORMS (document))) {
-		secondary_text = _("Document contains form fields that have been filled out. ");
-	} else if (EV_IS_DOCUMENT_ANNOTATIONS (document) &&
-		   ev_document_annotations_document_is_modified (EV_DOCUMENT_ANNOTATIONS (document))) {
-		secondary_text = _("Document contains new or modified annotations. ");
-	} else {
-		return FALSE;
-	}
-
-	dialog = gtk_message_dialog_new (GTK_WINDOW (ev_window),
-					 GTK_DIALOG_MODAL,
-					 GTK_MESSAGE_QUESTION,
-					 GTK_BUTTONS_NONE,
-					 NULL);
-
-	if (command == EV_WINDOW_ACTION_RELOAD) {
-		text = g_markup_printf_escaped (_("Reload document “%s”?"),
-						gtk_window_get_title (GTK_WINDOW (ev_window)));
-		secondary_text_command = _("If you reload the document, changes will be permanently lost.");
-		gtk_dialog_add_buttons (GTK_DIALOG (dialog),
-					_("_No"),
-					GTK_RESPONSE_NO,
-					_("_Reload"),
-					GTK_RESPONSE_YES,
-					NULL);
-		g_signal_connect (dialog, "response",
-				  G_CALLBACK (document_modified_reload_dialog_response),
-				  ev_window);
-	} else {
-		text = g_markup_printf_escaped (_("Save a copy of document “%s” before closing?"),
-                                                gtk_window_get_title (GTK_WINDOW (ev_window)));
-		secondary_text_command = _("If you don’t save a copy, changes will be permanently lost.");
-		gtk_dialog_add_buttons (GTK_DIALOG (dialog),
-				_("Close _without Saving"),
-				GTK_RESPONSE_NO,
-				_("C_ancel"),
-				GTK_RESPONSE_CANCEL,
-				_("Save a _Copy"),
-				GTK_RESPONSE_YES,
-				NULL);
-		g_signal_connect (dialog, "response",
-			  G_CALLBACK (document_modified_confirmation_dialog_response),
-			  ev_window);
-
-	}
-	markup = g_strdup_printf ("<b>%s</b>", text);
-	g_free (text);
-
-	gtk_message_dialog_set_markup (GTK_MESSAGE_DIALOG (dialog), markup);
-	g_free (markup);
-
-	gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog),
-						  "%s %s", secondary_text, secondary_text_command);
-	gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_YES);
-
-	gtk_widget_show (dialog);
-
-	return TRUE;
+                                   EvWindowAction command) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  EvDocument  *document = priv->document;
+  GtkWidget   *dialog;
+  gchar       *text, *markup;
+  const gchar *secondary_text, *secondary_text_command;
+
+  if (!document)
+    return FALSE;
+
+  if (EV_IS_DOCUMENT_FORMS (document) &&
+      ev_document_forms_document_is_modified (EV_DOCUMENT_FORMS (document))) {
+    secondary_text = _("Document contains form fields that have been filled out. ");
+  } else if (EV_IS_DOCUMENT_ANNOTATIONS (document) &&
+             ev_document_annotations_document_is_modified (EV_DOCUMENT_ANNOTATIONS (document))) {
+    secondary_text = _("Document contains new or modified annotations. ");
+  } else {
+    return FALSE;
+  }
+
+  dialog = gtk_message_dialog_new (GTK_WINDOW (ev_window),
+                                   GTK_DIALOG_MODAL,
+                                   GTK_MESSAGE_QUESTION,
+                                   GTK_BUTTONS_NONE,
+                                   NULL);
+
+  if (command == EV_WINDOW_ACTION_RELOAD) {
+    text = g_markup_printf_escaped (_("Reload document “%s”?"),
+                                    gtk_window_get_title (GTK_WINDOW (ev_window)));
+    secondary_text_command = _("If you reload the document, changes will be permanently lost.");
+    gtk_dialog_add_buttons (GTK_DIALOG (dialog),
+                            _("_No"),
+                            GTK_RESPONSE_NO,
+                            _("_Reload"),
+                            GTK_RESPONSE_YES,
+                            NULL);
+    g_signal_connect (dialog, "response",
+                      G_CALLBACK (document_modified_reload_dialog_response),
+                      ev_window);
+  } else {
+    text = g_markup_printf_escaped (_("Save a copy of document “%s” before closing?"),
+                                    gtk_window_get_title (GTK_WINDOW (ev_window)));
+    secondary_text_command = _("If you don’t save a copy, changes will be permanently lost.");
+    gtk_dialog_add_buttons (GTK_DIALOG (dialog),
+                            _("Close _without Saving"),
+                            GTK_RESPONSE_NO,
+                            _("C_ancel"),
+                            GTK_RESPONSE_CANCEL,
+                            _("Save a _Copy"),
+                            GTK_RESPONSE_YES,
+                            NULL);
+    g_signal_connect (dialog, "response",
+                      G_CALLBACK (document_modified_confirmation_dialog_response),
+                      ev_window);
+
+  }
+  markup = g_strdup_printf ("<b>%s</b>", text);
+  g_free (text);
+
+  gtk_message_dialog_set_markup (GTK_MESSAGE_DIALOG (dialog), markup);
+  g_free (markup);
+
+  gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog),
+                                            "%s %s", secondary_text, secondary_text_command);
+  gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_YES);
+
+  gtk_widget_show (dialog);
+
+  return TRUE;
 }
 
 static void
 print_jobs_confirmation_dialog_response (GtkDialog *dialog,
-					 gint       response,
-					 EvWindow  *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-
-	gtk_widget_destroy (GTK_WIDGET (dialog));
-
-	switch (response) {
-	case GTK_RESPONSE_YES:
-		if (!priv->print_queue ||
-		    g_queue_is_empty (priv->print_queue))
-			gtk_widget_destroy (GTK_WIDGET (ev_window));
-		else
-			priv->close_after_print = TRUE;
-		break;
-	case GTK_RESPONSE_NO:
-		priv->close_after_print = TRUE;
-		if (priv->print_queue &&
-		    !g_queue_is_empty (priv->print_queue)) {
-			gtk_widget_set_sensitive (GTK_WIDGET (ev_window), FALSE);
-			ev_window_print_cancel (ev_window);
-		} else {
-			gtk_widget_destroy (GTK_WIDGET (ev_window));
-		}
-		break;
-	case GTK_RESPONSE_CANCEL:
-	default:
-		priv->close_after_print = FALSE;
-	}
+                                         gint       response,
+                                         EvWindow  *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+
+  gtk_widget_destroy (GTK_WIDGET (dialog));
+
+  switch (response) {
+    case GTK_RESPONSE_YES:
+      if (!priv->print_queue ||
+          g_queue_is_empty (priv->print_queue))
+        gtk_widget_destroy (GTK_WIDGET (ev_window));
+      else
+        priv->close_after_print = TRUE;
+      break;
+    case GTK_RESPONSE_NO:
+      priv->close_after_print = TRUE;
+      if (priv->print_queue &&
+          !g_queue_is_empty (priv->print_queue)) {
+        gtk_widget_set_sensitive (GTK_WIDGET (ev_window), FALSE);
+        ev_window_print_cancel (ev_window);
+      } else {
+        gtk_widget_destroy (GTK_WIDGET (ev_window));
+      }
+      break;
+    case GTK_RESPONSE_CANCEL:
+    default:
+      priv->close_after_print = FALSE;
+  }
 }
 
 static gboolean
-ev_window_check_print_queue (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	GtkWidget *dialog;
-	gchar     *text, *markup;
-	gint       n_print_jobs;
-
-	n_print_jobs = priv->print_queue ?
-		g_queue_get_length (priv->print_queue) : 0;
-
-	if (n_print_jobs == 0)
-		return FALSE;
-
-	dialog = gtk_message_dialog_new (GTK_WINDOW (ev_window),
-					 GTK_DIALOG_MODAL,
-					 GTK_MESSAGE_QUESTION,
-					 GTK_BUTTONS_NONE,
-					 NULL);
-	if (n_print_jobs == 1) {
-		EvPrintOperation *op;
-		const gchar      *job_name;
-
-		op = g_queue_peek_tail (priv->print_queue);
-		job_name = ev_print_operation_get_job_name (op);
-
-		text = g_strdup_printf (_("Wait until print job “%s” finishes before closing?"),
-					job_name);
-	} else {
-		/* TRANS: the singular form is not really used as n_print_jobs > 1
- 			  but some languages distinguish between different plurals forms,
-			  so the ngettext is needed. */
-		text = g_strdup_printf (ngettext("There is %d print job active. "
-						 "Wait until print finishes before closing?",
-						 "There are %d print jobs active. "
-						 "Wait until print finishes before closing?",
-						 n_print_jobs),
-					n_print_jobs);
-	}
-
-	markup = g_strdup_printf ("<b>%s</b>", text);
-	g_free (text);
-
-	gtk_message_dialog_set_markup (GTK_MESSAGE_DIALOG (dialog), markup);
-	g_free (markup);
-
-	gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog), "%s",
-						  _("If you close the window, pending print "
-						    "jobs will not be printed."));
-
-	gtk_dialog_add_buttons (GTK_DIALOG (dialog),
-				_("Cancel _print and Close"),
-				GTK_RESPONSE_NO,
-				_("_Cancel"),
-				GTK_RESPONSE_CANCEL,
-				_("Close _after Printing"),
-				GTK_RESPONSE_YES,
-				NULL);
-	gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_YES);
-
-	g_signal_connect (dialog, "response",
-			  G_CALLBACK (print_jobs_confirmation_dialog_response),
-			  ev_window);
-	gtk_widget_show (dialog);
-
-	return TRUE;
+ev_window_check_print_queue (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  GtkWidget *dialog;
+  gchar     *text, *markup;
+  gint       n_print_jobs;
+
+  n_print_jobs = priv->print_queue ?
+                 g_queue_get_length (priv->print_queue) : 0;
+
+  if (n_print_jobs == 0)
+    return FALSE;
+
+  dialog = gtk_message_dialog_new (GTK_WINDOW (ev_window),
+                                   GTK_DIALOG_MODAL,
+                                   GTK_MESSAGE_QUESTION,
+                                   GTK_BUTTONS_NONE,
+                                   NULL);
+  if (n_print_jobs == 1) {
+    EvPrintOperation *op;
+    const gchar      *job_name;
+
+    op = g_queue_peek_tail (priv->print_queue);
+    job_name = ev_print_operation_get_job_name (op);
+
+    text = g_strdup_printf (_("Wait until print job “%s” finishes before closing?"),
+                            job_name);
+  } else {
+    /* TRANS: the singular form is not really used as n_print_jobs > 1
+          but some languages distinguish between different plurals forms,
+          so the ngettext is needed. */
+    text = g_strdup_printf (ngettext("There is %d print job active. "
+                                     "Wait until print finishes before closing?",
+                                     "There are %d print jobs active. "
+                                     "Wait until print finishes before closing?",
+                                     n_print_jobs),
+                            n_print_jobs);
+  }
+
+  markup = g_strdup_printf ("<b>%s</b>", text);
+  g_free (text);
+
+  gtk_message_dialog_set_markup (GTK_MESSAGE_DIALOG (dialog), markup);
+  g_free (markup);
+
+  gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog), "%s",
+                                            _("If you close the window, pending print "
+                                              "jobs will not be printed."));
+
+  gtk_dialog_add_buttons (GTK_DIALOG (dialog),
+                          _("Cancel _print and Close"),
+                          GTK_RESPONSE_NO,
+                          _("_Cancel"),
+                          GTK_RESPONSE_CANCEL,
+                          _("Close _after Printing"),
+                          GTK_RESPONSE_YES,
+                          NULL);
+  gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_YES);
+
+  g_signal_connect (dialog, "response",
+                    G_CALLBACK (print_jobs_confirmation_dialog_response),
+                    ev_window);
+  gtk_widget_show (dialog);
+
+  return TRUE;
 }
 
 static gboolean
-ev_window_close (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+ev_window_close (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (EV_WINDOW_IS_PRESENTATION (priv)) {
-		gint current_page;
+  if (EV_WINDOW_IS_PRESENTATION (priv)) {
+    gint current_page;
 
-		/* Save current page */
-		current_page = ev_view_presentation_get_current_page (
-			EV_VIEW_PRESENTATION (priv->presentation_view));
-		ev_document_model_set_page (priv->model, current_page);
-	}
+    /* Save current page */
+    current_page = ev_view_presentation_get_current_page (
+                     EV_VIEW_PRESENTATION (priv->presentation_view));
+    ev_document_model_set_page (priv->model, current_page);
+  }
 
-	if (ev_window_check_document_modified (ev_window, EV_WINDOW_ACTION_CLOSE))
-		return FALSE;
+  if (ev_window_check_document_modified (ev_window, EV_WINDOW_ACTION_CLOSE))
+    return FALSE;
 
-	if (ev_window_check_print_queue (ev_window))
-		return FALSE;
+  if (ev_window_check_print_queue (ev_window))
+    return FALSE;
 
-	return TRUE;
+  return TRUE;
 }
 
 static void
 ev_window_cmd_file_close_window (GSimpleAction *action,
-				 GVariant      *parameter,
-				 gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
+                                 GVariant      *parameter,
+                                 gpointer       user_data) {
+  EvWindow *ev_window = user_data;
 
-	if (ev_window_close (ev_window))
-		gtk_widget_destroy (GTK_WIDGET (ev_window));
+  if (ev_window_close (ev_window))
+    gtk_widget_destroy (GTK_WIDGET (ev_window));
 }
 
 /**
@@ -3998,1609 +3896,1553 @@ ev_window_cmd_file_close_window (GSimpleAction *action,
  */
 static void
 ev_window_show_help (EvWindow   *window,
-                     const char *topic)
-{
-        char *escaped_topic, *uri;
+                     const char *topic) {
+  char *escaped_topic, *uri;
 
-        if (topic != NULL) {
-                escaped_topic = g_uri_escape_string (topic, NULL, TRUE);
-                uri = g_strdup_printf ("help:evince/%s", escaped_topic);
-                g_free (escaped_topic);
-        } else {
-                uri = g_strdup ("help:evince");
-        }
+  if (topic != NULL) {
+    escaped_topic = g_uri_escape_string (topic, NULL, TRUE);
+    uri = g_strdup_printf ("help:evince/%s", escaped_topic);
+    g_free (escaped_topic);
+  } else {
+    uri = g_strdup ("help:evince");
+  }
 
-        gtk_show_uri_on_window (GTK_WINDOW (window), uri,
-				gtk_get_current_event_time (), NULL);
-        g_free (uri);
+  gtk_show_uri_on_window (GTK_WINDOW (window), uri,
+                          gtk_get_current_event_time (), NULL);
+  g_free (uri);
 }
 
 static void
 ev_window_cmd_help (GSimpleAction *action,
-		    GVariant      *parameter,
-		    gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
+                    GVariant      *parameter,
+                    gpointer       user_data) {
+  EvWindow *ev_window = user_data;
 
-        ev_window_show_help (ev_window, NULL);
+  ev_window_show_help (ev_window, NULL);
 }
 
 static void
 ev_window_cmd_about (GSimpleAction *action,
-		     GVariant      *parameter,
-		     gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-
-        const char *authors[] = {
-                "Martin Kretzschmar <m_kretzschmar@gmx.net>",
-                "Jonathan Blandford <jrb@gnome.org>",
-                "Marco Pesenti Gritti <marco@gnome.org>",
-                "Nickolay V. Shmyrev <nshmyrev@yandex.ru>",
-                "Bryan Clark <clarkbw@gnome.org>",
-                "Carlos Garcia Campos <carlosgc@gnome.org>",
-                "Wouter Bolsterlee <wbolster@gnome.org>",
-                "Christian Persch <chpe" "\100" "src.gnome.org>",
-                "Germán Poo-Caamaño <gpoo" "\100" "gnome.org>",
-                NULL
-        };
-        const char *documenters[] = {
-                "Nickolay V. Shmyrev <nshmyrev@yandex.ru>",
-                "Phil Bull <philbull@gmail.com>",
-                "Tiffany Antpolski <tiffany.antopolski@gmail.com>",
-                NULL
-        };
+                     GVariant      *parameter,
+                     gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+
+  const char *authors[] = {
+    "Martin Kretzschmar <m_kretzschmar@gmx.net>",
+    "Jonathan Blandford <jrb@gnome.org>",
+    "Marco Pesenti Gritti <marco@gnome.org>",
+    "Nickolay V. Shmyrev <nshmyrev@yandex.ru>",
+    "Bryan Clark <clarkbw@gnome.org>",
+    "Carlos Garcia Campos <carlosgc@gnome.org>",
+    "Wouter Bolsterlee <wbolster@gnome.org>",
+    "Christian Persch <chpe" "\100" "src.gnome.org>",
+    "Germán Poo-Caamaño <gpoo" "\100" "gnome.org>",
+    NULL
+  };
+  const char *documenters[] = {
+    "Nickolay V. Shmyrev <nshmyrev@yandex.ru>",
+    "Phil Bull <philbull@gmail.com>",
+    "Tiffany Antpolski <tiffany.antopolski@gmail.com>",
+    NULL
+  };
 #ifdef ENABLE_NLS
-        const char **p;
+  const char **p;
 
-        for (p = authors; *p; ++p)
-                *p = _(*p);
+  for (p = authors; *p; ++p)
+    *p = _(*p);
 
-        for (p = documenters; *p; ++p)
-                *p = _(*p);
+  for (p = documenters; *p; ++p)
+    *p = _(*p);
 #endif
 
-        gtk_show_about_dialog (GTK_WINDOW (ev_window),
-                               "name", _("Evince"),
-                               "version", VERSION,
-                               "copyright", _("© 1996–2017 The Evince authors"),
-                               "license-type", GTK_LICENSE_GPL_2_0,
-                               "website", "https://wiki.gnome.org/Apps/Evince",
-                               "comments", _("Document Viewer"),
-                               "authors", authors,
-                               "documenters", documenters,
-                               "translator-credits", _("translator-credits"),
-                               "logo-icon-name", "org.gnome.Evince",
-                               NULL);
+  gtk_show_about_dialog (GTK_WINDOW (ev_window),
+                         "name", _("Evince"),
+                         "version", VERSION,
+                         "copyright", _("© 1996–2017 The Evince authors"),
+                         "license-type", GTK_LICENSE_GPL_2_0,
+                         "website", "https://wiki.gnome.org/Apps/Evince",
+                         "comments", _("Document Viewer"),
+                         "authors", authors,
+                         "documenters", documenters,
+                         "translator-credits", _("translator-credits"),
+                         "logo-icon-name", "org.gnome.Evince",
+                         NULL);
 }
 
 static void
 ev_window_cmd_focus_page_selector (GSimpleAction *action,
-				   GVariant      *parameter,
-				   gpointer       user_data)
-{
-	EvWindow *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	GtkWidget *page_selector;
-	EvToolbar *toolbar;
+                                   GVariant      *parameter,
+                                   gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  GtkWidget *page_selector;
+  EvToolbar *toolbar;
 
-	update_chrome_flag (window, EV_CHROME_RAISE_TOOLBAR, TRUE);
-	update_chrome_visibility (window);
+  update_chrome_flag (window, EV_CHROME_RAISE_TOOLBAR, TRUE);
+  update_chrome_visibility (window);
 
-	toolbar = priv->fs_toolbar ? EV_TOOLBAR (priv->fs_toolbar) : EV_TOOLBAR (priv->toolbar);
-	page_selector = ev_toolbar_get_page_selector (toolbar);
-	ev_page_action_widget_grab_focus (EV_PAGE_ACTION_WIDGET (page_selector));
+  toolbar = priv->fs_toolbar ? EV_TOOLBAR (priv->fs_toolbar) : EV_TOOLBAR (priv->toolbar);
+  page_selector = ev_toolbar_get_page_selector (toolbar);
+  ev_page_action_widget_grab_focus (EV_PAGE_ACTION_WIDGET (page_selector));
 }
 
 static void
 ev_window_cmd_scroll_forward (GSimpleAction *action,
-			      GVariant      *parameter,
-			      gpointer       user_data)
-{
-	EvWindow *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                              GVariant      *parameter,
+                              gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	g_signal_emit_by_name (priv->view, "scroll", GTK_SCROLL_PAGE_FORWARD, GTK_ORIENTATION_VERTICAL);
+  g_signal_emit_by_name (priv->view, "scroll", GTK_SCROLL_PAGE_FORWARD, GTK_ORIENTATION_VERTICAL);
 }
 
 static void
 ev_window_cmd_scroll_backwards (GSimpleAction *action,
-				GVariant      *parameter,
-				gpointer       user_data)
-{
-	EvWindow *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                                GVariant      *parameter,
+                                gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	g_signal_emit_by_name (priv->view, "scroll", GTK_SCROLL_PAGE_BACKWARD, GTK_ORIENTATION_VERTICAL);
+  g_signal_emit_by_name (priv->view, "scroll", GTK_SCROLL_PAGE_BACKWARD, GTK_ORIENTATION_VERTICAL);
 }
 
 static void
 ev_window_cmd_continuous (GSimpleAction *action,
-			  GVariant      *state,
-			  gpointer       user_data)
-{
-	EvWindow *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                          GVariant      *state,
+                          gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_window_stop_presentation (window, TRUE);
-	ev_document_model_set_continuous (priv->model, g_variant_get_boolean (state));
-	g_simple_action_set_state (action, state);
+  ev_window_stop_presentation (window, TRUE);
+  ev_document_model_set_continuous (priv->model, g_variant_get_boolean (state));
+  g_simple_action_set_state (action, state);
 }
 
+static void
+ev_window_cmd_creator_mode (GSimpleAction *action,
+                            GVariant      *state,
+                            gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+
+  ev_window_stop_presentation (window, TRUE);
+  ev_document_model_set_creator_mode (priv->model, g_variant_get_boolean (state));
+  g_simple_action_set_state (action, state);
+}
+
+
+
 static void
 ev_window_cmd_dual (GSimpleAction *action,
-		    GVariant      *state,
-		    gpointer       user_data)
-{
-	EvWindow *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                    GVariant      *state,
+                    gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_window_stop_presentation (window, TRUE);
-	ev_document_model_set_dual_page (priv->model, g_variant_get_boolean (state));
-	g_simple_action_set_state (action, state);
+  ev_window_stop_presentation (window, TRUE);
+  ev_document_model_set_dual_page (priv->model, g_variant_get_boolean (state));
+  g_simple_action_set_state (action, state);
 }
 
 static void
 ev_window_cmd_dual_odd_pages_left (GSimpleAction *action,
-				   GVariant      *state,
-				   gpointer       user_data)
-{
-	EvWindow *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                                   GVariant      *state,
+                                   gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_document_model_set_dual_page_odd_pages_left (priv->model,
-							g_variant_get_boolean (state));
-	g_simple_action_set_state (action, state);
+  ev_document_model_set_dual_page_odd_pages_left (priv->model,
+                                                  g_variant_get_boolean (state));
+  g_simple_action_set_state (action, state);
 }
 
 static void
 ev_window_cmd_rtl (GSimpleAction *action,
                    GVariant      *state,
-                   gpointer       user_data)
-{
-	EvWindow *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                   gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_document_model_set_rtl (priv->model,
-	                           g_variant_get_boolean (state));
-	g_simple_action_set_state (action, state);
+  ev_document_model_set_rtl (priv->model,
+                             g_variant_get_boolean (state));
+  g_simple_action_set_state (action, state);
 }
 
 static void
 ev_window_change_sizing_mode_action_state (GSimpleAction *action,
-					   GVariant      *state,
-					   gpointer       user_data)
-{
-	EvWindow *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	const gchar *mode;
+                                           GVariant      *state,
+                                           gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  const gchar *mode;
 
-	mode = g_variant_get_string (state, NULL);
+  mode = g_variant_get_string (state, NULL);
 
-	if (g_str_equal (mode, "fit-page"))
-		ev_document_model_set_sizing_mode (priv->model, EV_SIZING_FIT_PAGE);
-	else if (g_str_equal (mode, "fit-width"))
-		ev_document_model_set_sizing_mode (priv->model, EV_SIZING_FIT_WIDTH);
-	else if (g_str_equal (mode, "automatic"))
-		ev_document_model_set_sizing_mode (priv->model, EV_SIZING_AUTOMATIC);
-	else if (g_str_equal (mode, "free"))
-		ev_document_model_set_sizing_mode (priv->model, EV_SIZING_FREE);
-	else
-		g_assert_not_reached ();
+  if (g_str_equal (mode, "fit-page"))
+    ev_document_model_set_sizing_mode (priv->model, EV_SIZING_FIT_PAGE);
+  else if (g_str_equal (mode, "fit-width"))
+    ev_document_model_set_sizing_mode (priv->model, EV_SIZING_FIT_WIDTH);
+  else if (g_str_equal (mode, "automatic"))
+    ev_document_model_set_sizing_mode (priv->model, EV_SIZING_AUTOMATIC);
+  else if (g_str_equal (mode, "free"))
+    ev_document_model_set_sizing_mode (priv->model, EV_SIZING_FREE);
+  else
+    g_assert_not_reached ();
 
-	g_simple_action_set_state (action, state);
+  g_simple_action_set_state (action, state);
 }
 
 static void
 ev_window_cmd_view_zoom (GSimpleAction *action,
-			 GVariant      *parameter,
-			 gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gdouble zoom = g_variant_get_double (parameter);
+                         GVariant      *parameter,
+                         gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gdouble zoom = g_variant_get_double (parameter);
 
-	ev_document_model_set_sizing_mode (priv->model, EV_SIZING_FREE);
-	ev_document_model_set_scale (priv->model,
-				     zoom * ev_document_misc_get_widget_dpi (GTK_WIDGET (ev_window)) / 72.0);
+  ev_document_model_set_sizing_mode (priv->model, EV_SIZING_FREE);
+  ev_document_model_set_scale (priv->model,
+                               zoom * ev_document_misc_get_widget_dpi (GTK_WIDGET (ev_window)) / 72.0);
 }
 
 static void
 ev_window_cmd_set_default_zoom (GSimpleAction *action,
-				GVariant      *parameter,
-				gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                                GVariant      *parameter,
+                                gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	ev_document_model_set_sizing_mode (priv->model, EV_SIZING_FREE);
-	ev_document_model_set_scale (priv->model,
-				     1. * ev_document_misc_get_widget_dpi (GTK_WIDGET (ev_window)) / 72.0);
+  ev_document_model_set_sizing_mode (priv->model, EV_SIZING_FREE);
+  ev_document_model_set_scale (priv->model,
+                               1. * ev_document_misc_get_widget_dpi (GTK_WIDGET (ev_window)) / 72.0);
 }
 
 static void
 ev_window_cmd_edit_select_all (GSimpleAction *action,
-			       GVariant      *parameter,
-			       gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                               GVariant      *parameter,
+                               gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	ev_view_select_all (EV_VIEW (priv->view));
+  ev_view_select_all (EV_VIEW (priv->view));
 }
 
 static void
 ev_window_cmd_toggle_find (GSimpleAction *action,
-			   GVariant      *state,
-			   gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
+                           GVariant      *state,
+                           gpointer       user_data) {
+  EvWindow *ev_window = user_data;
 
-	if (g_variant_get_boolean (state))
-		ev_window_show_find_bar (ev_window, TRUE);
-	else
-		ev_window_close_find_bar (ev_window);
+  if (g_variant_get_boolean (state))
+    ev_window_show_find_bar (ev_window, TRUE);
+  else
+    ev_window_close_find_bar (ev_window);
 
-	g_simple_action_set_state (action, state);
+  g_simple_action_set_state (action, state);
 }
 
 static void
 ev_window_cmd_find (GSimpleAction *action,
-		    GVariant      *parameter,
-		    gpointer       user_data)
-{
-	EvView *view;
-	gchar *selected_text = NULL;
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                    GVariant      *parameter,
+                    gpointer       user_data) {
+  EvView *view;
+  gchar *selected_text = NULL;
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	view = EV_VIEW (priv->view);
-        selected_text = ev_view_get_selected_text (view);
+  view = EV_VIEW (priv->view);
+  selected_text = ev_view_get_selected_text (view);
 
-        if (selected_text != NULL) {
-		GtkSearchEntry *entry = ev_search_box_get_entry (EV_SEARCH_BOX (priv->search_box));
-		gtk_entry_set_text (GTK_ENTRY (entry), selected_text);
-		g_free (selected_text);
-	}
+  if (selected_text != NULL) {
+    GtkSearchEntry *entry = ev_search_box_get_entry (EV_SEARCH_BOX (priv->search_box));
+    gtk_entry_set_text (GTK_ENTRY (entry), selected_text);
+    g_free (selected_text);
+  }
 
-	ev_window_show_find_bar (ev_window, TRUE);
+  ev_window_show_find_bar (ev_window, TRUE);
 }
 
 static void
-ev_window_find_restart (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gint page;
+ev_window_find_restart (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gint page;
 
-	page = ev_document_model_get_page (priv->model);
-	ev_view_find_restart (EV_VIEW (priv->view), page);
-	ev_find_sidebar_restart (EV_FIND_SIDEBAR (priv->find_sidebar), page);
+  page = ev_document_model_get_page (priv->model);
+  ev_view_find_restart (EV_VIEW (priv->view), page);
+  ev_find_sidebar_restart (EV_FIND_SIDEBAR (priv->find_sidebar), page);
 }
 
 static void
-ev_window_find_previous (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+ev_window_find_previous (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	ev_view_find_previous (EV_VIEW (priv->view));
-	ev_find_sidebar_previous (EV_FIND_SIDEBAR (priv->find_sidebar));
+  ev_view_find_previous (EV_VIEW (priv->view));
+  ev_find_sidebar_previous (EV_FIND_SIDEBAR (priv->find_sidebar));
 }
 
 static void
-ev_window_find_next (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+ev_window_find_next (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	ev_view_find_next (EV_VIEW (priv->view));
-	ev_find_sidebar_next (EV_FIND_SIDEBAR (priv->find_sidebar));
+  ev_view_find_next (EV_VIEW (priv->view));
+  ev_find_sidebar_next (EV_FIND_SIDEBAR (priv->find_sidebar));
 }
 
 static gboolean
-find_next_idle_cb (EvWindow *ev_window)
-{
-	ev_window_find_next (ev_window);
-	return FALSE;
+find_next_idle_cb (EvWindow *ev_window) {
+  ev_window_find_next (ev_window);
+  return FALSE;
 }
 
 static void
 ev_window_cmd_edit_find_next (GSimpleAction *action,
-			      GVariant      *parameter,
-			      gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gboolean search_mode_enabled;
+                              GVariant      *parameter,
+                              gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gboolean search_mode_enabled;
 
-	if (EV_WINDOW_IS_PRESENTATION (priv))
-		return;
+  if (EV_WINDOW_IS_PRESENTATION (priv))
+    return;
 
-	search_mode_enabled = gtk_search_bar_get_search_mode (GTK_SEARCH_BAR (priv->search_bar));
-	ev_window_show_find_bar (ev_window, FALSE);
+  search_mode_enabled = gtk_search_bar_get_search_mode (GTK_SEARCH_BAR (priv->search_bar));
+  ev_window_show_find_bar (ev_window, FALSE);
 
-	/* Use idle to make sure view allocation happens before find */
-	if (!search_mode_enabled)
-		g_idle_add ((GSourceFunc)find_next_idle_cb, ev_window);
-	else
-		ev_window_find_next (ev_window);
+  /* Use idle to make sure view allocation happens before find */
+  if (!search_mode_enabled)
+    g_idle_add ((GSourceFunc)find_next_idle_cb, ev_window);
+  else
+    ev_window_find_next (ev_window);
 }
 
 static gboolean
-find_previous_idle_cb (EvWindow *ev_window)
-{
-	ev_window_find_previous (ev_window);
-	return FALSE;
+find_previous_idle_cb (EvWindow *ev_window) {
+  ev_window_find_previous (ev_window);
+  return FALSE;
 }
 
 static void
 ev_window_cmd_edit_find_previous (GSimpleAction *action,
-				  GVariant      *parameter,
-				  gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gboolean search_mode_enabled;
+                                  GVariant      *parameter,
+                                  gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gboolean search_mode_enabled;
 
-	if (EV_WINDOW_IS_PRESENTATION (priv))
-		return;
+  if (EV_WINDOW_IS_PRESENTATION (priv))
+    return;
 
-	search_mode_enabled = gtk_search_bar_get_search_mode (GTK_SEARCH_BAR (priv->search_bar));
-	ev_window_show_find_bar (ev_window, FALSE);
+  search_mode_enabled = gtk_search_bar_get_search_mode (GTK_SEARCH_BAR (priv->search_bar));
+  ev_window_show_find_bar (ev_window, FALSE);
 
-	/* Use idle to make sure view allocation happens before find */
-	if (!search_mode_enabled)
-		g_idle_add ((GSourceFunc)find_previous_idle_cb, ev_window);
-	else
-		ev_window_find_previous (ev_window);
+  /* Use idle to make sure view allocation happens before find */
+  if (!search_mode_enabled)
+    g_idle_add ((GSourceFunc)find_previous_idle_cb, ev_window);
+  else
+    ev_window_find_previous (ev_window);
 }
 
 static void
 ev_window_cmd_edit_copy (GSimpleAction *action,
-			 GVariant      *parameter,
-			 gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                         GVariant      *parameter,
+                         gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	ev_view_copy (EV_VIEW (priv->view));
+  ev_view_copy (EV_VIEW (priv->view));
 }
 
 static void
 ev_window_sidebar_position_change_cb (GObject    *object,
-				      GParamSpec *pspec,
-				      EvWindow   *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                                      GParamSpec *pspec,
+                                      EvWindow   *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (priv->metadata && !ev_window_is_empty (ev_window))
-		ev_metadata_set_int (priv->metadata, "sidebar_size",
-				     gtk_paned_get_position (GTK_PANED (object)));
+  if (priv->metadata && !ev_window_is_empty (ev_window))
+    ev_metadata_set_int (priv->metadata, "sidebar_size",
+                         gtk_paned_get_position (GTK_PANED (object)));
 }
 
 static void
-ev_window_update_links_model (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	GtkTreeModel *model;
-	GtkWidget *page_selector;
+ev_window_update_links_model (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  GtkTreeModel *model;
+  GtkWidget *page_selector;
 
-	g_object_get (priv->sidebar_links,
-		      "model", &model,
-		      NULL);
+  g_object_get (priv->sidebar_links,
+                "model", &model,
+                NULL);
 
-	if (!model)
-		return;
+  if (!model)
+    return;
 
-	page_selector = ev_toolbar_get_page_selector (EV_TOOLBAR (priv->toolbar));
-	ev_page_action_widget_update_links_model (EV_PAGE_ACTION_WIDGET (page_selector), model);
-	if (priv->fs_toolbar) {
-		page_selector = ev_toolbar_get_page_selector (EV_TOOLBAR (priv->fs_toolbar));
-		ev_page_action_widget_update_links_model (EV_PAGE_ACTION_WIDGET (page_selector), model);
-	}
-	g_object_unref (model);
+  page_selector = ev_toolbar_get_page_selector (EV_TOOLBAR (priv->toolbar));
+  ev_page_action_widget_update_links_model (EV_PAGE_ACTION_WIDGET (page_selector), model);
+  if (priv->fs_toolbar) {
+    page_selector = ev_toolbar_get_page_selector (EV_TOOLBAR (priv->fs_toolbar));
+    ev_page_action_widget_update_links_model (EV_PAGE_ACTION_WIDGET (page_selector), model);
+  }
+  g_object_unref (model);
 }
 
 static void
-ev_window_update_fullscreen_action (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	GAction *action;
-	gboolean fullscreen;
+ev_window_update_fullscreen_action (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  GAction *action;
+  gboolean fullscreen;
 
-	action = g_action_map_lookup_action (G_ACTION_MAP (window), "fullscreen");
-	fullscreen = ev_document_model_get_fullscreen (priv->model);
-	g_simple_action_set_state (G_SIMPLE_ACTION (action), g_variant_new_boolean (fullscreen));
+  action = g_action_map_lookup_action (G_ACTION_MAP (window), "fullscreen");
+  fullscreen = ev_document_model_get_fullscreen (priv->model);
+  g_simple_action_set_state (G_SIMPLE_ACTION (action), g_variant_new_boolean (fullscreen));
 }
 
 static void
-ev_window_fullscreen_hide_toolbar (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+ev_window_fullscreen_hide_toolbar (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	if (!ev_toolbar_has_visible_popups (EV_TOOLBAR (priv->fs_toolbar)))
-		gtk_revealer_set_reveal_child (GTK_REVEALER (priv->fs_revealer), FALSE);
+  if (!ev_toolbar_has_visible_popups (EV_TOOLBAR (priv->fs_toolbar)))
+    gtk_revealer_set_reveal_child (GTK_REVEALER (priv->fs_revealer), FALSE);
 }
 
 static gboolean
-fullscreen_toolbar_timeout_cb (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+fullscreen_toolbar_timeout_cb (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_window_fullscreen_hide_toolbar (window);
+  ev_window_fullscreen_hide_toolbar (window);
 
-	if (!gtk_revealer_get_reveal_child (GTK_REVEALER (priv->fs_revealer))) {
-		priv->fs_timeout_id = 0;
-		return FALSE;
-	}
+  if (!gtk_revealer_get_reveal_child (GTK_REVEALER (priv->fs_revealer))) {
+    priv->fs_timeout_id = 0;
+    return FALSE;
+  }
 
-	return TRUE;
+  return TRUE;
 }
 
 static void
-ev_window_remove_fullscreen_timeout (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+ev_window_remove_fullscreen_timeout (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	if (priv->fs_timeout_id)
-		g_source_remove (priv->fs_timeout_id);
-	priv->fs_timeout_id = 0;
+  if (priv->fs_timeout_id)
+    g_source_remove (priv->fs_timeout_id);
+  priv->fs_timeout_id = 0;
 }
 
 static void
-ev_window_add_fullscreen_timeout (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+ev_window_add_fullscreen_timeout (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_window_remove_fullscreen_timeout (window);
-	priv->fs_timeout_id =
-		g_timeout_add_seconds (FULLSCREEN_POPUP_TIMEOUT,
-				       (GSourceFunc)fullscreen_toolbar_timeout_cb, window);
+  ev_window_remove_fullscreen_timeout (window);
+  priv->fs_timeout_id =
+    g_timeout_add_seconds (FULLSCREEN_POPUP_TIMEOUT,
+                           (GSourceFunc)fullscreen_toolbar_timeout_cb, window);
 }
 
 static void
-ev_window_fullscreen_show_toolbar (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+ev_window_fullscreen_show_toolbar (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_window_remove_fullscreen_timeout (window);
-	if (gtk_revealer_get_reveal_child (GTK_REVEALER (priv->fs_revealer)))
-		return;
+  ev_window_remove_fullscreen_timeout (window);
+  if (gtk_revealer_get_reveal_child (GTK_REVEALER (priv->fs_revealer)))
+    return;
 
-	gtk_revealer_set_reveal_child (GTK_REVEALER (priv->fs_revealer), TRUE);
-	if (!priv->fs_pointer_on_toolbar)
-		ev_window_add_fullscreen_timeout (window);
+  gtk_revealer_set_reveal_child (GTK_REVEALER (priv->fs_revealer), TRUE);
+  if (!priv->fs_pointer_on_toolbar)
+    ev_window_add_fullscreen_timeout (window);
 }
 
 static gboolean
 ev_window_fullscreen_toolbar_enter_notify (GtkWidget *widget,
-					   GdkEvent  *event,
-					   EvWindow  *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                                           GdkEvent  *event,
+                                           EvWindow  *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	priv->fs_pointer_on_toolbar = TRUE;
-	ev_window_fullscreen_show_toolbar (window);
+  priv->fs_pointer_on_toolbar = TRUE;
+  ev_window_fullscreen_show_toolbar (window);
 
-	return FALSE;
+  return FALSE;
 }
 
 static gboolean
 ev_window_fullscreen_toolbar_leave_notify (GtkWidget *widget,
-					   GdkEvent  *event,
-					   EvWindow  *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                                           GdkEvent  *event,
+                                           EvWindow  *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	priv->fs_pointer_on_toolbar = FALSE;
-	ev_window_add_fullscreen_timeout (window);
+  priv->fs_pointer_on_toolbar = FALSE;
+  ev_window_add_fullscreen_timeout (window);
 
-	return FALSE;
+  return FALSE;
 }
 
 static void
-ev_window_run_fullscreen (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	gboolean fullscreen_window = TRUE;
-
-	if (ev_document_model_get_fullscreen (priv->model))
-		return;
-
-	if (EV_WINDOW_IS_PRESENTATION (priv)) {
-		ev_window_stop_presentation (window, FALSE);
-		fullscreen_window = FALSE;
-	}
-
-	priv->fs_overlay = gtk_overlay_new ();
-	priv->fs_eventbox = gtk_event_box_new ();
-	priv->fs_revealer = gtk_revealer_new ();
-	g_signal_connect (priv->fs_eventbox, "enter-notify-event",
-			  G_CALLBACK (ev_window_fullscreen_toolbar_enter_notify),
-			  window);
-	g_signal_connect (priv->fs_eventbox, "leave-notify-event",
-			  G_CALLBACK (ev_window_fullscreen_toolbar_leave_notify),
-			  window);
-
-	gtk_widget_set_size_request (priv->fs_eventbox, -1, 1);
-	gtk_widget_set_valign (priv->fs_eventbox, GTK_ALIGN_START);
-	gtk_revealer_set_transition_duration (GTK_REVEALER (priv->fs_revealer), FULLSCREEN_TRANSITION_DURATION);
-
-	g_object_ref (priv->main_box);
-	gtk_container_remove (GTK_CONTAINER (window), priv->main_box);
-	gtk_container_add (GTK_CONTAINER (priv->fs_overlay),
-			   priv->main_box);
-	g_object_unref (priv->main_box);
-
-	priv->fs_toolbar = ev_toolbar_new (window);
-	ev_toolbar_set_mode (EV_TOOLBAR (priv->fs_toolbar),
-		             EV_TOOLBAR_MODE_FULLSCREEN);
-
-	ev_window_update_links_model (window);
-	g_signal_connect (ev_toolbar_get_page_selector (EV_TOOLBAR (priv->fs_toolbar)),
-			  "activate-link",
-			  G_CALLBACK (activate_link_cb),
-			  window);
-	gtk_container_add (GTK_CONTAINER (priv->fs_revealer),
-			   priv->fs_toolbar);
-	gtk_widget_show (priv->fs_toolbar);
-
-	gtk_container_add (GTK_CONTAINER (priv->fs_eventbox),
-			   priv->fs_revealer);
-	gtk_widget_show (priv->fs_revealer);
-	gtk_overlay_add_overlay (GTK_OVERLAY (priv->fs_overlay),
-				 priv->fs_eventbox);
-	gtk_widget_show (priv->fs_eventbox);
-
-	gtk_container_add (GTK_CONTAINER (window), priv->fs_overlay);
-	gtk_widget_show (priv->fs_overlay);
-
-	ev_document_model_set_fullscreen (priv->model, TRUE);
-	ev_window_update_fullscreen_action (window);
-
-	ev_window_fullscreen_show_toolbar (window);
-
-	if (fullscreen_window)
-		gtk_window_fullscreen (GTK_WINDOW (window));
-	gtk_widget_grab_focus (priv->view);
-
-	if (priv->metadata && !ev_window_is_empty (window))
-		ev_metadata_set_boolean (priv->metadata, "fullscreen", TRUE);
+ev_window_run_fullscreen (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  gboolean fullscreen_window = TRUE;
+
+  if (ev_document_model_get_fullscreen (priv->model))
+    return;
+
+  if (EV_WINDOW_IS_PRESENTATION (priv)) {
+    ev_window_stop_presentation (window, FALSE);
+    fullscreen_window = FALSE;
+  }
+
+  priv->fs_overlay = gtk_overlay_new ();
+  priv->fs_eventbox = gtk_event_box_new ();
+  priv->fs_revealer = gtk_revealer_new ();
+  g_signal_connect (priv->fs_eventbox, "enter-notify-event",
+                    G_CALLBACK (ev_window_fullscreen_toolbar_enter_notify),
+                    window);
+  g_signal_connect (priv->fs_eventbox, "leave-notify-event",
+                    G_CALLBACK (ev_window_fullscreen_toolbar_leave_notify),
+                    window);
+
+  gtk_widget_set_size_request (priv->fs_eventbox, -1, 1);
+  gtk_widget_set_valign (priv->fs_eventbox, GTK_ALIGN_START);
+  gtk_revealer_set_transition_duration (GTK_REVEALER (priv->fs_revealer), FULLSCREEN_TRANSITION_DURATION);
+
+  g_object_ref (priv->main_box);
+  gtk_container_remove (GTK_CONTAINER (window), priv->main_box);
+  gtk_container_add (GTK_CONTAINER (priv->fs_overlay),
+                     priv->main_box);
+  g_object_unref (priv->main_box);
+
+  priv->fs_toolbar = ev_toolbar_new (window);
+  ev_toolbar_set_mode (EV_TOOLBAR (priv->fs_toolbar),
+                       EV_TOOLBAR_MODE_FULLSCREEN);
+
+  ev_window_update_links_model (window);
+  g_signal_connect (ev_toolbar_get_page_selector (EV_TOOLBAR (priv->fs_toolbar)),
+                    "activate-link",
+                    G_CALLBACK (activate_link_cb),
+                    window);
+  gtk_container_add (GTK_CONTAINER (priv->fs_revealer),
+                     priv->fs_toolbar);
+  gtk_widget_show (priv->fs_toolbar);
+
+  gtk_container_add (GTK_CONTAINER (priv->fs_eventbox),
+                     priv->fs_revealer);
+  gtk_widget_show (priv->fs_revealer);
+  gtk_overlay_add_overlay (GTK_OVERLAY (priv->fs_overlay),
+                           priv->fs_eventbox);
+  gtk_widget_show (priv->fs_eventbox);
+
+  gtk_container_add (GTK_CONTAINER (window), priv->fs_overlay);
+  gtk_widget_show (priv->fs_overlay);
+
+  ev_document_model_set_fullscreen (priv->model, TRUE);
+  ev_window_update_fullscreen_action (window);
+
+  ev_window_fullscreen_show_toolbar (window);
+
+  if (fullscreen_window)
+    gtk_window_fullscreen (GTK_WINDOW (window));
+  gtk_widget_grab_focus (priv->view);
+
+  if (priv->metadata && !ev_window_is_empty (window))
+    ev_metadata_set_boolean (priv->metadata, "fullscreen", TRUE);
 }
 
 static void
 ev_window_stop_fullscreen (EvWindow *window,
-			   gboolean  unfullscreen_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                           gboolean  unfullscreen_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	if (!ev_document_model_get_fullscreen (priv->model))
-		return;
+  if (!ev_document_model_get_fullscreen (priv->model))
+    return;
 
-	gtk_container_remove (GTK_CONTAINER (priv->fs_revealer),
-			      priv->fs_toolbar);
-	priv->fs_toolbar = NULL;
-	gtk_container_remove (GTK_CONTAINER (priv->fs_eventbox),
-			      priv->fs_revealer);
-	gtk_container_remove (GTK_CONTAINER (priv->fs_overlay),
-			      priv->fs_eventbox);
+  gtk_container_remove (GTK_CONTAINER (priv->fs_revealer),
+                        priv->fs_toolbar);
+  priv->fs_toolbar = NULL;
+  gtk_container_remove (GTK_CONTAINER (priv->fs_eventbox),
+                        priv->fs_revealer);
+  gtk_container_remove (GTK_CONTAINER (priv->fs_overlay),
+                        priv->fs_eventbox);
 
-	g_object_ref (priv->main_box);
-	gtk_container_remove (GTK_CONTAINER (priv->fs_overlay),
-			      priv->main_box);
-	gtk_container_remove (GTK_CONTAINER (window), priv->fs_overlay);
-	priv->fs_overlay = NULL;
-	gtk_container_add (GTK_CONTAINER (window), priv->main_box);
-	g_object_unref (priv->main_box);
+  g_object_ref (priv->main_box);
+  gtk_container_remove (GTK_CONTAINER (priv->fs_overlay),
+                        priv->main_box);
+  gtk_container_remove (GTK_CONTAINER (window), priv->fs_overlay);
+  priv->fs_overlay = NULL;
+  gtk_container_add (GTK_CONTAINER (window), priv->main_box);
+  g_object_unref (priv->main_box);
 
-	ev_window_remove_fullscreen_timeout (window);
+  ev_window_remove_fullscreen_timeout (window);
 
-	ev_document_model_set_fullscreen (priv->model, FALSE);
-	ev_window_update_fullscreen_action (window);
+  ev_document_model_set_fullscreen (priv->model, FALSE);
+  ev_window_update_fullscreen_action (window);
 
-	if (unfullscreen_window)
-		gtk_window_unfullscreen (GTK_WINDOW (window));
+  if (unfullscreen_window)
+    gtk_window_unfullscreen (GTK_WINDOW (window));
 
-	if (priv->metadata && !ev_window_is_empty (window))
-		ev_metadata_set_boolean (priv->metadata, "fullscreen", FALSE);
+  if (priv->metadata && !ev_window_is_empty (window))
+    ev_metadata_set_boolean (priv->metadata, "fullscreen", FALSE);
 }
 
 static void
 ev_window_cmd_view_fullscreen (GSimpleAction *action,
-			       GVariant      *state,
-			       gpointer       user_data)
-{
-	EvWindow *window = user_data;
+                               GVariant      *state,
+                               gpointer       user_data) {
+  EvWindow *window = user_data;
 
-	if (g_variant_get_boolean (state)) {
-		ev_window_run_fullscreen (window);
-	} else {
-		ev_window_stop_fullscreen (window, TRUE);
-	}
+  if (g_variant_get_boolean (state)) {
+    ev_window_run_fullscreen (window);
+  } else {
+    ev_window_stop_fullscreen (window, TRUE);
+  }
 
-	g_simple_action_set_state (action, state);
+  g_simple_action_set_state (action, state);
 }
 
 static void
-ev_window_inhibit_screensaver (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+ev_window_inhibit_screensaver (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-        if (priv->presentation_mode_inhibit_id != 0)
-                return;
+  if (priv->presentation_mode_inhibit_id != 0)
+    return;
 
-        priv->presentation_mode_inhibit_id =
-                gtk_application_inhibit (GTK_APPLICATION (g_application_get_default ()),
-                                         GTK_WINDOW (window),
-                                         GTK_APPLICATION_INHIBIT_IDLE,
-                                         _("Running in presentation mode"));
+  priv->presentation_mode_inhibit_id =
+    gtk_application_inhibit (GTK_APPLICATION (g_application_get_default ()),
+                             GTK_WINDOW (window),
+                             GTK_APPLICATION_INHIBIT_IDLE,
+                             _("Running in presentation mode"));
 }
 
 
 static void
-ev_window_uninhibit_screensaver (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+ev_window_uninhibit_screensaver (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-        if (priv->presentation_mode_inhibit_id == 0)
-                return;
+  if (priv->presentation_mode_inhibit_id == 0)
+    return;
 
-        gtk_application_uninhibit (GTK_APPLICATION (g_application_get_default ()),
-                                   priv->presentation_mode_inhibit_id);
-        priv->presentation_mode_inhibit_id = 0;
+  gtk_application_uninhibit (GTK_APPLICATION (g_application_get_default ()),
+                             priv->presentation_mode_inhibit_id);
+  priv->presentation_mode_inhibit_id = 0;
 }
 
 static void
-ev_window_view_presentation_finished (EvWindow *window)
-{
-	ev_window_stop_presentation (window, TRUE);
+ev_window_view_presentation_finished (EvWindow *window) {
+  ev_window_stop_presentation (window, TRUE);
 }
 
 static gboolean
-ev_window_view_presentation_focus_in (EvWindow *window)
-{
-        ev_window_inhibit_screensaver (window);
+ev_window_view_presentation_focus_in (EvWindow *window) {
+  ev_window_inhibit_screensaver (window);
 
-	return FALSE;
+  return FALSE;
 }
 
 static gboolean
-ev_window_view_presentation_focus_out (EvWindow *window)
-{
-        ev_window_uninhibit_screensaver (window);
+ev_window_view_presentation_focus_out (EvWindow *window) {
+  ev_window_uninhibit_screensaver (window);
 
-	return FALSE;
+  return FALSE;
 }
 
 static void
-ev_window_run_presentation (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	gboolean fullscreen_window = TRUE;
-	guint    current_page;
-	guint    rotation;
-	gboolean inverted_colors;
-
-	if (EV_WINDOW_IS_PRESENTATION (priv))
-		return;
-
-	ev_window_close_find_bar (window);
-
-	if (ev_document_model_get_fullscreen (priv->model)) {
-		ev_window_stop_fullscreen (window, FALSE);
-		fullscreen_window = FALSE;
-	}
-
-	current_page = ev_document_model_get_page (priv->model);
-	rotation = ev_document_model_get_rotation (priv->model);
-	inverted_colors = ev_document_model_get_inverted_colors (priv->model);
-	priv->presentation_view = ev_view_presentation_new (priv->document,
-								    current_page,
-								    rotation,
-								    inverted_colors);
-	g_signal_connect_swapped (priv->presentation_view, "finished",
-				  G_CALLBACK (ev_window_view_presentation_finished),
-				  window);
-	g_signal_connect_swapped (priv->presentation_view, "external-link",
-				  G_CALLBACK (view_external_link_cb),
-				  window);
-	g_signal_connect_swapped (priv->presentation_view, "focus-in-event",
-				  G_CALLBACK (ev_window_view_presentation_focus_in),
-				  window);
-	g_signal_connect_swapped (priv->presentation_view, "focus-out-event",
-				  G_CALLBACK (ev_window_view_presentation_focus_out),
-				  window);
-
-	gtk_box_pack_start (GTK_BOX (priv->main_box),
-			    priv->presentation_view,
-			    TRUE, TRUE, 0);
-
-	gtk_widget_hide (priv->hpaned);
-	update_chrome_visibility (window);
-
-	gtk_widget_grab_focus (priv->presentation_view);
-	if (fullscreen_window)
-		gtk_window_fullscreen (GTK_WINDOW (window));
-
-	gtk_widget_show (priv->presentation_view);
-
-        ev_window_inhibit_screensaver (window);
-
-	if (priv->metadata && !ev_window_is_empty (window))
-		ev_metadata_set_boolean (priv->metadata, "presentation", TRUE);
+ev_window_run_presentation (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  gboolean fullscreen_window = TRUE;
+  guint    current_page;
+  guint    rotation;
+  gboolean inverted_colors;
+
+  if (EV_WINDOW_IS_PRESENTATION (priv))
+    return;
+
+  ev_window_close_find_bar (window);
+
+  if (ev_document_model_get_fullscreen (priv->model)) {
+    ev_window_stop_fullscreen (window, FALSE);
+    fullscreen_window = FALSE;
+  }
+
+  current_page = ev_document_model_get_page (priv->model);
+  rotation = ev_document_model_get_rotation (priv->model);
+  inverted_colors = ev_document_model_get_inverted_colors (priv->model);
+  priv->presentation_view = ev_view_presentation_new (priv->document,
+                                                      current_page,
+                                                      rotation,
+                                                      inverted_colors);
+  g_signal_connect_swapped (priv->presentation_view, "finished",
+                            G_CALLBACK (ev_window_view_presentation_finished),
+                            window);
+  g_signal_connect_swapped (priv->presentation_view, "external-link",
+                            G_CALLBACK (view_external_link_cb),
+                            window);
+  g_signal_connect_swapped (priv->presentation_view, "focus-in-event",
+                            G_CALLBACK (ev_window_view_presentation_focus_in),
+                            window);
+  g_signal_connect_swapped (priv->presentation_view, "focus-out-event",
+                            G_CALLBACK (ev_window_view_presentation_focus_out),
+                            window);
+
+  gtk_box_pack_start (GTK_BOX (priv->main_box),
+                      priv->presentation_view,
+                      TRUE, TRUE, 0);
+
+  gtk_widget_hide (priv->hpaned);
+  update_chrome_visibility (window);
+
+  gtk_widget_grab_focus (priv->presentation_view);
+  if (fullscreen_window)
+    gtk_window_fullscreen (GTK_WINDOW (window));
+
+  gtk_widget_show (priv->presentation_view);
+
+  ev_window_inhibit_screensaver (window);
+
+  if (priv->metadata && !ev_window_is_empty (window))
+    ev_metadata_set_boolean (priv->metadata, "presentation", TRUE);
 }
 
 static void
 ev_window_stop_presentation (EvWindow *window,
-			     gboolean  unfullscreen_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	guint current_page;
-	guint rotation;
+                             gboolean  unfullscreen_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  guint current_page;
+  guint rotation;
 
-	if (!EV_WINDOW_IS_PRESENTATION (priv))
-		return;
+  if (!EV_WINDOW_IS_PRESENTATION (priv))
+    return;
 
-	current_page = ev_view_presentation_get_current_page (EV_VIEW_PRESENTATION (priv->presentation_view));
-	ev_document_model_set_page (priv->model, current_page);
-	rotation = ev_view_presentation_get_rotation (EV_VIEW_PRESENTATION (priv->presentation_view));
-	ev_document_model_set_rotation (priv->model, rotation);
+  current_page = ev_view_presentation_get_current_page (EV_VIEW_PRESENTATION (priv->presentation_view));
+  ev_document_model_set_page (priv->model, current_page);
+  rotation = ev_view_presentation_get_rotation (EV_VIEW_PRESENTATION (priv->presentation_view));
+  ev_document_model_set_rotation (priv->model, rotation);
 
-	gtk_container_remove (GTK_CONTAINER (priv->main_box),
-			      priv->presentation_view);
-	priv->presentation_view = NULL;
+  gtk_container_remove (GTK_CONTAINER (priv->main_box),
+                        priv->presentation_view);
+  priv->presentation_view = NULL;
 
-	gtk_widget_show (priv->hpaned);
-	update_chrome_visibility (window);
-	if (unfullscreen_window)
-		gtk_window_unfullscreen (GTK_WINDOW (window));
+  gtk_widget_show (priv->hpaned);
+  update_chrome_visibility (window);
+  if (unfullscreen_window)
+    gtk_window_unfullscreen (GTK_WINDOW (window));
 
-	gtk_widget_grab_focus (priv->view);
+  gtk_widget_grab_focus (priv->view);
 
-        ev_window_uninhibit_screensaver (window);
+  ev_window_uninhibit_screensaver (window);
 
-	if (priv->metadata && !ev_window_is_empty (window))
-		ev_metadata_set_boolean (priv->metadata, "presentation", FALSE);
+  if (priv->metadata && !ev_window_is_empty (window))
+    ev_metadata_set_boolean (priv->metadata, "presentation", FALSE);
 }
 
 static void
 ev_window_cmd_view_presentation (GSimpleAction *action,
-				 GVariant      *state,
-				 gpointer       user_data)
-{
-	EvWindow *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                                 GVariant      *state,
+                                 gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	if (!EV_WINDOW_IS_PRESENTATION (priv))
-		ev_window_run_presentation (window);
-	/* We don't exit presentation when action is toggled because it conflicts with some
-	 * remote controls. The behaviour is also consistent with libreoffice and other
-	 * presentation tools. See https://bugzilla.gnome.org/show_bug.cgi?id=556162
-	 */
+  if (!EV_WINDOW_IS_PRESENTATION (priv))
+    ev_window_run_presentation (window);
+  /* We don't exit presentation when action is toggled because it conflicts with some
+   * remote controls. The behaviour is also consistent with libreoffice and other
+   * presentation tools. See https://bugzilla.gnome.org/show_bug.cgi?id=556162
+   */
 }
 
 static gboolean
 ev_window_state_event (GtkWidget           *widget,
-		       GdkEventWindowState *event)
-{
-	EvWindow *window = EV_WINDOW (widget);
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                       GdkEventWindowState *event) {
+  EvWindow *window = EV_WINDOW (widget);
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	if (GTK_WIDGET_CLASS (ev_window_parent_class)->window_state_event) {
-		GTK_WIDGET_CLASS (ev_window_parent_class)->window_state_event (widget, event);
-	}
+  if (GTK_WIDGET_CLASS (ev_window_parent_class)->window_state_event) {
+    GTK_WIDGET_CLASS (ev_window_parent_class)->window_state_event (widget, event);
+  }
 
-	if ((event->changed_mask & GDK_WINDOW_STATE_FULLSCREEN) == 0)
-		return FALSE;
+  if ((event->changed_mask & GDK_WINDOW_STATE_FULLSCREEN) == 0)
+    return FALSE;
 
-	if (event->new_window_state & GDK_WINDOW_STATE_FULLSCREEN) {
-		if (ev_document_model_get_fullscreen (priv->model) || EV_WINDOW_IS_PRESENTATION (priv))
-			return FALSE;
+  if (event->new_window_state & GDK_WINDOW_STATE_FULLSCREEN) {
+    if (ev_document_model_get_fullscreen (priv->model) || EV_WINDOW_IS_PRESENTATION (priv))
+      return FALSE;
 
-		ev_window_run_fullscreen (window);
-	} else {
-		if (ev_document_model_get_fullscreen (priv->model))
-			ev_window_stop_fullscreen (window, FALSE);
-		else if (EV_WINDOW_IS_PRESENTATION (priv))
-			ev_window_stop_presentation (window, FALSE);
-	}
+    ev_window_run_fullscreen (window);
+  } else {
+    if (ev_document_model_get_fullscreen (priv->model))
+      ev_window_stop_fullscreen (window, FALSE);
+    else if (EV_WINDOW_IS_PRESENTATION (priv))
+      ev_window_stop_presentation (window, FALSE);
+  }
 
-	return FALSE;
+  return FALSE;
 }
 
 static void
 ev_window_set_page_mode (EvWindow         *window,
-			 EvWindowPageMode  page_mode)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	GtkWidget *child = NULL;
-	GtkWidget *real_child;
-
-	if (priv->page_mode == page_mode)
-		return;
-
-	priv->page_mode = page_mode;
-
-	switch (page_mode) {
-	        case PAGE_MODE_DOCUMENT:
-			child = priv->view;
-			break;
-	        case PAGE_MODE_PASSWORD:
-			child = priv->password_view;
-			break;
-	        default:
-			g_assert_not_reached ();
-	}
-
-	real_child = gtk_bin_get_child (GTK_BIN (priv->scrolled_window));
-	if (child != real_child) {
-		gtk_container_remove (GTK_CONTAINER (priv->scrolled_window),
-				      real_child);
-		gtk_container_add (GTK_CONTAINER (priv->scrolled_window),
-				   child);
-	}
-	ev_window_update_actions_sensitivity (window);
+                         EvWindowPageMode  page_mode) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  GtkWidget *child = NULL;
+  GtkWidget *real_child;
+
+  if (priv->page_mode == page_mode)
+    return;
+
+  priv->page_mode = page_mode;
+
+  switch (page_mode) {
+    case PAGE_MODE_DOCUMENT:
+      child = priv->view;
+      break;
+    case PAGE_MODE_PASSWORD:
+      child = priv->password_view;
+      break;
+    default:
+      g_assert_not_reached ();
+  }
+
+  real_child = gtk_bin_get_child (GTK_BIN (priv->scrolled_window));
+  if (child != real_child) {
+    gtk_container_remove (GTK_CONTAINER (priv->scrolled_window),
+                          real_child);
+    gtk_container_add (GTK_CONTAINER (priv->scrolled_window),
+                       child);
+  }
+  ev_window_update_actions_sensitivity (window);
 }
 
 static void
 ev_window_cmd_edit_rotate_left (GSimpleAction *action,
-				GVariant      *parameter,
-				gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gint rotation;
+                                GVariant      *parameter,
+                                gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gint rotation;
 
-	if (EV_WINDOW_IS_PRESENTATION (priv)) {
-		rotation = ev_view_presentation_get_rotation (EV_VIEW_PRESENTATION (priv->presentation_view));
-		ev_view_presentation_set_rotation (EV_VIEW_PRESENTATION (priv->presentation_view),
-						   rotation - 90);
-	} else {
-		rotation = ev_document_model_get_rotation (priv->model);
+  if (EV_WINDOW_IS_PRESENTATION (priv)) {
+    rotation = ev_view_presentation_get_rotation (EV_VIEW_PRESENTATION (priv->presentation_view));
+    ev_view_presentation_set_rotation (EV_VIEW_PRESENTATION (priv->presentation_view),
+                                       rotation - 90);
+  } else {
+    rotation = ev_document_model_get_rotation (priv->model);
 
-		ev_document_model_set_rotation (priv->model, rotation - 90);
-	}
+    ev_document_model_set_rotation (priv->model, rotation - 90);
+  }
 }
 
 static void
 ev_window_cmd_edit_rotate_right (GSimpleAction *action,
-				 GVariant      *parameter,
-				 gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gint rotation;
+                                 GVariant      *parameter,
+                                 gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gint rotation;
 
-	if (EV_WINDOW_IS_PRESENTATION (priv)) {
-		rotation = ev_view_presentation_get_rotation (EV_VIEW_PRESENTATION (priv->presentation_view));
-		ev_view_presentation_set_rotation (EV_VIEW_PRESENTATION (priv->presentation_view),
-						   rotation + 90);
-	} else {
-		rotation = ev_document_model_get_rotation (priv->model);
+  if (EV_WINDOW_IS_PRESENTATION (priv)) {
+    rotation = ev_view_presentation_get_rotation (EV_VIEW_PRESENTATION (priv->presentation_view));
+    ev_view_presentation_set_rotation (EV_VIEW_PRESENTATION (priv->presentation_view),
+                                       rotation + 90);
+  } else {
+    rotation = ev_document_model_get_rotation (priv->model);
 
-		ev_document_model_set_rotation (priv->model, rotation + 90);
-	}
+    ev_document_model_set_rotation (priv->model, rotation + 90);
+  }
 }
 
 static void
 ev_window_cmd_view_inverted_colors (GSimpleAction *action,
-				    GVariant      *state,
-				    gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                                    GVariant      *state,
+                                    gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	ev_document_model_set_inverted_colors (priv->model,
-					       g_variant_get_boolean (state));
-	g_simple_action_set_state (action, state);
+  ev_document_model_set_inverted_colors (priv->model,
+                                         g_variant_get_boolean (state));
+  g_simple_action_set_state (action, state);
 }
 
 static void
 ev_window_cmd_view_enable_spellchecking (GSimpleAction *action,
-				    GVariant      *state,
-				    gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                                         GVariant      *state,
+                                         gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	ev_view_set_enable_spellchecking (EV_VIEW (priv->view),
-	g_variant_get_boolean (state));
-	g_simple_action_set_state (action, state);
+  ev_view_set_enable_spellchecking (EV_VIEW (priv->view),
+                                    g_variant_get_boolean (state));
+  g_simple_action_set_state (action, state);
 }
 
 static void
 ev_window_cmd_edit_save_settings (GSimpleAction *action,
-				  GVariant      *state,
-				  gpointer       user_data)
-{
-	EvWindow        *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	EvView          *ev_view = EV_VIEW (priv->view);
-	EvDocumentModel *model = priv->model;
-	GSettings       *settings = priv->default_settings;
-	EvSizingMode     sizing_mode;
-
-	g_settings_set_boolean (settings, "continuous",
-				ev_document_model_get_continuous (model));
-	g_settings_set_boolean (settings, "dual-page",
-        			ev_document_model_get_dual_page (model));
-	g_settings_set_boolean (settings, "dual-page-odd-left",
-				ev_document_model_get_dual_page_odd_pages_left (model));
-	g_settings_set_boolean (settings, "fullscreen",
-				ev_document_model_get_fullscreen (model));
-	g_settings_set_boolean (settings, "inverted-colors",
-				ev_document_model_get_inverted_colors (model));
-	sizing_mode = ev_document_model_get_sizing_mode (model);
-	g_settings_set_enum (settings, "sizing-mode", sizing_mode);
-	if (sizing_mode == EV_SIZING_FREE) {
-		gdouble zoom = ev_document_model_get_scale (model);
-
-		zoom *= 72.0 / ev_document_misc_get_widget_dpi (GTK_WIDGET (ev_window));
-		g_settings_set_double (settings, "zoom", zoom);
-	}
-	g_settings_set_boolean (settings, "show-sidebar",
-				gtk_widget_get_visible (priv->sidebar));
-	g_settings_set_int (settings, "sidebar-size",
-			    gtk_paned_get_position (GTK_PANED (priv->hpaned)));
-	g_settings_set_string (settings, "sidebar-page",
-			       ev_window_sidebar_get_current_page_id (ev_window));
-	g_settings_set_boolean (settings, "enable-spellchecking",
-				ev_view_get_enable_spellchecking (ev_view));
-	g_settings_apply (settings);
+                                  GVariant      *state,
+                                  gpointer       user_data) {
+  EvWindow        *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  EvView          *ev_view = EV_VIEW (priv->view);
+  EvDocumentModel *model = priv->model;
+  GSettings       *settings = priv->default_settings;
+  EvSizingMode     sizing_mode;
+
+  g_settings_set_boolean (settings, "continuous",
+                          ev_document_model_get_continuous (model));
+  g_settings_set_boolean (settings, "dual-page",
+                          ev_document_model_get_dual_page (model));
+  g_settings_set_boolean (settings, "dual-page-odd-left",
+                          ev_document_model_get_dual_page_odd_pages_left (model));
+  g_settings_set_boolean (settings, "fullscreen",
+                          ev_document_model_get_fullscreen (model));
+  g_settings_set_boolean (settings, "inverted-colors",
+                          ev_document_model_get_inverted_colors (model));
+  sizing_mode = ev_document_model_get_sizing_mode (model);
+  g_settings_set_enum (settings, "sizing-mode", sizing_mode);
+  if (sizing_mode == EV_SIZING_FREE) {
+    gdouble zoom = ev_document_model_get_scale (model);
+
+    zoom *= 72.0 / ev_document_misc_get_widget_dpi (GTK_WIDGET (ev_window));
+    g_settings_set_double (settings, "zoom", zoom);
+  }
+  g_settings_set_boolean (settings, "show-sidebar",
+                          gtk_widget_get_visible (priv->sidebar));
+  g_settings_set_int (settings, "sidebar-size",
+                      gtk_paned_get_position (GTK_PANED (priv->hpaned)));
+  g_settings_set_string (settings, "sidebar-page",
+                         ev_window_sidebar_get_current_page_id (ev_window));
+  g_settings_set_boolean (settings, "enable-spellchecking",
+                          ev_view_get_enable_spellchecking (ev_view));
+  g_settings_apply (settings);
 }
 
 static void
 ev_window_cmd_view_zoom_in (GSimpleAction *action,
-			    GVariant      *parameter,
-			    gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                            GVariant      *parameter,
+                            gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	ev_document_model_set_sizing_mode (priv->model, EV_SIZING_FREE);
-	ev_view_zoom_in (EV_VIEW (priv->view));
+  ev_document_model_set_sizing_mode (priv->model, EV_SIZING_FREE);
+  ev_view_zoom_in (EV_VIEW (priv->view));
 }
 
 static void
 ev_window_cmd_view_zoom_out (GSimpleAction *action,
-			     GVariant      *parameter,
-			     gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                             GVariant      *parameter,
+                             gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	ev_document_model_set_sizing_mode (priv->model, EV_SIZING_FREE);
-	ev_view_zoom_out (EV_VIEW (priv->view));
+  ev_document_model_set_sizing_mode (priv->model, EV_SIZING_FREE);
+  ev_view_zoom_out (EV_VIEW (priv->view));
 }
 
 static void
 ev_window_cmd_go_back_history (GSimpleAction *action,
-			       GVariant      *parameter,
-			       gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                               GVariant      *parameter,
+                               gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	ev_history_go_back (priv->history);
+  ev_history_go_back (priv->history);
 }
 
 static void
 ev_window_cmd_go_forward_history (GSimpleAction *action,
-				  GVariant      *parameter,
-				  gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                                  GVariant      *parameter,
+                                  gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	ev_history_go_forward (priv->history);
+  ev_history_go_forward (priv->history);
 }
 
 static void
 ev_window_cmd_go_previous_page (GSimpleAction *action,
-				GVariant      *parameter,
-				gpointer       user_data)
-{
-	EvWindow *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                                GVariant      *parameter,
+                                gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_view_previous_page (EV_VIEW (priv->view));
+  ev_view_previous_page (EV_VIEW (priv->view));
 }
 
 static void
 ev_window_cmd_go_next_page (GSimpleAction *action,
-					GVariant      *parameter,
-					gpointer       user_data)
-{
-	EvWindow *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                            GVariant      *parameter,
+                            gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_view_next_page (EV_VIEW (priv->view));
+  ev_view_next_page (EV_VIEW (priv->view));
 }
 
 static void
 ev_window_cmd_go_first_page (GSimpleAction *action,
-					 GVariant      *parameter,
-					 gpointer       user_data)
-{
-	EvWindow *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                             GVariant      *parameter,
+                             gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_document_model_set_page (priv->model, 0);
+  ev_document_model_set_page (priv->model, 0);
 }
 
 static void
 ev_window_cmd_go_last_page (GSimpleAction *action,
-			    GVariant      *parameter,
-			    gpointer       user_data)
-{
-	EvWindow *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                            GVariant      *parameter,
+                            gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_document_model_set_page (priv->model,
-				    ev_document_get_n_pages (priv->document) - 1);
+  ev_document_model_set_page (priv->model,
+                              ev_document_get_n_pages (priv->document) - 1);
 }
 
 static void
 ev_window_cmd_go_forward (GSimpleAction *action,
-			  GVariant      *parameter,
-			  gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	int n_pages, current_page;
+                          GVariant      *parameter,
+                          gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  int n_pages, current_page;
 
-	n_pages = ev_document_get_n_pages (priv->document);
-	current_page = ev_document_model_get_page (priv->model);
+  n_pages = ev_document_get_n_pages (priv->document);
+  current_page = ev_document_model_get_page (priv->model);
 
-	if (current_page + 10 < n_pages) {
-		ev_document_model_set_page (priv->model, current_page + 10);
-	}
+  if (current_page + 10 < n_pages) {
+    ev_document_model_set_page (priv->model, current_page + 10);
+  }
 }
 
 static void
 ev_window_cmd_go_backwards (GSimpleAction *action,
-			    GVariant      *parameter,
-			    gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	int current_page;
+                            GVariant      *parameter,
+                            gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  int current_page;
 
-	current_page = ev_document_model_get_page (priv->model);
+  current_page = ev_document_model_get_page (priv->model);
 
-	if (current_page - 10 >= 0) {
-		ev_document_model_set_page (priv->model, current_page - 10);
-	}
+  if (current_page - 10 >= 0) {
+    ev_document_model_set_page (priv->model, current_page - 10);
+  }
 }
 
 static gint
 compare_bookmarks (EvBookmark *a,
-		   EvBookmark *b)
-{
-	if (a->page < b->page)
-		return -1;
-	if (a->page > b->page)
-		return 1;
-	return 0;
+                   EvBookmark *b) {
+  if (a->page < b->page)
+    return -1;
+  if (a->page > b->page)
+    return 1;
+  return 0;
 }
 
 static void
-ev_window_setup_bookmarks (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	GList *items, *it;
+ev_window_setup_bookmarks (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  GList *items, *it;
 
-	g_menu_remove_all (priv->bookmarks_menu);
+  g_menu_remove_all (priv->bookmarks_menu);
 
-	items = g_list_sort (ev_bookmarks_get_bookmarks (priv->bookmarks),
-			     (GCompareFunc) compare_bookmarks);
+  items = g_list_sort (ev_bookmarks_get_bookmarks (priv->bookmarks),
+                       (GCompareFunc) compare_bookmarks);
 
-	for (it = items; it; it = it->next) {
-		EvBookmark *bookmark = it->data;
-		GMenuItem *item;
+  for (it = items; it; it = it->next) {
+    EvBookmark *bookmark = it->data;
+    GMenuItem *item;
 
-		item = g_menu_item_new (bookmark->title, NULL);
-		g_menu_item_set_action_and_target (item, "win.goto-bookmark", "u", bookmark->page);
-		g_menu_append_item (priv->bookmarks_menu, item);
+    item = g_menu_item_new (bookmark->title, NULL);
+    g_menu_item_set_action_and_target (item, "win.goto-bookmark", "u", bookmark->page);
+    g_menu_append_item (priv->bookmarks_menu, item);
 
-		g_object_unref (item);
-	}
+    g_object_unref (item);
+  }
 
-	g_list_free (items);
+  g_list_free (items);
 }
 
 static void
 ev_window_cmd_bookmarks_add (GSimpleAction *action,
-			     GVariant      *parameter,
-			     gpointer       user_data)
-{
-	EvWindow *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	EvBookmark bm;
-	gchar     *page_label;
+                             GVariant      *parameter,
+                             gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  EvBookmark bm;
+  gchar     *page_label;
 
-	bm.page = ev_document_model_get_page (priv->model);
-	page_label = ev_document_get_page_label (priv->document, bm.page);
-	bm.title = g_strdup_printf (_("Page %s"), page_label);
-	g_free (page_label);
+  bm.page = ev_document_model_get_page (priv->model);
+  page_label = ev_document_get_page_label (priv->document, bm.page);
+  bm.title = g_strdup_printf (_("Page %s"), page_label);
+  g_free (page_label);
 
-	/* EvBookmarks takes ownership of bookmark */
-	ev_bookmarks_add (priv->bookmarks, &bm);
+  /* EvBookmarks takes ownership of bookmark */
+  ev_bookmarks_add (priv->bookmarks, &bm);
 }
 
 static void
 ev_window_cmd_bookmarks_delete (GSimpleAction *action,
-				GVariant      *parameter,
-				gpointer       user_data)
-{
-	EvWindow *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	EvBookmark bm;
+                                GVariant      *parameter,
+                                gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  EvBookmark bm;
 
-	bm.page = ev_document_model_get_page (priv->model);
-	bm.title = NULL;
+  bm.page = ev_document_model_get_page (priv->model);
+  bm.title = NULL;
 
-	ev_bookmarks_delete (priv->bookmarks, &bm);
+  ev_bookmarks_delete (priv->bookmarks, &bm);
 }
 
 static void
 ev_window_activate_goto_bookmark_action (GSimpleAction *action,
-					 GVariant      *parameter,
-					 gpointer       user_data)
-{
-	EvWindow *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                                         GVariant      *parameter,
+                                         gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_document_model_set_page (priv->model, g_variant_get_uint32 (parameter));
+  ev_document_model_set_page (priv->model, g_variant_get_uint32 (parameter));
 }
 
 static void
 ev_window_cmd_view_reload (GSimpleAction *action,
-			   GVariant      *parameter,
-			   gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
+                           GVariant      *parameter,
+                           gpointer       user_data) {
+  EvWindow *ev_window = user_data;
 
-	if (ev_window_check_document_modified (ev_window, EV_WINDOW_ACTION_RELOAD))
-		return;
+  if (ev_window_check_document_modified (ev_window, EV_WINDOW_ACTION_RELOAD))
+    return;
 
-	ev_window_reload_document (ev_window, NULL);
+  ev_window_reload_document (ev_window, NULL);
 }
 
 static void
 ev_window_cmd_view_autoscroll (GSimpleAction *action,
-			       GVariant      *parameter,
-			       gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                               GVariant      *parameter,
+                               gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	ev_view_autoscroll_start (EV_VIEW (priv->view));
+  ev_view_autoscroll_start (EV_VIEW (priv->view));
 }
 
 static void
 ev_window_cmd_escape (GSimpleAction *action,
-		      GVariant      *parameter,
-		      gpointer       user_data)
-{
-	EvWindow *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                      GVariant      *parameter,
+                      gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_view_autoscroll_stop (EV_VIEW (priv->view));
+  ev_view_autoscroll_stop (EV_VIEW (priv->view));
 
-	if (gtk_search_bar_get_search_mode (GTK_SEARCH_BAR (priv->search_bar)))
-		ev_window_close_find_bar (window);
-	else if (ev_document_model_get_fullscreen (priv->model))
-		ev_window_stop_fullscreen (window, TRUE);
-	else if (EV_WINDOW_IS_PRESENTATION (priv))
-		ev_window_stop_presentation (window, TRUE);
-	else
-		gtk_widget_grab_focus (priv->view);
+  if (gtk_search_bar_get_search_mode (GTK_SEARCH_BAR (priv->search_bar)))
+    ev_window_close_find_bar (window);
+  else if (ev_document_model_get_fullscreen (priv->model))
+    ev_window_stop_fullscreen (window, TRUE);
+  else if (EV_WINDOW_IS_PRESENTATION (priv))
+    ev_window_stop_presentation (window, TRUE);
+  else
+    gtk_widget_grab_focus (priv->view);
 }
 
 static void
-save_sizing_mode (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	EvSizingMode mode;
-	GEnumValue *enum_value;
+save_sizing_mode (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  EvSizingMode mode;
+  GEnumValue *enum_value;
 
-	if (!priv->metadata || ev_window_is_empty (window))
-		return;
+  if (!priv->metadata || ev_window_is_empty (window))
+    return;
 
-	mode = ev_document_model_get_sizing_mode (priv->model);
-	enum_value = g_enum_get_value (g_type_class_peek (EV_TYPE_SIZING_MODE), mode);
-	ev_metadata_set_string (priv->metadata, "sizing_mode",
-				enum_value->value_nick);
+  mode = ev_document_model_get_sizing_mode (priv->model);
+  enum_value = g_enum_get_value (g_type_class_peek (EV_TYPE_SIZING_MODE), mode);
+  ev_metadata_set_string (priv->metadata, "sizing_mode",
+                          enum_value->value_nick);
 }
 
 static void
 ev_window_document_changed_cb (EvDocumentModel *model,
-			       GParamSpec      *pspec,
-			       EvWindow        *ev_window)
-{
-	ev_window_set_document (ev_window,
-				ev_document_model_get_document (model));
+                               GParamSpec      *pspec,
+                               EvWindow        *ev_window) {
+  ev_window_set_document (ev_window,
+                          ev_document_model_get_document (model));
 }
 
 static void
 ev_window_sizing_mode_changed_cb (EvDocumentModel *model,
-				  GParamSpec      *pspec,
-		 		  EvWindow        *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	EvSizingMode sizing_mode = ev_document_model_get_sizing_mode (model);
+                                  GParamSpec      *pspec,
+                                  EvWindow        *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  EvSizingMode sizing_mode = ev_document_model_get_sizing_mode (model);
 
-	g_object_set (priv->scrolled_window,
-		      "hscrollbar-policy",
-		      sizing_mode == EV_SIZING_FREE ?
-		      GTK_POLICY_AUTOMATIC : GTK_POLICY_NEVER,
-		      "vscrollbar-policy", GTK_POLICY_AUTOMATIC,
-		      NULL);
+  g_object_set (priv->scrolled_window,
+                "hscrollbar-policy",
+                sizing_mode == EV_SIZING_FREE ?
+                GTK_POLICY_AUTOMATIC : GTK_POLICY_NEVER,
+                "vscrollbar-policy", GTK_POLICY_AUTOMATIC,
+                NULL);
 
-	update_sizing_buttons (ev_window);
-	save_sizing_mode (ev_window);
+  update_sizing_buttons (ev_window);
+  save_sizing_mode (ev_window);
 }
 
 static void
-ev_window_zoom_changed_cb (EvDocumentModel *model, GParamSpec *pspec, EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+ev_window_zoom_changed_cb (EvDocumentModel *model, GParamSpec *pspec, EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-        ev_window_update_actions_sensitivity (ev_window);
+  ev_window_update_actions_sensitivity (ev_window);
 
-	if (!priv->metadata)
-		return;
+  if (!priv->metadata)
+    return;
 
-	if (ev_document_model_get_sizing_mode (model) == EV_SIZING_FREE && !ev_window_is_empty (ev_window)) {
-		gdouble zoom;
+  if (ev_document_model_get_sizing_mode (model) == EV_SIZING_FREE && !ev_window_is_empty (ev_window)) {
+    gdouble zoom;
 
-		zoom = ev_document_model_get_scale (model);
-		zoom *= 72.0 / ev_document_misc_get_widget_dpi (GTK_WIDGET (ev_window));
-		ev_metadata_set_double (priv->metadata, "zoom", zoom);
-	}
+    zoom = ev_document_model_get_scale (model);
+    zoom *= 72.0 / ev_document_misc_get_widget_dpi (GTK_WIDGET (ev_window));
+    ev_metadata_set_double (priv->metadata, "zoom", zoom);
+  }
 }
 
 static void
 ev_window_continuous_changed_cb (EvDocumentModel *model,
-				 GParamSpec      *pspec,
-				 EvWindow        *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gboolean continuous;
-	GAction *action;
+                                 GParamSpec      *pspec,
+                                 EvWindow        *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gboolean continuous;
+  GAction *action;
 
-	continuous = ev_document_model_get_continuous (model);
+  continuous = ev_document_model_get_continuous (model);
 
-	action = g_action_map_lookup_action (G_ACTION_MAP (ev_window), "continuous");
-	g_simple_action_set_state (G_SIMPLE_ACTION (action), g_variant_new_boolean (continuous));
+  action = g_action_map_lookup_action (G_ACTION_MAP (ev_window), "continuous");
+  g_simple_action_set_state (G_SIMPLE_ACTION (action), g_variant_new_boolean (continuous));
 
-	if (priv->metadata && !ev_window_is_empty (ev_window))
-		ev_metadata_set_boolean (priv->metadata, "continuous", continuous);
+  if (priv->metadata && !ev_window_is_empty (ev_window))
+    ev_metadata_set_boolean (priv->metadata, "continuous", continuous);
 }
+static void
+ev_window_creator_mode_changed_cb (EvDocumentModel *model,
+                                   GParamSpec      *pspec,
+                                   EvWindow        *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gboolean creator_mode;
+  GAction *action;
+  printf("Callback!\n");
+  creator_mode = ev_document_model_get_creator_mode (model);
+
+  action = g_action_map_lookup_action (G_ACTION_MAP (ev_window), "creator-mode");
+  g_simple_action_set_state (G_SIMPLE_ACTION (action), g_variant_new_boolean (creator_mode));
+
+  if (priv->metadata && !ev_window_is_empty (ev_window))
+    ev_metadata_set_boolean (priv->metadata, "creator-mode",
+                             creator_mode);
+}
+
+
 
 static void
 ev_window_rotation_changed_cb (EvDocumentModel *model,
-			       GParamSpec      *pspec,
-			       EvWindow        *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	gint rotation = ev_document_model_get_rotation (model);
+                               GParamSpec      *pspec,
+                               EvWindow        *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  gint rotation = ev_document_model_get_rotation (model);
 
-	if (priv->metadata && !ev_window_is_empty (window))
-		ev_metadata_set_int (priv->metadata, "rotation",
-				     rotation);
+  if (priv->metadata && !ev_window_is_empty (window))
+    ev_metadata_set_int (priv->metadata, "rotation",
+                         rotation);
 }
 
 static void
 ev_window_inverted_colors_changed_cb (EvDocumentModel *model,
-			              GParamSpec      *pspec,
-			              EvWindow        *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	gboolean inverted_colors = ev_document_model_get_inverted_colors (model);
-	GAction *action;
+                                      GParamSpec      *pspec,
+                                      EvWindow        *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  gboolean inverted_colors = ev_document_model_get_inverted_colors (model);
+  GAction *action;
 
-	action = g_action_map_lookup_action (G_ACTION_MAP (window), "inverted-colors");
-	g_simple_action_set_state (G_SIMPLE_ACTION (action),
-				   g_variant_new_boolean (inverted_colors));
+  action = g_action_map_lookup_action (G_ACTION_MAP (window), "inverted-colors");
+  g_simple_action_set_state (G_SIMPLE_ACTION (action),
+                             g_variant_new_boolean (inverted_colors));
 
-	if (priv->metadata && !ev_window_is_empty (window))
-		ev_metadata_set_boolean (priv->metadata, "inverted-colors",
-					 inverted_colors);
+  if (priv->metadata && !ev_window_is_empty (window))
+    ev_metadata_set_boolean (priv->metadata, "inverted-colors",
+                             inverted_colors);
 }
 
 static void
 ev_window_dual_mode_changed_cb (EvDocumentModel *model,
-				GParamSpec      *pspec,
-				EvWindow        *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gboolean dual_page;
-	GAction *action;
+                                GParamSpec      *pspec,
+                                EvWindow        *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gboolean dual_page;
+  GAction *action;
 
-	dual_page = ev_document_model_get_dual_page (model);
+  dual_page = ev_document_model_get_dual_page (model);
 
-	action = g_action_map_lookup_action (G_ACTION_MAP (ev_window), "dual-page");
-	g_simple_action_set_state (G_SIMPLE_ACTION (action), g_variant_new_boolean (dual_page));
+  action = g_action_map_lookup_action (G_ACTION_MAP (ev_window), "dual-page");
+  g_simple_action_set_state (G_SIMPLE_ACTION (action), g_variant_new_boolean (dual_page));
 
-	if (priv->metadata && !ev_window_is_empty (ev_window))
-		ev_metadata_set_boolean (priv->metadata, "dual-page", dual_page);
+  if (priv->metadata && !ev_window_is_empty (ev_window))
+    ev_metadata_set_boolean (priv->metadata, "dual-page", dual_page);
 }
 
 static void
 ev_window_dual_mode_odd_pages_left_changed_cb (EvDocumentModel *model,
-					       GParamSpec      *pspec,
-					       EvWindow        *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gboolean odd_left;
-	GAction *action;
+                                               GParamSpec      *pspec,
+                                               EvWindow        *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gboolean odd_left;
+  GAction *action;
 
-	odd_left = ev_document_model_get_dual_page_odd_pages_left (model);
+  odd_left = ev_document_model_get_dual_page_odd_pages_left (model);
 
-	action = g_action_map_lookup_action (G_ACTION_MAP (ev_window), "dual-odd-left");
-	g_simple_action_set_state (G_SIMPLE_ACTION (action), g_variant_new_boolean (odd_left));
+  action = g_action_map_lookup_action (G_ACTION_MAP (ev_window), "dual-odd-left");
+  g_simple_action_set_state (G_SIMPLE_ACTION (action), g_variant_new_boolean (odd_left));
 
-	if (priv->metadata && !ev_window_is_empty (ev_window))
-		ev_metadata_set_boolean (priv->metadata, "dual-page-odd-left",
-					 odd_left);
+  if (priv->metadata && !ev_window_is_empty (ev_window))
+    ev_metadata_set_boolean (priv->metadata, "dual-page-odd-left",
+                             odd_left);
 }
 
 static void
 ev_window_direction_changed_cb (EvDocumentModel *model,
-                          GParamSpec      *pspec,
-                          EvWindow        *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gboolean rtl;
-	GAction *action;
+                                GParamSpec      *pspec,
+                                EvWindow        *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gboolean rtl;
+  GAction *action;
 
-	rtl = ev_document_model_get_rtl (model);
+  rtl = ev_document_model_get_rtl (model);
 
-	action = g_action_map_lookup_action (G_ACTION_MAP (ev_window), "rtl");
-	g_simple_action_set_state (G_SIMPLE_ACTION (action), g_variant_new_boolean (rtl));
+  action = g_action_map_lookup_action (G_ACTION_MAP (ev_window), "rtl");
+  g_simple_action_set_state (G_SIMPLE_ACTION (action), g_variant_new_boolean (rtl));
 
-	if (priv->metadata && !ev_window_is_empty (ev_window))
-		ev_metadata_set_boolean (priv->metadata, "rtl",
-					 rtl);
+  if (priv->metadata && !ev_window_is_empty (ev_window))
+    ev_metadata_set_boolean (priv->metadata, "rtl",
+                             rtl);
 }
 
 static void
 ev_window_cmd_action_menu (GSimpleAction *action,
-			   GVariant      *parameter,
-			   gpointer       user_data)
-{
-	EvWindow  *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	EvToolbar *toolbar;
+                           GVariant      *parameter,
+                           gpointer       user_data) {
+  EvWindow  *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  EvToolbar *toolbar;
 
-	toolbar = priv->fs_toolbar ? EV_TOOLBAR (priv->fs_toolbar) : EV_TOOLBAR (priv->toolbar);
-	ev_toolbar_action_menu_popup (toolbar);
+  toolbar = priv->fs_toolbar ? EV_TOOLBAR (priv->fs_toolbar) : EV_TOOLBAR (priv->toolbar);
+  ev_toolbar_action_menu_popup (toolbar);
 }
 
 static void
 ev_window_view_cmd_toggle_sidebar (GSimpleAction *action,
-				   GVariant      *state,
-				   gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gboolean show_side_pane;
+                                   GVariant      *state,
+                                   gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gboolean show_side_pane;
 
-	if (EV_WINDOW_IS_PRESENTATION (priv))
-		return;
+  if (EV_WINDOW_IS_PRESENTATION (priv))
+    return;
 
-	show_side_pane = g_variant_get_boolean (state);
-	g_simple_action_set_state (action, g_variant_new_boolean (show_side_pane));
+  show_side_pane = g_variant_get_boolean (state);
+  g_simple_action_set_state (action, g_variant_new_boolean (show_side_pane));
 
-	update_chrome_flag (ev_window, EV_CHROME_SIDEBAR, show_side_pane);
-	update_chrome_visibility (ev_window);
+  update_chrome_flag (ev_window, EV_CHROME_SIDEBAR, show_side_pane);
+  update_chrome_visibility (ev_window);
 }
 
 static void
 ev_window_sidebar_current_page_changed_cb (EvSidebar  *ev_sidebar,
-					   GParamSpec *pspec,
-					   EvWindow   *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                                           GParamSpec *pspec,
+                                           EvWindow   *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (priv->metadata && !ev_window_is_empty (ev_window)) {
-		ev_metadata_set_string (priv->metadata,
-					"sidebar_page",
-					ev_window_sidebar_get_current_page_id (ev_window));
-	}
+  if (priv->metadata && !ev_window_is_empty (ev_window)) {
+    ev_metadata_set_string (priv->metadata,
+                            "sidebar_page",
+                            ev_window_sidebar_get_current_page_id (ev_window));
+  }
 }
 
 static void
 ev_window_sidebar_visibility_changed_cb (EvSidebar  *ev_sidebar,
-					 GParamSpec *pspec,
-					 EvWindow   *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                                         GParamSpec *pspec,
+                                         EvWindow   *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (!EV_WINDOW_IS_PRESENTATION (priv)) {
-		gboolean visible = gtk_widget_get_visible (GTK_WIDGET (ev_sidebar));
+  if (!EV_WINDOW_IS_PRESENTATION (priv)) {
+    gboolean visible = gtk_widget_get_visible (GTK_WIDGET (ev_sidebar));
 
-		g_action_group_change_action_state (G_ACTION_GROUP (ev_window), "show-side-pane",
-						    g_variant_new_boolean (visible));
+    g_action_group_change_action_state (G_ACTION_GROUP (ev_window), "show-side-pane",
+                                        g_variant_new_boolean (visible));
 
-		if (priv->metadata)
-			ev_metadata_set_boolean (priv->metadata, "sidebar_visibility",
-						 visible);
-		if (!visible)
-			gtk_widget_grab_focus (priv->view);
-	}
+    if (priv->metadata)
+      ev_metadata_set_boolean (priv->metadata, "sidebar_visibility",
+                               visible);
+    if (!visible)
+      gtk_widget_grab_focus (priv->view);
+  }
 }
 
 static void
 view_menu_link_popup (EvWindow *ev_window,
-		      EvLink   *link)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gboolean  show_external = FALSE;
-	gboolean  show_internal = FALSE;
-
-	g_clear_object (&priv->link);
-	if (link) {
-		EvLinkAction *ev_action;
-
-		priv->link = g_object_ref (link);
-
-		ev_action = ev_link_get_action (link);
-		if (ev_action) {
-			switch (ev_link_action_get_action_type (ev_action)) {
-		                case EV_LINK_ACTION_TYPE_GOTO_DEST:
-		                case EV_LINK_ACTION_TYPE_GOTO_REMOTE:
-					show_internal = TRUE;
-					break;
-		                case EV_LINK_ACTION_TYPE_EXTERNAL_URI:
-		                case EV_LINK_ACTION_TYPE_LAUNCH:
-					show_external = TRUE;
-					break;
-		                default:
-					break;
-			}
-		}
-	}
+                      EvLink   *link) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gboolean  show_external = FALSE;
+  gboolean  show_internal = FALSE;
+
+  g_clear_object (&priv->link);
+  if (link) {
+    EvLinkAction *ev_action;
+
+    priv->link = g_object_ref (link);
+
+    ev_action = ev_link_get_action (link);
+    if (ev_action) {
+      switch (ev_link_action_get_action_type (ev_action)) {
+        case EV_LINK_ACTION_TYPE_GOTO_DEST:
+        case EV_LINK_ACTION_TYPE_GOTO_REMOTE:
+          show_internal = TRUE;
+          break;
+        case EV_LINK_ACTION_TYPE_EXTERNAL_URI:
+        case EV_LINK_ACTION_TYPE_LAUNCH:
+          show_external = TRUE;
+          break;
+        default:
+          break;
+      }
+    }
+  }
 
-	ev_window_set_action_enabled (ev_window, "open-link", show_external);
-	ev_window_set_action_enabled (ev_window, "copy-link-address", show_external);
-	ev_window_set_action_enabled (ev_window, "go-to-link", show_internal);
+  ev_window_set_action_enabled (ev_window, "open-link", show_external);
+  ev_window_set_action_enabled (ev_window, "copy-link-address", show_external);
+  ev_window_set_action_enabled (ev_window, "go-to-link", show_internal);
 
-	ev_window_set_action_enabled (ev_window, "open-link-new-window", show_internal);
+  ev_window_set_action_enabled (ev_window, "open-link-new-window", show_internal);
 }
 
 static void
 view_menu_image_popup (EvWindow  *ev_window,
-		       EvImage   *image)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gboolean show_image = FALSE;
+                       EvImage   *image) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gboolean show_image = FALSE;
 
-	g_clear_object (&priv->image);
-	if (image) {
-		priv->image = g_object_ref (image);
-		show_image = TRUE;
-	}
+  g_clear_object (&priv->image);
+  if (image) {
+    priv->image = g_object_ref (image);
+    show_image = TRUE;
+  }
 
-	ev_window_set_action_enabled (ev_window, "save-image", show_image);
-	ev_window_set_action_enabled (ev_window, "copy-image", show_image);
+  ev_window_set_action_enabled (ev_window, "save-image", show_image);
+  ev_window_set_action_enabled (ev_window, "copy-image", show_image);
 }
 
 static void
 view_menu_annot_popup (EvWindow     *ev_window,
-		       EvAnnotation *annot)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gboolean show_annot_props = FALSE;
-	gboolean show_attachment = FALSE;
-	gboolean can_remove_annots = FALSE;
+                       EvAnnotation *annot) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gboolean show_annot_props = FALSE;
+  gboolean show_attachment = FALSE;
+  gboolean can_remove_annots = FALSE;
 
-	g_clear_object (&priv->annot);
-	if (annot) {
-		priv->annot = g_object_ref (annot);
+  g_clear_object (&priv->annot);
+  if (annot) {
+    priv->annot = g_object_ref (annot);
 
-		show_annot_props = EV_IS_ANNOTATION_MARKUP (annot);
+    show_annot_props = EV_IS_ANNOTATION_MARKUP (annot);
 
-		if (EV_IS_ANNOTATION_ATTACHMENT (annot)) {
-			EvAttachment *attachment;
+    if (EV_IS_ANNOTATION_ATTACHMENT (annot)) {
+      EvAttachment *attachment;
 
-			attachment = ev_annotation_attachment_get_attachment (EV_ANNOTATION_ATTACHMENT (annot));
-			if (attachment) {
-				show_attachment = TRUE;
+      attachment = ev_annotation_attachment_get_attachment (EV_ANNOTATION_ATTACHMENT (annot));
+      if (attachment) {
+        show_attachment = TRUE;
 
-				g_list_free_full (priv->attach_list,
-						  g_object_unref);
-				priv->attach_list = NULL;
-				priv->attach_list =
-					g_list_prepend (priv->attach_list,
-							g_object_ref (attachment));
-			}
-		}
-	}
+        g_list_free_full (priv->attach_list,
+                          g_object_unref);
+        priv->attach_list = NULL;
+        priv->attach_list =
+          g_list_prepend (priv->attach_list,
+                          g_object_ref (attachment));
+      }
+    }
+  }
 
-	if (EV_IS_DOCUMENT_ANNOTATIONS (priv->document))
-		can_remove_annots = ev_document_annotations_can_remove_annotation (EV_DOCUMENT_ANNOTATIONS (priv->document));
+  if (EV_IS_DOCUMENT_ANNOTATIONS (priv->document))
+    can_remove_annots = ev_document_annotations_can_remove_annotation (EV_DOCUMENT_ANNOTATIONS (priv->document));
 
-	ev_window_set_action_enabled (ev_window, "annot-properties", show_annot_props);
-	ev_window_set_action_enabled (ev_window, "remove-annot", annot != NULL && can_remove_annots);
-	ev_window_set_action_enabled (ev_window, "open-attachment", show_attachment);
-	ev_window_set_action_enabled (ev_window, "save-attachment", show_attachment);
+  ev_window_set_action_enabled (ev_window, "annot-properties", show_annot_props);
+  ev_window_set_action_enabled (ev_window, "remove-annot", annot != NULL && can_remove_annots);
+  ev_window_set_action_enabled (ev_window, "open-attachment", show_attachment);
+  ev_window_set_action_enabled (ev_window, "save-attachment", show_attachment);
 }
 
 static gboolean
 view_menu_popup_cb (EvView   *view,
-		    GList    *items,
-		    EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	EvDocument *document = priv->document;
-	GList   *l;
-	gboolean has_link = FALSE;
-	gboolean has_image = FALSE;
-	gboolean has_annot = FALSE;
-	gboolean can_annotate;
-
-	for (l = items; l; l = g_list_next (l)) {
-		if (EV_IS_LINK (l->data)) {
-			view_menu_link_popup (ev_window, EV_LINK (l->data));
-			has_link = TRUE;
-		} else if (EV_IS_IMAGE (l->data)) {
-			view_menu_image_popup (ev_window, EV_IMAGE (l->data));
-			has_image = TRUE;
-		} else if (EV_IS_ANNOTATION (l->data)) {
-			view_menu_annot_popup (ev_window, EV_ANNOTATION (l->data));
-			has_annot = TRUE;
-		}
-	}
-
-	if (!has_link)
-		view_menu_link_popup (ev_window, NULL);
-	if (!has_image)
-		view_menu_image_popup (ev_window, NULL);
-	if (!has_annot)
-		view_menu_annot_popup (ev_window, NULL);
-
-	can_annotate = EV_IS_DOCUMENT_ANNOTATIONS (document) &&
-		ev_document_annotations_can_add_annotation (EV_DOCUMENT_ANNOTATIONS (document)) &&
-		!has_annot && ev_view_get_has_selection (view);
-
-	ev_window_set_action_enabled (ev_window, "annotate-selected-text", can_annotate);
-
-	if (!priv->view_popup) {
-		priv->view_popup = gtk_menu_new_from_model (priv->view_popup_menu);
-		gtk_menu_attach_to_widget (GTK_MENU (priv->view_popup),
-					   GTK_WIDGET (ev_window), NULL);
-	}
-
-	gtk_menu_popup_at_pointer (GTK_MENU (priv->view_popup), NULL);
-	return TRUE;
+                    GList    *items,
+                    EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  EvDocument *document = priv->document;
+  GList   *l;
+  gboolean has_link = FALSE;
+  gboolean has_image = FALSE;
+  gboolean has_annot = FALSE;
+  gboolean can_annotate;
+
+  for (l = items; l; l = g_list_next (l)) {
+    if (EV_IS_LINK (l->data)) {
+      view_menu_link_popup (ev_window, EV_LINK (l->data));
+      has_link = TRUE;
+    } else if (EV_IS_IMAGE (l->data)) {
+      view_menu_image_popup (ev_window, EV_IMAGE (l->data));
+      has_image = TRUE;
+    } else if (EV_IS_ANNOTATION (l->data)) {
+      view_menu_annot_popup (ev_window, EV_ANNOTATION (l->data));
+      has_annot = TRUE;
+    }
+  }
+
+  if (!has_link)
+    view_menu_link_popup (ev_window, NULL);
+  if (!has_image)
+    view_menu_image_popup (ev_window, NULL);
+  if (!has_annot)
+    view_menu_annot_popup (ev_window, NULL);
+
+  can_annotate = EV_IS_DOCUMENT_ANNOTATIONS (document) &&
+                 ev_document_annotations_can_add_annotation (EV_DOCUMENT_ANNOTATIONS (document)) &&
+                 !has_annot && ev_view_get_has_selection (view);
+
+  ev_window_set_action_enabled (ev_window, "annotate-selected-text", can_annotate);
+
+  if (!priv->view_popup) {
+    priv->view_popup = gtk_menu_new_from_model (priv->view_popup_menu);
+    gtk_menu_attach_to_widget (GTK_MENU (priv->view_popup),
+                               GTK_WIDGET (ev_window), NULL);
+  }
+
+  gtk_menu_popup_at_pointer (GTK_MENU (priv->view_popup), NULL);
+  return TRUE;
 }
 
 static gboolean
 attachment_bar_menu_popup_cb (EvSidebarAttachments *attachbar,
-			      GList                *attach_list,
-			      EvWindow             *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                              GList                *attach_list,
+                              EvWindow             *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	g_assert (attach_list != NULL);
+  g_assert (attach_list != NULL);
 
-	ev_window_set_action_enabled (ev_window, "open-attachment", TRUE);
+  ev_window_set_action_enabled (ev_window, "open-attachment", TRUE);
 
-	ev_window_set_action_enabled (ev_window, "save-attachment", TRUE);
+  ev_window_set_action_enabled (ev_window, "save-attachment", TRUE);
 
-	g_list_free_full (priv->attach_list, g_object_unref);
-	priv->attach_list = attach_list;
+  g_list_free_full (priv->attach_list, g_object_unref);
+  priv->attach_list = attach_list;
 
-	if (!priv->attachment_popup) {
-		priv->attachment_popup = gtk_menu_new_from_model (priv->attachment_popup_menu);
-		gtk_menu_attach_to_widget (GTK_MENU (priv->attachment_popup),
-					   GTK_WIDGET (ev_window), NULL);
-	}
+  if (!priv->attachment_popup) {
+    priv->attachment_popup = gtk_menu_new_from_model (priv->attachment_popup_menu);
+    gtk_menu_attach_to_widget (GTK_MENU (priv->attachment_popup),
+                               GTK_WIDGET (ev_window), NULL);
+  }
 
-	gtk_menu_popup_at_pointer (GTK_MENU (priv->attachment_popup), NULL);
+  gtk_menu_popup_at_pointer (GTK_MENU (priv->attachment_popup), NULL);
 
-	return TRUE;
+  return TRUE;
 }
 
 static gboolean
@@ -5608,590 +5450,569 @@ save_attachment_to_target_file (EvAttachment *attachment,
                                 GFile        *target_file,
                                 gboolean      is_dir,
                                 gboolean      is_native,
-                                EvWindow     *ev_window)
-{
-	GFile  *save_to = NULL;
-	GError *error = NULL;
-
-	if (is_native) {
-		if (is_dir) {
-			save_to = g_file_get_child (target_file,
-                            /* FIXMEchpe: file name encoding! */
-						    ev_attachment_get_name (attachment));
-		} else {
-			save_to = g_object_ref (target_file);
-		}
-	} else {
-		save_to = ev_mkstemp_file ("saveattachment.XXXXXX", &error);
-	}
-
-        if (save_to)
-                ev_attachment_save (attachment, save_to, &error);
-
-	if (error) {
-		ev_window_error_message (ev_window, error,
-					 "%s", _("The attachment could not be saved."));
-		g_error_free (error);
-		g_object_unref (save_to);
-
-		return FALSE;
-	}
-
-	if (!is_native) {
-		GFile *dest_file;
-
-		if (is_dir) {
-			dest_file = g_file_get_child (target_file,
-						      ev_attachment_get_name (attachment));
-		} else {
-			dest_file = g_object_ref (target_file);
-		}
-
-		ev_window_save_remote (ev_window, EV_SAVE_ATTACHMENT,
-				       save_to, dest_file);
-
-		g_object_unref (dest_file);
-	}
-
-	g_object_unref (save_to);
-	return TRUE;
+                                EvWindow     *ev_window) {
+  GFile  *save_to = NULL;
+  GError *error = NULL;
+
+  if (is_native) {
+    if (is_dir) {
+      save_to = g_file_get_child (target_file,
+                                  /* FIXMEchpe: file name encoding! */
+                                  ev_attachment_get_name (attachment));
+    } else {
+      save_to = g_object_ref (target_file);
+    }
+  } else {
+    save_to = ev_mkstemp_file ("saveattachment.XXXXXX", &error);
+  }
+
+  if (save_to)
+    ev_attachment_save (attachment, save_to, &error);
+
+  if (error) {
+    ev_window_error_message (ev_window, error,
+                             "%s", _("The attachment could not be saved."));
+    g_error_free (error);
+    g_object_unref (save_to);
+
+    return FALSE;
+  }
+
+  if (!is_native) {
+    GFile *dest_file;
+
+    if (is_dir) {
+      dest_file = g_file_get_child (target_file,
+                                    ev_attachment_get_name (attachment));
+    } else {
+      dest_file = g_object_ref (target_file);
+    }
+
+    ev_window_save_remote (ev_window, EV_SAVE_ATTACHMENT,
+                           save_to, dest_file);
+
+    g_object_unref (dest_file);
+  }
+
+  g_object_unref (save_to);
+  return TRUE;
 }
 
 static gboolean
 attachment_bar_save_attachment_cb (EvSidebarAttachments  *attachbar,
                                    EvAttachment          *attachment,
                                    const char            *uri,
-                                   EvWindow              *ev_window)
-{
-	GFile    *target_file;
-	gboolean  is_native;
-	gboolean  success;
+                                   EvWindow              *ev_window) {
+  GFile    *target_file;
+  gboolean  is_native;
+  gboolean  success;
 
-	target_file = g_file_new_for_uri (uri);
-	is_native = g_file_is_native (target_file);
+  target_file = g_file_new_for_uri (uri);
+  is_native = g_file_is_native (target_file);
 
-	success = save_attachment_to_target_file (attachment,
-	                                          target_file,
-	                                          FALSE,
-	                                          is_native,
-	                                          ev_window);
+  success = save_attachment_to_target_file (attachment,
+                                            target_file,
+                                            FALSE,
+                                            is_native,
+                                            ev_window);
 
-	g_object_unref (target_file);
-	return success;
+  g_object_unref (target_file);
+  return success;
 }
 
 static void
 find_sidebar_result_activated_cb (EvFindSidebar *find_sidebar,
-				  gint           page,
-				  gint           result,
-				  EvWindow      *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                                  gint           page,
+                                  gint           result,
+                                  EvWindow      *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_view_find_set_result (EV_VIEW (priv->view), page, result);
+  ev_view_find_set_result (EV_VIEW (priv->view), page, result);
 }
 
 static void
 recent_view_item_activated_cb (EvRecentView *recent_view,
                                const char   *uri,
-                               EvWindow     *ev_window)
-{
-	ev_application_open_uri_at_dest (EV_APP, uri,
-					 gtk_window_get_screen (GTK_WINDOW (ev_window)),
-					 NULL, 0, NULL, gtk_get_current_event_time ());
+                               EvWindow     *ev_window) {
+  ev_application_open_uri_at_dest (EV_APP, uri,
+                                   gtk_window_get_screen (GTK_WINDOW (ev_window)),
+                                   NULL, 0, NULL, gtk_get_current_event_time ());
 }
 
 static void
 search_entry_stop_search_cb (GtkSearchEntry *entry,
-			     EvWindow       *ev_window)
-{
-	ev_window_close_find_bar (ev_window);
+                             EvWindow       *ev_window) {
+  ev_window_close_find_bar (ev_window);
 }
 
 static void
 search_started_cb (EvSearchBox *search_box,
-		   EvJobFind   *job,
-		   EvWindow    *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                   EvJobFind   *job,
+                   EvWindow    *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (!priv->document || !EV_IS_DOCUMENT_FIND (priv->document))
-		return;
+  if (!priv->document || !EV_IS_DOCUMENT_FIND (priv->document))
+    return;
 
-	ev_view_find_search_changed (EV_VIEW (priv->view));
-	ev_view_find_started (EV_VIEW (priv->view), job);
-	ev_find_sidebar_start (EV_FIND_SIDEBAR (priv->find_sidebar), job);
+  ev_view_find_search_changed (EV_VIEW (priv->view));
+  ev_view_find_started (EV_VIEW (priv->view), job);
+  ev_find_sidebar_start (EV_FIND_SIDEBAR (priv->find_sidebar), job);
 }
 
 static void
 search_updated_cb (EvSearchBox *search_box,
-		   gint         page,
-		   EvWindow    *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                   gint         page,
+                   EvWindow    *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	ev_window_update_actions_sensitivity (ev_window);
-	ev_find_sidebar_update (EV_FIND_SIDEBAR (priv->find_sidebar));
+  ev_window_update_actions_sensitivity (ev_window);
+  ev_find_sidebar_update (EV_FIND_SIDEBAR (priv->find_sidebar));
 }
 
 static void
 search_cleared_cb (EvSearchBox *search_box,
-		   EvWindow    *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                   EvWindow    *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	ev_window_update_actions_sensitivity (ev_window);
-	ev_find_sidebar_clear (EV_FIND_SIDEBAR (priv->find_sidebar));
+  ev_window_update_actions_sensitivity (ev_window);
+  ev_find_sidebar_clear (EV_FIND_SIDEBAR (priv->find_sidebar));
 
-	ev_view_find_search_changed (EV_VIEW (priv->view));
-	gtk_widget_queue_draw (GTK_WIDGET (priv->view));
+  ev_view_find_search_changed (EV_VIEW (priv->view));
+  gtk_widget_queue_draw (GTK_WIDGET (priv->view));
 }
 
 static void
 search_previous_cb (EvSearchBox *search_box,
-		    EvWindow    *ev_window)
-{
-	ev_window_find_previous (ev_window);
+                    EvWindow    *ev_window) {
+  ev_window_find_previous (ev_window);
 }
 
 static void
 search_next_cb (EvSearchBox *search_box,
-		EvWindow    *ev_window)
-{
-	ev_window_find_next (ev_window);
+                EvWindow    *ev_window) {
+  ev_window_find_next (ev_window);
 }
 
 static void
 search_bar_search_mode_enabled_changed (GtkSearchBar *search_bar,
-					GParamSpec   *param,
-					EvWindow     *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	gboolean enabled = gtk_search_bar_get_search_mode (search_bar);
+                                        GParamSpec   *param,
+                                        EvWindow     *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  gboolean enabled = gtk_search_bar_get_search_mode (search_bar);
 
-	ev_view_find_set_highlight_search (EV_VIEW (priv->view), enabled);
-	ev_window_update_actions_sensitivity (ev_window);
+  ev_view_find_set_highlight_search (EV_VIEW (priv->view), enabled);
+  ev_window_update_actions_sensitivity (ev_window);
 
-	if (!enabled) {
-		/* Handle the case of search bar close button clicked */
-		ev_window_close_find_bar (ev_window);
-	}
+  if (!enabled) {
+    /* Handle the case of search bar close button clicked */
+    ev_window_close_find_bar (ev_window);
+  }
 }
 
 void
 ev_window_handle_annot_popup (EvWindow     *ev_window,
-			      EvAnnotation *annot)
-{
-	view_menu_annot_popup (ev_window, annot);
+                              EvAnnotation *annot) {
+  view_menu_annot_popup (ev_window, annot);
 }
 
 static void
 ev_window_show_find_bar (EvWindow *ev_window,
-			 gboolean  restart)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                         gboolean  restart) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (gtk_widget_get_visible (priv->find_sidebar)) {
-		gtk_widget_grab_focus (priv->search_box);
-		return;
-	}
+  if (gtk_widget_get_visible (priv->find_sidebar)) {
+    gtk_widget_grab_focus (priv->search_box);
+    return;
+  }
 
-	if (priv->document == NULL || !EV_IS_DOCUMENT_FIND (priv->document)) {
-		g_error ("Find action should be insensitive since document doesn't support find");
-		return;
-	}
+  if (priv->document == NULL || !EV_IS_DOCUMENT_FIND (priv->document)) {
+    g_error ("Find action should be insensitive since document doesn't support find");
+    return;
+  }
 
-	if (EV_WINDOW_IS_PRESENTATION (priv))
-		return;
+  if (EV_WINDOW_IS_PRESENTATION (priv))
+    return;
 
-	ev_history_freeze (priv->history);
+  ev_history_freeze (priv->history);
 
-	g_object_ref (priv->sidebar);
-	gtk_container_remove (GTK_CONTAINER (priv->hpaned), priv->sidebar);
-	gtk_paned_pack1 (GTK_PANED (priv->hpaned),
-			 priv->find_sidebar, FALSE, FALSE);
-	gtk_widget_show (priv->find_sidebar);
+  g_object_ref (priv->sidebar);
+  gtk_container_remove (GTK_CONTAINER (priv->hpaned), priv->sidebar);
+  gtk_paned_pack1 (GTK_PANED (priv->hpaned),
+                   priv->find_sidebar, FALSE, FALSE);
+  gtk_widget_show (priv->find_sidebar);
 
 
-	gtk_search_bar_set_search_mode (GTK_SEARCH_BAR (priv->search_bar), TRUE);
-	gtk_widget_grab_focus (priv->search_box);
-	g_action_group_change_action_state (G_ACTION_GROUP (ev_window), "toggle-find", g_variant_new_boolean (TRUE));
+  gtk_search_bar_set_search_mode (GTK_SEARCH_BAR (priv->search_bar), TRUE);
+  gtk_widget_grab_focus (priv->search_box);
+  g_action_group_change_action_state (G_ACTION_GROUP (ev_window), "toggle-find", g_variant_new_boolean (TRUE));
 
-	if (restart) {
-		GtkSearchEntry *entry = ev_search_box_get_entry (EV_SEARCH_BOX (priv->search_box));
-		const char     *search_string = gtk_entry_get_text (GTK_ENTRY (entry));
+  if (restart) {
+    GtkSearchEntry *entry = ev_search_box_get_entry (EV_SEARCH_BOX (priv->search_box));
+    const char     *search_string = gtk_entry_get_text (GTK_ENTRY (entry));
 
-		if (search_string && search_string[0])
-			ev_window_find_restart (ev_window);
-	}
+    if (search_string && search_string[0])
+      ev_window_find_restart (ev_window);
+  }
 }
 
 static void
-ev_window_close_find_bar (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+ev_window_close_find_bar (EvWindow *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (!gtk_widget_get_visible (priv->find_sidebar))
-		return;
+  if (!gtk_widget_get_visible (priv->find_sidebar))
+    return;
 
-	g_object_ref (priv->find_sidebar);
-	gtk_container_remove (GTK_CONTAINER (priv->hpaned),
-			      priv->find_sidebar);
-	gtk_paned_pack1 (GTK_PANED (priv->hpaned),
-			 priv->sidebar, FALSE, FALSE);
-	gtk_widget_hide (priv->find_sidebar);
+  g_object_ref (priv->find_sidebar);
+  gtk_container_remove (GTK_CONTAINER (priv->hpaned),
+                        priv->find_sidebar);
+  gtk_paned_pack1 (GTK_PANED (priv->hpaned),
+                   priv->sidebar, FALSE, FALSE);
+  gtk_widget_hide (priv->find_sidebar);
 
-	gtk_search_bar_set_search_mode (GTK_SEARCH_BAR (priv->search_bar), FALSE);
-	gtk_widget_grab_focus (priv->view);
-	g_action_group_change_action_state (G_ACTION_GROUP (ev_window), "toggle-find", g_variant_new_boolean (FALSE));
+  gtk_search_bar_set_search_mode (GTK_SEARCH_BAR (priv->search_bar), FALSE);
+  gtk_widget_grab_focus (priv->view);
+  g_action_group_change_action_state (G_ACTION_GROUP (ev_window), "toggle-find", g_variant_new_boolean (FALSE));
 
-	ev_history_thaw (priv->history);
+  ev_history_thaw (priv->history);
 }
 
 static void
 ev_window_drag_data_received (GtkWidget        *widget,
-			      GdkDragContext   *context,
-			      gint              x,
-			      gint              y,
-			      GtkSelectionData *selection_data,
-			      guint             info,
-			      guint             time)
+                              GdkDragContext   *context,
+                              gint              x,
+                              gint              y,
+                              GtkSelectionData *selection_data,
+                              guint             info,
+                              guint             time)
 
 {
-	EvWindow  *window = EV_WINDOW (widget);
-	gchar    **uris;
-	gint       i = 0;
-	GSList    *uri_list = NULL;
-	GtkWidget *source;
+  EvWindow  *window = EV_WINDOW (widget);
+  gchar    **uris;
+  gint       i = 0;
+  GSList    *uri_list = NULL;
+  GtkWidget *source;
 
-	source = gtk_drag_get_source_widget (context);
-	if (source && widget == gtk_widget_get_toplevel (source)) {
-		gtk_drag_finish (context, FALSE, FALSE, time);
-		return;
-	}
+  source = gtk_drag_get_source_widget (context);
+  if (source && widget == gtk_widget_get_toplevel (source)) {
+    gtk_drag_finish (context, FALSE, FALSE, time);
+    return;
+  }
 
-	uris = gtk_selection_data_get_uris (selection_data);
-	if (!uris) {
-		gtk_drag_finish (context, FALSE, FALSE, time);
-		return;
-	}
+  uris = gtk_selection_data_get_uris (selection_data);
+  if (!uris) {
+    gtk_drag_finish (context, FALSE, FALSE, time);
+    return;
+  }
 
-	for (i = 0; uris[i]; i++) {
-		uri_list = g_slist_prepend (uri_list, (gpointer) uris[i]);
-	}
+  for (i = 0; uris[i]; i++) {
+    uri_list = g_slist_prepend (uri_list, (gpointer) uris[i]);
+  }
 
-	ev_application_open_uri_list (EV_APP, uri_list,
-				      gtk_window_get_screen (GTK_WINDOW (window)),
-				      0);
-	gtk_drag_finish (context, TRUE, FALSE, time);
+  ev_application_open_uri_list (EV_APP, uri_list,
+                                gtk_window_get_screen (GTK_WINDOW (window)),
+                                0);
+  gtk_drag_finish (context, TRUE, FALSE, time);
 
-	g_strfreev (uris);
-	g_slist_free (uri_list);
+  g_strfreev (uris);
+  g_slist_free (uri_list);
 }
 
 static void
 ev_window_set_caret_navigation_enabled (EvWindow *window,
-					gboolean enabled)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	GAction *action;
+                                        gboolean enabled) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  GAction *action;
 
-	if (priv->metadata)
-		ev_metadata_set_boolean (priv->metadata, "caret-navigation", enabled);
+  if (priv->metadata)
+    ev_metadata_set_boolean (priv->metadata, "caret-navigation", enabled);
 
-	ev_view_set_caret_navigation_enabled (EV_VIEW (priv->view), enabled);
+  ev_view_set_caret_navigation_enabled (EV_VIEW (priv->view), enabled);
 
-	action = g_action_map_lookup_action (G_ACTION_MAP (window), "caret-navigation");
-	g_simple_action_set_state (G_SIMPLE_ACTION (action), g_variant_new_boolean (enabled));
+  action = g_action_map_lookup_action (G_ACTION_MAP (window), "caret-navigation");
+  g_simple_action_set_state (G_SIMPLE_ACTION (action), g_variant_new_boolean (enabled));
 }
 
 static void
 ev_window_caret_navigation_message_area_response_cb (EvMessageArea *area,
-						     gint           response_id,
-						     EvWindow      *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                                                     gint           response_id,
+                                                     EvWindow      *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	/* Turn the caret navigation mode on */
-	if (response_id == GTK_RESPONSE_YES)
-		ev_window_set_caret_navigation_enabled (window, TRUE);
+  /* Turn the caret navigation mode on */
+  if (response_id == GTK_RESPONSE_YES)
+    ev_window_set_caret_navigation_enabled (window, TRUE);
 
-	/* Turn the confirmation dialog off if the user has requested not to show it again */
-	if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (priv->ask_caret_navigation_check))) {
-		g_settings_set_boolean (ev_window_ensure_settings (window), "show-caret-navigation-message", FALSE);
-		g_settings_apply (priv->settings);
-	}
+  /* Turn the confirmation dialog off if the user has requested not to show it again */
+  if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (priv->ask_caret_navigation_check))) {
+    g_settings_set_boolean (ev_window_ensure_settings (window), "show-caret-navigation-message", FALSE);
+    g_settings_apply (priv->settings);
+  }
 
-	priv->ask_caret_navigation_check = NULL;
-	ev_window_set_message_area (window, NULL);
-	gtk_widget_grab_focus (priv->view);
+  priv->ask_caret_navigation_check = NULL;
+  ev_window_set_message_area (window, NULL);
+  gtk_widget_grab_focus (priv->view);
 }
 
 static void
 ev_window_cmd_view_toggle_caret_navigation (GSimpleAction *action,
-					    GVariant      *state,
-					    gpointer       user_data)
-{
-	EvWindow  *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	GtkWidget *message_area;
-	GtkWidget *box;
-	GtkWidget *hbox;
-	gboolean   enabled;
-
-	/* Don't ask for user confirmation to turn the caret navigation off when it is active,
-	 * or to turn it on when the confirmation dialog is not to be shown per settings */
-	enabled = ev_view_is_caret_navigation_enabled (EV_VIEW (priv->view));
-	if (enabled || !g_settings_get_boolean (ev_window_ensure_settings (window), "show-caret-navigation-message")) {
-		ev_window_set_caret_navigation_enabled (window, !enabled);
-		return;
-	}
-
-	/* Ask for user confirmation to turn the caret navigation mode on */
-	if (priv->message_area)
-		return;
-
-	message_area = ev_message_area_new (GTK_MESSAGE_QUESTION,
-					    _("Enable caret navigation?"),
-					    _("_Enable"), GTK_RESPONSE_YES,
-					    NULL);
-	ev_message_area_set_secondary_text (EV_MESSAGE_AREA (message_area),
-					    _("Pressing F7 turns the caret navigation on or off. "
-					      "This feature places a moveable cursor in text pages, "
-					      "allowing you to move around and select text with your keyboard. "
-					      "Do you want to enable the caret navigation?"));
-
-	priv->ask_caret_navigation_check = gtk_check_button_new_with_label (_("Don’t show this message again"));
-	hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 12);
-	gtk_box_pack_start (GTK_BOX (hbox), priv->ask_caret_navigation_check,
-			    TRUE, TRUE, 0);
-	gtk_widget_show_all (hbox);
-
-	box = _ev_message_area_get_main_box (EV_MESSAGE_AREA (message_area));
-	gtk_box_pack_start (GTK_BOX (box), hbox, TRUE, TRUE, 0);
-
-	g_signal_connect (message_area, "response",
-			  G_CALLBACK (ev_window_caret_navigation_message_area_response_cb),
-			  window);
-
-	gtk_widget_show (message_area);
-	ev_window_set_message_area (window, message_area);
+                                            GVariant      *state,
+                                            gpointer       user_data) {
+  EvWindow  *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  GtkWidget *message_area;
+  GtkWidget *box;
+  GtkWidget *hbox;
+  gboolean   enabled;
+
+  /* Don't ask for user confirmation to turn the caret navigation off when it is active,
+   * or to turn it on when the confirmation dialog is not to be shown per settings */
+  enabled = ev_view_is_caret_navigation_enabled (EV_VIEW (priv->view));
+  if (enabled || !g_settings_get_boolean (ev_window_ensure_settings (window), "show-caret-navigation-message")) {
+    ev_window_set_caret_navigation_enabled (window, !enabled);
+    return;
+  }
+
+  /* Ask for user confirmation to turn the caret navigation mode on */
+  if (priv->message_area)
+    return;
+
+  message_area = ev_message_area_new (GTK_MESSAGE_QUESTION,
+                                      _("Enable caret navigation?"),
+                                      _("_Enable"), GTK_RESPONSE_YES,
+                                      NULL);
+  ev_message_area_set_secondary_text (EV_MESSAGE_AREA (message_area),
+                                      _("Pressing F7 turns the caret navigation on or off. "
+                                        "This feature places a moveable cursor in text pages, "
+                                        "allowing you to move around and select text with your keyboard. "
+                                        "Do you want to enable the caret navigation?"));
+
+  priv->ask_caret_navigation_check = gtk_check_button_new_with_label (_("Don’t show this message again"));
+  hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 12);
+  gtk_box_pack_start (GTK_BOX (hbox), priv->ask_caret_navigation_check,
+                      TRUE, TRUE, 0);
+  gtk_widget_show_all (hbox);
+
+  box = _ev_message_area_get_main_box (EV_MESSAGE_AREA (message_area));
+  gtk_box_pack_start (GTK_BOX (box), hbox, TRUE, TRUE, 0);
+
+  g_signal_connect (message_area, "response",
+                    G_CALLBACK (ev_window_caret_navigation_message_area_response_cb),
+                    window);
+
+  gtk_widget_show (message_area);
+  ev_window_set_message_area (window, message_area);
 }
 
 static void
 ev_window_cmd_add_highlight_annotation (GSimpleAction *action,
                                         GVariant      *state,
-                                        gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
+                                        gpointer       user_data) {
+  EvWindow *ev_window = user_data;
 
-	ev_window_begin_add_annot (ev_window, EV_ANNOTATION_TYPE_TEXT_MARKUP);
+  ev_window_begin_add_annot (ev_window, EV_ANNOTATION_TYPE_TEXT_MARKUP);
 }
 
 static void
 ev_window_cmd_add_annotation (GSimpleAction *action,
-			      GVariant      *state,
-			      gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
+                              GVariant      *state,
+                              gpointer       user_data) {
+  EvWindow *ev_window = user_data;
 
-	ev_window_begin_add_annot (ev_window, EV_ANNOTATION_TYPE_TEXT);
+  ev_window_begin_add_annot (ev_window, EV_ANNOTATION_TYPE_TEXT);
 }
 
 static void
 ev_window_cmd_toggle_edit_annots (GSimpleAction *action,
-				  GVariant      *state,
-				  gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+                                  GVariant      *state,
+                                  gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	if (g_variant_get_boolean (state))
-		gtk_widget_show (priv->annots_toolbar);
-	else
-		gtk_widget_hide (priv->annots_toolbar);
+  if (g_variant_get_boolean (state))
+    gtk_widget_show (priv->annots_toolbar);
+  else
+    gtk_widget_hide (priv->annots_toolbar);
 
-	g_simple_action_set_state (action, state);
+  g_simple_action_set_state (action, state);
 }
 
 static void
-ev_window_dispose (GObject *object)
-{
-	EvWindow *window = EV_WINDOW (object);
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	GObject *mpkeys = ev_application_get_media_keys (EV_APP);
+ev_window_dispose (GObject *object) {
+  EvWindow *window = EV_WINDOW (object);
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  GObject *mpkeys = ev_application_get_media_keys (EV_APP);
 
-	if (mpkeys) {
-		g_signal_handlers_disconnect_by_func (mpkeys,
-						      ev_window_media_player_key_pressed,
-						      window);
-	}
+  if (mpkeys) {
+    g_signal_handlers_disconnect_by_func (mpkeys,
+                                          ev_window_media_player_key_pressed,
+                                          window);
+  }
 
 #ifdef ENABLE_DBUS
-	if (priv->skeleton != NULL) {
-                ev_window_emit_closed (window);
-
-                g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (priv->skeleton));
-                g_object_unref (priv->skeleton);
-                priv->skeleton = NULL;
-                g_free (priv->dbus_object_path);
-                priv->dbus_object_path = NULL;
-	}
+  if (priv->skeleton != NULL) {
+    ev_window_emit_closed (window);
+
+    g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (priv->skeleton));
+    g_object_unref (priv->skeleton);
+    priv->skeleton = NULL;
+    g_free (priv->dbus_object_path);
+    priv->dbus_object_path = NULL;
+  }
 #endif /* ENABLE_DBUS */
 
-	if (priv->bookmarks) {
-		g_object_unref (priv->bookmarks);
-		priv->bookmarks = NULL;
-	}
-
-	if (priv->metadata) {
-		g_object_unref (priv->metadata);
-		priv->metadata = NULL;
-	}
-
-	if (priv->setup_document_idle > 0) {
-		g_source_remove (priv->setup_document_idle);
-		priv->setup_document_idle = 0;
-	}
-
-	if (priv->loading_message_timeout) {
-		g_source_remove (priv->loading_message_timeout);
-		priv->loading_message_timeout = 0;
-	}
-
-	ev_window_remove_fullscreen_timeout (window);
-
-	if (priv->monitor) {
-		g_object_unref (priv->monitor);
-		priv->monitor = NULL;
-	}
-
-	if (priv->title) {
-		ev_window_title_free (priv->title);
-		priv->title = NULL;
-	}
-
-	g_clear_object (&priv->bookmarks_menu);
-	g_clear_object (&priv->view_popup_menu);
-	g_clear_object (&priv->attachment_popup_menu);
-
-	if (priv->recent_manager) {
-		priv->recent_manager = NULL;
-	}
-
-	if (priv->settings) {
-		g_object_unref (priv->settings);
-		priv->settings = NULL;
-	}
-
-	if (priv->default_settings) {
-		g_settings_apply (priv->default_settings);
-		g_object_unref (priv->default_settings);
-		priv->default_settings = NULL;
-	}
-
-	if (priv->lockdown_settings) {
-		g_object_unref (priv->lockdown_settings);
-		priv->lockdown_settings = NULL;
-	}
-
-	if (priv->model) {
-		g_signal_handlers_disconnect_by_func (priv->model,
-						      ev_window_page_changed_cb,
-						      window);
-		g_object_unref (priv->model);
-		priv->model = NULL;
-	}
-
-	if (priv->document) {
-		g_object_unref (priv->document);
-		priv->document = NULL;
-	}
-
-	if (priv->view) {
-		g_object_unref (priv->view);
-		priv->view = NULL;
-	}
-
-	if (priv->password_view) {
-		g_object_unref (priv->password_view);
-		priv->password_view = NULL;
-	}
-
-	if (priv->load_job) {
-		ev_window_clear_load_job (window);
-	}
-
-	if (priv->reload_job) {
-		ev_window_clear_reload_job (window);
-	}
-
-	if (priv->save_job) {
-		ev_window_clear_save_job (window);
-	}
-
-	if (priv->local_uri) {
-		ev_window_clear_local_uri (window);
-		priv->local_uri = NULL;
-	}
-
-	ev_window_clear_progress_idle (window);
-	if (priv->progress_cancellable) {
-		g_object_unref (priv->progress_cancellable);
-		priv->progress_cancellable = NULL;
-	}
-
-	ev_window_close_dialogs (window);
-
-	if (priv->link) {
-		g_object_unref (priv->link);
-		priv->link = NULL;
-	}
-
-	if (priv->image) {
-		g_object_unref (priv->image);
-		priv->image = NULL;
-	}
-
-	if (priv->annot) {
-		g_object_unref (priv->annot);
-		priv->annot = NULL;
-	}
-
-	if (priv->attach_list) {
-		g_list_free_full (priv->attach_list, g_object_unref);
-		priv->attach_list = NULL;
-	}
-
-	if (priv->uri) {
-		g_free (priv->uri);
-		priv->uri = NULL;
-	}
-
-	g_clear_pointer (&priv->display_name, g_free);
-	g_clear_pointer (&priv->edit_name, g_free);
-
-	if (priv->search_string) {
-		g_free (priv->search_string);
-		priv->search_string = NULL;
-	}
-
-	if (priv->dest) {
-		g_object_unref (priv->dest);
-		priv->dest = NULL;
-	}
-
-	if (priv->history) {
-		g_object_unref (priv->history);
-		priv->history = NULL;
-	}
-
-	if (priv->print_queue) {
-		g_queue_free (priv->print_queue);
-		priv->print_queue = NULL;
-	}
-
-	G_OBJECT_CLASS (ev_window_parent_class)->dispose (object);
+  if (priv->bookmarks) {
+    g_object_unref (priv->bookmarks);
+    priv->bookmarks = NULL;
+  }
+
+  if (priv->metadata) {
+    g_object_unref (priv->metadata);
+    priv->metadata = NULL;
+  }
+
+  if (priv->setup_document_idle > 0) {
+    g_source_remove (priv->setup_document_idle);
+    priv->setup_document_idle = 0;
+  }
+
+  if (priv->loading_message_timeout) {
+    g_source_remove (priv->loading_message_timeout);
+    priv->loading_message_timeout = 0;
+  }
+
+  ev_window_remove_fullscreen_timeout (window);
+
+  if (priv->monitor) {
+    g_object_unref (priv->monitor);
+    priv->monitor = NULL;
+  }
+
+  if (priv->title) {
+    ev_window_title_free (priv->title);
+    priv->title = NULL;
+  }
+
+  g_clear_object (&priv->bookmarks_menu);
+  g_clear_object (&priv->view_popup_menu);
+  g_clear_object (&priv->attachment_popup_menu);
+
+  if (priv->recent_manager) {
+    priv->recent_manager = NULL;
+  }
+
+  if (priv->settings) {
+    g_object_unref (priv->settings);
+    priv->settings = NULL;
+  }
+
+  if (priv->default_settings) {
+    g_settings_apply (priv->default_settings);
+    g_object_unref (priv->default_settings);
+    priv->default_settings = NULL;
+  }
+
+  if (priv->lockdown_settings) {
+    g_object_unref (priv->lockdown_settings);
+    priv->lockdown_settings = NULL;
+  }
+
+  if (priv->model) {
+    g_signal_handlers_disconnect_by_func (priv->model,
+                                          ev_window_page_changed_cb,
+                                          window);
+    g_object_unref (priv->model);
+    priv->model = NULL;
+  }
+
+  if (priv->document) {
+    g_object_unref (priv->document);
+    priv->document = NULL;
+  }
+
+  if (priv->view) {
+    g_object_unref (priv->view);
+    priv->view = NULL;
+  }
+
+  if (priv->password_view) {
+    g_object_unref (priv->password_view);
+    priv->password_view = NULL;
+  }
+
+  if (priv->load_job) {
+    ev_window_clear_load_job (window);
+  }
+
+  if (priv->reload_job) {
+    ev_window_clear_reload_job (window);
+  }
+
+  if (priv->save_job) {
+    ev_window_clear_save_job (window);
+  }
+
+  if (priv->local_uri) {
+    ev_window_clear_local_uri (window);
+    priv->local_uri = NULL;
+  }
+
+  ev_window_clear_progress_idle (window);
+  if (priv->progress_cancellable) {
+    g_object_unref (priv->progress_cancellable);
+    priv->progress_cancellable = NULL;
+  }
+
+  ev_window_close_dialogs (window);
+
+  if (priv->link) {
+    g_object_unref (priv->link);
+    priv->link = NULL;
+  }
+
+  if (priv->image) {
+    g_object_unref (priv->image);
+    priv->image = NULL;
+  }
+
+  if (priv->annot) {
+    g_object_unref (priv->annot);
+    priv->annot = NULL;
+  }
+
+  if (priv->attach_list) {
+    g_list_free_full (priv->attach_list, g_object_unref);
+    priv->attach_list = NULL;
+  }
+
+  if (priv->uri) {
+    g_free (priv->uri);
+    priv->uri = NULL;
+  }
+
+  g_clear_pointer (&priv->display_name, g_free);
+  g_clear_pointer (&priv->edit_name, g_free);
+
+  if (priv->search_string) {
+    g_free (priv->search_string);
+    priv->search_string = NULL;
+  }
+
+  if (priv->dest) {
+    g_object_unref (priv->dest);
+    priv->dest = NULL;
+  }
+
+  if (priv->history) {
+    g_object_unref (priv->history);
+    priv->history = NULL;
+  }
+
+  if (priv->print_queue) {
+    g_queue_free (priv->print_queue);
+    priv->print_queue = NULL;
+  }
+
+  G_OBJECT_CLASS (ev_window_parent_class)->dispose (object);
 }
 
 /*
@@ -6205,1607 +6026,1568 @@ ev_window_dispose (GObject *object)
  */
 static gboolean
 ev_window_key_press_event (GtkWidget   *widget,
-			   GdkEventKey *event)
-{
-	static gpointer grand_parent_class = NULL;
-	GtkWindow *window = GTK_WINDOW (widget);
+                           GdkEventKey *event) {
+  static gpointer grand_parent_class = NULL;
+  GtkWindow *window = GTK_WINDOW (widget);
 
-	if (grand_parent_class == NULL)
-                grand_parent_class = g_type_class_peek_parent (ev_window_parent_class);
+  if (grand_parent_class == NULL)
+    grand_parent_class = g_type_class_peek_parent (ev_window_parent_class);
 
-        /* Handle focus widget key events */
-        if (gtk_window_propagate_key_event (window, event))
-		return TRUE;
+  /* Handle focus widget key events */
+  if (gtk_window_propagate_key_event (window, event))
+    return TRUE;
 
-	/* Handle mnemonics and accelerators */
-	if (gtk_window_activate_key (window, event))
-		return TRUE;
+  /* Handle mnemonics and accelerators */
+  if (gtk_window_activate_key (window, event))
+    return TRUE;
 
-        /* Chain up, invokes binding set on window */
-	return GTK_WIDGET_CLASS (grand_parent_class)->key_press_event (widget, event);
+  /* Chain up, invokes binding set on window */
+  return GTK_WIDGET_CLASS (grand_parent_class)->key_press_event (widget, event);
 }
 
 static gboolean
 ev_window_button_press_event (GtkWidget      *widget,
-                              GdkEventButton *event)
-{
-        EvWindow *window = EV_WINDOW (widget);
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-
-        switch (event->button) {
-        case MOUSE_BACK_BUTTON:
-                ev_history_go_back (priv->history);
-                return TRUE;
-        case MOUSE_FORWARD_BUTTON:
-                ev_history_go_forward (priv->history);
-                return TRUE;
-        default:
-                break;
-        }
+                              GdkEventButton *event) {
+  EvWindow *window = EV_WINDOW (widget);
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-        return FALSE;
+  switch (event->button) {
+    case MOUSE_BACK_BUTTON:
+      ev_history_go_back (priv->history);
+      return TRUE;
+    case MOUSE_FORWARD_BUTTON:
+      ev_history_go_forward (priv->history);
+      return TRUE;
+    default:
+      break;
+  }
+
+  return FALSE;
 }
 
 static gboolean
 ev_window_delete_event (GtkWidget   *widget,
-			GdkEventAny *event)
-{
-	return !ev_window_close (EV_WINDOW (widget));
+                        GdkEventAny *event) {
+  return !ev_window_close (EV_WINDOW (widget));
 }
 
 static void
-ev_window_class_init (EvWindowClass *ev_window_class)
-{
-	GObjectClass *g_object_class = G_OBJECT_CLASS (ev_window_class);
-	GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (ev_window_class);
+ev_window_class_init (EvWindowClass *ev_window_class) {
+  GObjectClass *g_object_class = G_OBJECT_CLASS (ev_window_class);
+  GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (ev_window_class);
 
-	g_object_class->dispose = ev_window_dispose;
+  g_object_class->dispose = ev_window_dispose;
 
-	widget_class->delete_event = ev_window_delete_event;
-	widget_class->key_press_event = ev_window_key_press_event;
-	widget_class->window_state_event = ev_window_state_event;
-	widget_class->drag_data_received = ev_window_drag_data_received;
-	widget_class->button_press_event = ev_window_button_press_event;
+  widget_class->delete_event = ev_window_delete_event;
+  widget_class->key_press_event = ev_window_key_press_event;
+  widget_class->window_state_event = ev_window_state_event;
+  widget_class->drag_data_received = ev_window_drag_data_received;
+  widget_class->button_press_event = ev_window_button_press_event;
 
-	nautilus_sendto = g_find_program_in_path ("nautilus-sendto");
+  nautilus_sendto = g_find_program_in_path ("nautilus-sendto");
 }
 
 static const GActionEntry actions[] = {
-	{ "new", ev_window_cmd_new_window },
-	{ "open", ev_window_cmd_file_open },
-	{ "open-copy", ev_window_cmd_file_open_copy },
-	{ "save-as", ev_window_cmd_save_as },
-	{ "send-to", ev_window_cmd_send_to },
-	{ "open-containing-folder", ev_window_cmd_open_containing_folder },
-	{ "print", ev_window_cmd_file_print },
-	{ "show-properties", ev_window_cmd_file_properties },
-	{ "copy", ev_window_cmd_edit_copy },
-	{ "select-all", ev_window_cmd_edit_select_all },
-	{ "save-settings", ev_window_cmd_edit_save_settings },
-	{ "go-previous-page", ev_window_cmd_go_previous_page },
-	{ "go-next-page", ev_window_cmd_go_next_page },
-	{ "go-first-page", ev_window_cmd_go_first_page },
-	{ "go-last-page", ev_window_cmd_go_last_page },
-	{ "go-forward", ev_window_cmd_go_forward },
-	{ "go-backwards", ev_window_cmd_go_backwards },
-	{ "go-back-history", ev_window_cmd_go_back_history },
-	{ "go-forward-history", ev_window_cmd_go_forward_history },
-	{ "find", ev_window_cmd_find },
-	{ "toggle-find", NULL, NULL, "false", ev_window_cmd_toggle_find },
-	{ "find-next", ev_window_cmd_edit_find_next },
-	{ "find-previous", ev_window_cmd_edit_find_previous },
-	{ "select-page", ev_window_cmd_focus_page_selector },
-	{ "continuous", NULL, NULL, "true", ev_window_cmd_continuous },
-	{ "dual-page", NULL, NULL, "false", ev_window_cmd_dual },
-	{ "dual-odd-left", NULL, NULL, "false", ev_window_cmd_dual_odd_pages_left },
-	{ "rtl", NULL, NULL, "false", ev_window_cmd_rtl },
-	{ "show-side-pane", NULL, NULL, "false", ev_window_view_cmd_toggle_sidebar },
-	{ "inverted-colors", NULL, NULL, "false", ev_window_cmd_view_inverted_colors },
-	{ "enable-spellchecking", NULL, NULL, "false", ev_window_cmd_view_enable_spellchecking },
-	{ "fullscreen", NULL, NULL, "false", ev_window_cmd_view_fullscreen },
-	{ "presentation", ev_window_cmd_view_presentation },
-	{ "rotate-left", ev_window_cmd_edit_rotate_left },
-	{ "rotate-right", ev_window_cmd_edit_rotate_right },
-	{ "zoom-in", ev_window_cmd_view_zoom_in },
-	{ "zoom-out", ev_window_cmd_view_zoom_out },
-	{ "reload", ev_window_cmd_view_reload },
-	{ "auto-scroll", ev_window_cmd_view_autoscroll },
-	{ "add-bookmark", ev_window_cmd_bookmarks_add },
-	{ "delete-bookmark", ev_window_cmd_bookmarks_delete },
-	{ "goto-bookmark", ev_window_activate_goto_bookmark_action, "u" },
-	{ "close", ev_window_cmd_file_close_window },
-	{ "scroll-forward", ev_window_cmd_scroll_forward },
-	{ "scroll-backwards", ev_window_cmd_scroll_backwards },
-	{ "sizing-mode", NULL, "s", "'free'", ev_window_change_sizing_mode_action_state },
-	{ "zoom", ev_window_cmd_view_zoom, "d" },
-	{ "default-zoom", ev_window_cmd_set_default_zoom },
-	{ "escape", ev_window_cmd_escape },
-	{ "open-menu", ev_window_cmd_action_menu },
-	{ "caret-navigation", NULL, NULL, "false", ev_window_cmd_view_toggle_caret_navigation },
-	{ "add-annotation", NULL, NULL, "false", ev_window_cmd_add_annotation },
-	{ "highlight-annotation", NULL, NULL, "false", ev_window_cmd_add_highlight_annotation },
-	{ "toggle-edit-annots", NULL, NULL, "false", ev_window_cmd_toggle_edit_annots },
-	{ "about", ev_window_cmd_about },
-	{ "help", ev_window_cmd_help },
-	/* Popups specific items */
-	{ "annotate-selected-text", ev_window_popup_cmd_annotate_selected_text },
-	{ "open-link", ev_window_popup_cmd_open_link },
-	{ "open-link-new-window", ev_window_popup_cmd_open_link_new_window },
-	{ "go-to-link", ev_window_popup_cmd_open_link },
-	{ "copy-link-address", ev_window_popup_cmd_copy_link_address },
-	{ "save-image", ev_window_popup_cmd_save_image_as },
-	{ "copy-image", ev_window_popup_cmd_copy_image },
-	{ "open-attachment", ev_window_popup_cmd_open_attachment },
-	{ "save-attachment", ev_window_popup_cmd_save_attachment_as },
-	{ "annot-properties", ev_window_popup_cmd_annot_properties },
-	{ "remove-annot", ev_window_popup_cmd_remove_annotation }
+  { "new", ev_window_cmd_new_window },
+  { "open", ev_window_cmd_file_open },
+  { "open-copy", ev_window_cmd_file_open_copy },
+  { "save-as", ev_window_cmd_save_as },
+  { "send-to", ev_window_cmd_send_to },
+  { "open-containing-folder", ev_window_cmd_open_containing_folder },
+  { "print", ev_window_cmd_file_print },
+  { "show-properties", ev_window_cmd_file_properties },
+  { "copy", ev_window_cmd_edit_copy },
+  { "select-all", ev_window_cmd_edit_select_all },
+  { "save-settings", ev_window_cmd_edit_save_settings },
+  { "go-previous-page", ev_window_cmd_go_previous_page },
+  { "go-next-page", ev_window_cmd_go_next_page },
+  { "go-first-page", ev_window_cmd_go_first_page },
+  { "go-last-page", ev_window_cmd_go_last_page },
+  { "go-forward", ev_window_cmd_go_forward },
+  { "go-backwards", ev_window_cmd_go_backwards },
+  { "go-back-history", ev_window_cmd_go_back_history },
+  { "go-forward-history", ev_window_cmd_go_forward_history },
+  { "find", ev_window_cmd_find },
+  { "toggle-find", NULL, NULL, "false", ev_window_cmd_toggle_find },
+  { "find-next", ev_window_cmd_edit_find_next },
+  { "find-previous", ev_window_cmd_edit_find_previous },
+  { "select-page", ev_window_cmd_focus_page_selector },
+  { "continuous", NULL, NULL, "true", ev_window_cmd_continuous },
+  { "creator-mode", NULL, NULL, "false", ev_window_cmd_creator_mode },
+  { "dual-page", NULL, NULL, "false", ev_window_cmd_dual },
+  { "dual-odd-left", NULL, NULL, "false", ev_window_cmd_dual_odd_pages_left },
+  { "rtl", NULL, NULL, "false", ev_window_cmd_rtl },
+  { "show-side-pane", NULL, NULL, "false", ev_window_view_cmd_toggle_sidebar },
+  { "inverted-colors", NULL, NULL, "false", ev_window_cmd_view_inverted_colors },
+  { "enable-spellchecking", NULL, NULL, "false", ev_window_cmd_view_enable_spellchecking },
+  { "fullscreen", NULL, NULL, "false", ev_window_cmd_view_fullscreen },
+  { "presentation", ev_window_cmd_view_presentation },
+  { "rotate-left", ev_window_cmd_edit_rotate_left },
+  { "rotate-right", ev_window_cmd_edit_rotate_right },
+  { "zoom-in", ev_window_cmd_view_zoom_in },
+  { "zoom-out", ev_window_cmd_view_zoom_out },
+  { "reload", ev_window_cmd_view_reload },
+  { "auto-scroll", ev_window_cmd_view_autoscroll },
+  { "add-bookmark", ev_window_cmd_bookmarks_add },
+  { "delete-bookmark", ev_window_cmd_bookmarks_delete },
+  { "goto-bookmark", ev_window_activate_goto_bookmark_action, "u" },
+  { "close", ev_window_cmd_file_close_window },
+  { "scroll-forward", ev_window_cmd_scroll_forward },
+  { "scroll-backwards", ev_window_cmd_scroll_backwards },
+  { "sizing-mode", NULL, "s", "'free'", ev_window_change_sizing_mode_action_state },
+  { "zoom", ev_window_cmd_view_zoom, "d" },
+  { "default-zoom", ev_window_cmd_set_default_zoom },
+  { "escape", ev_window_cmd_escape },
+  { "open-menu", ev_window_cmd_action_menu },
+  { "caret-navigation", NULL, NULL, "false", ev_window_cmd_view_toggle_caret_navigation },
+  { "add-annotation", NULL, NULL, "false", ev_window_cmd_add_annotation },
+  { "highlight-annotation", NULL, NULL, "false", ev_window_cmd_add_highlight_annotation },
+  { "toggle-edit-annots", NULL, NULL, "false", ev_window_cmd_toggle_edit_annots },
+  { "about", ev_window_cmd_about },
+  { "help", ev_window_cmd_help },
+  /* Popups specific items */
+  { "annotate-selected-text", ev_window_popup_cmd_annotate_selected_text },
+  { "open-link", ev_window_popup_cmd_open_link },
+  { "open-link-new-window", ev_window_popup_cmd_open_link_new_window },
+  { "go-to-link", ev_window_popup_cmd_open_link },
+  { "copy-link-address", ev_window_popup_cmd_copy_link_address },
+  { "save-image", ev_window_popup_cmd_save_image_as },
+  { "copy-image", ev_window_popup_cmd_copy_image },
+  { "open-attachment", ev_window_popup_cmd_open_attachment },
+  { "save-attachment", ev_window_popup_cmd_save_attachment_as },
+  { "annot-properties", ev_window_popup_cmd_annot_properties },
+  { "remove-annot", ev_window_popup_cmd_remove_annotation }
 };
 
 static void
-sidebar_links_link_activated_cb (EvSidebarLinks *sidebar_links, EvLink *link, EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+sidebar_links_link_activated_cb (EvSidebarLinks *sidebar_links, EvLink *link, EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_view_handle_link (EV_VIEW (priv->view), link);
+  ev_view_handle_link (EV_VIEW (priv->view), link);
 }
 
 static void
-activate_link_cb (GObject *object, EvLink *link, EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+activate_link_cb (GObject *object, EvLink *link, EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_view_handle_link (EV_VIEW (priv->view), link);
-	gtk_widget_grab_focus (priv->view);
+  ev_view_handle_link (EV_VIEW (priv->view), link);
+  gtk_widget_grab_focus (priv->view);
 }
 
 static void
 history_changed_cb (EvHistory *history,
-                    EvWindow  *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                    EvWindow  *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_window_set_action_enabled (window, "go-back-history",
-				      ev_history_can_go_back (priv->history));
-	ev_window_set_action_enabled (window, "go-forward-history",
-				      ev_history_can_go_forward (priv->history));
+  ev_window_set_action_enabled (window, "go-back-history",
+                                ev_history_can_go_back (priv->history));
+  ev_window_set_action_enabled (window, "go-forward-history",
+                                ev_history_can_go_forward (priv->history));
 }
 
 static void
 sidebar_layers_visibility_changed (EvSidebarLayers *layers,
-				   EvWindow        *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                                   EvWindow        *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_view_reload (EV_VIEW (priv->view));
+  ev_view_reload (EV_VIEW (priv->view));
 }
 
 static void
 sidebar_annots_annot_activated_cb (EvSidebarAnnotations *sidebar_annots,
-				   EvMapping            *annot_mapping,
-				   EvWindow             *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                                   EvMapping            *annot_mapping,
+                                   EvWindow             *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_view_focus_annotation (EV_VIEW (priv->view), annot_mapping);
+  ev_view_focus_annotation (EV_VIEW (priv->view), annot_mapping);
 }
 
 static void
 ev_window_begin_add_annot (EvWindow        *window,
-			   EvAnnotationType annot_type)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                           EvAnnotationType annot_type) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	if (annot_type == EV_ANNOTATION_TYPE_TEXT_MARKUP &&
-	    ev_view_get_has_selection (EV_VIEW (priv->view))) {
-		ev_view_add_text_markup_annotation_for_selected_text (EV_VIEW (priv->view));
-		return;
-	}
+  if (annot_type == EV_ANNOTATION_TYPE_TEXT_MARKUP &&
+      ev_view_get_has_selection (EV_VIEW (priv->view))) {
+    ev_view_add_text_markup_annotation_for_selected_text (EV_VIEW (priv->view));
+    return;
+  }
 
-	ev_view_begin_add_annotation (EV_VIEW (priv->view), annot_type);
+  ev_view_begin_add_annotation (EV_VIEW (priv->view), annot_type);
 }
 
 static void
 view_annot_added (EvView       *view,
-		  EvAnnotation *annot,
-		  EvWindow     *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                  EvAnnotation *annot,
+                  EvWindow     *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_sidebar_annotations_annot_added (EV_SIDEBAR_ANNOTATIONS (priv->sidebar_annots),
-					    annot);
-	ev_annotations_toolbar_add_annot_finished (EV_ANNOTATIONS_TOOLBAR (priv->annots_toolbar));
+  ev_sidebar_annotations_annot_added (EV_SIDEBAR_ANNOTATIONS (priv->sidebar_annots),
+                                      annot);
+  ev_annotations_toolbar_add_annot_finished (EV_ANNOTATIONS_TOOLBAR (priv->annots_toolbar));
 }
 
 static void
 view_annot_removed (EvView       *view,
-		    EvAnnotation *annot,
-		    EvWindow     *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                    EvAnnotation *annot,
+                    EvWindow     *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_sidebar_annotations_annot_removed (EV_SIDEBAR_ANNOTATIONS (priv->sidebar_annots));
+  ev_sidebar_annotations_annot_removed (EV_SIDEBAR_ANNOTATIONS (priv->sidebar_annots));
 }
 
 static void
-ev_window_cancel_add_annot(EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+ev_window_cancel_add_annot(EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_view_cancel_add_annotation (EV_VIEW (priv->view));
+  ev_view_cancel_add_annotation (EV_VIEW (priv->view));
 }
 
 static void
 sidebar_widget_model_set (EvSidebarLinks *ev_sidebar_links,
-			  GParamSpec     *pspec,
-			  EvWindow       *ev_window)
-{
-	ev_window_update_links_model (ev_window);
+                          GParamSpec     *pspec,
+                          EvWindow       *ev_window) {
+  ev_window_update_links_model (ev_window);
 }
 
 static gboolean
-view_actions_focus_in_cb (GtkWidget *widget, GdkEventFocus *event, EvWindow *window)
-{
+view_actions_focus_in_cb (GtkWidget *widget, GdkEventFocus *event, EvWindow *window) {
 #ifdef ENABLE_DBUS
-	GObject *keys;
+  GObject *keys;
 
-	keys = ev_application_get_media_keys (EV_APP);
-	if (keys)
-		ev_media_player_keys_focused (EV_MEDIA_PLAYER_KEYS (keys));
+  keys = ev_application_get_media_keys (EV_APP);
+  if (keys)
+    ev_media_player_keys_focused (EV_MEDIA_PLAYER_KEYS (keys));
 #endif /* ENABLE_DBUS */
 
-	update_chrome_flag (window, EV_CHROME_RAISE_TOOLBAR, FALSE);
-	update_chrome_visibility (window);
+  update_chrome_flag (window, EV_CHROME_RAISE_TOOLBAR, FALSE);
+  update_chrome_visibility (window);
 
-	return FALSE;
+  return FALSE;
 }
 
 static void
 sidebar_page_main_widget_update_cb (GObject *ev_sidebar_page,
-				    GParamSpec         *pspec,
-				    EvWindow           *ev_window)
-{
-	GtkWidget *widget;
+                                    GParamSpec         *pspec,
+                                    EvWindow           *ev_window) {
+  GtkWidget *widget;
 
-	g_object_get (ev_sidebar_page, "main_widget", &widget, NULL);
+  g_object_get (ev_sidebar_page, "main_widget", &widget, NULL);
 
-    	if (widget != NULL) {
-		g_signal_connect_object (widget, "focus_in_event",
-				         G_CALLBACK (view_actions_focus_in_cb),
-					 ev_window, 0);
-		g_object_unref (widget);
-	}
+  if (widget != NULL) {
+    g_signal_connect_object (widget, "focus_in_event",
+                             G_CALLBACK (view_actions_focus_in_cb),
+                             ev_window, 0);
+    g_object_unref (widget);
+  }
 }
 
 static gboolean
-window_state_event_cb (EvWindow *window, GdkEventWindowState *event, gpointer dummy)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+window_state_event_cb (EvWindow *window, GdkEventWindowState *event, gpointer dummy) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	if (!(event->new_window_state & GDK_WINDOW_STATE_FULLSCREEN)) {
-		gboolean maximized;
+  if (!(event->new_window_state & GDK_WINDOW_STATE_FULLSCREEN)) {
+    gboolean maximized;
 
-		maximized = event->new_window_state & GDK_WINDOW_STATE_MAXIMIZED;
-		if (priv->metadata && !ev_window_is_empty (window))
-			ev_metadata_set_boolean (priv->metadata, "window_maximized", maximized);
-	}
+    maximized = event->new_window_state & GDK_WINDOW_STATE_MAXIMIZED;
+    if (priv->metadata && !ev_window_is_empty (window))
+      ev_metadata_set_boolean (priv->metadata, "window_maximized", maximized);
+  }
 
-	return FALSE;
+  return FALSE;
 }
 
 static gboolean
-window_configure_event_cb (EvWindow *window, GdkEventConfigure *event, gpointer dummy)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	GdkWindowState state;
-	gdouble document_width, document_height;
-	gint window_x, window_y, window_width, window_height;
-
-	if (!priv->metadata)
-		return FALSE;
-
-	state = gdk_window_get_state (gtk_widget_get_window (GTK_WIDGET (window)));
-
-	if (!(state & GDK_WINDOW_STATE_FULLSCREEN) &&
-	    !(state & GDK_WINDOW_STATE_MAXIMIZED)) {
-		if (priv->document) {
-			ev_document_get_max_page_size (priv->document,
-						       &document_width, &document_height);
-			gtk_window_get_size (GTK_WINDOW (window), &window_width, &window_height);
-			gtk_window_get_position (GTK_WINDOW (window), &window_x, &window_y);
-			g_settings_set (priv->default_settings, "window-ratio", "(dd)",
-					(double)window_width / document_width,
-					(double)window_height / document_height);
-
-			ev_metadata_set_int (priv->metadata, "window_x", window_x);
-			ev_metadata_set_int (priv->metadata, "window_y", window_y);
-			ev_metadata_set_int (priv->metadata, "window_width",window_width);
-			ev_metadata_set_int (priv->metadata, "window_height", window_height);
-		}
-	}
-
-	return FALSE;
-}
-
-static void
-launch_action (EvWindow *window, EvLinkAction *action)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	const char *filename = ev_link_action_get_filename (action);
-	GAppInfo *app_info;
-	GFile *file;
-	GList file_list = {NULL};
-	GdkAppLaunchContext *context;
-	GdkScreen *screen;
-	GError *error = NULL;
-
-	if (filename == NULL)
-		return;
-
-	if (g_path_is_absolute (filename)) {
-		file = g_file_new_for_path (filename);
-	} else {
-		GFile *base_file;
-		gchar *dir;
-
-		dir = g_path_get_dirname (priv->uri);
-		base_file = g_file_new_for_uri (dir);
-		g_free (dir);
-		
-		file = g_file_resolve_relative_path (base_file, filename);
-		g_object_unref (base_file);
-	}
-
-	app_info = g_file_query_default_handler (file, NULL, &error);
-	if (!app_info) {
-		ev_window_error_message (window, error,
-					 "%s",
-					 _("Unable to launch external application."));
-		g_object_unref (file);
-		g_error_free (error);
-
-		return;
-	}
-
-	screen = gtk_window_get_screen (GTK_WINDOW (window));
-	context = gdk_display_get_app_launch_context (gdk_screen_get_display (screen));
-	gdk_app_launch_context_set_screen (context, screen);
-	gdk_app_launch_context_set_timestamp (context, gtk_get_current_event_time ());
-
-	file_list.data = file;
-	if (!g_app_info_launch (app_info, &file_list, G_APP_LAUNCH_CONTEXT (context), &error)) {
-		ev_window_error_message (window, error,
-					 "%s",
-					 _("Unable to launch external application."));
-		g_error_free (error);
-	}
-
-	g_object_unref (app_info);
-	g_object_unref (file);
-        /* FIXMEchpe: unref launch context? */
-
-	/* According to the PDF spec filename can be an executable. I'm not sure
-	   allowing to launch executables is a good idea though. -- marco */
-}
-
-static void
-launch_external_uri (EvWindow *window, EvLinkAction *action)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	const gchar *uri = ev_link_action_get_uri (action);
-	GError *error = NULL;
-	gboolean ret;
-	GdkAppLaunchContext *context;
-	GdkScreen *screen;
-	GFile *file;
-	gchar *uri_scheme;
-
-	screen = gtk_window_get_screen (GTK_WINDOW (window));
-	context = gdk_display_get_app_launch_context (gdk_screen_get_display (screen));
-	gdk_app_launch_context_set_screen (context, screen);
-	gdk_app_launch_context_set_timestamp (context, gtk_get_current_event_time ());
-	file = g_file_new_for_uri (uri);
-	uri_scheme = g_file_get_uri_scheme (file);
-	g_object_unref (file);
-
-	if (uri_scheme == NULL) {
-		gchar *new_uri;
-
-		/* Not a valid uri, assume http if it starts with www */
-		if (g_str_has_prefix (uri, "www.")) {
-			new_uri = g_strdup_printf ("http://%s", uri);
-		} else {
-			GFile *parent;
-
-			file = g_file_new_for_uri (priv->uri);
-			parent = g_file_get_parent (file);
-			g_object_unref (file);
-			if (parent) {
-				gchar *parent_uri = g_file_get_uri (parent);
-
-				new_uri = g_build_filename (parent_uri, uri, NULL);
-				g_free (parent_uri);
-				g_object_unref (parent);
-			} else {
-				new_uri = g_strdup_printf ("file:///%s", uri);
-			}
-		}
-		ret = g_app_info_launch_default_for_uri (new_uri, G_APP_LAUNCH_CONTEXT (context), &error);
-		g_free (new_uri);
-	} else {
-		ret = g_app_info_launch_default_for_uri (uri, G_APP_LAUNCH_CONTEXT (context), &error);
-	}
-
-  	if (ret == FALSE) {
-		ev_window_error_message (window, error,
-					 "%s", _("Unable to open external link"));
-		g_error_free (error);
-	}
-
-        g_object_unref (context);
-}
-
-static void
-open_remote_link (EvWindow *window, EvLinkAction *action)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	gchar *uri;
-	gchar *dir;
-
-	dir = g_path_get_dirname (priv->uri);
-	
-	uri = g_build_filename (dir, ev_link_action_get_filename (action),
-				NULL);
-	g_free (dir);
-
-	ev_application_open_uri_at_dest (EV_APP, uri,
-					 gtk_window_get_screen (GTK_WINDOW (window)),
-					 ev_link_action_get_dest (action),
-					 0,
-					 NULL,
-					 gtk_get_current_event_time ());
-
-	g_free (uri);
-}
-
-static void
-do_action_named (EvWindow *window, EvLinkAction *action)
-{
-	const gchar *name = ev_link_action_get_name (action);
-
-	if (g_ascii_strcasecmp (name, "FirstPage") == 0) {
-		g_action_group_activate_action (G_ACTION_GROUP (window), "go-first-page", NULL);
-	} else if (g_ascii_strcasecmp (name, "PrevPage") == 0) {
-		g_action_group_activate_action (G_ACTION_GROUP (window), "go-previous-page", NULL);
-	} else if (g_ascii_strcasecmp (name, "NextPage") == 0) {
-		g_action_group_activate_action (G_ACTION_GROUP (window), "go-next-page", NULL);
-	} else if (g_ascii_strcasecmp (name, "LastPage") == 0) {
-		g_action_group_activate_action (G_ACTION_GROUP (window), "go-last-page", NULL);
-	} else if (g_ascii_strcasecmp (name, "GoToPage") == 0) {
-		g_action_group_activate_action (G_ACTION_GROUP (window), "select-page", NULL);
-	} else if (g_ascii_strcasecmp (name, "Find") == 0) {
-		g_action_group_activate_action (G_ACTION_GROUP (window), "find", NULL);
-	} else if (g_ascii_strcasecmp (name, "Close") == 0) {
-		g_action_group_activate_action (G_ACTION_GROUP (window), "close", NULL);
-	} else if (g_ascii_strcasecmp (name, "Print") == 0) {
-		g_action_group_activate_action (G_ACTION_GROUP (window), "print", NULL);
-	} else if (g_ascii_strcasecmp (name, "SaveAs") == 0) {
-		g_action_group_activate_action (G_ACTION_GROUP (window), "save-as", NULL);
-	} else {
-		g_warning ("Unimplemented named action: %s, please post a "
-		           "bug report in Evince Gitlab "
-		           "(https://gitlab.gnome.org/GNOME/evince/issues) "
-			   "with a testcase.",
-			   name);
-	}
-}
-
-static void
-view_external_link_cb (EvWindow *window, EvLinkAction *action)
-{
-	switch (ev_link_action_get_action_type (action)) {
-	        case EV_LINK_ACTION_TYPE_GOTO_DEST: {
-			EvLinkDest *dest;
-
-			dest = ev_link_action_get_dest (action);
-			if (!dest)
-				return;
-
-			ev_window_open_copy_at_dest (window, dest);
-		}
-			break;
-	        case EV_LINK_ACTION_TYPE_EXTERNAL_URI:
-			launch_external_uri (window, action);
-			break;
-	        case EV_LINK_ACTION_TYPE_LAUNCH:
-			launch_action (window, action);
-			break;
-	        case EV_LINK_ACTION_TYPE_GOTO_REMOTE:
-			open_remote_link (window, action);
-			break;
-	        case EV_LINK_ACTION_TYPE_NAMED:
-			do_action_named (window, action);
-			break;
-	        default:
-			g_assert_not_reached ();
-	}
+window_configure_event_cb (EvWindow *window, GdkEventConfigure *event, gpointer dummy) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  GdkWindowState state;
+  gdouble document_width, document_height;
+  gint window_x, window_y, window_width, window_height;
+
+  if (!priv->metadata)
+    return FALSE;
+
+  state = gdk_window_get_state (gtk_widget_get_window (GTK_WIDGET (window)));
+
+  if (!(state & GDK_WINDOW_STATE_FULLSCREEN) &&
+      !(state & GDK_WINDOW_STATE_MAXIMIZED)) {
+    if (priv->document) {
+      ev_document_get_max_page_size (priv->document,
+                                     &document_width, &document_height);
+      gtk_window_get_size (GTK_WINDOW (window), &window_width, &window_height);
+      gtk_window_get_position (GTK_WINDOW (window), &window_x, &window_y);
+      g_settings_set (priv->default_settings, "window-ratio", "(dd)",
+                      (double)window_width / document_width,
+                      (double)window_height / document_height);
+
+      ev_metadata_set_int (priv->metadata, "window_x", window_x);
+      ev_metadata_set_int (priv->metadata, "window_y", window_y);
+      ev_metadata_set_int (priv->metadata, "window_width", window_width);
+      ev_metadata_set_int (priv->metadata, "window_height", window_height);
+    }
+  }
+
+  return FALSE;
+}
+
+static void
+launch_action (EvWindow *window, EvLinkAction *action) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  const char *filename = ev_link_action_get_filename (action);
+  GAppInfo *app_info;
+  GFile *file;
+  GList file_list = {NULL};
+  GdkAppLaunchContext *context;
+  GdkScreen *screen;
+  GError *error = NULL;
+
+  if (filename == NULL)
+    return;
+
+  if (g_path_is_absolute (filename)) {
+    file = g_file_new_for_path (filename);
+  } else {
+    GFile *base_file;
+    gchar *dir;
+
+    dir = g_path_get_dirname (priv->uri);
+    base_file = g_file_new_for_uri (dir);
+    g_free (dir);
+
+    file = g_file_resolve_relative_path (base_file, filename);
+    g_object_unref (base_file);
+  }
+
+  app_info = g_file_query_default_handler (file, NULL, &error);
+  if (!app_info) {
+    ev_window_error_message (window, error,
+                             "%s",
+                             _("Unable to launch external application."));
+    g_object_unref (file);
+    g_error_free (error);
+
+    return;
+  }
+
+  screen = gtk_window_get_screen (GTK_WINDOW (window));
+  context = gdk_display_get_app_launch_context (gdk_screen_get_display (screen));
+  gdk_app_launch_context_set_screen (context, screen);
+  gdk_app_launch_context_set_timestamp (context, gtk_get_current_event_time ());
+
+  file_list.data = file;
+  if (!g_app_info_launch (app_info, &file_list, G_APP_LAUNCH_CONTEXT (context), &error)) {
+    ev_window_error_message (window, error,
+                             "%s",
+                             _("Unable to launch external application."));
+    g_error_free (error);
+  }
+
+  g_object_unref (app_info);
+  g_object_unref (file);
+  /* FIXMEchpe: unref launch context? */
+
+  /* According to the PDF spec filename can be an executable. I'm not sure
+     allowing to launch executables is a good idea though. -- marco */
+}
+
+static void
+launch_external_uri (EvWindow *window, EvLinkAction *action) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  const gchar *uri = ev_link_action_get_uri (action);
+  GError *error = NULL;
+  gboolean ret;
+  GdkAppLaunchContext *context;
+  GdkScreen *screen;
+  GFile *file;
+  gchar *uri_scheme;
+
+  screen = gtk_window_get_screen (GTK_WINDOW (window));
+  context = gdk_display_get_app_launch_context (gdk_screen_get_display (screen));
+  gdk_app_launch_context_set_screen (context, screen);
+  gdk_app_launch_context_set_timestamp (context, gtk_get_current_event_time ());
+  file = g_file_new_for_uri (uri);
+  uri_scheme = g_file_get_uri_scheme (file);
+  g_object_unref (file);
+
+  if (uri_scheme == NULL) {
+    gchar *new_uri;
+
+    /* Not a valid uri, assume http if it starts with www */
+    if (g_str_has_prefix (uri, "www.")) {
+      new_uri = g_strdup_printf ("http://%s", uri);
+    } else {
+      GFile *parent;
+
+      file = g_file_new_for_uri (priv->uri);
+      parent = g_file_get_parent (file);
+      g_object_unref (file);
+      if (parent) {
+        gchar *parent_uri = g_file_get_uri (parent);
+
+        new_uri = g_build_filename (parent_uri, uri, NULL);
+        g_free (parent_uri);
+        g_object_unref (parent);
+      } else {
+        new_uri = g_strdup_printf ("file:///%s", uri);
+      }
+    }
+    ret = g_app_info_launch_default_for_uri (new_uri, G_APP_LAUNCH_CONTEXT (context), &error);
+    g_free (new_uri);
+  } else {
+    ret = g_app_info_launch_default_for_uri (uri, G_APP_LAUNCH_CONTEXT (context), &error);
+  }
+
+  if (ret == FALSE) {
+    ev_window_error_message (window, error,
+                             "%s", _("Unable to open external link"));
+    g_error_free (error);
+  }
+
+  g_object_unref (context);
+}
+
+static void
+open_remote_link (EvWindow *window, EvLinkAction *action) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  gchar *uri;
+  gchar *dir;
+
+  dir = g_path_get_dirname (priv->uri);
+
+  uri = g_build_filename (dir, ev_link_action_get_filename (action),
+                          NULL);
+  g_free (dir);
+
+  ev_application_open_uri_at_dest (EV_APP, uri,
+                                   gtk_window_get_screen (GTK_WINDOW (window)),
+                                   ev_link_action_get_dest (action),
+                                   0,
+                                   NULL,
+                                   gtk_get_current_event_time ());
+
+  g_free (uri);
+}
+
+static void
+do_action_named (EvWindow *window, EvLinkAction *action) {
+  const gchar *name = ev_link_action_get_name (action);
+
+  if (g_ascii_strcasecmp (name, "FirstPage") == 0) {
+    g_action_group_activate_action (G_ACTION_GROUP (window), "go-first-page", NULL);
+  } else if (g_ascii_strcasecmp (name, "PrevPage") == 0) {
+    g_action_group_activate_action (G_ACTION_GROUP (window), "go-previous-page", NULL);
+  } else if (g_ascii_strcasecmp (name, "NextPage") == 0) {
+    g_action_group_activate_action (G_ACTION_GROUP (window), "go-next-page", NULL);
+  } else if (g_ascii_strcasecmp (name, "LastPage") == 0) {
+    g_action_group_activate_action (G_ACTION_GROUP (window), "go-last-page", NULL);
+  } else if (g_ascii_strcasecmp (name, "GoToPage") == 0) {
+    g_action_group_activate_action (G_ACTION_GROUP (window), "select-page", NULL);
+  } else if (g_ascii_strcasecmp (name, "Find") == 0) {
+    g_action_group_activate_action (G_ACTION_GROUP (window), "find", NULL);
+  } else if (g_ascii_strcasecmp (name, "Close") == 0) {
+    g_action_group_activate_action (G_ACTION_GROUP (window), "close", NULL);
+  } else if (g_ascii_strcasecmp (name, "Print") == 0) {
+    g_action_group_activate_action (G_ACTION_GROUP (window), "print", NULL);
+  } else if (g_ascii_strcasecmp (name, "SaveAs") == 0) {
+    g_action_group_activate_action (G_ACTION_GROUP (window), "save-as", NULL);
+  } else {
+    g_warning ("Unimplemented named action: %s, please post a "
+               "bug report in Evince Gitlab "
+               "(https://gitlab.gnome.org/GNOME/evince/issues) "
+               "with a testcase.",
+               name);
+  }
+}
+
+static void
+view_external_link_cb (EvWindow *window, EvLinkAction *action) {
+  switch (ev_link_action_get_action_type (action)) {
+    case EV_LINK_ACTION_TYPE_GOTO_DEST: {
+      EvLinkDest *dest;
+
+      dest = ev_link_action_get_dest (action);
+      if (!dest)
+        return;
+
+      ev_window_open_copy_at_dest (window, dest);
+    }
+    break;
+    case EV_LINK_ACTION_TYPE_EXTERNAL_URI:
+      launch_external_uri (window, action);
+      break;
+    case EV_LINK_ACTION_TYPE_LAUNCH:
+      launch_action (window, action);
+      break;
+    case EV_LINK_ACTION_TYPE_GOTO_REMOTE:
+      open_remote_link (window, action);
+      break;
+    case EV_LINK_ACTION_TYPE_NAMED:
+      do_action_named (window, action);
+      break;
+    default:
+      g_assert_not_reached ();
+  }
 }
 
 static void
 ev_window_popup_cmd_open_link (GSimpleAction *action,
-			       GVariant      *parameter,
-			       gpointer       user_data)
-{
-	EvWindow *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                               GVariant      *parameter,
+                               gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_view_handle_link (EV_VIEW (priv->view), priv->link);
+  ev_view_handle_link (EV_VIEW (priv->view), priv->link);
 }
 
 static void
 ev_window_popup_cmd_annotate_selected_text (GSimpleAction *action,
-					    GVariant      *parameter,
-					    gpointer       user_data)
-{
-	EvWindow *ev_window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	EvView *view = EV_VIEW (priv->view);
-	ev_view_add_text_markup_annotation_for_selected_text (view);
+                                            GVariant      *parameter,
+                                            gpointer       user_data) {
+  EvWindow *ev_window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  EvView *view = EV_VIEW (priv->view);
+  ev_view_add_text_markup_annotation_for_selected_text (view);
 }
 
 static void
 ev_window_popup_cmd_open_link_new_window (GSimpleAction *action,
-					  GVariant      *parameter,
-					  gpointer       user_data)
-{
-	EvLinkAction *ev_action = NULL;
-	EvLinkDest   *dest;
-	EvWindow     *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                                          GVariant      *parameter,
+                                          gpointer       user_data) {
+  EvLinkAction *ev_action = NULL;
+  EvLinkDest   *dest;
+  EvWindow     *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_action = ev_link_get_action (priv->link);
-	if (!ev_action)
-		return;
+  ev_action = ev_link_get_action (priv->link);
+  if (!ev_action)
+    return;
 
-	dest = ev_link_action_get_dest (ev_action);
-	if (!dest)
-		return;
+  dest = ev_link_action_get_dest (ev_action);
+  if (!dest)
+    return;
 
-	ev_window_open_copy_at_dest (window, dest);
+  ev_window_open_copy_at_dest (window, dest);
 }
 
 static void
 ev_window_popup_cmd_copy_link_address (GSimpleAction *action,
-				       GVariant      *parameter,
-				       gpointer       user_data)
-{
-	EvLinkAction *ev_action;
-	EvWindow     *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                                       GVariant      *parameter,
+                                       gpointer       user_data) {
+  EvLinkAction *ev_action;
+  EvWindow     *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_action = ev_link_get_action (priv->link);
-	if (!ev_action)
-		return;
+  ev_action = ev_link_get_action (priv->link);
+  if (!ev_action)
+    return;
 
-	ev_view_copy_link_address (EV_VIEW (priv->view),
-				   ev_action);
+  ev_view_copy_link_address (EV_VIEW (priv->view),
+                             ev_action);
 }
 
 static GFile *
 create_file_from_uri_for_format (const gchar     *uri,
-				 GdkPixbufFormat *format)
-{
-	GFile  *target_file;
-	gchar **extensions;
-	gchar  *uri_extension;
-	gint    i;
+                                 GdkPixbufFormat *format) {
+  GFile  *target_file;
+  gchar **extensions;
+  gchar  *uri_extension;
+  gint    i;
 
-	extensions = gdk_pixbuf_format_get_extensions (format);
-	for (i = 0; extensions[i]; i++) {
-		if (g_str_has_suffix (uri, extensions[i])) {
-			g_strfreev (extensions);
-			return g_file_new_for_uri (uri);
-		}
-	}
+  extensions = gdk_pixbuf_format_get_extensions (format);
+  for (i = 0; extensions[i]; i++) {
+    if (g_str_has_suffix (uri, extensions[i])) {
+      g_strfreev (extensions);
+      return g_file_new_for_uri (uri);
+    }
+  }
 
-	uri_extension = g_strconcat (uri, ".", extensions[0], NULL);
-	target_file = g_file_new_for_uri (uri_extension);
-	g_free (uri_extension);
-	g_strfreev (extensions);
+  uri_extension = g_strconcat (uri, ".", extensions[0], NULL);
+  target_file = g_file_new_for_uri (uri_extension);
+  g_free (uri_extension);
+  g_strfreev (extensions);
 
-	return target_file;
+  return target_file;
 }
 
 static void
 image_save_dialog_response_cb (GtkWidget *fc,
-			       gint       response_id,
-			       EvWindow  *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	GFile           *target_file;
-	gboolean         is_native;
-	GError          *error = NULL;
-	GdkPixbuf       *pixbuf;
-	gchar           *uri;
-	gchar           *filename;
-	gchar           *file_format;
-	GdkPixbufFormat *format;
-	GtkFileFilter   *filter;
-
-	if (response_id != GTK_RESPONSE_OK) {
-		gtk_widget_destroy (fc);
-		return;
-	}
-
-	ev_window_file_chooser_save_folder (ev_window, GTK_FILE_CHOOSER (fc),
-                                            G_USER_DIRECTORY_PICTURES);
-
-	uri = gtk_file_chooser_get_uri (GTK_FILE_CHOOSER (fc));
-	filter = gtk_file_chooser_get_filter (GTK_FILE_CHOOSER (fc));
-	format = g_object_get_data (G_OBJECT (filter), "pixbuf-format");
-	
-	if (format == NULL) {
-		format = get_gdk_pixbuf_format_by_extension (uri);
-	}
-
-	if (format == NULL && g_strrstr (uri, ".") == NULL) {
-		/* no extension found and no extension provided within uri */
-		format = get_gdk_pixbuf_format_by_extension (".png");
-		if (format == NULL) {
-			/* no .png support, try .jpeg */
-			format = get_gdk_pixbuf_format_by_extension (".jpeg");
-		}
-	}
-
-	if (format == NULL) {
-		ev_window_error_message (ev_window, NULL, 
-					 "%s",
-					 _("Couldn’t find appropriate format to save image"));
-		g_free (uri);
-		gtk_widget_destroy (fc);
-
-		return;
-	}
-
-	target_file = create_file_from_uri_for_format (uri, format);
-	g_free (uri);
-
-	is_native = g_file_is_native (target_file);
-	if (is_native) {
-		filename = g_file_get_path (target_file);
-	} else {
-                /* Create a temporary local file to save to */
-                if (ev_mkstemp ("saveimage.XXXXXX", &filename, &error) == -1)
-                        goto has_error;
-	}
-
-	ev_document_doc_mutex_lock ();
-	pixbuf = ev_document_images_get_image (EV_DOCUMENT_IMAGES (priv->document),
-					       priv->image);
-	ev_document_doc_mutex_unlock ();
-
-	file_format = gdk_pixbuf_format_get_name (format);
-	gdk_pixbuf_save (pixbuf, filename, file_format, &error, NULL);
-	g_free (file_format);
-	g_object_unref (pixbuf);
-	
-    has_error:
-	if (error) {
-		ev_window_error_message (ev_window, error, 
-					 "%s", _("The image could not be saved."));
-		g_error_free (error);
-		g_free (filename);
-		g_object_unref (target_file);
-		gtk_widget_destroy (fc);
-
-		return;
-	}
-
-	if (!is_native) {
-		GFile *source_file;
-
-		source_file = g_file_new_for_path (filename);
-
-		ev_window_save_remote (ev_window, EV_SAVE_IMAGE,
-				       source_file, target_file);
-		g_object_unref (source_file);
-	}
-	
-	g_free (filename);
-	g_object_unref (target_file);
-	gtk_widget_destroy (fc);
+                               gint       response_id,
+                               EvWindow  *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  GFile           *target_file;
+  gboolean         is_native;
+  GError          *error = NULL;
+  GdkPixbuf       *pixbuf;
+  gchar           *uri;
+  gchar           *filename;
+  gchar           *file_format;
+  GdkPixbufFormat *format;
+  GtkFileFilter   *filter;
+
+  if (response_id != GTK_RESPONSE_OK) {
+    gtk_widget_destroy (fc);
+    return;
+  }
+
+  ev_window_file_chooser_save_folder (ev_window, GTK_FILE_CHOOSER (fc),
+                                      G_USER_DIRECTORY_PICTURES);
+
+  uri = gtk_file_chooser_get_uri (GTK_FILE_CHOOSER (fc));
+  filter = gtk_file_chooser_get_filter (GTK_FILE_CHOOSER (fc));
+  format = g_object_get_data (G_OBJECT (filter), "pixbuf-format");
+
+  if (format == NULL) {
+    format = get_gdk_pixbuf_format_by_extension (uri);
+  }
+
+  if (format == NULL && g_strrstr (uri, ".") == NULL) {
+    /* no extension found and no extension provided within uri */
+    format = get_gdk_pixbuf_format_by_extension (".png");
+    if (format == NULL) {
+      /* no .png support, try .jpeg */
+      format = get_gdk_pixbuf_format_by_extension (".jpeg");
+    }
+  }
+
+  if (format == NULL) {
+    ev_window_error_message (ev_window, NULL,
+                             "%s",
+                             _("Couldn’t find appropriate format to save image"));
+    g_free (uri);
+    gtk_widget_destroy (fc);
+
+    return;
+  }
+
+  target_file = create_file_from_uri_for_format (uri, format);
+  g_free (uri);
+
+  is_native = g_file_is_native (target_file);
+  if (is_native) {
+    filename = g_file_get_path (target_file);
+  } else {
+    /* Create a temporary local file to save to */
+    if (ev_mkstemp ("saveimage.XXXXXX", &filename, &error) == -1)
+      goto has_error;
+  }
+
+  ev_document_doc_mutex_lock ();
+  pixbuf = ev_document_images_get_image (EV_DOCUMENT_IMAGES (priv->document),
+                                         priv->image);
+  ev_document_doc_mutex_unlock ();
+
+  file_format = gdk_pixbuf_format_get_name (format);
+  gdk_pixbuf_save (pixbuf, filename, file_format, &error, NULL);
+  g_free (file_format);
+  g_object_unref (pixbuf);
+
+has_error:
+  if (error) {
+    ev_window_error_message (ev_window, error,
+                             "%s", _("The image could not be saved."));
+    g_error_free (error);
+    g_free (filename);
+    g_object_unref (target_file);
+    gtk_widget_destroy (fc);
+
+    return;
+  }
+
+  if (!is_native) {
+    GFile *source_file;
+
+    source_file = g_file_new_for_path (filename);
+
+    ev_window_save_remote (ev_window, EV_SAVE_IMAGE,
+                           source_file, target_file);
+    g_object_unref (source_file);
+  }
+
+  g_free (filename);
+  g_object_unref (target_file);
+  gtk_widget_destroy (fc);
 }
 
 static void
 ev_window_popup_cmd_save_image_as (GSimpleAction *action,
-				   GVariant      *parameter,
-				   gpointer       user_data)
-{
-	GtkWidget *fc;
-	EvWindow  *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                                   GVariant      *parameter,
+                                   gpointer       user_data) {
+  GtkWidget *fc;
+  EvWindow  *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	if (!priv->image)
-		return;
+  if (!priv->image)
+    return;
 
-	fc = gtk_file_chooser_dialog_new (_("Save Image"),
-					  GTK_WINDOW (window),
-					  GTK_FILE_CHOOSER_ACTION_SAVE,
-					  _("_Cancel"),
-					  GTK_RESPONSE_CANCEL,
-					  _("_Save"), GTK_RESPONSE_OK,
-					  NULL);
+  fc = gtk_file_chooser_dialog_new (_("Save Image"),
+                                    GTK_WINDOW (window),
+                                    GTK_FILE_CHOOSER_ACTION_SAVE,
+                                    _("_Cancel"),
+                                    GTK_RESPONSE_CANCEL,
+                                    _("_Save"), GTK_RESPONSE_OK,
+                                    NULL);
 
-	gtk_dialog_set_default_response (GTK_DIALOG (fc), GTK_RESPONSE_OK);
+  gtk_dialog_set_default_response (GTK_DIALOG (fc), GTK_RESPONSE_OK);
 
-	gtk_file_chooser_set_local_only (GTK_FILE_CHOOSER (fc), FALSE);
-	gtk_file_chooser_set_do_overwrite_confirmation (GTK_FILE_CHOOSER (fc), TRUE);
+  gtk_file_chooser_set_local_only (GTK_FILE_CHOOSER (fc), FALSE);
+  gtk_file_chooser_set_do_overwrite_confirmation (GTK_FILE_CHOOSER (fc), TRUE);
 
-	file_chooser_dialog_add_writable_pixbuf_formats	(GTK_FILE_CHOOSER (fc));
+  file_chooser_dialog_add_writable_pixbuf_formats	(GTK_FILE_CHOOSER (fc));
 
-        ev_window_file_chooser_restore_folder (window, GTK_FILE_CHOOSER (fc), NULL,
-                                               G_USER_DIRECTORY_PICTURES);
+  ev_window_file_chooser_restore_folder (window, GTK_FILE_CHOOSER (fc), NULL,
+                                         G_USER_DIRECTORY_PICTURES);
 
-	g_signal_connect (fc, "response",
-			  G_CALLBACK (image_save_dialog_response_cb),
-			  window);
+  g_signal_connect (fc, "response",
+                    G_CALLBACK (image_save_dialog_response_cb),
+                    window);
 
-	gtk_widget_show (fc);
+  gtk_widget_show (fc);
 }
 
 static void
 ev_window_popup_cmd_copy_image (GSimpleAction *action,
-				GVariant      *parameter,
-				gpointer       user_data)
-{
-	GtkClipboard *clipboard;
-	GdkPixbuf    *pixbuf;
-	EvWindow     *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                                GVariant      *parameter,
+                                gpointer       user_data) {
+  GtkClipboard *clipboard;
+  GdkPixbuf    *pixbuf;
+  EvWindow     *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	if (!priv->image)
-		return;
+  if (!priv->image)
+    return;
 
-	clipboard = gtk_widget_get_clipboard (GTK_WIDGET (window),
-					      GDK_SELECTION_CLIPBOARD);
-	ev_document_doc_mutex_lock ();
-	pixbuf = ev_document_images_get_image (EV_DOCUMENT_IMAGES (priv->document),
-					       priv->image);
-	ev_document_doc_mutex_unlock ();
+  clipboard = gtk_widget_get_clipboard (GTK_WIDGET (window),
+                                        GDK_SELECTION_CLIPBOARD);
+  ev_document_doc_mutex_lock ();
+  pixbuf = ev_document_images_get_image (EV_DOCUMENT_IMAGES (priv->document),
+                                         priv->image);
+  ev_document_doc_mutex_unlock ();
 
-	gtk_clipboard_set_image (clipboard, pixbuf);
-	g_object_unref (pixbuf);
+  gtk_clipboard_set_image (clipboard, pixbuf);
+  g_object_unref (pixbuf);
 }
 
 static void
 ev_window_popup_cmd_annot_properties (GSimpleAction *action,
-				      GVariant      *parameter,
-				      gpointer       user_data)
-{
-	EvWindow                     *window = user_data;
-	EvWindowPrivate              *priv = GET_PRIVATE (window);
-	const gchar                  *author;
-	GdkRGBA                       rgba;
-	gdouble                       opacity;
-	gboolean                      popup_is_open;
-	EvAnnotationPropertiesDialog *dialog;
-	EvAnnotation                 *annot = priv->annot;
-	EvAnnotationsSaveMask         mask = EV_ANNOTATIONS_SAVE_NONE;
+                                      GVariant      *parameter,
+                                      gpointer       user_data) {
+  EvWindow                     *window = user_data;
+  EvWindowPrivate              *priv = GET_PRIVATE (window);
+  const gchar                  *author;
+  GdkRGBA                       rgba;
+  gdouble                       opacity;
+  gboolean                      popup_is_open;
+  EvAnnotationPropertiesDialog *dialog;
+  EvAnnotation                 *annot = priv->annot;
+  EvAnnotationsSaveMask         mask = EV_ANNOTATIONS_SAVE_NONE;
 
-	if (!annot)
-		return;
+  if (!annot)
+    return;
 
-	dialog = EV_ANNOTATION_PROPERTIES_DIALOG (ev_annotation_properties_dialog_new_with_annotation (priv->annot));
-	gtk_window_set_transient_for (GTK_WINDOW (dialog), GTK_WINDOW (window));
-	if (gtk_dialog_run (GTK_DIALOG (dialog)) != GTK_RESPONSE_APPLY) {
-		gtk_widget_destroy (GTK_WIDGET (dialog));
+  dialog = EV_ANNOTATION_PROPERTIES_DIALOG (ev_annotation_properties_dialog_new_with_annotation (priv->annot));
+  gtk_window_set_transient_for (GTK_WINDOW (dialog), GTK_WINDOW (window));
+  if (gtk_dialog_run (GTK_DIALOG (dialog)) != GTK_RESPONSE_APPLY) {
+    gtk_widget_destroy (GTK_WIDGET (dialog));
 
-		return;
-	}
+    return;
+  }
 
-	/* Set annotations changes */
-	author = ev_annotation_properties_dialog_get_author (dialog);
-	if (ev_annotation_markup_set_label (EV_ANNOTATION_MARKUP (annot), author))
-		mask |= EV_ANNOTATIONS_SAVE_LABEL;
+  /* Set annotations changes */
+  author = ev_annotation_properties_dialog_get_author (dialog);
+  if (ev_annotation_markup_set_label (EV_ANNOTATION_MARKUP (annot), author))
+    mask |= EV_ANNOTATIONS_SAVE_LABEL;
 
-	ev_annotation_properties_dialog_get_rgba (dialog, &rgba);
-	if (ev_annotation_set_rgba (annot, &rgba))
-		mask |= EV_ANNOTATIONS_SAVE_COLOR;
+  ev_annotation_properties_dialog_get_rgba (dialog, &rgba);
+  if (ev_annotation_set_rgba (annot, &rgba))
+    mask |= EV_ANNOTATIONS_SAVE_COLOR;
 
-	opacity = ev_annotation_properties_dialog_get_opacity (dialog);
-	if (ev_annotation_markup_set_opacity (EV_ANNOTATION_MARKUP (annot), opacity))
-		mask |= EV_ANNOTATIONS_SAVE_OPACITY;
+  opacity = ev_annotation_properties_dialog_get_opacity (dialog);
+  if (ev_annotation_markup_set_opacity (EV_ANNOTATION_MARKUP (annot), opacity))
+    mask |= EV_ANNOTATIONS_SAVE_OPACITY;
 
-	popup_is_open = ev_annotation_properties_dialog_get_popup_is_open (dialog);
-	if (ev_annotation_markup_set_popup_is_open (EV_ANNOTATION_MARKUP (annot), popup_is_open))
-		mask |= EV_ANNOTATIONS_SAVE_POPUP_IS_OPEN;
+  popup_is_open = ev_annotation_properties_dialog_get_popup_is_open (dialog);
+  if (ev_annotation_markup_set_popup_is_open (EV_ANNOTATION_MARKUP (annot), popup_is_open))
+    mask |= EV_ANNOTATIONS_SAVE_POPUP_IS_OPEN;
 
-	if (EV_IS_ANNOTATION_TEXT (annot)) {
-		EvAnnotationTextIcon icon;
+  if (EV_IS_ANNOTATION_TEXT (annot)) {
+    EvAnnotationTextIcon icon;
 
-		icon = ev_annotation_properties_dialog_get_text_icon (dialog);
-		if (ev_annotation_text_set_icon (EV_ANNOTATION_TEXT (annot), icon))
-			mask |= EV_ANNOTATIONS_SAVE_TEXT_ICON;
-	}
+    icon = ev_annotation_properties_dialog_get_text_icon (dialog);
+    if (ev_annotation_text_set_icon (EV_ANNOTATION_TEXT (annot), icon))
+      mask |= EV_ANNOTATIONS_SAVE_TEXT_ICON;
+  }
 
-	if (EV_IS_ANNOTATION_TEXT_MARKUP (annot)) {
-		EvAnnotationTextMarkupType markup_type;
+  if (EV_IS_ANNOTATION_TEXT_MARKUP (annot)) {
+    EvAnnotationTextMarkupType markup_type;
 
-		markup_type = ev_annotation_properties_dialog_get_text_markup_type (dialog);
-		if (ev_annotation_text_markup_set_markup_type (EV_ANNOTATION_TEXT_MARKUP (annot), markup_type))
-			mask |= EV_ANNOTATIONS_SAVE_TEXT_MARKUP_TYPE;
-	}
+    markup_type = ev_annotation_properties_dialog_get_text_markup_type (dialog);
+    if (ev_annotation_text_markup_set_markup_type (EV_ANNOTATION_TEXT_MARKUP (annot), markup_type))
+      mask |= EV_ANNOTATIONS_SAVE_TEXT_MARKUP_TYPE;
+  }
 
-	if (mask != EV_ANNOTATIONS_SAVE_NONE) {
-		ev_document_doc_mutex_lock ();
-		ev_document_annotations_save_annotation (EV_DOCUMENT_ANNOTATIONS (priv->document),
-							 priv->annot,
-							 mask);
-		ev_document_doc_mutex_unlock ();
+  if (mask != EV_ANNOTATIONS_SAVE_NONE) {
+    ev_document_doc_mutex_lock ();
+    ev_document_annotations_save_annotation (EV_DOCUMENT_ANNOTATIONS (priv->document),
+                                             priv->annot,
+                                             mask);
+    ev_document_doc_mutex_unlock ();
 
-		/* FIXME: update annot region only */
-		ev_view_reload (EV_VIEW (priv->view));
-	}
+    /* FIXME: update annot region only */
+    ev_view_reload (EV_VIEW (priv->view));
+  }
 
-	gtk_widget_destroy (GTK_WIDGET (dialog));
+  gtk_widget_destroy (GTK_WIDGET (dialog));
 }
 
 static void
 ev_window_popup_cmd_remove_annotation (GSimpleAction *action,
-				       GVariant      *parameter,
-				       gpointer       user_data)
-{
-	EvWindow *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                                       GVariant      *parameter,
+                                       gpointer       user_data) {
+  EvWindow *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	ev_view_remove_annotation (EV_VIEW (priv->view),
-				   priv->annot);
+  ev_view_remove_annotation (EV_VIEW (priv->view),
+                             priv->annot);
 }
 
 static void
 ev_window_popup_cmd_open_attachment (GSimpleAction *action,
-				     GVariant      *parameter,
-				     gpointer       user_data)
-{
-	GList     *l;
-	GdkScreen *screen;
-	EvWindow  *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                                     GVariant      *parameter,
+                                     gpointer       user_data) {
+  GList     *l;
+  GdkScreen *screen;
+  EvWindow  *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	if (!priv->attach_list)
-		return;
+  if (!priv->attach_list)
+    return;
 
-	screen = gtk_window_get_screen (GTK_WINDOW (window));
+  screen = gtk_window_get_screen (GTK_WINDOW (window));
 
-	for (l = priv->attach_list; l && l->data; l = g_list_next (l)) {
-		EvAttachment *attachment;
-		GError       *error = NULL;
+  for (l = priv->attach_list; l && l->data; l = g_list_next (l)) {
+    EvAttachment *attachment;
+    GError       *error = NULL;
 
-		attachment = (EvAttachment *) l->data;
+    attachment = (EvAttachment *) l->data;
 
-		ev_attachment_open (attachment, screen, gtk_get_current_event_time (), &error);
+    ev_attachment_open (attachment, screen, gtk_get_current_event_time (), &error);
 
-		if (error) {
-			ev_window_error_message (window, error, 
-						 "%s", _("Unable to open attachment"));
-			g_error_free (error);
-		}
-	}
+    if (error) {
+      ev_window_error_message (window, error,
+                               "%s", _("Unable to open attachment"));
+      g_error_free (error);
+    }
+  }
 }
 
 static void
 attachment_save_dialog_response_cb (GtkWidget *fc,
-				    gint       response_id,
-				    EvWindow  *ev_window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
-	GFile                *target_file;
-	gchar                *uri;
-	GList                *l;
-	GtkFileChooserAction  fc_action;
-	gboolean              is_dir;
-	gboolean              is_native;
+                                    gint       response_id,
+                                    EvWindow  *ev_window) {
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  GFile                *target_file;
+  gchar                *uri;
+  GList                *l;
+  GtkFileChooserAction  fc_action;
+  gboolean              is_dir;
+  gboolean              is_native;
 
-	if (response_id != GTK_RESPONSE_OK) {
-		gtk_widget_destroy (fc);
-		return;
-	}
+  if (response_id != GTK_RESPONSE_OK) {
+    gtk_widget_destroy (fc);
+    return;
+  }
 
-	ev_window_file_chooser_save_folder (ev_window, GTK_FILE_CHOOSER (fc),
-                                            G_USER_DIRECTORY_DOCUMENTS);
+  ev_window_file_chooser_save_folder (ev_window, GTK_FILE_CHOOSER (fc),
+                                      G_USER_DIRECTORY_DOCUMENTS);
 
-	uri = gtk_file_chooser_get_uri (GTK_FILE_CHOOSER (fc));
-	target_file = g_file_new_for_uri (uri);
-	g_object_get (G_OBJECT (fc), "action", &fc_action, NULL);
-	is_dir = (fc_action == GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER);
-	is_native = g_file_is_native (target_file);
+  uri = gtk_file_chooser_get_uri (GTK_FILE_CHOOSER (fc));
+  target_file = g_file_new_for_uri (uri);
+  g_object_get (G_OBJECT (fc), "action", &fc_action, NULL);
+  is_dir = (fc_action == GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER);
+  is_native = g_file_is_native (target_file);
 
-	for (l = priv->attach_list; l && l->data; l = g_list_next (l)) {
-		EvAttachment *attachment;
+  for (l = priv->attach_list; l && l->data; l = g_list_next (l)) {
+    EvAttachment *attachment;
 
-		attachment = (EvAttachment *) l->data;
+    attachment = (EvAttachment *) l->data;
 
-		save_attachment_to_target_file (attachment,
-		                                target_file,
-		                                is_dir,
-		                                is_native,
-		                                ev_window);
-	}
+    save_attachment_to_target_file (attachment,
+                                    target_file,
+                                    is_dir,
+                                    is_native,
+                                    ev_window);
+  }
 
-	g_free (uri);
-	g_object_unref (target_file);
+  g_free (uri);
+  g_object_unref (target_file);
 
-	gtk_widget_destroy (fc);
+  gtk_widget_destroy (fc);
 }
 
 static void
 ev_window_popup_cmd_save_attachment_as (GSimpleAction *action,
-					GVariant      *parameter,
-					gpointer       user_data)
-{
-	GtkWidget    *fc;
-	EvAttachment *attachment = NULL;
-	EvWindow     *window = user_data;
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                                        GVariant      *parameter,
+                                        gpointer       user_data) {
+  GtkWidget    *fc;
+  EvAttachment *attachment = NULL;
+  EvWindow     *window = user_data;
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	if (!priv->attach_list)
-		return;
+  if (!priv->attach_list)
+    return;
 
-	if (g_list_length (priv->attach_list) == 1)
-		attachment = (EvAttachment *) priv->attach_list->data;
-	
-	fc = gtk_file_chooser_dialog_new (
-		_("Save Attachment"),
-		GTK_WINDOW (window),
-		attachment ? GTK_FILE_CHOOSER_ACTION_SAVE : GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER,
-		_("_Cancel"),
-		GTK_RESPONSE_CANCEL,
-		_("_Save"), GTK_RESPONSE_OK,
-		NULL);
+  if (g_list_length (priv->attach_list) == 1)
+    attachment = (EvAttachment *) priv->attach_list->data;
 
-	gtk_dialog_set_default_response (GTK_DIALOG (fc), GTK_RESPONSE_OK);
+  fc = gtk_file_chooser_dialog_new (
+         _("Save Attachment"),
+         GTK_WINDOW (window),
+         attachment ? GTK_FILE_CHOOSER_ACTION_SAVE : GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER,
+         _("_Cancel"),
+         GTK_RESPONSE_CANCEL,
+         _("_Save"), GTK_RESPONSE_OK,
+         NULL);
 
-	gtk_file_chooser_set_do_overwrite_confirmation (GTK_FILE_CHOOSER (fc), TRUE);
-	gtk_file_chooser_set_local_only (GTK_FILE_CHOOSER (fc), FALSE);
+  gtk_dialog_set_default_response (GTK_DIALOG (fc), GTK_RESPONSE_OK);
 
-	if (attachment)
-		gtk_file_chooser_set_current_name (GTK_FILE_CHOOSER (fc),
-						   ev_attachment_get_name (attachment));
+  gtk_file_chooser_set_do_overwrite_confirmation (GTK_FILE_CHOOSER (fc), TRUE);
+  gtk_file_chooser_set_local_only (GTK_FILE_CHOOSER (fc), FALSE);
 
-        ev_window_file_chooser_restore_folder (window, GTK_FILE_CHOOSER (fc), NULL,
-                                               G_USER_DIRECTORY_DOCUMENTS);
+  if (attachment)
+    gtk_file_chooser_set_current_name (GTK_FILE_CHOOSER (fc),
+                                       ev_attachment_get_name (attachment));
 
-	g_signal_connect (fc, "response",
-			  G_CALLBACK (attachment_save_dialog_response_cb),
-			  window);
+  ev_window_file_chooser_restore_folder (window, GTK_FILE_CHOOSER (fc), NULL,
+                                         G_USER_DIRECTORY_DOCUMENTS);
 
-	gtk_widget_show (fc);
+  g_signal_connect (fc, "response",
+                    G_CALLBACK (attachment_save_dialog_response_cb),
+                    window);
+
+  gtk_widget_show (fc);
 }
 
 static void
 ev_window_media_player_key_pressed (EvWindow    *window,
-				    const gchar *key,
-				    gpointer     user_data)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-
-	if (!gtk_window_is_active (GTK_WINDOW (window)))
-		return;
-
-	/* Note how Previous/Next only go to the
-	 * next/previous page despite their icon telling you
-	 * they should go to the beginning/end.
-	 *
-	 * There's very few keyboards with FFW/RWD though,
-	 * so we stick the most useful keybinding on the most
-	 * often seen keys
-	 */
-	if (strcmp (key, "Play") == 0) {
-		ev_window_run_presentation (window);
-	} else if (strcmp (key, "Previous") == 0) {
-		if (EV_WINDOW_IS_PRESENTATION (priv))
-			ev_view_presentation_previous_page (EV_VIEW_PRESENTATION (priv->presentation_view));
-		else
-			g_action_group_activate_action (G_ACTION_GROUP (window), "go-previous-page", NULL);
-	} else if (strcmp (key, "Next") == 0) {
-		if (EV_WINDOW_IS_PRESENTATION (priv))
-			ev_view_presentation_next_page (EV_VIEW_PRESENTATION (priv->presentation_view));
-		else
-			g_action_group_activate_action (G_ACTION_GROUP (window), "go-next-page", NULL);
-	} else if (strcmp (key, "FastForward") == 0) {
-		g_action_group_activate_action (G_ACTION_GROUP (window), "go-last-page", NULL);
-	} else if (strcmp (key, "Rewind") == 0) {
-		g_action_group_activate_action (G_ACTION_GROUP (window), "go-first-page", NULL);
-	}
+                                    const gchar *key,
+                                    gpointer     user_data) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+
+  if (!gtk_window_is_active (GTK_WINDOW (window)))
+    return;
+
+  /* Note how Previous/Next only go to the
+   * next/previous page despite their icon telling you
+   * they should go to the beginning/end.
+   *
+   * There's very few keyboards with FFW/RWD though,
+   * so we stick the most useful keybinding on the most
+   * often seen keys
+   */
+  if (strcmp (key, "Play") == 0) {
+    ev_window_run_presentation (window);
+  } else if (strcmp (key, "Previous") == 0) {
+    if (EV_WINDOW_IS_PRESENTATION (priv))
+      ev_view_presentation_previous_page (EV_VIEW_PRESENTATION (priv->presentation_view));
+    else
+      g_action_group_activate_action (G_ACTION_GROUP (window), "go-previous-page", NULL);
+  } else if (strcmp (key, "Next") == 0) {
+    if (EV_WINDOW_IS_PRESENTATION (priv))
+      ev_view_presentation_next_page (EV_VIEW_PRESENTATION (priv->presentation_view));
+    else
+      g_action_group_activate_action (G_ACTION_GROUP (window), "go-next-page", NULL);
+  } else if (strcmp (key, "FastForward") == 0) {
+    g_action_group_activate_action (G_ACTION_GROUP (window), "go-last-page", NULL);
+  } else if (strcmp (key, "Rewind") == 0) {
+    g_action_group_activate_action (G_ACTION_GROUP (window), "go-first-page", NULL);
+  }
 }
 
 #ifdef ENABLE_DBUS
 static void
 ev_window_sync_source (EvWindow     *window,
-		       EvSourceLink *link)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
-	guint32		 timestamp;
-	gchar		*uri_input;
-	GFile		*input_gfile;
+                       EvSourceLink *link) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
+  guint32		 timestamp;
+  gchar		*uri_input;
+  GFile		*input_gfile;
 
-        if (priv->skeleton == NULL)
-		return;
+  if (priv->skeleton == NULL)
+    return;
 
-	timestamp = gtk_get_current_event_time ();
-	if (g_path_is_absolute (link->filename)) {
-		input_gfile = g_file_new_for_path (link->filename);
-	} else {
-		GFile *gfile, *parent_gfile;
+  timestamp = gtk_get_current_event_time ();
+  if (g_path_is_absolute (link->filename)) {
+    input_gfile = g_file_new_for_path (link->filename);
+  } else {
+    GFile *gfile, *parent_gfile;
 
-		gfile = g_file_new_for_uri (priv->uri);
-		parent_gfile = g_file_get_parent (gfile);
+    gfile = g_file_new_for_uri (priv->uri);
+    parent_gfile = g_file_get_parent (gfile);
 
-		/* parent_gfile should never be NULL */
-		if (parent_gfile == NULL) {
-			g_printerr ("Document URI is '/'\n");
-			return;
-		}
+    /* parent_gfile should never be NULL */
+    if (parent_gfile == NULL) {
+      g_printerr ("Document URI is '/'\n");
+      return;
+    }
 
-		input_gfile = g_file_get_child (parent_gfile, link->filename);
-		g_object_unref (parent_gfile);
-		g_object_unref (gfile);
-	}
+    input_gfile = g_file_get_child (parent_gfile, link->filename);
+    g_object_unref (parent_gfile);
+    g_object_unref (gfile);
+  }
 
-	uri_input = g_file_get_uri (input_gfile);
-	g_object_unref (input_gfile);
+  uri_input = g_file_get_uri (input_gfile);
+  g_object_unref (input_gfile);
 
-        ev_evince_window_emit_sync_source (priv->skeleton,
-                                           uri_input,
-                                           g_variant_new ("(ii)", link->line, link->col),
-                                           timestamp);
-	g_free (uri_input);
+  ev_evince_window_emit_sync_source (priv->skeleton,
+                                     uri_input,
+                                     g_variant_new ("(ii)", link->line, link->col),
+                                     timestamp);
+  g_free (uri_input);
 }
 
 static void
-ev_window_emit_closed (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+ev_window_emit_closed (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	if (priv->skeleton == NULL)
-		return;
+  if (priv->skeleton == NULL)
+    return;
 
-        ev_evince_window_emit_closed (priv->skeleton);
+  ev_evince_window_emit_closed (priv->skeleton);
 
-	/* If this is the last window call g_dbus_connection_flush_sync()
-	 * to make sure the signal is emitted.
-	 */
-	if (ev_application_get_n_windows (EV_APP) == 1)
-		g_dbus_connection_flush_sync (g_application_get_dbus_connection (g_application_get_default ()), NULL, NULL);
+  /* If this is the last window call g_dbus_connection_flush_sync()
+   * to make sure the signal is emitted.
+   */
+  if (ev_application_get_n_windows (EV_APP) == 1)
+    g_dbus_connection_flush_sync (g_application_get_dbus_connection (g_application_get_default ()), NULL, NULL);
 }
 
 static void
-ev_window_emit_doc_loaded (EvWindow *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+ev_window_emit_doc_loaded (EvWindow *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-        if (priv->skeleton == NULL)
-                return;
+  if (priv->skeleton == NULL)
+    return;
 
-        ev_evince_window_emit_document_loaded (priv->skeleton, priv->uri);
+  ev_evince_window_emit_document_loaded (priv->skeleton, priv->uri);
 }
 
 static gboolean
 handle_sync_view_cb (EvEvinceWindow        *object,
-		     GDBusMethodInvocation *invocation,
-		     const gchar           *source_file,
-		     GVariant              *source_point,
-		     guint                  timestamp,
-		     EvWindow              *window)
-{
-	EvWindowPrivate *priv = GET_PRIVATE (window);
+                     GDBusMethodInvocation *invocation,
+                     const gchar           *source_file,
+                     GVariant              *source_point,
+                     guint                  timestamp,
+                     EvWindow              *window) {
+  EvWindowPrivate *priv = GET_PRIVATE (window);
 
-	if (priv->document && ev_document_has_synctex (priv->document)) {
-		EvSourceLink link;
+  if (priv->document && ev_document_has_synctex (priv->document)) {
+    EvSourceLink link;
 
-		link.filename = (char *) source_file;
-		g_variant_get (source_point, "(ii)", &link.line, &link.col);
-		ev_view_highlight_forward_search (EV_VIEW (priv->view), &link);
-		gtk_window_present_with_time (GTK_WINDOW (window), timestamp);
-	}
+    link.filename = (char *) source_file;
+    g_variant_get (source_point, "(ii)", &link.line, &link.col);
+    ev_view_highlight_forward_search (EV_VIEW (priv->view), &link);
+    gtk_window_present_with_time (GTK_WINDOW (window), timestamp);
+  }
 
-	ev_evince_window_complete_sync_view (object, invocation);
+  ev_evince_window_complete_sync_view (object, invocation);
 
-	return TRUE;
+  return TRUE;
 }
 #endif /* ENABLE_DBUS */
 
 static gboolean
 _gtk_css_provider_load_from_resource (GtkCssProvider *provider,
-				      const char     *resource_path,
-				      GError        **error)
-{
-	GBytes  *data;
-	gboolean retval;
-
-	data = g_resources_lookup_data (resource_path, 0, error);
-	if (!data)
-		return FALSE;
-
-	retval = gtk_css_provider_load_from_data (provider,
-						  g_bytes_get_data (data, NULL),
-						  g_bytes_get_size (data),
-						  error);
-	g_bytes_unref (data);
-
-	return retval;
-}
-
-static void
-ev_window_init_css (void)
-{
-	static gsize initialization_value = 0;
-
-	if (g_once_init_enter (&initialization_value)) {
-		GtkCssProvider *css_provider;
-		GError *error = NULL;
-
-		css_provider = gtk_css_provider_new ();
-		_gtk_css_provider_load_from_resource (css_provider,
-						      "/org/gnome/evince/ui/evince.css",
-						      &error);
-		g_assert_no_error (error);
-		gtk_style_context_add_provider_for_screen (gdk_screen_get_default (),
-						GTK_STYLE_PROVIDER (css_provider),
-						GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
-		g_object_unref (css_provider);
-
-		g_once_init_leave (&initialization_value, 1);
-	}
-}
-
-static void
-ev_window_init (EvWindow *ev_window)
-{
-	GtkBuilder *builder;
-	GError *error = NULL;
-	GtkWidget *sidebar_widget;
-	GtkWidget *overlay;
-	GtkWidget *searchbar_revealer;
-	GObject *mpkeys;
-	guint page_cache_mb;
-	gboolean allow_links_change_zoom;
-	GtkEntry *search_entry;
-	EvWindowPrivate *priv;
+                                      const char     *resource_path,
+                                      GError        **error) {
+  GBytes  *data;
+  gboolean retval;
+
+  data = g_resources_lookup_data (resource_path, 0, error);
+  if (!data)
+    return FALSE;
+
+  retval = gtk_css_provider_load_from_data (provider,
+                                            g_bytes_get_data (data, NULL),
+                                            g_bytes_get_size (data),
+                                            error);
+  g_bytes_unref (data);
+
+  return retval;
+}
+
+static void
+ev_window_init_css (void) {
+  static gsize initialization_value = 0;
+
+  if (g_once_init_enter (&initialization_value)) {
+    GtkCssProvider *css_provider;
+    GError *error = NULL;
+
+    css_provider = gtk_css_provider_new ();
+    _gtk_css_provider_load_from_resource (css_provider,
+                                          "/org/gnome/evince/ui/evince.css",
+                                          &error);
+    g_assert_no_error (error);
+    gtk_style_context_add_provider_for_screen (gdk_screen_get_default (),
+                                               GTK_STYLE_PROVIDER (css_provider),
+                                               GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
+    g_object_unref (css_provider);
+
+    g_once_init_leave (&initialization_value, 1);
+  }
+}
+
+static void
+ev_window_init (EvWindow *ev_window) {
+  GtkBuilder *builder;
+  GError *error = NULL;
+  GtkWidget *sidebar_widget;
+  GtkWidget *overlay;
+  GtkWidget *searchbar_revealer;
+  GObject *mpkeys;
+  guint page_cache_mb;
+  gboolean allow_links_change_zoom;
+  GtkEntry *search_entry;
+  EvWindowPrivate *priv;
 #ifdef ENABLE_DBUS
-	GDBusConnection *connection;
-	static gint window_id = 0;
+  GDBusConnection *connection;
+  static gint window_id = 0;
 #endif
-	GAppInfo *app_info;
+  GAppInfo *app_info;
 
-	g_signal_connect (ev_window, "configure_event",
-			  G_CALLBACK (window_configure_event_cb), NULL);
-	g_signal_connect (ev_window, "window_state_event",
-			  G_CALLBACK (window_state_event_cb), NULL);
+  g_signal_connect (ev_window, "configure_event",
+                    G_CALLBACK (window_configure_event_cb), NULL);
+  g_signal_connect (ev_window, "window_state_event",
+                    G_CALLBACK (window_state_event_cb), NULL);
 
-	priv = GET_PRIVATE (ev_window);
+  priv = GET_PRIVATE (ev_window);
 
 #ifdef ENABLE_DBUS
-	connection = g_application_get_dbus_connection (g_application_get_default ());
-        if (connection) {
-                EvEvinceWindow *skeleton;
-
-		priv->dbus_object_path = g_strdup_printf (EV_WINDOW_DBUS_OBJECT_PATH, window_id++);
-
-                skeleton = ev_evince_window_skeleton_new ();
-                if (g_dbus_interface_skeleton_export (G_DBUS_INTERFACE_SKELETON (skeleton),
-                                                      connection,
-                                                      priv->dbus_object_path,
-                                                      &error)) {
-                        priv->skeleton = skeleton;
-			g_signal_connect (skeleton, "handle-sync-view",
-					  G_CALLBACK (handle_sync_view_cb),
-					  ev_window);
-                } else {
-                        g_printerr ("Failed to register bus object %s: %s\n",
-				    priv->dbus_object_path, error->message);
-                        g_error_free (error);
-			g_free (priv->dbus_object_path);
-			priv->dbus_object_path = NULL;
-			error = NULL;
-
-                        g_object_unref (skeleton);
-                        priv->skeleton = NULL;
-                }
-        }
+  connection = g_application_get_dbus_connection (g_application_get_default ());
+  if (connection) {
+    EvEvinceWindow *skeleton;
+
+    priv->dbus_object_path = g_strdup_printf (EV_WINDOW_DBUS_OBJECT_PATH, window_id++);
+
+    skeleton = ev_evince_window_skeleton_new ();
+    if (g_dbus_interface_skeleton_export (G_DBUS_INTERFACE_SKELETON (skeleton),
+                                          connection,
+                                          priv->dbus_object_path,
+                                          &error)) {
+      priv->skeleton = skeleton;
+      g_signal_connect (skeleton, "handle-sync-view",
+                        G_CALLBACK (handle_sync_view_cb),
+                        ev_window);
+    } else {
+      g_printerr ("Failed to register bus object %s: %s\n",
+                  priv->dbus_object_path, error->message);
+      g_error_free (error);
+      g_free (priv->dbus_object_path);
+      priv->dbus_object_path = NULL;
+      error = NULL;
+
+      g_object_unref (skeleton);
+      priv->skeleton = NULL;
+    }
+  }
 #endif /* ENABLE_DBUS */
 
-	priv->model = ev_document_model_new ();
-
-	priv->page_mode = PAGE_MODE_DOCUMENT;
-	priv->chrome = EV_CHROME_NORMAL;
-        priv->presentation_mode_inhibit_id = 0;
-
-	priv->history = ev_history_new (priv->model);
-	g_signal_connect (priv->history, "activate-link",
-			  G_CALLBACK (activate_link_cb),
-			  ev_window);
-        g_signal_connect (priv->history, "changed",
-                          G_CALLBACK (history_changed_cb),
-                          ev_window);
-
-	priv->bookmarks_menu = g_menu_new ();
-
-	app_info = g_app_info_get_default_for_uri_scheme ("mailto");
-	priv->has_mailto_handler = app_info != NULL;
-	g_clear_object (&app_info);
-
-	priv->main_box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
-	gtk_container_add (GTK_CONTAINER (ev_window), priv->main_box);
-	gtk_widget_show (priv->main_box);
-
-	g_action_map_add_action_entries (G_ACTION_MAP (ev_window),
-					 actions, G_N_ELEMENTS (actions),
-					 ev_window);
-
-	ev_window_init_css ();
-
-	priv->recent_manager = gtk_recent_manager_get_default ();
-
-	priv->toolbar = ev_toolbar_new (ev_window);
-	gtk_widget_set_no_show_all (priv->toolbar, TRUE);
-	gtk_header_bar_set_show_close_button (GTK_HEADER_BAR (priv->toolbar), TRUE);
-	gtk_window_set_titlebar (GTK_WINDOW (ev_window), priv->toolbar);
-	gtk_widget_show (priv->toolbar);
-
-	/* Window title */
-	priv->title = ev_window_title_new (ev_window);
-
-	g_signal_connect (ev_toolbar_get_page_selector (EV_TOOLBAR (priv->toolbar)),
-			  "activate-link",
-			  G_CALLBACK (activate_link_cb),
-			  ev_window);
-
-        /* Annotations toolbar */
-	priv->annots_toolbar = ev_annotations_toolbar_new ();
-	g_signal_connect_swapped (priv->annots_toolbar,
-				  "begin-add-annot",
-				  G_CALLBACK (ev_window_begin_add_annot),
-				  ev_window);
-	g_signal_connect_swapped (priv->annots_toolbar,
-				  "cancel-add-annot",
-				  G_CALLBACK (ev_window_cancel_add_annot),
-				  ev_window);
-	gtk_box_pack_start (GTK_BOX (priv->main_box),
-			    priv->annots_toolbar, FALSE, TRUE, 0);
-
-	/* Search Bar */
-	priv->search_bar = gtk_search_bar_new ();
-	gtk_search_bar_set_show_close_button (GTK_SEARCH_BAR (priv->search_bar), TRUE);
-
-	priv->search_box = ev_search_box_new (priv->model);
-	search_entry = GTK_ENTRY (ev_search_box_get_entry (EV_SEARCH_BOX (priv->search_box)));
-	gtk_entry_set_width_chars (search_entry, 32);
-	gtk_entry_set_max_length (search_entry, 512);
-	gtk_container_add (GTK_CONTAINER (priv->search_bar),
-			   priv->search_box);
-	gtk_widget_show (priv->search_box);
-
-	/* Wrap search bar in a revealer.
-	 * Workaround for the gtk+ bug: https://bugzilla.gnome.org/show_bug.cgi?id=724096
-	 */
-	searchbar_revealer = gtk_revealer_new ();
-	g_object_bind_property (G_OBJECT (searchbar_revealer), "reveal-child",
-				G_OBJECT (priv->search_bar), "search-mode-enabled",
-				G_BINDING_BIDIRECTIONAL);
-	gtk_container_add (GTK_CONTAINER (searchbar_revealer), priv->search_bar);
-	gtk_widget_show (GTK_WIDGET (searchbar_revealer));
-
-	/* We don't use gtk_search_bar_connect_entry, because it clears the entry when the
-	 * search is closed, but we want to keep the current search.
-	 */
-	gtk_box_pack_start (GTK_BOX (priv->main_box),
-			    searchbar_revealer, FALSE, TRUE, 0);
-	gtk_widget_show (priv->search_bar);
-
-	/* Add the main area */
-	priv->hpaned = gtk_paned_new (GTK_ORIENTATION_HORIZONTAL);
-	g_signal_connect (priv->hpaned,
-			  "notify::position",
-			  G_CALLBACK (ev_window_sidebar_position_change_cb),
-			  ev_window);
-	
-	gtk_paned_set_position (GTK_PANED (priv->hpaned), SIDEBAR_DEFAULT_SIZE);
-	gtk_box_pack_start (GTK_BOX (priv->main_box), priv->hpaned,
-			    TRUE, TRUE, 0);
-	gtk_widget_show (priv->hpaned);
-	
-	priv->sidebar = ev_sidebar_new ();
-	ev_sidebar_set_model (EV_SIDEBAR (priv->sidebar),
-			      priv->model);
-	gtk_paned_pack1 (GTK_PANED (priv->hpaned),
-			 priv->sidebar, FALSE, FALSE);
-	gtk_widget_show (priv->sidebar);
-
-	/* Stub sidebar, for now */
-
-	sidebar_widget = ev_sidebar_thumbnails_new ();
-	priv->sidebar_thumbs = sidebar_widget;
-	g_signal_connect (sidebar_widget,
-			  "notify::main-widget",
-			  G_CALLBACK (sidebar_page_main_widget_update_cb),
-			  ev_window);
-	sidebar_page_main_widget_update_cb (G_OBJECT (sidebar_widget), NULL, ev_window);
-	gtk_widget_show (sidebar_widget);
-	ev_sidebar_add_page (EV_SIDEBAR (priv->sidebar),
-			      sidebar_widget,
-			      THUMBNAILS_SIDEBAR_ID, _("Thumbnails"),
-			      THUMBNAILS_SIDEBAR_ICON);
-
-	sidebar_widget = ev_sidebar_links_new ();
-	priv->sidebar_links = sidebar_widget;
-	g_signal_connect (sidebar_widget,
-			  "notify::model",
-			  G_CALLBACK (sidebar_widget_model_set),
-			  ev_window);
-	g_signal_connect (sidebar_widget,
-			  "link_activated",
-			  G_CALLBACK (sidebar_links_link_activated_cb),
-			  ev_window);
-	sidebar_page_main_widget_update_cb (G_OBJECT (sidebar_widget), NULL, ev_window);
-	gtk_widget_show (sidebar_widget);
-	ev_sidebar_add_page (EV_SIDEBAR (priv->sidebar),
-			      sidebar_widget,
-			      LINKS_SIDEBAR_ID, _("Outline"),
-			      LINKS_SIDEBAR_ICON);
-
-	sidebar_widget = ev_sidebar_annotations_new ();
-	priv->sidebar_annots = sidebar_widget;
-	g_signal_connect (sidebar_widget,
-			  "annot_activated",
-			  G_CALLBACK (sidebar_annots_annot_activated_cb),
-			  ev_window);
-	gtk_widget_show (sidebar_widget);
-	ev_sidebar_add_page (EV_SIDEBAR (priv->sidebar),
-			      sidebar_widget,
-			      ANNOTS_SIDEBAR_ID, _("Annotations"),
-			      ANNOTS_SIDEBAR_ICON);
-
-	sidebar_widget = ev_sidebar_bookmarks_new ();
-	priv->sidebar_bookmarks = sidebar_widget;
-	gtk_widget_show (sidebar_widget);
-	ev_sidebar_add_page (EV_SIDEBAR (priv->sidebar),
-			      sidebar_widget,
-			      BOOKMARKS_SIDEBAR_ID, _("Bookmarks"),
-			      BOOKMARKS_SIDEBAR_ICON);
-
-	sidebar_widget = ev_sidebar_attachments_new ();
-	priv->sidebar_attachments = sidebar_widget;
-	g_signal_connect_object (sidebar_widget,
-				 "popup",
-				 G_CALLBACK (attachment_bar_menu_popup_cb),
-				 ev_window, 0);
-	g_signal_connect_object (sidebar_widget,
-				 "save-attachment",
-				 G_CALLBACK (attachment_bar_save_attachment_cb),
-				 ev_window, 0);
-	gtk_widget_show (sidebar_widget);
-	ev_sidebar_add_page (EV_SIDEBAR (priv->sidebar),
-			      sidebar_widget,
-			      ATTACHMENTS_SIDEBAR_ID, _("Attachments"),
-			      ATTACHMENTS_SIDEBAR_ICON);
-
-	sidebar_widget = ev_sidebar_layers_new ();
-	priv->sidebar_layers = sidebar_widget;
-	g_signal_connect (sidebar_widget,
-			  "layers_visibility_changed",
-			  G_CALLBACK (sidebar_layers_visibility_changed),
-			  ev_window);
-	gtk_widget_show (sidebar_widget);
-	ev_sidebar_add_page (EV_SIDEBAR (priv->sidebar),
-			      sidebar_widget,
-			      LAYERS_SIDEBAR_ID, _("Layers"),
-			      LAYERS_SIDEBAR_ICON);
-
-	priv->view_box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
-
-	overlay = gtk_overlay_new ();
-	priv->scrolled_window = gtk_scrolled_window_new (NULL, NULL);
-	gtk_container_add (GTK_CONTAINER (overlay), priv->scrolled_window);
-	gtk_widget_show (priv->scrolled_window);
-
-	priv->loading_message = ev_loading_message_new ();
-	gtk_widget_set_name (priv->loading_message, "ev-loading-message");
-	gtk_widget_set_halign (priv->loading_message, GTK_ALIGN_END);
-	gtk_widget_set_valign (priv->loading_message, GTK_ALIGN_START);
-	gtk_widget_set_no_show_all (priv->loading_message, TRUE);
-	gtk_overlay_add_overlay (GTK_OVERLAY (overlay), priv->loading_message);
-
-	gtk_box_pack_start (GTK_BOX (priv->view_box),
-			    overlay,
-			    TRUE, TRUE, 0);
-	gtk_widget_show (overlay);
-
-	gtk_paned_add2 (GTK_PANED (priv->hpaned),
-			priv->view_box);
-	gtk_widget_show (priv->view_box);
-
-	priv->view = ev_view_new ();
-	page_cache_mb = g_settings_get_uint (ev_window_ensure_settings (ev_window),
-					     GS_PAGE_CACHE_SIZE);
-	ev_view_set_page_cache_size (EV_VIEW (priv->view),
-				     page_cache_mb * 1024 * 1024);
-	allow_links_change_zoom = g_settings_get_boolean (ev_window_ensure_settings (ev_window),
-				     GS_ALLOW_LINKS_CHANGE_ZOOM);
-	ev_view_set_allow_links_change_zoom (EV_VIEW (priv->view),
-				     allow_links_change_zoom);
-	ev_view_set_model (EV_VIEW (priv->view), priv->model);
-
-	priv->password_view = ev_password_view_new (GTK_WINDOW (ev_window));
-	g_signal_connect_swapped (priv->password_view,
-				  "unlock",
-				  G_CALLBACK (ev_window_password_view_unlock),
-				  ev_window);
-	g_signal_connect_object (priv->view, "focus_in_event",
-			         G_CALLBACK (view_actions_focus_in_cb),
-				 ev_window, 0);
-	g_signal_connect_swapped (priv->view, "external-link",
-				  G_CALLBACK (view_external_link_cb),
-				  ev_window);
-	g_signal_connect_object (priv->view, "handle-link",
-			         G_CALLBACK (view_handle_link_cb),
-			         ev_window, 0);
-	g_signal_connect_object (priv->view, "popup",
-				 G_CALLBACK (view_menu_popup_cb),
-				 ev_window, 0);
-	g_signal_connect_object (priv->view, "selection-changed",
-				 G_CALLBACK (view_selection_changed_cb),
-				 ev_window, 0);
-	g_signal_connect_object (priv->view, "annot-added",
-				 G_CALLBACK (view_annot_added),
-				 ev_window, 0);
-	g_signal_connect_object (priv->view, "annot-removed",
-				 G_CALLBACK (view_annot_removed),
-				 ev_window, 0);
-	g_signal_connect_object (priv->view, "layers-changed",
-				 G_CALLBACK (view_layers_changed_cb),
-				 ev_window, 0);
-	g_signal_connect_object (priv->view, "notify::is-loading",
-				 G_CALLBACK (view_is_loading_changed_cb),
-				 ev_window, 0);
-	g_signal_connect_object (priv->view, "cursor-moved",
-				 G_CALLBACK (view_caret_cursor_moved_cb),
-				 ev_window, 0);
+  priv->model = ev_document_model_new ();
+
+  priv->page_mode = PAGE_MODE_DOCUMENT;
+  priv->chrome = EV_CHROME_NORMAL;
+  priv->presentation_mode_inhibit_id = 0;
+
+  priv->history = ev_history_new (priv->model);
+  g_signal_connect (priv->history, "activate-link",
+                    G_CALLBACK (activate_link_cb),
+                    ev_window);
+  g_signal_connect (priv->history, "changed",
+                    G_CALLBACK (history_changed_cb),
+                    ev_window);
+
+  priv->bookmarks_menu = g_menu_new ();
+
+  app_info = g_app_info_get_default_for_uri_scheme ("mailto");
+  priv->has_mailto_handler = app_info != NULL;
+  g_clear_object (&app_info);
+
+  priv->main_box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
+  gtk_container_add (GTK_CONTAINER (ev_window), priv->main_box);
+  gtk_widget_show (priv->main_box);
+
+  g_action_map_add_action_entries (G_ACTION_MAP (ev_window),
+                                   actions, G_N_ELEMENTS (actions),
+                                   ev_window);
+
+  ev_window_init_css ();
+
+  priv->recent_manager = gtk_recent_manager_get_default ();
+
+  priv->toolbar = ev_toolbar_new (ev_window);
+  gtk_widget_set_no_show_all (priv->toolbar, TRUE);
+  gtk_header_bar_set_show_close_button (GTK_HEADER_BAR (priv->toolbar), TRUE);
+  gtk_window_set_titlebar (GTK_WINDOW (ev_window), priv->toolbar);
+  gtk_widget_show (priv->toolbar);
+
+  /* Window title */
+  priv->title = ev_window_title_new (ev_window);
+
+  g_signal_connect (ev_toolbar_get_page_selector (EV_TOOLBAR (priv->toolbar)),
+                    "activate-link",
+                    G_CALLBACK (activate_link_cb),
+                    ev_window);
+
+  /* Annotations toolbar */
+  priv->annots_toolbar = ev_annotations_toolbar_new ();
+  g_signal_connect_swapped (priv->annots_toolbar,
+                            "begin-add-annot",
+                            G_CALLBACK (ev_window_begin_add_annot),
+                            ev_window);
+  g_signal_connect_swapped (priv->annots_toolbar,
+                            "cancel-add-annot",
+                            G_CALLBACK (ev_window_cancel_add_annot),
+                            ev_window);
+  gtk_box_pack_start (GTK_BOX (priv->main_box),
+                      priv->annots_toolbar, FALSE, TRUE, 0);
+
+  /* Search Bar */
+  priv->search_bar = gtk_search_bar_new ();
+  gtk_search_bar_set_show_close_button (GTK_SEARCH_BAR (priv->search_bar), TRUE);
+
+  priv->search_box = ev_search_box_new (priv->model);
+  search_entry = GTK_ENTRY (ev_search_box_get_entry (EV_SEARCH_BOX (priv->search_box)));
+  gtk_entry_set_width_chars (search_entry, 32);
+  gtk_entry_set_max_length (search_entry, 512);
+  gtk_container_add (GTK_CONTAINER (priv->search_bar),
+                     priv->search_box);
+  gtk_widget_show (priv->search_box);
+
+  /* Wrap search bar in a revealer.
+   * Workaround for the gtk+ bug: https://bugzilla.gnome.org/show_bug.cgi?id=724096
+   */
+  searchbar_revealer = gtk_revealer_new ();
+  g_object_bind_property (G_OBJECT (searchbar_revealer), "reveal-child",
+                          G_OBJECT (priv->search_bar), "search-mode-enabled",
+                          G_BINDING_BIDIRECTIONAL);
+  gtk_container_add (GTK_CONTAINER (searchbar_revealer), priv->search_bar);
+  gtk_widget_show (GTK_WIDGET (searchbar_revealer));
+
+  /* We don't use gtk_search_bar_connect_entry, because it clears the entry when the
+   * search is closed, but we want to keep the current search.
+   */
+  gtk_box_pack_start (GTK_BOX (priv->main_box),
+                      searchbar_revealer, FALSE, TRUE, 0);
+  gtk_widget_show (priv->search_bar);
+
+  /* Add the main area */
+  priv->hpaned = gtk_paned_new (GTK_ORIENTATION_HORIZONTAL);
+  g_signal_connect (priv->hpaned,
+                    "notify::position",
+                    G_CALLBACK (ev_window_sidebar_position_change_cb),
+                    ev_window);
+
+  gtk_paned_set_position (GTK_PANED (priv->hpaned), SIDEBAR_DEFAULT_SIZE);
+  gtk_box_pack_start (GTK_BOX (priv->main_box), priv->hpaned,
+                      TRUE, TRUE, 0);
+  gtk_widget_show (priv->hpaned);
+
+  priv->sidebar = ev_sidebar_new ();
+  ev_sidebar_set_model (EV_SIDEBAR (priv->sidebar),
+                        priv->model);
+  gtk_paned_pack1 (GTK_PANED (priv->hpaned),
+                   priv->sidebar, FALSE, FALSE);
+  gtk_widget_show (priv->sidebar);
+
+  /* Stub sidebar, for now */
+
+  sidebar_widget = ev_sidebar_thumbnails_new ();
+  priv->sidebar_thumbs = sidebar_widget;
+  g_signal_connect (sidebar_widget,
+                    "notify::main-widget",
+                    G_CALLBACK (sidebar_page_main_widget_update_cb),
+                    ev_window);
+  sidebar_page_main_widget_update_cb (G_OBJECT (sidebar_widget), NULL, ev_window);
+  gtk_widget_show (sidebar_widget);
+  ev_sidebar_add_page (EV_SIDEBAR (priv->sidebar),
+                       sidebar_widget,
+                       THUMBNAILS_SIDEBAR_ID, _("Thumbnails"),
+                       THUMBNAILS_SIDEBAR_ICON);
+
+  sidebar_widget = ev_sidebar_links_new ();
+  priv->sidebar_links = sidebar_widget;
+  g_signal_connect (sidebar_widget,
+                    "notify::model",
+                    G_CALLBACK (sidebar_widget_model_set),
+                    ev_window);
+  g_signal_connect (sidebar_widget,
+                    "link_activated",
+                    G_CALLBACK (sidebar_links_link_activated_cb),
+                    ev_window);
+  sidebar_page_main_widget_update_cb (G_OBJECT (sidebar_widget), NULL, ev_window);
+  gtk_widget_show (sidebar_widget);
+  ev_sidebar_add_page (EV_SIDEBAR (priv->sidebar),
+                       sidebar_widget,
+                       LINKS_SIDEBAR_ID, _("Outline"),
+                       LINKS_SIDEBAR_ICON);
+
+  sidebar_widget = ev_sidebar_annotations_new ();
+  priv->sidebar_annots = sidebar_widget;
+  g_signal_connect (sidebar_widget,
+                    "annot_activated",
+                    G_CALLBACK (sidebar_annots_annot_activated_cb),
+                    ev_window);
+  gtk_widget_show (sidebar_widget);
+  ev_sidebar_add_page (EV_SIDEBAR (priv->sidebar),
+                       sidebar_widget,
+                       ANNOTS_SIDEBAR_ID, _("Annotations"),
+                       ANNOTS_SIDEBAR_ICON);
+
+  sidebar_widget = ev_sidebar_bookmarks_new ();
+  priv->sidebar_bookmarks = sidebar_widget;
+  gtk_widget_show (sidebar_widget);
+  ev_sidebar_add_page (EV_SIDEBAR (priv->sidebar),
+                       sidebar_widget,
+                       BOOKMARKS_SIDEBAR_ID, _("Bookmarks"),
+                       BOOKMARKS_SIDEBAR_ICON);
+
+  sidebar_widget = ev_sidebar_attachments_new ();
+  priv->sidebar_attachments = sidebar_widget;
+  g_signal_connect_object (sidebar_widget,
+                           "popup",
+                           G_CALLBACK (attachment_bar_menu_popup_cb),
+                           ev_window, 0);
+  g_signal_connect_object (sidebar_widget,
+                           "save-attachment",
+                           G_CALLBACK (attachment_bar_save_attachment_cb),
+                           ev_window, 0);
+  gtk_widget_show (sidebar_widget);
+  ev_sidebar_add_page (EV_SIDEBAR (priv->sidebar),
+                       sidebar_widget,
+                       ATTACHMENTS_SIDEBAR_ID, _("Attachments"),
+                       ATTACHMENTS_SIDEBAR_ICON);
+
+  sidebar_widget = ev_sidebar_layers_new ();
+  priv->sidebar_layers = sidebar_widget;
+  g_signal_connect (sidebar_widget,
+                    "layers_visibility_changed",
+                    G_CALLBACK (sidebar_layers_visibility_changed),
+                    ev_window);
+  gtk_widget_show (sidebar_widget);
+  ev_sidebar_add_page (EV_SIDEBAR (priv->sidebar),
+                       sidebar_widget,
+                       LAYERS_SIDEBAR_ID, _("Layers"),
+                       LAYERS_SIDEBAR_ICON);
+
+  priv->view_box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
+
+  overlay = gtk_overlay_new ();
+  priv->scrolled_window = gtk_scrolled_window_new (NULL, NULL);
+  gtk_container_add (GTK_CONTAINER (overlay), priv->scrolled_window);
+  gtk_widget_show (priv->scrolled_window);
+
+  priv->loading_message = ev_loading_message_new ();
+  gtk_widget_set_name (priv->loading_message, "ev-loading-message");
+  gtk_widget_set_halign (priv->loading_message, GTK_ALIGN_END);
+  gtk_widget_set_valign (priv->loading_message, GTK_ALIGN_START);
+  gtk_widget_set_no_show_all (priv->loading_message, TRUE);
+  gtk_overlay_add_overlay (GTK_OVERLAY (overlay), priv->loading_message);
+
+  gtk_box_pack_start (GTK_BOX (priv->view_box),
+                      overlay,
+                      TRUE, TRUE, 0);
+  gtk_widget_show (overlay);
+
+  gtk_paned_add2 (GTK_PANED (priv->hpaned),
+                  priv->view_box);
+  gtk_widget_show (priv->view_box);
+
+  priv->view = ev_view_new ();
+  page_cache_mb = g_settings_get_uint (ev_window_ensure_settings (ev_window),
+                                       GS_PAGE_CACHE_SIZE);
+  ev_view_set_page_cache_size (EV_VIEW (priv->view),
+                               page_cache_mb * 1024 * 1024);
+  allow_links_change_zoom = g_settings_get_boolean (ev_window_ensure_settings (ev_window),
+                                                    GS_ALLOW_LINKS_CHANGE_ZOOM);
+  ev_view_set_allow_links_change_zoom (EV_VIEW (priv->view),
+                                       allow_links_change_zoom);
+  ev_view_set_model (EV_VIEW (priv->view), priv->model);
+
+  priv->password_view = ev_password_view_new (GTK_WINDOW (ev_window));
+  g_signal_connect_swapped (priv->password_view,
+                            "unlock",
+                            G_CALLBACK (ev_window_password_view_unlock),
+                            ev_window);
+  g_signal_connect_object (priv->view, "focus_in_event",
+                           G_CALLBACK (view_actions_focus_in_cb),
+                           ev_window, 0);
+  g_signal_connect_swapped (priv->view, "external-link",
+                            G_CALLBACK (view_external_link_cb),
+                            ev_window);
+  g_signal_connect_object (priv->view, "handle-link",
+                           G_CALLBACK (view_handle_link_cb),
+                           ev_window, 0);
+  g_signal_connect_object (priv->view, "popup",
+                           G_CALLBACK (view_menu_popup_cb),
+                           ev_window, 0);
+  g_signal_connect_object (priv->view, "selection-changed",
+                           G_CALLBACK (view_selection_changed_cb),
+                           ev_window, 0);
+  g_signal_connect_object (priv->view, "annot-added",
+                           G_CALLBACK (view_annot_added),
+                           ev_window, 0);
+  g_signal_connect_object (priv->view, "annot-removed",
+                           G_CALLBACK (view_annot_removed),
+                           ev_window, 0);
+  g_signal_connect_object (priv->view, "layers-changed",
+                           G_CALLBACK (view_layers_changed_cb),
+                           ev_window, 0);
+  g_signal_connect_object (priv->view, "notify::is-loading",
+                           G_CALLBACK (view_is_loading_changed_cb),
+                           ev_window, 0);
+  g_signal_connect_object (priv->view, "cursor-moved",
+                           G_CALLBACK (view_caret_cursor_moved_cb),
+                           ev_window, 0);
 #ifdef ENABLE_DBUS
-	g_signal_connect_swapped (priv->view, "sync-source",
-				  G_CALLBACK (ev_window_sync_source),
-				  ev_window);
+  g_signal_connect_swapped (priv->view, "sync-source",
+                            G_CALLBACK (ev_window_sync_source),
+                            ev_window);
 #endif
-	gtk_widget_show (priv->view);
-	gtk_widget_show (priv->password_view);
-
-	/* Find results sidebar */
-	priv->find_sidebar = ev_find_sidebar_new ();
-	g_signal_connect (priv->find_sidebar,
-			  "result-activated",
-			  G_CALLBACK (find_sidebar_result_activated_cb),
-			  ev_window);
-
-	/* We own a ref on these widgets, as we can swap them in and out */
-	g_object_ref (priv->view);
-	g_object_ref (priv->password_view);
-
-	gtk_container_add (GTK_CONTAINER (priv->scrolled_window),
-			   priv->view);
-
-	/* Connect to model signals */
-	g_signal_connect_swapped (priv->model,
-				  "page-changed",
-				  G_CALLBACK (ev_window_page_changed_cb),
-				  ev_window);
-	g_signal_connect (priv->model,
-			  "notify::document",
-			  G_CALLBACK (ev_window_document_changed_cb),
-			  ev_window);
-	g_signal_connect (priv->model,
-			  "notify::scale",
-			  G_CALLBACK (ev_window_zoom_changed_cb),
-			  ev_window);
-	g_signal_connect (priv->model,
-			  "notify::sizing-mode",
-			  G_CALLBACK (ev_window_sizing_mode_changed_cb),
-			  ev_window);
-	g_signal_connect (priv->model,
-			  "notify::rotation",
-			  G_CALLBACK (ev_window_rotation_changed_cb),
-			  ev_window);
-	g_signal_connect (priv->model,
-			  "notify::continuous",
-			  G_CALLBACK (ev_window_continuous_changed_cb),
-			  ev_window);
-	g_signal_connect (priv->model,
-			  "notify::dual-page",
-			  G_CALLBACK (ev_window_dual_mode_changed_cb),
-			  ev_window);
-	g_signal_connect (priv->model,
-			  "notify::dual-odd-left",
-			  G_CALLBACK (ev_window_dual_mode_odd_pages_left_changed_cb),
-			  ev_window);
-	g_signal_connect (priv->model,
-			  "notify::rtl",
-			  G_CALLBACK (ev_window_direction_changed_cb),
-			  ev_window);
-	g_signal_connect (priv->model,
-			  "notify::inverted-colors",
-			  G_CALLBACK (ev_window_inverted_colors_changed_cb),
-			  ev_window);
-
-     	/* Connect sidebar signals */
-	g_signal_connect (priv->sidebar,
-			  "notify::visible",
-			  G_CALLBACK (ev_window_sidebar_visibility_changed_cb),
-			  ev_window);
-	g_signal_connect (priv->sidebar,
-			  "notify::current-page",
-			  G_CALLBACK (ev_window_sidebar_current_page_changed_cb),
-			  ev_window);
-
-	/* Connect to find bar signals */
-	g_signal_connect (priv->search_box,
-			  "started",
-			  G_CALLBACK (search_started_cb),
-			  ev_window);
-	g_signal_connect (priv->search_box,
-			  "updated",
-			  G_CALLBACK (search_updated_cb),
-			  ev_window);
-	g_signal_connect (priv->search_box,
-			  "cleared",
-			  G_CALLBACK (search_cleared_cb),
-			  ev_window);
-	g_signal_connect (priv->search_box,
-			  "previous",
-			  G_CALLBACK (search_previous_cb),
-			  ev_window);
-	g_signal_connect (priv->search_box,
-			  "next",
-			  G_CALLBACK (search_next_cb),
-			  ev_window);
-	g_signal_connect (search_entry,
-			  "stop-search",
-			  G_CALLBACK (search_entry_stop_search_cb),
-			  ev_window);
-	g_signal_connect (priv->search_bar,
-			  "notify::search-mode-enabled",
-			  G_CALLBACK (search_bar_search_mode_enabled_changed),
-			  ev_window);
-
-	/* Popups */
-	builder = gtk_builder_new_from_resource ("/org/gnome/evince/gtk/menus.ui");
-	priv->view_popup_menu = g_object_ref (G_MENU_MODEL (gtk_builder_get_object (builder, "view-popup-menu")));
-	priv->attachment_popup_menu = g_object_ref (G_MENU_MODEL (gtk_builder_get_object (builder, "attachments-popup")));
-	g_object_unref (builder);
-
-	/* Media player keys */
-	mpkeys = ev_application_get_media_keys (EV_APP);
-	if (mpkeys) {
-		g_signal_connect_swapped (mpkeys, "key_pressed",
-					  G_CALLBACK (ev_window_media_player_key_pressed),
-					  ev_window);
-	}
-
-	/* Give focus to the document view */
-	gtk_widget_grab_focus (priv->view);
-
-	priv->default_settings = g_settings_new (GS_SCHEMA_NAME".Default");
-	g_settings_delay (priv->default_settings);
-	ev_window_setup_default (ev_window);
-
-	gtk_window_set_default_size (GTK_WINDOW (ev_window), 600, 600);
-
-        ev_window_sizing_mode_changed_cb (priv->model, NULL, ev_window);
-	ev_window_update_actions_sensitivity (ev_window);
-
-	/* Drag and Drop */
-	gtk_drag_dest_set (GTK_WIDGET (ev_window),
-			   GTK_DEST_DEFAULT_ALL,
-			   NULL, 0,
-			   GDK_ACTION_COPY);
-	gtk_drag_dest_add_uri_targets (GTK_WIDGET (ev_window));
+  gtk_widget_show (priv->view);
+  gtk_widget_show (priv->password_view);
+
+  /* Find results sidebar */
+  priv->find_sidebar = ev_find_sidebar_new ();
+  g_signal_connect (priv->find_sidebar,
+                    "result-activated",
+                    G_CALLBACK (find_sidebar_result_activated_cb),
+                    ev_window);
+
+  /* We own a ref on these widgets, as we can swap them in and out */
+  g_object_ref (priv->view);
+  g_object_ref (priv->password_view);
+
+  gtk_container_add (GTK_CONTAINER (priv->scrolled_window),
+                     priv->view);
+
+  /* Connect to model signals */
+  g_signal_connect_swapped (priv->model,
+                            "page-changed",
+                            G_CALLBACK (ev_window_page_changed_cb),
+                            ev_window);
+  g_signal_connect (priv->model,
+                    "notify::document",
+                    G_CALLBACK (ev_window_document_changed_cb),
+                    ev_window);
+  g_signal_connect (priv->model,
+                    "notify::scale",
+                    G_CALLBACK (ev_window_zoom_changed_cb),
+                    ev_window);
+  g_signal_connect (priv->model,
+                    "notify::sizing-mode",
+                    G_CALLBACK (ev_window_sizing_mode_changed_cb),
+                    ev_window);
+  g_signal_connect (priv->model,
+                    "notify::rotation",
+                    G_CALLBACK (ev_window_rotation_changed_cb),
+                    ev_window);
+  g_signal_connect (priv->model,
+                    "notify::continuous",
+                    G_CALLBACK (ev_window_continuous_changed_cb),
+                    ev_window);
+  g_signal_connect (priv->model,
+                    "notify::creator-mode",
+                    G_CALLBACK (ev_window_creator_mode_changed_cb),
+                    ev_window);
+  g_signal_connect (priv->model,
+                    "notify::dual-page",
+                    G_CALLBACK (ev_window_dual_mode_changed_cb),
+                    ev_window);
+  g_signal_connect (priv->model,
+                    "notify::dual-odd-left",
+                    G_CALLBACK (ev_window_dual_mode_odd_pages_left_changed_cb),
+                    ev_window);
+  g_signal_connect (priv->model,
+                    "notify::rtl",
+                    G_CALLBACK (ev_window_direction_changed_cb),
+                    ev_window);
+  g_signal_connect (priv->model,
+                    "notify::inverted-colors",
+                    G_CALLBACK (ev_window_inverted_colors_changed_cb),
+                    ev_window);
+
+  /* Connect sidebar signals */
+  g_signal_connect (priv->sidebar,
+                    "notify::visible",
+                    G_CALLBACK (ev_window_sidebar_visibility_changed_cb),
+                    ev_window);
+  g_signal_connect (priv->sidebar,
+                    "notify::current-page",
+                    G_CALLBACK (ev_window_sidebar_current_page_changed_cb),
+                    ev_window);
+
+  /* Connect to find bar signals */
+  g_signal_connect (priv->search_box,
+                    "started",
+                    G_CALLBACK (search_started_cb),
+                    ev_window);
+  g_signal_connect (priv->search_box,
+                    "updated",
+                    G_CALLBACK (search_updated_cb),
+                    ev_window);
+  g_signal_connect (priv->search_box,
+                    "cleared",
+                    G_CALLBACK (search_cleared_cb),
+                    ev_window);
+  g_signal_connect (priv->search_box,
+                    "previous",
+                    G_CALLBACK (search_previous_cb),
+                    ev_window);
+  g_signal_connect (priv->search_box,
+                    "next",
+                    G_CALLBACK (search_next_cb),
+                    ev_window);
+  g_signal_connect (search_entry,
+                    "stop-search",
+                    G_CALLBACK (search_entry_stop_search_cb),
+                    ev_window);
+  g_signal_connect (priv->search_bar,
+                    "notify::search-mode-enabled",
+                    G_CALLBACK (search_bar_search_mode_enabled_changed),
+                    ev_window);
+
+  /* Popups */
+  builder = gtk_builder_new_from_resource ("/org/gnome/evince/gtk/menus.ui");
+  priv->view_popup_menu = g_object_ref (G_MENU_MODEL (gtk_builder_get_object (builder, "view-popup-menu")));
+  priv->attachment_popup_menu = g_object_ref (G_MENU_MODEL (gtk_builder_get_object (builder, "attachments-popup")));
+  g_object_unref (builder);
+
+  /* Media player keys */
+  mpkeys = ev_application_get_media_keys (EV_APP);
+  if (mpkeys) {
+    g_signal_connect_swapped (mpkeys, "key_pressed",
+                              G_CALLBACK (ev_window_media_player_key_pressed),
+                              ev_window);
+  }
+
+  /* Give focus to the document view */
+  gtk_widget_grab_focus (priv->view);
+
+  priv->default_settings = g_settings_new (GS_SCHEMA_NAME".Default");
+  g_settings_delay (priv->default_settings);
+  ev_window_setup_default (ev_window);
+
+  gtk_window_set_default_size (GTK_WINDOW (ev_window), 600, 600);
+
+  ev_window_sizing_mode_changed_cb (priv->model, NULL, ev_window);
+  ev_window_update_actions_sensitivity (ev_window);
+
+  /* Drag and Drop */
+  gtk_drag_dest_set (GTK_WIDGET (ev_window),
+                     GTK_DEST_DEFAULT_ALL,
+                     NULL, 0,
+                     GDK_ACTION_COPY);
+  gtk_drag_dest_add_uri_targets (GTK_WIDGET (ev_window));
 }
 
 /**
@@ -7816,118 +7598,109 @@ ev_window_init (EvWindow *ev_window)
  * Returns: the #GtkWidget that represents the window.
  */
 GtkWidget *
-ev_window_new (void)
-{
-	GtkWidget *ev_window;
+ev_window_new (void) {
+  GtkWidget *ev_window;
 
-	ev_window = GTK_WIDGET (g_object_new (EV_TYPE_WINDOW,
-					      "type", GTK_WINDOW_TOPLEVEL,
-                                              "application", g_application_get_default (),
-					      "show-menubar", FALSE,
-					      NULL));
+  ev_window = GTK_WIDGET (g_object_new (EV_TYPE_WINDOW,
+                                        "type", GTK_WINDOW_TOPLEVEL,
+                                        "application", g_application_get_default (),
+                                        "show-menubar", FALSE,
+                                        NULL));
 
-	return ev_window;
+  return ev_window;
 }
 
 const gchar *
-ev_window_get_dbus_object_path (EvWindow *ev_window)
-{
+ev_window_get_dbus_object_path (EvWindow *ev_window) {
 #ifdef ENABLE_DBUS
-	EvWindowPrivate *priv = GET_PRIVATE (ev_window);
+  EvWindowPrivate *priv = GET_PRIVATE (ev_window);
 
-	return priv->dbus_object_path;
+  return priv->dbus_object_path;
 #else
-	return NULL;
+  return NULL;
 #endif
 }
 
 GMenuModel *
-ev_window_get_bookmarks_menu (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv;
+ev_window_get_bookmarks_menu (EvWindow *ev_window) {
+  EvWindowPrivate *priv;
 
-	g_return_val_if_fail (EV_WINDOW (ev_window), NULL);
+  g_return_val_if_fail (EV_WINDOW (ev_window), NULL);
 
-	priv = GET_PRIVATE (ev_window);
+  priv = GET_PRIVATE (ev_window);
 
-	return G_MENU_MODEL (priv->bookmarks_menu);
+  return G_MENU_MODEL (priv->bookmarks_menu);
 }
 
 EvHistory *
-ev_window_get_history (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv;
+ev_window_get_history (EvWindow *ev_window) {
+  EvWindowPrivate *priv;
 
-	g_return_val_if_fail (EV_WINDOW (ev_window), NULL);
+  g_return_val_if_fail (EV_WINDOW (ev_window), NULL);
 
-	priv = GET_PRIVATE (ev_window);
+  priv = GET_PRIVATE (ev_window);
 
-	return priv->history;
+  return priv->history;
 }
 
 EvDocumentModel *
-ev_window_get_document_model (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv;
+ev_window_get_document_model (EvWindow *ev_window) {
+  EvWindowPrivate *priv;
 
-	g_return_val_if_fail (EV_WINDOW (ev_window), NULL);
+  g_return_val_if_fail (EV_WINDOW (ev_window), NULL);
 
-	priv = GET_PRIVATE (ev_window);
+  priv = GET_PRIVATE (ev_window);
 
-	return priv->model;
+  return priv->model;
 }
 
 GtkWidget *
-ev_window_get_toolbar (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv;
+ev_window_get_toolbar (EvWindow *ev_window) {
+  EvWindowPrivate *priv;
 
-	g_return_val_if_fail (EV_WINDOW (ev_window), NULL);
+  g_return_val_if_fail (EV_WINDOW (ev_window), NULL);
 
-	priv = GET_PRIVATE (ev_window);
+  priv = GET_PRIVATE (ev_window);
 
-	return priv->toolbar;
+  return priv->toolbar;
 }
 
 void
-ev_window_focus_view (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv;
+ev_window_focus_view (EvWindow *ev_window) {
+  EvWindowPrivate *priv;
 
-	g_return_if_fail (EV_WINDOW (ev_window));
+  g_return_if_fail (EV_WINDOW (ev_window));
 
-	priv = GET_PRIVATE (ev_window);
+  priv = GET_PRIVATE (ev_window);
 
-	gtk_widget_grab_focus (priv->view);
+  gtk_widget_grab_focus (priv->view);
 }
 
 EvMetadata *
-ev_window_get_metadata (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv;
+ev_window_get_metadata (EvWindow *ev_window) {
+  EvWindowPrivate *priv;
 
-	g_return_val_if_fail (EV_WINDOW (ev_window), NULL);
+  g_return_val_if_fail (EV_WINDOW (ev_window), NULL);
 
-	priv = GET_PRIVATE (ev_window);
+  priv = GET_PRIVATE (ev_window);
 
-	return priv->metadata;
+  return priv->metadata;
 }
 
 gint
-ev_window_get_metadata_sidebar_size (EvWindow *ev_window)
-{
-	EvWindowPrivate *priv;
-	gint sidebar_size;
+ev_window_get_metadata_sidebar_size (EvWindow *ev_window) {
+  EvWindowPrivate *priv;
+  gint sidebar_size;
 
-	g_return_val_if_fail (EV_WINDOW (ev_window), 0);
+  g_return_val_if_fail (EV_WINDOW (ev_window), 0);
 
-	priv = GET_PRIVATE (ev_window);
+  priv = GET_PRIVATE (ev_window);
 
-	if (!priv->metadata)
-		return 0;
+  if (!priv->metadata)
+    return 0;
 
-	if (ev_metadata_get_int (priv->metadata, "sidebar_size", &sidebar_size))
-		return sidebar_size;
+  if (ev_metadata_get_int (priv->metadata, "sidebar_size", &sidebar_size))
+    return sidebar_size;
 
-	return 0;
+  return 0;
 }
diff --git a/shell/ev-zoom-action.c b/shell/ev-zoom-action.c
index fc11c47..14bbec6 100644
--- a/shell/ev-zoom-action.c
+++ b/shell/ev-zoom-action.c
@@ -25,52 +25,51 @@
 #include <glib/gi18n.h>
 
 enum {
-        ACTIVATED,
-        LAST_SIGNAL
+  ACTIVATED,
+  LAST_SIGNAL
 };
 
-enum
-{
-        PROP_0,
+enum {
+  PROP_0,
 
-        PROP_DOCUMENT_MODEL,
-        PROP_MENU
+  PROP_DOCUMENT_MODEL,
+  PROP_MENU
 };
 
 enum {
-        ZOOM_MODES_SECTION,
-        ZOOM_FREE_SECTION
+  ZOOM_MODES_SECTION,
+  ZOOM_FREE_SECTION
 };
 
 static const struct {
-        const gchar *name;
-        float        level;
+  const gchar *name;
+  float        level;
 } zoom_levels[] = {
-        { N_("50%"), 0.5 },
-        { N_("70%"), 0.7071067811 },
-        { N_("85%"), 0.8408964152 },
-        { N_("100%"), 1.0 },
-        { N_("125%"), 1.1892071149 },
-        { N_("150%"), 1.4142135623 },
-        { N_("175%"), 1.6817928304 },
-        { N_("200%"), 2.0 },
-        { N_("300%"), 2.8284271247 },
-        { N_("400%"), 4.0 },
-        { N_("800%"), 8.0 },
-        { N_("1600%"), 16.0 },
-        { N_("3200%"), 32.0 },
-        { N_("6400%"), 64.0 }
+  { N_("50%"), 0.5 },
+  { N_("70%"), 0.7071067811 },
+  { N_("85%"), 0.8408964152 },
+  { N_("100%"), 1.0 },
+  { N_("125%"), 1.1892071149 },
+  { N_("150%"), 1.4142135623 },
+  { N_("175%"), 1.6817928304 },
+  { N_("200%"), 2.0 },
+  { N_("300%"), 2.8284271247 },
+  { N_("400%"), 4.0 },
+  { N_("800%"), 8.0 },
+  { N_("1600%"), 16.0 },
+  { N_("3200%"), 32.0 },
+  { N_("6400%"), 64.0 }
 };
 
 typedef struct {
-        GtkWidget       *entry;
+  GtkWidget       *entry;
 
-        EvDocumentModel *model;
-        GMenu           *menu;
+  EvDocumentModel *model;
+  GMenu           *menu;
 
-        GMenuModel      *zoom_free_section;
-        GtkPopover      *popup;
-        gboolean         popup_shown;
+  GMenuModel      *zoom_free_section;
+  GtkPopover      *popup;
+  gboolean         popup_shown;
 } EvZoomActionPrivate;
 
 G_DEFINE_TYPE_WITH_PRIVATE (EvZoomAction, ev_zoom_action, GTK_TYPE_BOX)
@@ -83,391 +82,370 @@ static guint signals[LAST_SIGNAL] = { 0 };
 
 static void
 ev_zoom_action_set_zoom_level (EvZoomAction *zoom_action,
-                               float         zoom)
-{
-	EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
-        gchar *zoom_str;
-        float  zoom_perc;
-        guint  i;
-
-        for (i = 0; i < G_N_ELEMENTS (zoom_levels); i++) {
-                if (ABS (zoom - zoom_levels[i].level) < EPSILON) {
-                        gtk_entry_set_text (GTK_ENTRY (priv->entry),
-                                            zoom_levels[i].name);
-                        return;
-                }
-        }
-
-        zoom_perc = zoom * 100.;
-        if (ABS ((gint)zoom_perc - zoom_perc) < 0.01)
-                zoom_str = g_strdup_printf ("%d%%", (gint)zoom_perc);
-        else
-                zoom_str = g_strdup_printf ("%.1f%%", zoom_perc);
-        gtk_entry_set_text (GTK_ENTRY (priv->entry), zoom_str);
-        g_free (zoom_str);
+                               float         zoom) {
+  EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
+  gchar *zoom_str;
+  float  zoom_perc;
+  guint  i;
+
+  for (i = 0; i < G_N_ELEMENTS (zoom_levels); i++) {
+    if (ABS (zoom - zoom_levels[i].level) < EPSILON) {
+      gtk_entry_set_text (GTK_ENTRY (priv->entry),
+                          zoom_levels[i].name);
+      return;
+    }
+  }
+
+  zoom_perc = zoom * 100.;
+  if (ABS ((gint)zoom_perc - zoom_perc) < 0.01)
+    zoom_str = g_strdup_printf ("%d%%", (gint)zoom_perc);
+  else
+    zoom_str = g_strdup_printf ("%.1f%%", zoom_perc);
+  gtk_entry_set_text (GTK_ENTRY (priv->entry), zoom_str);
+  g_free (zoom_str);
 }
 
 static void
-ev_zoom_action_update_zoom_level (EvZoomAction *zoom_action)
-{
-	EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
+ev_zoom_action_update_zoom_level (EvZoomAction *zoom_action) {
+  EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
 
-        float       zoom = ev_document_model_get_scale (priv->model);
+  float       zoom = ev_document_model_get_scale (priv->model);
 
-        zoom *= 72.0 / ev_document_misc_get_widget_dpi  (GTK_WIDGET (zoom_action));
+  zoom *= 72.0 / ev_document_misc_get_widget_dpi  (GTK_WIDGET (zoom_action));
 
-        ev_zoom_action_set_zoom_level (zoom_action, zoom);
+  ev_zoom_action_set_zoom_level (zoom_action, zoom);
 }
 
 static void
 zoom_changed_cb (EvDocumentModel *model,
                  GParamSpec      *pspec,
-                 EvZoomAction    *zoom_action)
-{
-        ev_zoom_action_update_zoom_level (zoom_action);
+                 EvZoomAction    *zoom_action) {
+  ev_zoom_action_update_zoom_level (zoom_action);
 }
 
 static void
 document_changed_cb (EvDocumentModel *model,
                      GParamSpec      *pspec,
-                     EvZoomAction    *zoom_action)
-{
-        EvDocument *document = ev_document_model_get_document (model);
+                     EvZoomAction    *zoom_action) {
+  EvDocument *document = ev_document_model_get_document (model);
 
-        if (!document) {
-                gtk_widget_set_sensitive (GTK_WIDGET (zoom_action), FALSE);
-                return;
-        }
-        gtk_widget_set_sensitive (GTK_WIDGET (zoom_action), ev_document_get_n_pages (document) > 0);
+  if (!document) {
+    gtk_widget_set_sensitive (GTK_WIDGET (zoom_action), FALSE);
+    return;
+  }
+  gtk_widget_set_sensitive (GTK_WIDGET (zoom_action), ev_document_get_n_pages (document) > 0);
 
-        ev_zoom_action_update_zoom_level (zoom_action);
+  ev_zoom_action_update_zoom_level (zoom_action);
 }
 
 static void
 ev_zoom_action_set_width_chars (EvZoomAction *zoom_action,
-                                gint          width)
-{
-	EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
+                                gint          width) {
+  EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
 
-        /* width + 2 (one decimals and the comma) + 3 (for the icon) */
-        gtk_entry_set_width_chars (GTK_ENTRY (priv->entry), width + 2 + 3);
+  /* width + 2 (one decimals and the comma) + 3 (for the icon) */
+  gtk_entry_set_width_chars (GTK_ENTRY (priv->entry), width + 2 + 3);
 }
 
 static void
-ev_zoom_action_populate_free_zoom_section (EvZoomAction *zoom_action)
-{
-	EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
-        gdouble max_scale;
-        guint   i;
-        gint    width = 0;
-
-        max_scale = ev_document_model_get_max_scale (priv->model);
-
-        for (i = 0; i < G_N_ELEMENTS (zoom_levels); i++) {
-                GMenuItem *item;
-                gint       length;
-
-                if (zoom_levels[i].level > max_scale)
-                        break;
-
-                length = g_utf8_strlen (zoom_levels[i].name, -1);
-                if (length > width)
-                        width = length;
-
-                item = g_menu_item_new (zoom_levels[i].name, NULL);
-                g_menu_item_set_action_and_target (item, "win.zoom",
-                                                   "d", zoom_levels[i].level);
-                g_menu_append_item (G_MENU (priv->zoom_free_section), item);
-                g_object_unref (item);
-        }
-
-        ev_zoom_action_set_width_chars (zoom_action, width);
+ev_zoom_action_populate_free_zoom_section (EvZoomAction *zoom_action) {
+  EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
+  gdouble max_scale;
+  guint   i;
+  gint    width = 0;
+
+  max_scale = ev_document_model_get_max_scale (priv->model);
+
+  for (i = 0; i < G_N_ELEMENTS (zoom_levels); i++) {
+    GMenuItem *item;
+    gint       length;
+
+    if (zoom_levels[i].level > max_scale)
+      break;
+
+    length = g_utf8_strlen (zoom_levels[i].name, -1);
+    if (length > width)
+      width = length;
+
+    item = g_menu_item_new (zoom_levels[i].name, NULL);
+    g_menu_item_set_action_and_target (item, "win.zoom",
+                                       "d", zoom_levels[i].level);
+    g_menu_append_item (G_MENU (priv->zoom_free_section), item);
+    g_object_unref (item);
+  }
+
+  ev_zoom_action_set_width_chars (zoom_action, width);
 }
 
 static void
 max_zoom_changed_cb (EvDocumentModel *model,
                      GParamSpec      *pspec,
-                     EvZoomAction    *zoom_action)
-{
-	EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
+                     EvZoomAction    *zoom_action) {
+  EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
 
-        g_menu_remove_all (G_MENU (priv->zoom_free_section));
-        g_clear_pointer (&priv->popup, (GDestroyNotify)gtk_widget_destroy);
-        ev_zoom_action_populate_free_zoom_section (zoom_action);
+  g_menu_remove_all (G_MENU (priv->zoom_free_section));
+  g_clear_pointer (&priv->popup, (GDestroyNotify)gtk_widget_destroy);
+  ev_zoom_action_populate_free_zoom_section (zoom_action);
 }
 
 static void
 entry_activated_cb (GtkEntry     *entry,
-                    EvZoomAction *zoom_action)
-{
-	EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
-
-        double       zoom_perc;
-        float        zoom;
-        const gchar *text = gtk_entry_get_text (entry);
-        gchar       *end_ptr = NULL;
-
-        if (!text || text[0] == '\0') {
-                ev_zoom_action_update_zoom_level (zoom_action);
-                g_signal_emit (zoom_action, signals[ACTIVATED], 0, NULL);
-                return;
-        }
-
-        zoom_perc = g_strtod (text, &end_ptr);
-        if (end_ptr && end_ptr[0] != '\0' && end_ptr[0] != '%') {
-                ev_zoom_action_update_zoom_level (zoom_action);
-                g_signal_emit (zoom_action, signals[ACTIVATED], 0, NULL);
-                return;
-        }
-
-        zoom = zoom_perc / 100.;
-        ev_document_model_set_sizing_mode (priv->model, EV_SIZING_FREE);
-        ev_document_model_set_scale (priv->model,
-                                     zoom * ev_document_misc_get_widget_dpi (GTK_WIDGET (zoom_action)) / 72.0);
-        g_signal_emit (zoom_action, signals[ACTIVATED], 0, NULL);
+                    EvZoomAction *zoom_action) {
+  EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
+
+  double       zoom_perc;
+  float        zoom;
+  const gchar *text = gtk_entry_get_text (entry);
+  gchar       *end_ptr = NULL;
+
+  if (!text || text[0] == '\0') {
+    ev_zoom_action_update_zoom_level (zoom_action);
+    g_signal_emit (zoom_action, signals[ACTIVATED], 0, NULL);
+    return;
+  }
+
+  zoom_perc = g_strtod (text, &end_ptr);
+  if (end_ptr && end_ptr[0] != '\0' && end_ptr[0] != '%') {
+    ev_zoom_action_update_zoom_level (zoom_action);
+    g_signal_emit (zoom_action, signals[ACTIVATED], 0, NULL);
+    return;
+  }
+
+  zoom = zoom_perc / 100.;
+  ev_document_model_set_sizing_mode (priv->model, EV_SIZING_FREE);
+  ev_document_model_set_scale (priv->model,
+                               zoom * ev_document_misc_get_widget_dpi (GTK_WIDGET (zoom_action)) / 72.0);
+  g_signal_emit (zoom_action, signals[ACTIVATED], 0, NULL);
 }
 
 static gboolean
-focus_out_cb (EvZoomAction *zoom_action)
-{
-        ev_zoom_action_update_zoom_level (zoom_action);
+focus_out_cb (EvZoomAction *zoom_action) {
+  ev_zoom_action_update_zoom_level (zoom_action);
 
-        return FALSE;
+  return FALSE;
 }
 
 static void
 popup_menu_closed (GtkPopover   *popup,
-                   EvZoomAction *zoom_action)
-{
-	EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
+                   EvZoomAction *zoom_action) {
+  EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
 
-        if (priv->popup != popup)
-                return;
+  if (priv->popup != popup)
+    return;
 
-        priv->popup_shown = FALSE;
-        priv->popup = NULL;
+  priv->popup_shown = FALSE;
+  priv->popup = NULL;
 }
 
 static GtkPopover *
-get_popup (EvZoomAction *zoom_action)
-{
-	EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
-        GdkRectangle rect;
-
-        if (priv->popup)
-                return priv->popup;
-
-        priv->popup = GTK_POPOVER (gtk_popover_new_from_model (GTK_WIDGET (zoom_action),
-                                                                            G_MENU_MODEL (priv->menu)));
-        g_signal_connect (priv->popup, "closed",
-                          G_CALLBACK (popup_menu_closed),
-                          zoom_action);
-        gtk_entry_get_icon_area (GTK_ENTRY (priv->entry),
-                                 GTK_ENTRY_ICON_SECONDARY, &rect);
-        gtk_popover_set_pointing_to (priv->popup, &rect);
-        gtk_popover_set_position (priv->popup, GTK_POS_BOTTOM);
-
-        return priv->popup;
+get_popup (EvZoomAction *zoom_action) {
+  EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
+  GdkRectangle rect;
+
+  if (priv->popup)
+    return priv->popup;
+
+  priv->popup = GTK_POPOVER (gtk_popover_new_from_model (GTK_WIDGET (zoom_action),
+                                                         G_MENU_MODEL (priv->menu)));
+  g_signal_connect (priv->popup, "closed",
+                    G_CALLBACK (popup_menu_closed),
+                    zoom_action);
+  gtk_entry_get_icon_area (GTK_ENTRY (priv->entry),
+                           GTK_ENTRY_ICON_SECONDARY, &rect);
+  gtk_popover_set_pointing_to (priv->popup, &rect);
+  gtk_popover_set_position (priv->popup, GTK_POS_BOTTOM);
+
+  return priv->popup;
 }
 
 static void
 entry_icon_press_callback (GtkEntry            *entry,
                            GtkEntryIconPosition icon_pos,
                            GdkEvent            *event,
-                           EvZoomAction        *zoom_action)
-{
-	EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
-        guint button = 0;
+                           EvZoomAction        *zoom_action) {
+  EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
+  guint button = 0;
 
-        if (gdk_event_get_button (event, &button) &&
-            button != GDK_BUTTON_PRIMARY)
-                return;
+  if (gdk_event_get_button (event, &button) &&
+      button != GDK_BUTTON_PRIMARY)
+    return;
 
-        gtk_popover_popup (get_popup (zoom_action));
-        priv->popup_shown = TRUE;
+  gtk_popover_popup (get_popup (zoom_action));
+  priv->popup_shown = TRUE;
 }
 
 static void
-ev_zoom_action_finalize (GObject *object)
-{
-        EvZoomAction *zoom_action = EV_ZOOM_ACTION (object);
-	EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
+ev_zoom_action_finalize (GObject *object) {
+  EvZoomAction *zoom_action = EV_ZOOM_ACTION (object);
+  EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
 
-        if (priv->model) {
-                g_object_remove_weak_pointer (G_OBJECT (priv->model),
-                                              (gpointer)&priv->model);
-        }
+  if (priv->model) {
+    g_object_remove_weak_pointer (G_OBJECT (priv->model),
+                                  (gpointer)&priv->model);
+  }
 
-        g_clear_object (&priv->menu);
-        g_clear_object (&priv->zoom_free_section);
+  g_clear_object (&priv->menu);
+  g_clear_object (&priv->zoom_free_section);
 
-        G_OBJECT_CLASS (ev_zoom_action_parent_class)->finalize (object);
+  G_OBJECT_CLASS (ev_zoom_action_parent_class)->finalize (object);
 }
 
 static void
 ev_zoom_action_set_property (GObject      *object,
                              guint         prop_id,
                              const GValue *value,
-                             GParamSpec   *pspec)
-{
-        EvZoomAction *zoom_action = EV_ZOOM_ACTION (object);
-	EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
-
-        switch (prop_id) {
-        case PROP_DOCUMENT_MODEL:
-                priv->model = g_value_get_object (value);
-                break;
-        case PROP_MENU:
-                priv->menu = g_value_dup_object (value);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-        }
+                             GParamSpec   *pspec) {
+  EvZoomAction *zoom_action = EV_ZOOM_ACTION (object);
+  EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
+
+  switch (prop_id) {
+    case PROP_DOCUMENT_MODEL:
+      priv->model = g_value_get_object (value);
+      break;
+    case PROP_MENU:
+      priv->menu = g_value_dup_object (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+  }
 }
 
 static void
-setup_initial_entry_size (EvZoomAction *zoom_action)
-{
-        gint width;
+setup_initial_entry_size (EvZoomAction *zoom_action) {
+  gint width;
 
-        width = g_utf8_strlen (zoom_levels[G_N_ELEMENTS (zoom_levels) - 1].name, -1);
-        ev_zoom_action_set_width_chars (zoom_action, width);
+  width = g_utf8_strlen (zoom_levels[G_N_ELEMENTS (zoom_levels) - 1].name, -1);
+  ev_zoom_action_set_width_chars (zoom_action, width);
 }
 
 static void
 ev_zoom_action_get_preferred_width (GtkWidget *widget,
                                     gint      *minimum_width,
-                                    gint      *natural_width)
-{
-        *minimum_width = *natural_width = 0;
+                                    gint      *natural_width) {
+  *minimum_width = *natural_width = 0;
 
-        GTK_WIDGET_CLASS (ev_zoom_action_parent_class)->get_preferred_width (widget, minimum_width, natural_width);
-        *natural_width = *minimum_width;
+  GTK_WIDGET_CLASS (ev_zoom_action_parent_class)->get_preferred_width (widget, minimum_width, natural_width);
+  *natural_width = *minimum_width;
 }
 
 static void
-ev_zoom_action_constructed (GObject *object)
-{
-        EvZoomAction *zoom_action = EV_ZOOM_ACTION (object);
-	EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
-
-        G_OBJECT_CLASS (ev_zoom_action_parent_class)->constructed (object);
-
-        priv->zoom_free_section =
-                g_menu_model_get_item_link (G_MENU_MODEL (priv->menu),
-                                            ZOOM_FREE_SECTION, G_MENU_LINK_SECTION);
-        ev_zoom_action_populate_free_zoom_section (zoom_action);
-
-        g_object_add_weak_pointer (G_OBJECT (priv->model),
-                                   (gpointer)&priv->model);
-        if (ev_document_model_get_document (priv->model)) {
-                ev_zoom_action_update_zoom_level (zoom_action);
-        } else {
-                ev_zoom_action_set_zoom_level (zoom_action, 1.);
-                gtk_widget_set_sensitive (GTK_WIDGET (zoom_action), FALSE);
-        }
-
-        g_signal_connect_object (priv->model, "notify::document",
-                                 G_CALLBACK (document_changed_cb),
-                                 zoom_action, 0);
-        g_signal_connect_object (priv->model, "notify::scale",
-                                 G_CALLBACK (zoom_changed_cb),
-                                 zoom_action, 0);
-        g_signal_connect_object (priv->model, "notify::max-scale",
-                                 G_CALLBACK (max_zoom_changed_cb),
-                                 zoom_action, 0);
-
-        setup_initial_entry_size (zoom_action);
+ev_zoom_action_constructed (GObject *object) {
+  EvZoomAction *zoom_action = EV_ZOOM_ACTION (object);
+  EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
+
+  G_OBJECT_CLASS (ev_zoom_action_parent_class)->constructed (object);
+
+  priv->zoom_free_section =
+    g_menu_model_get_item_link (G_MENU_MODEL (priv->menu),
+                                ZOOM_FREE_SECTION, G_MENU_LINK_SECTION);
+  ev_zoom_action_populate_free_zoom_section (zoom_action);
+
+  g_object_add_weak_pointer (G_OBJECT (priv->model),
+                             (gpointer)&priv->model);
+  if (ev_document_model_get_document (priv->model)) {
+    ev_zoom_action_update_zoom_level (zoom_action);
+  } else {
+    ev_zoom_action_set_zoom_level (zoom_action, 1.);
+    gtk_widget_set_sensitive (GTK_WIDGET (zoom_action), FALSE);
+  }
+
+  g_signal_connect_object (priv->model, "notify::document",
+                           G_CALLBACK (document_changed_cb),
+                           zoom_action, 0);
+  g_signal_connect_object (priv->model, "notify::scale",
+                           G_CALLBACK (zoom_changed_cb),
+                           zoom_action, 0);
+  g_signal_connect_object (priv->model, "notify::max-scale",
+                           G_CALLBACK (max_zoom_changed_cb),
+                           zoom_action, 0);
+
+  setup_initial_entry_size (zoom_action);
 }
 
 static void
-ev_zoom_action_class_init (EvZoomActionClass *klass)
-{
-        GObjectClass *object_class = G_OBJECT_CLASS (klass);
-        GtkWidgetClass *widget_class = GTK_WIDGET_CLASS(klass);
-
-        object_class->finalize = ev_zoom_action_finalize;
-        object_class->constructed = ev_zoom_action_constructed;
-        object_class->set_property = ev_zoom_action_set_property;
-
-        widget_class->get_preferred_width = ev_zoom_action_get_preferred_width;
-
-        g_object_class_install_property (object_class,
-                                         PROP_DOCUMENT_MODEL,
-                                         g_param_spec_object ("document-model",
-                                                              "DocumentModel",
-                                                              "The document model",
-                                                              EV_TYPE_DOCUMENT_MODEL,
-                                                              G_PARAM_WRITABLE |
-                                                              G_PARAM_CONSTRUCT_ONLY |
-                                                              G_PARAM_STATIC_STRINGS));
-
-        g_object_class_install_property (object_class,
-                                         PROP_MENU,
-                                         g_param_spec_object ("menu",
-                                                              "Menu",
-                                                              "The zoom popup menu",
-                                                              G_TYPE_MENU,
-                                                              G_PARAM_WRITABLE |
-                                                              G_PARAM_CONSTRUCT_ONLY |
-                                                              G_PARAM_STATIC_STRINGS));
-
-        signals[ACTIVATED] =
-                g_signal_new ("activated",
-                              G_OBJECT_CLASS_TYPE (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              0, NULL, NULL,
-                              g_cclosure_marshal_VOID__VOID,
-                              G_TYPE_NONE, 0);
+ev_zoom_action_class_init (EvZoomActionClass *klass) {
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  GtkWidgetClass *widget_class = GTK_WIDGET_CLASS(klass);
+
+  object_class->finalize = ev_zoom_action_finalize;
+  object_class->constructed = ev_zoom_action_constructed;
+  object_class->set_property = ev_zoom_action_set_property;
+
+  widget_class->get_preferred_width = ev_zoom_action_get_preferred_width;
+
+  g_object_class_install_property (object_class,
+                                   PROP_DOCUMENT_MODEL,
+                                   g_param_spec_object ("document-model",
+                                                        "DocumentModel",
+                                                        "The document model",
+                                                        EV_TYPE_DOCUMENT_MODEL,
+                                                        G_PARAM_WRITABLE |
+                                                        G_PARAM_CONSTRUCT_ONLY |
+                                                        G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class,
+                                   PROP_MENU,
+                                   g_param_spec_object ("menu",
+                                                        "Menu",
+                                                        "The zoom popup menu",
+                                                        G_TYPE_MENU,
+                                                        G_PARAM_WRITABLE |
+                                                        G_PARAM_CONSTRUCT_ONLY |
+                                                        G_PARAM_STATIC_STRINGS));
+
+  signals[ACTIVATED] =
+    g_signal_new ("activated",
+                  G_OBJECT_CLASS_TYPE (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  0, NULL, NULL,
+                  g_cclosure_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
 }
 
 static void
-ev_zoom_action_init (EvZoomAction *zoom_action)
-{
-        EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
-
-        gtk_orientable_set_orientation (GTK_ORIENTABLE (zoom_action), GTK_ORIENTATION_VERTICAL);
-
-        priv->entry = gtk_entry_new ();
-        gtk_entry_set_icon_from_icon_name (GTK_ENTRY (priv->entry),
-                                           GTK_ENTRY_ICON_SECONDARY,
-                                           "pan-down-symbolic");
-        gtk_box_pack_start (GTK_BOX (zoom_action), priv->entry, TRUE, FALSE, 0);
-        g_object_set (priv->entry, "xalign", 1.0, NULL);
-        gtk_widget_show (priv->entry);
-
-        g_signal_connect (priv->entry, "icon-press",
-                          G_CALLBACK (entry_icon_press_callback),
-                          zoom_action);
-        g_signal_connect (priv->entry, "activate",
-                          G_CALLBACK (entry_activated_cb),
-                          zoom_action);
-        g_signal_connect_swapped (priv->entry, "focus-out-event",
-                                  G_CALLBACK (focus_out_cb),
-                                  zoom_action);
+ev_zoom_action_init (EvZoomAction *zoom_action) {
+  EvZoomActionPrivate *priv = GET_PRIVATE (zoom_action);
+
+  gtk_orientable_set_orientation (GTK_ORIENTABLE (zoom_action), GTK_ORIENTATION_VERTICAL);
+
+  priv->entry = gtk_entry_new ();
+  gtk_entry_set_icon_from_icon_name (GTK_ENTRY (priv->entry),
+                                     GTK_ENTRY_ICON_SECONDARY,
+                                     "pan-down-symbolic");
+  gtk_box_pack_start (GTK_BOX (zoom_action), priv->entry, TRUE, FALSE, 0);
+  g_object_set (priv->entry, "xalign", 1.0, NULL);
+  gtk_widget_show (priv->entry);
+
+  g_signal_connect (priv->entry, "icon-press",
+                    G_CALLBACK (entry_icon_press_callback),
+                    zoom_action);
+  g_signal_connect (priv->entry, "activate",
+                    G_CALLBACK (entry_activated_cb),
+                    zoom_action);
+  g_signal_connect_swapped (priv->entry, "focus-out-event",
+                            G_CALLBACK (focus_out_cb),
+                            zoom_action);
 }
 
 GtkWidget *
 ev_zoom_action_new (EvDocumentModel *model,
-                    GMenu           *menu)
-{
-        g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), NULL);
-        g_return_val_if_fail (G_IS_MENU (menu), NULL);
-
-        return GTK_WIDGET (g_object_new (EV_TYPE_ZOOM_ACTION,
-                                         "document-model", model,
-                                         "menu", menu,
-                                         NULL));
+                    GMenu           *menu) {
+  g_return_val_if_fail (EV_IS_DOCUMENT_MODEL (model), NULL);
+  g_return_val_if_fail (G_IS_MENU (menu), NULL);
+
+  return GTK_WIDGET (g_object_new (EV_TYPE_ZOOM_ACTION,
+                                   "document-model", model,
+                                   "menu", menu,
+                                   NULL));
 }
 
 gboolean
-ev_zoom_action_get_popup_shown (EvZoomAction *zoom_action)
-{
-	EvZoomActionPrivate *priv;
+ev_zoom_action_get_popup_shown (EvZoomAction *zoom_action) {
+  EvZoomActionPrivate *priv;
 
-        g_return_val_if_fail (EV_IS_ZOOM_ACTION (zoom_action), FALSE);
+  g_return_val_if_fail (EV_IS_ZOOM_ACTION (zoom_action), FALSE);
 
-	priv = GET_PRIVATE (zoom_action);
+  priv = GET_PRIVATE (zoom_action);
 
-        return priv->popup_shown;
+  return priv->popup_shown;
 }
diff --git a/shell/evince-menus.ui b/shell/evince-menus.ui
index adf566c..5a0f0ba 100644
--- a/shell/evince-menus.ui
+++ b/shell/evince-menus.ui
@@ -69,6 +69,10 @@
       <item>
         <attribute name="label" translatable="yes">_Continuous</attribute>
         <attribute name="action">win.continuous</attribute>
+      </item>
+       <item>
+        <attribute name="label" translatable="yes">Creator Mode</attribute>
+        <attribute name="action">win.creator-mode</attribute>
       </item>
       <item>
         <attribute name="label" translatable="yes">_Dual</attribute>
diff --git a/shell/help-overlay.ui b/shell/help-overlay.ui
index f12c219..160cc02 100644
--- a/shell/help-overlay.ui
+++ b/shell/help-overlay.ui
@@ -307,6 +307,13 @@
                 <property name="accelerator">c</property>
               </object>
             </child>
+        <child>
+              <object class="GtkShortcutsShortcut">
+                <property name="visible">True</property>
+                <property name="title" translatable="yes" context="shortcut window">Toggle Creator Mode option</property>
+                <property name="accelerator">c</property>
+              </object>
+            </child>
             <child>
               <object class="GtkShortcutsShortcut">
                 <property name="visible">True</property>
diff --git a/shell/main.c b/shell/main.c
index 6c54078..775fd0c 100644
--- a/shell/main.c
+++ b/shell/main.c
@@ -58,267 +58,257 @@ static gboolean
 option_version_cb (const gchar *option_name,
                    const gchar *value,
                    gpointer     data,
-                   GError     **error)
-{
+                   GError     **error) {
   g_print ("%s %s\n", _("GNOME Document Viewer"), VERSION);
 
   exit (0);
   return FALSE;
 }
 
-static const GOptionEntry goption_options[] =
-{
-	{ "page-label", 'p', 0, G_OPTION_ARG_STRING, &ev_page_label, N_("The page label of the document to display."), N_("PAGE")},
-	{ "page-index", 'i', 0, G_OPTION_ARG_INT, &ev_page_index, N_("The page number of the document to display."), N_("NUMBER")},
-	{ "named-dest", 'n', 0, G_OPTION_ARG_STRING, &ev_named_dest, N_("Named destination to display."), N_("DEST")},
-	{ "fullscreen", 'f', 0, G_OPTION_ARG_NONE, &fullscreen_mode, N_("Run evince in fullscreen mode"), NULL },
-	{ "presentation", 's', 0, G_OPTION_ARG_NONE, &presentation_mode, N_("Run evince in presentation mode"), NULL },
-	{ "preview", 'w', 0, G_OPTION_ARG_NONE, &preview_mode, N_("Run evince as a previewer"), NULL },
-	{ "find", 'l', 0, G_OPTION_ARG_STRING, &ev_find_string, N_("The word or phrase to find in the document"), N_("STRING")},
-	{ "unlink-tempfile", 'u', G_OPTION_FLAG_HIDDEN, G_OPTION_ARG_NONE, &unlink_temp_file, NULL, NULL },
-	{ "print-settings", 't', G_OPTION_FLAG_HIDDEN, G_OPTION_ARG_FILENAME, &print_settings, NULL, NULL },
-	{ "version", 0, G_OPTION_FLAG_NO_ARG | G_OPTION_FLAG_HIDDEN, G_OPTION_ARG_CALLBACK, option_version_cb, NULL, NULL },
-	{ G_OPTION_REMAINING, 0, 0, G_OPTION_ARG_FILENAME_ARRAY, &file_arguments, NULL, N_("[FILE…]") },
-	{ NULL }
+static const GOptionEntry goption_options[] = {
+  { "page-label", 'p', 0, G_OPTION_ARG_STRING, &ev_page_label, N_("The page label of the document to display."), N_("PAGE")},
+  { "page-index", 'i', 0, G_OPTION_ARG_INT, &ev_page_index, N_("The page number of the document to display."), N_("NUMBER")},
+  { "named-dest", 'n', 0, G_OPTION_ARG_STRING, &ev_named_dest, N_("Named destination to display."), N_("DEST")},
+  { "fullscreen", 'f', 0, G_OPTION_ARG_NONE, &fullscreen_mode, N_("Run evince in fullscreen mode"), NULL },
+  { "presentation", 's', 0, G_OPTION_ARG_NONE, &presentation_mode, N_("Run evince in presentation mode"), NULL },
+  { "preview", 'w', 0, G_OPTION_ARG_NONE, &preview_mode, N_("Run evince as a previewer"), NULL },
+  { "find", 'l', 0, G_OPTION_ARG_STRING, &ev_find_string, N_("The word or phrase to find in the document"), N_("STRING")},
+  { "unlink-tempfile", 'u', G_OPTION_FLAG_HIDDEN, G_OPTION_ARG_NONE, &unlink_temp_file, NULL, NULL },
+  { "print-settings", 't', G_OPTION_FLAG_HIDDEN, G_OPTION_ARG_FILENAME, &print_settings, NULL, NULL },
+  { "version", 0, G_OPTION_FLAG_NO_ARG | G_OPTION_FLAG_HIDDEN, G_OPTION_ARG_CALLBACK, option_version_cb, NULL, NULL },
+  { G_OPTION_REMAINING, 0, 0, G_OPTION_ARG_FILENAME_ARRAY, &file_arguments, NULL, N_("[FILE…]") },
+  { NULL }
 };
 
 static gboolean
-launch_previewer (void)
-{
-	GString *cmd_str;
-	gchar   *cmd;
-	gboolean retval = FALSE;
-	GError  *error = NULL;
-
-	/* Rebuild the command line, ignoring options
-	 * not supported by the previewer and taking only
-	 * the first path given
-	 */
-	cmd_str = g_string_new ("evince-previewer");
-		
-	if (print_settings) {
-		gchar *quoted;
-
-		quoted = g_shell_quote (print_settings);
-		g_string_append_printf (cmd_str, " --print-settings %s", quoted);
-		g_free (quoted);
-	}
-
-	if (unlink_temp_file)
-		g_string_append (cmd_str, " --unlink-tempfile");
-
-	if (file_arguments) {
-		gchar *quoted;
-		
-		quoted = g_shell_quote (file_arguments[0]);
-		g_string_append_printf (cmd_str, " %s", quoted);
-		g_free (quoted);
-	}
-
-	cmd = g_string_free (cmd_str, FALSE);
-
-	if (!error) {
-		GAppInfo *app;
-
-		app = g_app_info_create_from_commandline (cmd, NULL, 0, &error);
-
-		if (app != NULL) {
-			retval = g_app_info_launch (app, NULL, NULL, &error);
-			g_object_unref (app);
-		}
-	}
-
-	if (error) {
-		g_warning ("Error launching previewer: %s\n", error->message);
-		g_error_free (error);
-	}
-
-	g_free (cmd);
-
-	return retval;
+launch_previewer (void) {
+  GString *cmd_str;
+  gchar   *cmd;
+  gboolean retval = FALSE;
+  GError  *error = NULL;
+
+  /* Rebuild the command line, ignoring options
+   * not supported by the previewer and taking only
+   * the first path given
+   */
+  cmd_str = g_string_new ("evince-previewer");
+
+  if (print_settings) {
+    gchar *quoted;
+
+    quoted = g_shell_quote (print_settings);
+    g_string_append_printf (cmd_str, " --print-settings %s", quoted);
+    g_free (quoted);
+  }
+
+  if (unlink_temp_file)
+    g_string_append (cmd_str, " --unlink-tempfile");
+
+  if (file_arguments) {
+    gchar *quoted;
+
+    quoted = g_shell_quote (file_arguments[0]);
+    g_string_append_printf (cmd_str, " %s", quoted);
+    g_free (quoted);
+  }
+
+  cmd = g_string_free (cmd_str, FALSE);
+
+  if (!error) {
+    GAppInfo *app;
+
+    app = g_app_info_create_from_commandline (cmd, NULL, 0, &error);
+
+    if (app != NULL) {
+      retval = g_app_info_launch (app, NULL, NULL, &error);
+      g_object_unref (app);
+    }
+  }
+
+  if (error) {
+    g_warning ("Error launching previewer: %s\n", error->message);
+    g_error_free (error);
+  }
+
+  g_free (cmd);
+
+  return retval;
 }
 
 static gchar *
-get_label_from_filename (const gchar *filename)
-{
-	GFile   *file;
-	gchar   *label;
-	gboolean exists;
-
-	label = g_strrstr (filename, "#");
-	if (!label)
-		return NULL;
-
-	/* Filename contains a #, check
-	 * whether it's part of the path
-	 * or a label
-	 */
-	file = g_file_new_for_commandline_arg (filename);
-	exists = g_file_query_exists (file, NULL);
-	g_object_unref (file);
-
-	return exists ? NULL : label;
+get_label_from_filename (const gchar *filename) {
+  GFile   *file;
+  gchar   *label;
+  gboolean exists;
+
+  label = g_strrstr (filename, "#");
+  if (!label)
+    return NULL;
+
+  /* Filename contains a #, check
+   * whether it's part of the path
+   * or a label
+   */
+  file = g_file_new_for_commandline_arg (filename);
+  exists = g_file_query_exists (file, NULL);
+  g_object_unref (file);
+
+  return exists ? NULL : label;
 }
 
 static void
-load_files (const char **files)
-{
-	GdkScreen       *screen = gdk_screen_get_default ();
-	EvWindowRunMode  mode = EV_WINDOW_MODE_NORMAL;
-	gint             i;
-	EvLinkDest      *global_dest = NULL;
-
-	if (!files) {
-		if (!ev_application_has_window (EV_APP))
-			ev_application_open_recent_view (EV_APP, screen, GDK_CURRENT_TIME);
-		return;
-	}
-
-	if (ev_page_label)
-		global_dest = ev_link_dest_new_page_label (ev_page_label);
-	else if (ev_page_index)
-		global_dest = ev_link_dest_new_page (MAX (0, ev_page_index - 1));
-	else if (ev_named_dest)
-		global_dest = ev_link_dest_new_named (ev_named_dest);
-
-	if (fullscreen_mode)
-		mode = EV_WINDOW_MODE_FULLSCREEN;
-	else if (presentation_mode)
-		mode = EV_WINDOW_MODE_PRESENTATION;
-
-	for (i = 0; files[i]; i++) {
-		const gchar *filename;
-		gchar       *uri;
-		gchar       *label;
-		GFile       *file;
-		EvLinkDest  *dest = NULL;
-		const gchar *app_uri;
-
-		filename = files[i];
-		label = get_label_from_filename (filename);
-		if (label) {
-			*label = 0;
-			label++;
-			dest = ev_link_dest_new_page_label (label);
-		} else if (global_dest) {
-			dest = g_object_ref (global_dest);
-		}
-
-		file = g_file_new_for_commandline_arg (filename);
-		uri = g_file_get_uri (file);
-		g_object_unref (file);
-
-		app_uri = ev_application_get_uri (EV_APP);
-		if (app_uri && strcmp (app_uri, uri) == 0) {
-			g_free (uri);
-			continue;
-		}
-
-
-
-		ev_application_open_uri_at_dest (EV_APP, uri, screen, dest,
-						 mode, ev_find_string,
-						 GDK_CURRENT_TIME);
-
-		if (dest)
-			g_object_unref (dest);
-		g_free (uri);
-        }
+load_files (const char **files) {
+  GdkScreen       *screen = gdk_screen_get_default ();
+  EvWindowRunMode  mode = EV_WINDOW_MODE_NORMAL;
+  gint             i;
+  EvLinkDest      *global_dest = NULL;
+
+  if (!files) {
+    if (!ev_application_has_window (EV_APP))
+      ev_application_open_recent_view (EV_APP, screen, GDK_CURRENT_TIME);
+    return;
+  }
+
+  if (ev_page_label)
+    global_dest = ev_link_dest_new_page_label (ev_page_label);
+  else if (ev_page_index)
+    global_dest = ev_link_dest_new_page (MAX (0, ev_page_index - 1));
+  else if (ev_named_dest)
+    global_dest = ev_link_dest_new_named (ev_named_dest);
+
+  if (fullscreen_mode)
+    mode = EV_WINDOW_MODE_FULLSCREEN;
+  else if (presentation_mode)
+    mode = EV_WINDOW_MODE_PRESENTATION;
+
+  for (i = 0; files[i]; i++) {
+    const gchar *filename;
+    gchar       *uri;
+    gchar       *label;
+    GFile       *file;
+    EvLinkDest  *dest = NULL;
+    const gchar *app_uri;
+
+    filename = files[i];
+    label = get_label_from_filename (filename);
+    if (label) {
+      *label = 0;
+      label++;
+      dest = ev_link_dest_new_page_label (label);
+    } else if (global_dest) {
+      dest = g_object_ref (global_dest);
+    }
+
+    file = g_file_new_for_commandline_arg (filename);
+    uri = g_file_get_uri (file);
+    g_object_unref (file);
+
+    app_uri = ev_application_get_uri (EV_APP);
+    if (app_uri && strcmp (app_uri, uri) == 0) {
+      g_free (uri);
+      continue;
+    }
+
+
+
+    ev_application_open_uri_at_dest (EV_APP, uri, screen, dest,
+                                     mode, ev_find_string,
+                                     GDK_CURRENT_TIME);
+
+    if (dest)
+      g_object_unref (dest);
+    g_free (uri);
+  }
 }
 
 int
-main (int argc, char *argv[])
-{
-        EvApplication  *application;
-	GOptionContext *context;
-	GError         *error = NULL;
-        int             status;
+main (int argc, char *argv[]) {
+  EvApplication  *application;
+  GOptionContext *context;
+  GError         *error = NULL;
+  int             status;
 
 #ifdef G_OS_WIN32
 
-    if (fileno (stdout) != -1 &&
- 	  _get_osfhandle (fileno (stdout)) != -1)
-	{
-	  /* stdout is fine, presumably redirected to a file or pipe */
-	}
-    else
-    {
-	  typedef BOOL (* WINAPI AttachConsole_t) (DWORD);
-
-	  AttachConsole_t p_AttachConsole =
-	    (AttachConsole_t) GetProcAddress (GetModuleHandle ("kernel32.dll"), "AttachConsole");
-
-	  if (p_AttachConsole != NULL && p_AttachConsole (ATTACH_PARENT_PROCESS))
-      {
-	      freopen ("CONOUT$", "w", stdout);
-	      dup2 (fileno (stdout), 1);
-	      freopen ("CONOUT$", "w", stderr);
-	      dup2 (fileno (stderr), 2);
-
-      }
-	}
+  if (fileno (stdout) != -1 &&
+      _get_osfhandle (fileno (stdout)) != -1) {
+    /* stdout is fine, presumably redirected to a file or pipe */
+  } else {
+    typedef BOOL (* WINAPI AttachConsole_t) (DWORD);
+
+    AttachConsole_t p_AttachConsole =
+      (AttachConsole_t) GetProcAddress (GetModuleHandle ("kernel32.dll"), "AttachConsole");
+
+    if (p_AttachConsole != NULL && p_AttachConsole (ATTACH_PARENT_PROCESS)) {
+      freopen ("CONOUT$", "w", stdout);
+      dup2 (fileno (stdout), 1);
+      freopen ("CONOUT$", "w", stderr);
+      dup2 (fileno (stderr), 2);
+
+    }
+  }
 #endif
 
 #ifdef ENABLE_NLS
-	/* Initialize the i18n stuff */
-	bindtextdomain (GETTEXT_PACKAGE, ev_get_locale_dir());
-	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
-	textdomain (GETTEXT_PACKAGE);
+  /* Initialize the i18n stuff */
+  bindtextdomain (GETTEXT_PACKAGE, ev_get_locale_dir());
+  bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
+  textdomain (GETTEXT_PACKAGE);
 #endif
 
-	context = g_option_context_new (N_("GNOME Document Viewer"));
-	g_option_context_set_translation_domain(context, GETTEXT_PACKAGE);
-	g_option_context_add_main_entries (context, goption_options, GETTEXT_PACKAGE);
+  context = g_option_context_new (N_("GNOME Document Viewer"));
+  g_option_context_set_translation_domain(context, GETTEXT_PACKAGE);
+  g_option_context_add_main_entries (context, goption_options, GETTEXT_PACKAGE);
+
+  g_option_context_add_group (context, gtk_get_option_group (TRUE));
+
+  if (!g_option_context_parse (context, &argc, &argv, &error)) {
+    g_printerr ("Cannot parse arguments: %s\n", error->message);
+    g_error_free (error);
+    g_option_context_free (context);
 
-	g_option_context_add_group (context, gtk_get_option_group (TRUE));
+    return 1;
+  }
+  g_option_context_free (context);
 
-	if (!g_option_context_parse (context, &argc, &argv, &error)) {
-		g_printerr ("Cannot parse arguments: %s\n", error->message);
-		g_error_free (error);
-		g_option_context_free (context);
+  if (preview_mode) {
+    gboolean retval;
 
-		return 1;
-	}
-	g_option_context_free (context);
+    retval = launch_previewer ();
 
-	if (preview_mode) {
-		gboolean retval;
-		
-		retval = launch_previewer ();
-		
-		return retval ? 0 : 1;
-	}
+    return retval ? 0 : 1;
+  }
 
-        if (!ev_init ())
-                return 1;
+  if (!ev_init ())
+    return 1;
 
-	ev_stock_icons_init ();
+  ev_stock_icons_init ();
 
-	/* Manually set name and icon */
-	g_set_application_name (_("Document Viewer"));
-	gtk_window_set_default_icon_name ("org.gnome.Evince");
+  /* Manually set name and icon */
+  g_set_application_name (_("Document Viewer"));
+  gtk_window_set_default_icon_name ("org.gnome.Evince");
 
-        application = ev_application_new ();
-        if (!g_application_register (G_APPLICATION (application), NULL, &error)) {
-                g_printerr ("Failed to register: %s\n", error->message);
-                g_error_free (error);
-                status = 1;
-                goto done;
-        }
+  application = ev_application_new ();
+  if (!g_application_register (G_APPLICATION (application), NULL, &error)) {
+    g_printerr ("Failed to register: %s\n", error->message);
+    g_error_free (error);
+    status = 1;
+    goto done;
+  }
 
-	load_files (file_arguments);
+  load_files (file_arguments);
 
-	/* Change directory so we don't prevent unmounting in case the initial cwd
-	 * is on an external device (see bug #575436)
-	 */
-	g_chdir (g_get_home_dir ());
+  /* Change directory so we don't prevent unmounting in case the initial cwd
+   * is on an external device (see bug #575436)
+   */
+  g_chdir (g_get_home_dir ());
 
-	status = g_application_run (G_APPLICATION (application), 0, NULL);
+  status = g_application_run (G_APPLICATION (application), 0, NULL);
 
-    done:
-	ev_shutdown ();
-	ev_stock_icons_shutdown ();
+done:
+  ev_shutdown ();
+  ev_stock_icons_shutdown ();
 
-        g_object_unref (application);
-	return status;
+  g_object_unref (application);
+  return status;
 }
